var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var jquery = { exports: {} };
/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
(function(module) {
  (function(global2, factory2) {
    {
      module.exports = global2.document ? factory2(global2, true) : function(w) {
        if (!w.document) {
          throw new Error("jQuery requires a window with a document");
        }
        return factory2(w);
      };
    }
  })(typeof window !== "undefined" ? window : commonjsGlobal, function(window2, noGlobal) {
    var arr = [];
    var getProto = Object.getPrototypeOf;
    var slice2 = arr.slice;
    var flat = arr.flat ? function(array) {
      return arr.flat.call(array);
    } : function(array) {
      return arr.concat.apply([], array);
    };
    var push = arr.push;
    var indexOf2 = arr.indexOf;
    var class2type = {};
    var toString2 = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    var isFunction3 = function isFunction4(obj) {
      return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
    };
    var isWindow = function isWindow2(obj) {
      return obj != null && obj === obj.window;
    };
    var document2 = window2.document;
    var preservedScriptAttributes = {
      type: true,
      src: true,
      nonce: true,
      noModule: true
    };
    function DOMEval(code, node2, doc) {
      doc = doc || document2;
      var i, val, script = doc.createElement("script");
      script.text = code;
      if (node2) {
        for (i in preservedScriptAttributes) {
          val = node2[i] || node2.getAttribute && node2.getAttribute(i);
          if (val) {
            script.setAttribute(i, val);
          }
        }
      }
      doc.head.appendChild(script).parentNode.removeChild(script);
    }
    function toType(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString2.call(obj)] || "object" : typeof obj;
    }
    var version2 = "3.6.0", jQuery = function(selector2, context) {
      return new jQuery.fn.init(selector2, context);
    };
    jQuery.fn = jQuery.prototype = {
      jquery: version2,
      constructor: jQuery,
      length: 0,
      toArray: function() {
        return slice2.call(this);
      },
      get: function(num) {
        if (num == null) {
          return slice2.call(this);
        }
        return num < 0 ? this[num + this.length] : this[num];
      },
      pushStack: function(elems) {
        var ret = jQuery.merge(this.constructor(), elems);
        ret.prevObject = this;
        return ret;
      },
      each: function(callback) {
        return jQuery.each(this, callback);
      },
      map: function(callback) {
        return this.pushStack(jQuery.map(this, function(elem, i) {
          return callback.call(elem, i, elem);
        }));
      },
      slice: function() {
        return this.pushStack(slice2.apply(this, arguments));
      },
      first: function() {
        return this.eq(0);
      },
      last: function() {
        return this.eq(-1);
      },
      even: function() {
        return this.pushStack(jQuery.grep(this, function(_elem, i) {
          return (i + 1) % 2;
        }));
      },
      odd: function() {
        return this.pushStack(jQuery.grep(this, function(_elem, i) {
          return i % 2;
        }));
      },
      eq: function(i) {
        var len = this.length, j = +i + (i < 0 ? len : 0);
        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
      },
      end: function() {
        return this.prevObject || this.constructor();
      },
      push,
      sort: arr.sort,
      splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
      var options, name2, src, copy2, copyIsArray, clone2, target = arguments[0] || {}, i = 1, length2 = arguments.length, deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[i] || {};
        i++;
      }
      if (typeof target !== "object" && !isFunction3(target)) {
        target = {};
      }
      if (i === length2) {
        target = this;
        i--;
      }
      for (; i < length2; i++) {
        if ((options = arguments[i]) != null) {
          for (name2 in options) {
            copy2 = options[name2];
            if (name2 === "__proto__" || target === copy2) {
              continue;
            }
            if (deep && copy2 && (jQuery.isPlainObject(copy2) || (copyIsArray = Array.isArray(copy2)))) {
              src = target[name2];
              if (copyIsArray && !Array.isArray(src)) {
                clone2 = [];
              } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                clone2 = {};
              } else {
                clone2 = src;
              }
              copyIsArray = false;
              target[name2] = jQuery.extend(deep, clone2, copy2);
            } else if (copy2 !== void 0) {
              target[name2] = copy2;
            }
          }
        }
      }
      return target;
    };
    jQuery.extend({
      expando: "jQuery" + (version2 + Math.random()).replace(/\D/g, ""),
      isReady: true,
      error: function(msg) {
        throw new Error(msg);
      },
      noop: function() {
      },
      isPlainObject: function(obj) {
        var proto2, Ctor;
        if (!obj || toString2.call(obj) !== "[object Object]") {
          return false;
        }
        proto2 = getProto(obj);
        if (!proto2) {
          return true;
        }
        Ctor = hasOwn.call(proto2, "constructor") && proto2.constructor;
        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
      },
      isEmptyObject: function(obj) {
        var name2;
        for (name2 in obj) {
          return false;
        }
        return true;
      },
      globalEval: function(code, options, doc) {
        DOMEval(code, { nonce: options && options.nonce }, doc);
      },
      each: function(obj, callback) {
        var length2, i = 0;
        if (isArrayLike2(obj)) {
          length2 = obj.length;
          for (; i < length2; i++) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        }
        return obj;
      },
      makeArray: function(arr2, results) {
        var ret = results || [];
        if (arr2 != null) {
          if (isArrayLike2(Object(arr2))) {
            jQuery.merge(ret, typeof arr2 === "string" ? [arr2] : arr2);
          } else {
            push.call(ret, arr2);
          }
        }
        return ret;
      },
      inArray: function(elem, arr2, i) {
        return arr2 == null ? -1 : indexOf2.call(arr2, elem, i);
      },
      merge: function(first, second) {
        var len = +second.length, j = 0, i = first.length;
        for (; j < len; j++) {
          first[i++] = second[j];
        }
        first.length = i;
        return first;
      },
      grep: function(elems, callback, invert) {
        var callbackInverse, matches = [], i = 0, length2 = elems.length, callbackExpect = !invert;
        for (; i < length2; i++) {
          callbackInverse = !callback(elems[i], i);
          if (callbackInverse !== callbackExpect) {
            matches.push(elems[i]);
          }
        }
        return matches;
      },
      map: function(elems, callback, arg) {
        var length2, value, i = 0, ret = [];
        if (isArrayLike2(elems)) {
          length2 = elems.length;
          for (; i < length2; i++) {
            value = callback(elems[i], i, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        } else {
          for (i in elems) {
            value = callback(elems[i], i, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        }
        return flat(ret);
      },
      guid: 1,
      support
    });
    if (typeof Symbol === "function") {
      jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(_i, name2) {
      class2type["[object " + name2 + "]"] = name2.toLowerCase();
    });
    function isArrayLike2(obj) {
      var length2 = !!obj && "length" in obj && obj.length, type = toType(obj);
      if (isFunction3(obj) || isWindow(obj)) {
        return false;
      }
      return type === "array" || length2 === 0 || typeof length2 === "number" && length2 > 0 && length2 - 1 in obj;
    }
    var Sizzle = function(window3) {
      var i, support2, Expr, getText, isXML, tokenize, compile3, select, outermostContext, sortInput, hasDuplicate, setDocument, document3, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window3.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
        if (a === b) {
          hasDuplicate = true;
        }
        return 0;
      }, hasOwn2 = {}.hasOwnProperty, arr2 = [], pop = arr2.pop, pushNative = arr2.push, push2 = arr2.push, slice3 = arr2.slice, indexOf3 = function(list, elem) {
        var i2 = 0, len = list.length;
        for (; i2 < len; i2++) {
          if (list[i2] === elem) {
            return i2;
          }
        }
        return -1;
      }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim2 = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
        "ID": new RegExp("^#(" + identifier + ")"),
        "CLASS": new RegExp("^\\.(" + identifier + ")"),
        "TAG": new RegExp("^(" + identifier + "|[*])"),
        "ATTR": new RegExp("^" + attributes),
        "PSEUDO": new RegExp("^" + pseudos),
        "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
        "bool": new RegExp("^(?:" + booleans + ")$", "i"),
        "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
      }, rhtml2 = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
        var high = "0x" + escape2.slice(1) - 65536;
        return nonHex ? nonHex : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
        if (asCodePoint) {
          if (ch === "\0") {
            return "\uFFFD";
          }
          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }
        return "\\" + ch;
      }, unloadHandler = function() {
        setDocument();
      }, inDisabledFieldset = addCombinator(function(elem) {
        return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
      }, { dir: "parentNode", next: "legend" });
      try {
        push2.apply(arr2 = slice3.call(preferredDoc.childNodes), preferredDoc.childNodes);
        arr2[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push2 = {
          apply: arr2.length ? function(target, els) {
            pushNative.apply(target, slice3.call(els));
          } : function(target, els) {
            var j = target.length, i2 = 0;
            while (target[j++] = els[i2++]) {
            }
            target.length = j - 1;
          }
        };
      }
      function Sizzle2(selector2, context, results, seed) {
        var m, i2, elem, nid, match2, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
        results = results || [];
        if (typeof selector2 !== "string" || !selector2 || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
          return results;
        }
        if (!seed) {
          setDocument(context);
          context = context || document3;
          if (documentIsHTML) {
            if (nodeType !== 11 && (match2 = rquickExpr2.exec(selector2))) {
              if (m = match2[1]) {
                if (nodeType === 9) {
                  if (elem = context.getElementById(m)) {
                    if (elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  } else {
                    return results;
                  }
                } else {
                  if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                }
              } else if (match2[2]) {
                push2.apply(results, context.getElementsByTagName(selector2));
                return results;
              } else if ((m = match2[3]) && support2.getElementsByClassName && context.getElementsByClassName) {
                push2.apply(results, context.getElementsByClassName(m));
                return results;
              }
            }
            if (support2.qsa && !nonnativeSelectorCache[selector2 + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector2)) && (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
              newSelector = selector2;
              newContext = context;
              if (nodeType === 1 && (rdescend.test(selector2) || rcombinators.test(selector2))) {
                newContext = rsibling.test(selector2) && testContext(context.parentNode) || context;
                if (newContext !== context || !support2.scope) {
                  if (nid = context.getAttribute("id")) {
                    nid = nid.replace(rcssescape, fcssescape);
                  } else {
                    context.setAttribute("id", nid = expando);
                  }
                }
                groups = tokenize(selector2);
                i2 = groups.length;
                while (i2--) {
                  groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                }
                newSelector = groups.join(",");
              }
              try {
                push2.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {
                nonnativeSelectorCache(selector2, true);
              } finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
        return select(selector2.replace(rtrim2, "$1"), context, results, seed);
      }
      function createCache() {
        var keys2 = [];
        function cache(key, value) {
          if (keys2.push(key + " ") > Expr.cacheLength) {
            delete cache[keys2.shift()];
          }
          return cache[key + " "] = value;
        }
        return cache;
      }
      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }
      function assert(fn) {
        var el = document3.createElement("fieldset");
        try {
          return !!fn(el);
        } catch (e) {
          return false;
        } finally {
          if (el.parentNode) {
            el.parentNode.removeChild(el);
          }
          el = null;
        }
      }
      function addHandle(attrs, handler) {
        var arr3 = attrs.split("|"), i2 = arr3.length;
        while (i2--) {
          Expr.attrHandle[arr3[i2]] = handler;
        }
      }
      function siblingCheck(a, b) {
        var cur = b && a, diff2 = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
        if (diff2) {
          return diff2;
        }
        if (cur) {
          while (cur = cur.nextSibling) {
            if (cur === b) {
              return -1;
            }
          }
        }
        return a ? 1 : -1;
      }
      function createInputPseudo(type) {
        return function(elem) {
          var name2 = elem.nodeName.toLowerCase();
          return name2 === "input" && elem.type === type;
        };
      }
      function createButtonPseudo(type) {
        return function(elem) {
          var name2 = elem.nodeName.toLowerCase();
          return (name2 === "input" || name2 === "button") && elem.type === type;
        };
      }
      function createDisabledPseudo(disabled) {
        return function(elem) {
          if ("form" in elem) {
            if (elem.parentNode && elem.disabled === false) {
              if ("label" in elem) {
                if ("label" in elem.parentNode) {
                  return elem.parentNode.disabled === disabled;
                } else {
                  return elem.disabled === disabled;
                }
              }
              return elem.isDisabled === disabled || elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
            }
            return elem.disabled === disabled;
          } else if ("label" in elem) {
            return elem.disabled === disabled;
          }
          return false;
        };
      }
      function createPositionalPseudo(fn) {
        return markFunction(function(argument) {
          argument = +argument;
          return markFunction(function(seed, matches2) {
            var j, matchIndexes = fn([], seed.length, argument), i2 = matchIndexes.length;
            while (i2--) {
              if (seed[j = matchIndexes[i2]]) {
                seed[j] = !(matches2[j] = seed[j]);
              }
            }
          });
        });
      }
      function testContext(context) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
      }
      support2 = Sizzle2.support = {};
      isXML = Sizzle2.isXML = function(elem) {
        var namespace = elem && elem.namespaceURI, docElem2 = elem && (elem.ownerDocument || elem).documentElement;
        return !rhtml2.test(namespace || docElem2 && docElem2.nodeName || "HTML");
      };
      setDocument = Sizzle2.setDocument = function(node2) {
        var hasCompare, subWindow, doc = node2 ? node2.ownerDocument || node2 : preferredDoc;
        if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
          return document3;
        }
        document3 = doc;
        docElem = document3.documentElement;
        documentIsHTML = !isXML(document3);
        if (preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
          if (subWindow.addEventListener) {
            subWindow.addEventListener("unload", unloadHandler, false);
          } else if (subWindow.attachEvent) {
            subWindow.attachEvent("onunload", unloadHandler);
          }
        }
        support2.scope = assert(function(el) {
          docElem.appendChild(el).appendChild(document3.createElement("div"));
          return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
        });
        support2.attributes = assert(function(el) {
          el.className = "i";
          return !el.getAttribute("className");
        });
        support2.getElementsByTagName = assert(function(el) {
          el.appendChild(document3.createComment(""));
          return !el.getElementsByTagName("*").length;
        });
        support2.getElementsByClassName = rnative.test(document3.getElementsByClassName);
        support2.getById = assert(function(el) {
          docElem.appendChild(el).id = expando;
          return !document3.getElementsByName || !document3.getElementsByName(expando).length;
        });
        if (support2.getById) {
          Expr.filter["ID"] = function(id2) {
            var attrId = id2.replace(runescape, funescape);
            return function(elem) {
              return elem.getAttribute("id") === attrId;
            };
          };
          Expr.find["ID"] = function(id2, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var elem = context.getElementById(id2);
              return elem ? [elem] : [];
            }
          };
        } else {
          Expr.filter["ID"] = function(id2) {
            var attrId = id2.replace(runescape, funescape);
            return function(elem) {
              var node3 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
              return node3 && node3.value === attrId;
            };
          };
          Expr.find["ID"] = function(id2, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var node3, i2, elems, elem = context.getElementById(id2);
              if (elem) {
                node3 = elem.getAttributeNode("id");
                if (node3 && node3.value === id2) {
                  return [elem];
                }
                elems = context.getElementsByName(id2);
                i2 = 0;
                while (elem = elems[i2++]) {
                  node3 = elem.getAttributeNode("id");
                  if (node3 && node3.value === id2) {
                    return [elem];
                  }
                }
              }
              return [];
            }
          };
        }
        Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context) {
          if (typeof context.getElementsByTagName !== "undefined") {
            return context.getElementsByTagName(tag);
          } else if (support2.qsa) {
            return context.querySelectorAll(tag);
          }
        } : function(tag, context) {
          var elem, tmp = [], i2 = 0, results = context.getElementsByTagName(tag);
          if (tag === "*") {
            while (elem = results[i2++]) {
              if (elem.nodeType === 1) {
                tmp.push(elem);
              }
            }
            return tmp;
          }
          return results;
        };
        Expr.find["CLASS"] = support2.getElementsByClassName && function(className, context) {
          if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };
        rbuggyMatches = [];
        rbuggyQSA = [];
        if (support2.qsa = rnative.test(document3.querySelectorAll)) {
          assert(function(el) {
            var input;
            docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
            if (el.querySelectorAll("[msallowcapture^='']").length) {
              rbuggyQSA.push("[*^$]=" + whitespace + `*(?:''|"")`);
            }
            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            }
            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }
            input = document3.createElement("input");
            input.setAttribute("name", "");
            el.appendChild(input);
            if (!el.querySelectorAll("[name='']").length) {
              rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
            }
            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
            el.querySelectorAll("\\\f");
            rbuggyQSA.push("[\\r\\n\\f]");
          });
          assert(function(el) {
            el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
            var input = document3.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D");
            if (el.querySelectorAll("[name=d]").length) {
              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
            }
            if (el.querySelectorAll(":enabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            docElem.appendChild(el).disabled = true;
            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            el.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }
        if (support2.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
          assert(function(el) {
            support2.disconnectedMatch = matches.call(el, "*");
            matches.call(el, "[s!='']:x");
            rbuggyMatches.push("!=", pseudos);
          });
        }
        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
        hasCompare = rnative.test(docElem.compareDocumentPosition);
        contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
          var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
          return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
        } : function(a, b) {
          if (b) {
            while (b = b.parentNode) {
              if (b === a) {
                return true;
              }
            }
          }
          return false;
        };
        sortOrder = hasCompare ? function(a, b) {
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }
          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
          if (compare) {
            return compare;
          }
          compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
          if (compare & 1 || !support2.sortDetached && b.compareDocumentPosition(a) === compare) {
            if (a == document3 || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
              return -1;
            }
            if (b == document3 || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
              return 1;
            }
            return sortInput ? indexOf3(sortInput, a) - indexOf3(sortInput, b) : 0;
          }
          return compare & 4 ? -1 : 1;
        } : function(a, b) {
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }
          var cur, i2 = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
          if (!aup || !bup) {
            return a == document3 ? -1 : b == document3 ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf3(sortInput, a) - indexOf3(sortInput, b) : 0;
          } else if (aup === bup) {
            return siblingCheck(a, b);
          }
          cur = a;
          while (cur = cur.parentNode) {
            ap.unshift(cur);
          }
          cur = b;
          while (cur = cur.parentNode) {
            bp.unshift(cur);
          }
          while (ap[i2] === bp[i2]) {
            i2++;
          }
          return i2 ? siblingCheck(ap[i2], bp[i2]) : ap[i2] == preferredDoc ? -1 : bp[i2] == preferredDoc ? 1 : 0;
        };
        return document3;
      };
      Sizzle2.matches = function(expr, elements) {
        return Sizzle2(expr, null, null, elements);
      };
      Sizzle2.matchesSelector = function(elem, expr) {
        setDocument(elem);
        if (support2.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
          try {
            var ret = matches.call(elem, expr);
            if (ret || support2.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
              return ret;
            }
          } catch (e) {
            nonnativeSelectorCache(expr, true);
          }
        }
        return Sizzle2(expr, document3, null, [elem]).length > 0;
      };
      Sizzle2.contains = function(context, elem) {
        if ((context.ownerDocument || context) != document3) {
          setDocument(context);
        }
        return contains(context, elem);
      };
      Sizzle2.attr = function(elem, name2) {
        if ((elem.ownerDocument || elem) != document3) {
          setDocument(elem);
        }
        var fn = Expr.attrHandle[name2.toLowerCase()], val = fn && hasOwn2.call(Expr.attrHandle, name2.toLowerCase()) ? fn(elem, name2, !documentIsHTML) : void 0;
        return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name2) : (val = elem.getAttributeNode(name2)) && val.specified ? val.value : null;
      };
      Sizzle2.escape = function(sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };
      Sizzle2.error = function(msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };
      Sizzle2.uniqueSort = function(results) {
        var elem, duplicates = [], j = 0, i2 = 0;
        hasDuplicate = !support2.detectDuplicates;
        sortInput = !support2.sortStable && results.slice(0);
        results.sort(sortOrder);
        if (hasDuplicate) {
          while (elem = results[i2++]) {
            if (elem === results[i2]) {
              j = duplicates.push(i2);
            }
          }
          while (j--) {
            results.splice(duplicates[j], 1);
          }
        }
        sortInput = null;
        return results;
      };
      getText = Sizzle2.getText = function(elem) {
        var node2, ret = "", i2 = 0, nodeType = elem.nodeType;
        if (!nodeType) {
          while (node2 = elem[i2++]) {
            ret += getText(node2);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          if (typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        }
        return ret;
      };
      Expr = Sizzle2.selectors = {
        cacheLength: 50,
        createPseudo: markFunction,
        match: matchExpr,
        attrHandle: {},
        find: {},
        relative: {
          ">": { dir: "parentNode", first: true },
          " ": { dir: "parentNode" },
          "+": { dir: "previousSibling", first: true },
          "~": { dir: "previousSibling" }
        },
        preFilter: {
          "ATTR": function(match2) {
            match2[1] = match2[1].replace(runescape, funescape);
            match2[3] = (match2[3] || match2[4] || match2[5] || "").replace(runescape, funescape);
            if (match2[2] === "~=") {
              match2[3] = " " + match2[3] + " ";
            }
            return match2.slice(0, 4);
          },
          "CHILD": function(match2) {
            match2[1] = match2[1].toLowerCase();
            if (match2[1].slice(0, 3) === "nth") {
              if (!match2[3]) {
                Sizzle2.error(match2[0]);
              }
              match2[4] = +(match2[4] ? match2[5] + (match2[6] || 1) : 2 * (match2[3] === "even" || match2[3] === "odd"));
              match2[5] = +(match2[7] + match2[8] || match2[3] === "odd");
            } else if (match2[3]) {
              Sizzle2.error(match2[0]);
            }
            return match2;
          },
          "PSEUDO": function(match2) {
            var excess, unquoted = !match2[6] && match2[2];
            if (matchExpr["CHILD"].test(match2[0])) {
              return null;
            }
            if (match2[3]) {
              match2[2] = match2[4] || match2[5] || "";
            } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
              match2[0] = match2[0].slice(0, excess);
              match2[2] = unquoted.slice(0, excess);
            }
            return match2.slice(0, 3);
          }
        },
        filter: {
          "TAG": function(nodeNameSelector) {
            var nodeName2 = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === "*" ? function() {
              return true;
            } : function(elem) {
              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName2;
            };
          },
          "CLASS": function(className) {
            var pattern = classCache[className + " "];
            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
              return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
            });
          },
          "ATTR": function(name2, operator, check) {
            return function(elem) {
              var result = Sizzle2.attr(elem, name2);
              if (result == null) {
                return operator === "!=";
              }
              if (!operator) {
                return true;
              }
              result += "";
              return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
            };
          },
          "CHILD": function(type, what, _argument, first, last2) {
            var simple2 = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
            return first === 1 && last2 === 0 ? function(elem) {
              return !!elem.parentNode;
            } : function(elem, _context, xml2) {
              var cache, uniqueCache, outerCache, node2, nodeIndex, start, dir2 = simple2 !== forward ? "nextSibling" : "previousSibling", parent2 = elem.parentNode, name2 = ofType && elem.nodeName.toLowerCase(), useCache = !xml2 && !ofType, diff2 = false;
              if (parent2) {
                if (simple2) {
                  while (dir2) {
                    node2 = elem;
                    while (node2 = node2[dir2]) {
                      if (ofType ? node2.nodeName.toLowerCase() === name2 : node2.nodeType === 1) {
                        return false;
                      }
                    }
                    start = dir2 = type === "only" && !start && "nextSibling";
                  }
                  return true;
                }
                start = [forward ? parent2.firstChild : parent2.lastChild];
                if (forward && useCache) {
                  node2 = parent2;
                  outerCache = node2[expando] || (node2[expando] = {});
                  uniqueCache = outerCache[node2.uniqueID] || (outerCache[node2.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff2 = nodeIndex && cache[2];
                  node2 = nodeIndex && parent2.childNodes[nodeIndex];
                  while (node2 = ++nodeIndex && node2 && node2[dir2] || (diff2 = nodeIndex = 0) || start.pop()) {
                    if (node2.nodeType === 1 && ++diff2 && node2 === elem) {
                      uniqueCache[type] = [dirruns, nodeIndex, diff2];
                      break;
                    }
                  }
                } else {
                  if (useCache) {
                    node2 = elem;
                    outerCache = node2[expando] || (node2[expando] = {});
                    uniqueCache = outerCache[node2.uniqueID] || (outerCache[node2.uniqueID] = {});
                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff2 = nodeIndex;
                  }
                  if (diff2 === false) {
                    while (node2 = ++nodeIndex && node2 && node2[dir2] || (diff2 = nodeIndex = 0) || start.pop()) {
                      if ((ofType ? node2.nodeName.toLowerCase() === name2 : node2.nodeType === 1) && ++diff2) {
                        if (useCache) {
                          outerCache = node2[expando] || (node2[expando] = {});
                          uniqueCache = outerCache[node2.uniqueID] || (outerCache[node2.uniqueID] = {});
                          uniqueCache[type] = [dirruns, diff2];
                        }
                        if (node2 === elem) {
                          break;
                        }
                      }
                    }
                  }
                }
                diff2 -= last2;
                return diff2 === first || diff2 % first === 0 && diff2 / first >= 0;
              }
            };
          },
          "PSEUDO": function(pseudo, argument) {
            var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
            if (fn[expando]) {
              return fn(argument);
            }
            if (fn.length > 1) {
              args = [pseudo, pseudo, "", argument];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                var idx, matched = fn(seed, argument), i2 = matched.length;
                while (i2--) {
                  idx = indexOf3(seed, matched[i2]);
                  seed[idx] = !(matches2[idx] = matched[i2]);
                }
              }) : function(elem) {
                return fn(elem, 0, args);
              };
            }
            return fn;
          }
        },
        pseudos: {
          "not": markFunction(function(selector2) {
            var input = [], results = [], matcher = compile3(selector2.replace(rtrim2, "$1"));
            return matcher[expando] ? markFunction(function(seed, matches2, _context, xml2) {
              var elem, unmatched = matcher(seed, null, xml2, []), i2 = seed.length;
              while (i2--) {
                if (elem = unmatched[i2]) {
                  seed[i2] = !(matches2[i2] = elem);
                }
              }
            }) : function(elem, _context, xml2) {
              input[0] = elem;
              matcher(input, null, xml2, results);
              input[0] = null;
              return !results.pop();
            };
          }),
          "has": markFunction(function(selector2) {
            return function(elem) {
              return Sizzle2(selector2, elem).length > 0;
            };
          }),
          "contains": markFunction(function(text) {
            text = text.replace(runescape, funescape);
            return function(elem) {
              return (elem.textContent || getText(elem)).indexOf(text) > -1;
            };
          }),
          "lang": markFunction(function(lang) {
            if (!ridentifier.test(lang || "")) {
              Sizzle2.error("unsupported lang: " + lang);
            }
            lang = lang.replace(runescape, funescape).toLowerCase();
            return function(elem) {
              var elemLang;
              do {
                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);
              return false;
            };
          }),
          "target": function(elem) {
            var hash = window3.location && window3.location.hash;
            return hash && hash.slice(1) === elem.id;
          },
          "root": function(elem) {
            return elem === docElem;
          },
          "focus": function(elem) {
            return elem === document3.activeElement && (!document3.hasFocus || document3.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
          },
          "enabled": createDisabledPseudo(false),
          "disabled": createDisabledPseudo(true),
          "checked": function(elem) {
            var nodeName2 = elem.nodeName.toLowerCase();
            return nodeName2 === "input" && !!elem.checked || nodeName2 === "option" && !!elem.selected;
          },
          "selected": function(elem) {
            if (elem.parentNode) {
              elem.parentNode.selectedIndex;
            }
            return elem.selected === true;
          },
          "empty": function(elem) {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }
            return true;
          },
          "parent": function(elem) {
            return !Expr.pseudos["empty"](elem);
          },
          "header": function(elem) {
            return rheader.test(elem.nodeName);
          },
          "input": function(elem) {
            return rinputs.test(elem.nodeName);
          },
          "button": function(elem) {
            var name2 = elem.nodeName.toLowerCase();
            return name2 === "input" && elem.type === "button" || name2 === "button";
          },
          "text": function(elem) {
            var attr2;
            return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr2 = elem.getAttribute("type")) == null || attr2.toLowerCase() === "text");
          },
          "first": createPositionalPseudo(function() {
            return [0];
          }),
          "last": createPositionalPseudo(function(_matchIndexes, length2) {
            return [length2 - 1];
          }),
          "eq": createPositionalPseudo(function(_matchIndexes, length2, argument) {
            return [argument < 0 ? argument + length2 : argument];
          }),
          "even": createPositionalPseudo(function(matchIndexes, length2) {
            var i2 = 0;
            for (; i2 < length2; i2 += 2) {
              matchIndexes.push(i2);
            }
            return matchIndexes;
          }),
          "odd": createPositionalPseudo(function(matchIndexes, length2) {
            var i2 = 1;
            for (; i2 < length2; i2 += 2) {
              matchIndexes.push(i2);
            }
            return matchIndexes;
          }),
          "lt": createPositionalPseudo(function(matchIndexes, length2, argument) {
            var i2 = argument < 0 ? argument + length2 : argument > length2 ? length2 : argument;
            for (; --i2 >= 0; ) {
              matchIndexes.push(i2);
            }
            return matchIndexes;
          }),
          "gt": createPositionalPseudo(function(matchIndexes, length2, argument) {
            var i2 = argument < 0 ? argument + length2 : argument;
            for (; ++i2 < length2; ) {
              matchIndexes.push(i2);
            }
            return matchIndexes;
          })
        }
      };
      Expr.pseudos["nth"] = Expr.pseudos["eq"];
      for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }
      for (i in { submit: true, reset: true }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      }
      function setFilters() {
      }
      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();
      tokenize = Sizzle2.tokenize = function(selector2, parseOnly) {
        var matched, match2, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector2 + " "];
        if (cached) {
          return parseOnly ? 0 : cached.slice(0);
        }
        soFar = selector2;
        groups = [];
        preFilters = Expr.preFilter;
        while (soFar) {
          if (!matched || (match2 = rcomma.exec(soFar))) {
            if (match2) {
              soFar = soFar.slice(match2[0].length) || soFar;
            }
            groups.push(tokens = []);
          }
          matched = false;
          if (match2 = rcombinators.exec(soFar)) {
            matched = match2.shift();
            tokens.push({
              value: matched,
              type: match2[0].replace(rtrim2, " ")
            });
            soFar = soFar.slice(matched.length);
          }
          for (type in Expr.filter) {
            if ((match2 = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match2 = preFilters[type](match2)))) {
              matched = match2.shift();
              tokens.push({
                value: matched,
                type,
                matches: match2
              });
              soFar = soFar.slice(matched.length);
            }
          }
          if (!matched) {
            break;
          }
        }
        return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector2) : tokenCache(selector2, groups).slice(0);
      };
      function toSelector(tokens) {
        var i2 = 0, len = tokens.length, selector2 = "";
        for (; i2 < len; i2++) {
          selector2 += tokens[i2].value;
        }
        return selector2;
      }
      function addCombinator(matcher, combinator, base2) {
        var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base2 && key === "parentNode", doneName = done++;
        return combinator.first ? function(elem, context, xml2) {
          while (elem = elem[dir2]) {
            if (elem.nodeType === 1 || checkNonElements) {
              return matcher(elem, context, xml2);
            }
          }
          return false;
        } : function(elem, context, xml2) {
          var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
          if (xml2) {
            while (elem = elem[dir2]) {
              if (elem.nodeType === 1 || checkNonElements) {
                if (matcher(elem, context, xml2)) {
                  return true;
                }
              }
            }
          } else {
            while (elem = elem[dir2]) {
              if (elem.nodeType === 1 || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {});
                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                if (skip && skip === elem.nodeName.toLowerCase()) {
                  elem = elem[dir2] || elem;
                } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                  return newCache[2] = oldCache[2];
                } else {
                  uniqueCache[key] = newCache;
                  if (newCache[2] = matcher(elem, context, xml2)) {
                    return true;
                  }
                }
              }
            }
          }
          return false;
        };
      }
      function elementMatcher(matchers) {
        return matchers.length > 1 ? function(elem, context, xml2) {
          var i2 = matchers.length;
          while (i2--) {
            if (!matchers[i2](elem, context, xml2)) {
              return false;
            }
          }
          return true;
        } : matchers[0];
      }
      function multipleContexts(selector2, contexts, results) {
        var i2 = 0, len = contexts.length;
        for (; i2 < len; i2++) {
          Sizzle2(selector2, contexts[i2], results);
        }
        return results;
      }
      function condense(unmatched, map2, filter2, context, xml2) {
        var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map2 != null;
        for (; i2 < len; i2++) {
          if (elem = unmatched[i2]) {
            if (!filter2 || filter2(elem, context, xml2)) {
              newUnmatched.push(elem);
              if (mapped) {
                map2.push(i2);
              }
            }
          }
        }
        return newUnmatched;
      }
      function setMatcher(preFilter, selector2, matcher, postFilter, postFinder, postSelector) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }
        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }
        return markFunction(function(seed, results, context, xml2) {
          var temp, i2, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector2 || "*", context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector2) ? condense(elems, preMap, preFilter, context, xml2) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
          if (matcher) {
            matcher(matcherIn, matcherOut, context, xml2);
          }
          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml2);
            i2 = temp.length;
            while (i2--) {
              if (elem = temp[i2]) {
                matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
              }
            }
          }
          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {
                temp = [];
                i2 = matcherOut.length;
                while (i2--) {
                  if (elem = matcherOut[i2]) {
                    temp.push(matcherIn[i2] = elem);
                  }
                }
                postFinder(null, matcherOut = [], temp, xml2);
              }
              i2 = matcherOut.length;
              while (i2--) {
                if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf3(seed, elem) : preMap[i2]) > -1) {
                  seed[temp] = !(results[temp] = elem);
                }
              }
            }
          } else {
            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
            if (postFinder) {
              postFinder(null, results, matcherOut, xml2);
            } else {
              push2.apply(results, matcherOut);
            }
          }
        });
      }
      function matcherFromTokens(tokens) {
        var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
          return indexOf3(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [function(elem, context, xml2) {
          var ret = !leadingRelative && (xml2 || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml2) : matchAnyContext(elem, context, xml2));
          checkContext = null;
          return ret;
        }];
        for (; i2 < len; i2++) {
          if (matcher = Expr.relative[tokens[i2].type]) {
            matchers = [addCombinator(elementMatcher(matchers), matcher)];
          } else {
            matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
            if (matcher[expando]) {
              j = ++i2;
              for (; j < len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }
              return setMatcher(i2 > 1 && elementMatcher(matchers), i2 > 1 && toSelector(tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })).replace(rtrim2, "$1"), matcher, i2 < j && matcherFromTokens(tokens.slice(i2, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
            }
            matchers.push(matcher);
          }
        }
        return elementMatcher(matchers);
      }
      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml2, results, outermost) {
          var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
          if (outermost) {
            outermostContext = context == document3 || context || outermost;
          }
          for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
            if (byElement && elem) {
              j = 0;
              if (!context && elem.ownerDocument != document3) {
                setDocument(elem);
                xml2 = !documentIsHTML;
              }
              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context || document3, xml2)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
              }
            }
            if (bySet) {
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          matchedCount += i2;
          if (bySet && i2 !== matchedCount) {
            j = 0;
            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml2);
            }
            if (seed) {
              if (matchedCount > 0) {
                while (i2--) {
                  if (!(unmatched[i2] || setMatched[i2])) {
                    setMatched[i2] = pop.call(results);
                  }
                }
              }
              setMatched = condense(setMatched);
            }
            push2.apply(results, setMatched);
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle2.uniqueSort(results);
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
        return bySet ? markFunction(superMatcher) : superMatcher;
      }
      compile3 = Sizzle2.compile = function(selector2, match2) {
        var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector2 + " "];
        if (!cached) {
          if (!match2) {
            match2 = tokenize(selector2);
          }
          i2 = match2.length;
          while (i2--) {
            cached = matcherFromTokens(match2[i2]);
            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          }
          cached = compilerCache(selector2, matcherFromGroupMatchers(elementMatchers, setMatchers));
          cached.selector = selector2;
        }
        return cached;
      };
      select = Sizzle2.select = function(selector2, context, results, seed) {
        var i2, tokens, token, type, find2, compiled = typeof selector2 === "function" && selector2, match2 = !seed && tokenize(selector2 = compiled.selector || selector2);
        results = results || [];
        if (match2.length === 1) {
          tokens = match2[0] = match2[0].slice(0);
          if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
            if (!context) {
              return results;
            } else if (compiled) {
              context = context.parentNode;
            }
            selector2 = selector2.slice(tokens.shift().value.length);
          }
          i2 = matchExpr["needsContext"].test(selector2) ? 0 : tokens.length;
          while (i2--) {
            token = tokens[i2];
            if (Expr.relative[type = token.type]) {
              break;
            }
            if (find2 = Expr.find[type]) {
              if (seed = find2(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                tokens.splice(i2, 1);
                selector2 = seed.length && toSelector(tokens);
                if (!selector2) {
                  push2.apply(results, seed);
                  return results;
                }
                break;
              }
            }
          }
        }
        (compiled || compile3(selector2, match2))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector2) && testContext(context.parentNode) || context);
        return results;
      };
      support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
      support2.detectDuplicates = !!hasDuplicate;
      setDocument();
      support2.sortDetached = assert(function(el) {
        return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
      });
      if (!assert(function(el) {
        el.innerHTML = "<a href='#'></a>";
        return el.firstChild.getAttribute("href") === "#";
      })) {
        addHandle("type|href|height|width", function(elem, name2, isXML2) {
          if (!isXML2) {
            return elem.getAttribute(name2, name2.toLowerCase() === "type" ? 1 : 2);
          }
        });
      }
      if (!support2.attributes || !assert(function(el) {
        el.innerHTML = "<input/>";
        el.firstChild.setAttribute("value", "");
        return el.firstChild.getAttribute("value") === "";
      })) {
        addHandle("value", function(elem, _name, isXML2) {
          if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
            return elem.defaultValue;
          }
        });
      }
      if (!assert(function(el) {
        return el.getAttribute("disabled") == null;
      })) {
        addHandle(booleans, function(elem, name2, isXML2) {
          var val;
          if (!isXML2) {
            return elem[name2] === true ? name2.toLowerCase() : (val = elem.getAttributeNode(name2)) && val.specified ? val.value : null;
          }
        });
      }
      return Sizzle2;
    }(window2);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;
    var dir = function(elem, dir2, until) {
      var matched = [], truncate = until !== void 0;
      while ((elem = elem[dir2]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    };
    var siblings = function(n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    function nodeName(elem, name2) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name2.toLowerCase();
    }
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function winnow(elements, qualifier, not) {
      if (isFunction3(qualifier)) {
        return jQuery.grep(elements, function(elem, i) {
          return !!qualifier.call(elem, i, elem) !== not;
        });
      }
      if (qualifier.nodeType) {
        return jQuery.grep(elements, function(elem) {
          return elem === qualifier !== not;
        });
      }
      if (typeof qualifier !== "string") {
        return jQuery.grep(elements, function(elem) {
          return indexOf2.call(qualifier, elem) > -1 !== not;
        });
      }
      return jQuery.filter(qualifier, elements, not);
    }
    jQuery.filter = function(expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ":not(" + expr + ")";
      }
      if (elems.length === 1 && elem.nodeType === 1) {
        return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
      }
      return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
        return elem2.nodeType === 1;
      }));
    };
    jQuery.fn.extend({
      find: function(selector2) {
        var i, ret, len = this.length, self2 = this;
        if (typeof selector2 !== "string") {
          return this.pushStack(jQuery(selector2).filter(function() {
            for (i = 0; i < len; i++) {
              if (jQuery.contains(self2[i], this)) {
                return true;
              }
            }
          }));
        }
        ret = this.pushStack([]);
        for (i = 0; i < len; i++) {
          jQuery.find(selector2, self2[i], ret);
        }
        return len > 1 ? jQuery.uniqueSort(ret) : ret;
      },
      filter: function(selector2) {
        return this.pushStack(winnow(this, selector2 || [], false));
      },
      not: function(selector2) {
        return this.pushStack(winnow(this, selector2 || [], true));
      },
      is: function(selector2) {
        return !!winnow(this, typeof selector2 === "string" && rneedsContext.test(selector2) ? jQuery(selector2) : selector2 || [], false).length;
      }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init2 = jQuery.fn.init = function(selector2, context, root2) {
      var match2, elem;
      if (!selector2) {
        return this;
      }
      root2 = root2 || rootjQuery;
      if (typeof selector2 === "string") {
        if (selector2[0] === "<" && selector2[selector2.length - 1] === ">" && selector2.length >= 3) {
          match2 = [null, selector2, null];
        } else {
          match2 = rquickExpr.exec(selector2);
        }
        if (match2 && (match2[1] || !context)) {
          if (match2[1]) {
            context = context instanceof jQuery ? context[0] : context;
            jQuery.merge(this, jQuery.parseHTML(match2[1], context && context.nodeType ? context.ownerDocument || context : document2, true));
            if (rsingleTag.test(match2[1]) && jQuery.isPlainObject(context)) {
              for (match2 in context) {
                if (isFunction3(this[match2])) {
                  this[match2](context[match2]);
                } else {
                  this.attr(match2, context[match2]);
                }
              }
            }
            return this;
          } else {
            elem = document2.getElementById(match2[2]);
            if (elem) {
              this[0] = elem;
              this.length = 1;
            }
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || root2).find(selector2);
        } else {
          return this.constructor(context).find(selector2);
        }
      } else if (selector2.nodeType) {
        this[0] = selector2;
        this.length = 1;
        return this;
      } else if (isFunction3(selector2)) {
        return root2.ready !== void 0 ? root2.ready(selector2) : selector2(jQuery);
      }
      return jQuery.makeArray(selector2, this);
    };
    init2.prototype = jQuery.fn;
    rootjQuery = jQuery(document2);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
    jQuery.fn.extend({
      has: function(target) {
        var targets = jQuery(target, this), l = targets.length;
        return this.filter(function() {
          var i = 0;
          for (; i < l; i++) {
            if (jQuery.contains(this, targets[i])) {
              return true;
            }
          }
        });
      },
      closest: function(selectors, context) {
        var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
        if (!rneedsContext.test(selectors)) {
          for (; i < l; i++) {
            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
              if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                matched.push(cur);
                break;
              }
            }
          }
        }
        return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
      },
      index: function(elem) {
        if (!elem) {
          return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        }
        if (typeof elem === "string") {
          return indexOf2.call(jQuery(elem), this[0]);
        }
        return indexOf2.call(this, elem.jquery ? elem[0] : elem);
      },
      add: function(selector2, context) {
        return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector2, context))));
      },
      addBack: function(selector2) {
        return this.add(selector2 == null ? this.prevObject : this.prevObject.filter(selector2));
      }
    });
    function sibling(cur, dir2) {
      while ((cur = cur[dir2]) && cur.nodeType !== 1) {
      }
      return cur;
    }
    jQuery.each({
      parent: function(elem) {
        var parent2 = elem.parentNode;
        return parent2 && parent2.nodeType !== 11 ? parent2 : null;
      },
      parents: function(elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function(elem, _i, until) {
        return dir(elem, "parentNode", until);
      },
      next: function(elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function(elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function(elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function(elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function(elem, _i, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function(elem, _i, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function(elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function(elem) {
        return siblings(elem.firstChild);
      },
      contents: function(elem) {
        if (elem.contentDocument != null && getProto(elem.contentDocument)) {
          return elem.contentDocument;
        }
        if (nodeName(elem, "template")) {
          elem = elem.content || elem;
        }
        return jQuery.merge([], elem.childNodes);
      }
    }, function(name2, fn) {
      jQuery.fn[name2] = function(until, selector2) {
        var matched = jQuery.map(this, fn, until);
        if (name2.slice(-5) !== "Until") {
          selector2 = until;
        }
        if (selector2 && typeof selector2 === "string") {
          matched = jQuery.filter(selector2, matched);
        }
        if (this.length > 1) {
          if (!guaranteedUnique[name2]) {
            jQuery.uniqueSort(matched);
          }
          if (rparentsprev.test(name2)) {
            matched.reverse();
          }
        }
        return this.pushStack(matched);
      };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    function createOptions(options) {
      var object = {};
      jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
        object[flag] = true;
      });
      return object;
    }
    jQuery.Callbacks = function(options) {
      options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
      var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
        locked = locked || options.once;
        fired = firing = true;
        for (; queue.length; firingIndex = -1) {
          memory = queue.shift();
          while (++firingIndex < list.length) {
            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
              firingIndex = list.length;
              memory = false;
            }
          }
        }
        if (!options.memory) {
          memory = false;
        }
        firing = false;
        if (locked) {
          if (memory) {
            list = [];
          } else {
            list = "";
          }
        }
      }, self2 = {
        add: function() {
          if (list) {
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue.push(memory);
            }
            (function add2(args) {
              jQuery.each(args, function(_, arg) {
                if (isFunction3(arg)) {
                  if (!options.unique || !self2.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && toType(arg) !== "string") {
                  add2(arg);
                }
              });
            })(arguments);
            if (memory && !firing) {
              fire();
            }
          }
          return this;
        },
        remove: function() {
          jQuery.each(arguments, function(_, arg) {
            var index2;
            while ((index2 = jQuery.inArray(arg, list, index2)) > -1) {
              list.splice(index2, 1);
              if (index2 <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },
        has: function(fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
        },
        empty: function() {
          if (list) {
            list = [];
          }
          return this;
        },
        disable: function() {
          locked = queue = [];
          list = memory = "";
          return this;
        },
        disabled: function() {
          return !list;
        },
        lock: function() {
          locked = queue = [];
          if (!memory && !firing) {
            list = memory = "";
          }
          return this;
        },
        locked: function() {
          return !!locked;
        },
        fireWith: function(context, args) {
          if (!locked) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            queue.push(args);
            if (!firing) {
              fire();
            }
          }
          return this;
        },
        fire: function() {
          self2.fireWith(this, arguments);
          return this;
        },
        fired: function() {
          return !!fired;
        }
      };
      return self2;
    };
    function Identity(v) {
      return v;
    }
    function Thrower(ex) {
      throw ex;
    }
    function adoptValue(value, resolve, reject, noValue) {
      var method;
      try {
        if (value && isFunction3(method = value.promise)) {
          method.call(value).done(resolve).fail(reject);
        } else if (value && isFunction3(method = value.then)) {
          method.call(value, resolve, reject);
        } else {
          resolve.apply(void 0, [value].slice(noValue));
        }
      } catch (value2) {
        reject.apply(void 0, [value2]);
      }
    }
    jQuery.extend({
      Deferred: function(func) {
        var tuples = [
          [
            "notify",
            "progress",
            jQuery.Callbacks("memory"),
            jQuery.Callbacks("memory"),
            2
          ],
          [
            "resolve",
            "done",
            jQuery.Callbacks("once memory"),
            jQuery.Callbacks("once memory"),
            0,
            "resolved"
          ],
          [
            "reject",
            "fail",
            jQuery.Callbacks("once memory"),
            jQuery.Callbacks("once memory"),
            1,
            "rejected"
          ]
        ], state = "pending", promise = {
          state: function() {
            return state;
          },
          always: function() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          "catch": function(fn) {
            return promise.then(null, fn);
          },
          pipe: function() {
            var fns = arguments;
            return jQuery.Deferred(function(newDefer) {
              jQuery.each(tuples, function(_i, tuple) {
                var fn = isFunction3(fns[tuple[4]]) && fns[tuple[4]];
                deferred[tuple[1]](function() {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && isFunction3(returned.promise)) {
                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                  } else {
                    newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          then: function(onFulfilled, onRejected, onProgress) {
            var maxDepth = 0;
            function resolve(depth, deferred2, handler, special) {
              return function() {
                var that = this, args = arguments, mightThrow = function() {
                  var returned, then;
                  if (depth < maxDepth) {
                    return;
                  }
                  returned = handler.apply(that, args);
                  if (returned === deferred2.promise()) {
                    throw new TypeError("Thenable self-resolution");
                  }
                  then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                  if (isFunction3(then)) {
                    if (special) {
                      then.call(returned, resolve(maxDepth, deferred2, Identity, special), resolve(maxDepth, deferred2, Thrower, special));
                    } else {
                      maxDepth++;
                      then.call(returned, resolve(maxDepth, deferred2, Identity, special), resolve(maxDepth, deferred2, Thrower, special), resolve(maxDepth, deferred2, Identity, deferred2.notifyWith));
                    }
                  } else {
                    if (handler !== Identity) {
                      that = void 0;
                      args = [returned];
                    }
                    (special || deferred2.resolveWith)(that, args);
                  }
                }, process2 = special ? mightThrow : function() {
                  try {
                    mightThrow();
                  } catch (e) {
                    if (jQuery.Deferred.exceptionHook) {
                      jQuery.Deferred.exceptionHook(e, process2.stackTrace);
                    }
                    if (depth + 1 >= maxDepth) {
                      if (handler !== Thrower) {
                        that = void 0;
                        args = [e];
                      }
                      deferred2.rejectWith(that, args);
                    }
                  }
                };
                if (depth) {
                  process2();
                } else {
                  if (jQuery.Deferred.getStackHook) {
                    process2.stackTrace = jQuery.Deferred.getStackHook();
                  }
                  window2.setTimeout(process2);
                }
              };
            }
            return jQuery.Deferred(function(newDefer) {
              tuples[0][3].add(resolve(0, newDefer, isFunction3(onProgress) ? onProgress : Identity, newDefer.notifyWith));
              tuples[1][3].add(resolve(0, newDefer, isFunction3(onFulfilled) ? onFulfilled : Identity));
              tuples[2][3].add(resolve(0, newDefer, isFunction3(onRejected) ? onRejected : Thrower));
            }).promise();
          },
          promise: function(obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        }, deferred = {};
        jQuery.each(tuples, function(i, tuple) {
          var list = tuple[2], stateString = tuple[5];
          promise[tuple[1]] = list.add;
          if (stateString) {
            list.add(function() {
              state = stateString;
            }, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock);
          }
          list.add(tuple[3].fire);
          deferred[tuple[0]] = function() {
            deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
            return this;
          };
          deferred[tuple[0] + "With"] = list.fireWith;
        });
        promise.promise(deferred);
        if (func) {
          func.call(deferred, deferred);
        }
        return deferred;
      },
      when: function(singleValue) {
        var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice2.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i2) {
          return function(value) {
            resolveContexts[i2] = this;
            resolveValues[i2] = arguments.length > 1 ? slice2.call(arguments) : value;
            if (!--remaining) {
              primary.resolveWith(resolveContexts, resolveValues);
            }
          };
        };
        if (remaining <= 1) {
          adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining);
          if (primary.state() === "pending" || isFunction3(resolveValues[i] && resolveValues[i].then)) {
            return primary.then();
          }
        }
        while (i--) {
          adoptValue(resolveValues[i], updateFunc(i), primary.reject);
        }
        return primary.promise();
      }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function(error2, stack) {
      if (window2.console && window2.console.warn && error2 && rerrorNames.test(error2.name)) {
        window2.console.warn("jQuery.Deferred exception: " + error2.message, error2.stack, stack);
      }
    };
    jQuery.readyException = function(error2) {
      window2.setTimeout(function() {
        throw error2;
      });
    };
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function(fn) {
      readyList.then(fn).catch(function(error2) {
        jQuery.readyException(error2);
      });
      return this;
    };
    jQuery.extend({
      isReady: false,
      readyWait: 1,
      ready: function(wait) {
        if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
          return;
        }
        jQuery.isReady = true;
        if (wait !== true && --jQuery.readyWait > 0) {
          return;
        }
        readyList.resolveWith(document2, [jQuery]);
      }
    });
    jQuery.ready.then = readyList.then;
    function completed() {
      document2.removeEventListener("DOMContentLoaded", completed);
      window2.removeEventListener("load", completed);
      jQuery.ready();
    }
    if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
      window2.setTimeout(jQuery.ready);
    } else {
      document2.addEventListener("DOMContentLoaded", completed);
      window2.addEventListener("load", completed);
    }
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0, len = elems.length, bulk = key == null;
      if (toType(key) === "object") {
        chainable = true;
        for (i in key) {
          access(elems, fn, i, key[i], true, emptyGet, raw);
        }
      } else if (value !== void 0) {
        chainable = true;
        if (!isFunction3(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn.call(elems, value);
            fn = null;
          } else {
            bulk = fn;
            fn = function(elem, _key, value2) {
              return bulk.call(jQuery(elem), value2);
            };
          }
        }
        if (fn) {
          for (; i < len; i++) {
            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          }
        }
      }
      if (chainable) {
        return elems;
      }
      if (bulk) {
        return fn.call(elems);
      }
      return len ? fn(elems[0], key) : emptyGet;
    };
    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
    function fcamelCase(_all, letter) {
      return letter.toUpperCase();
    }
    function camelCase(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function(owner) {
      return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
      this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
      cache: function(owner) {
        var value = owner[this.expando];
        if (!value) {
          value = {};
          if (acceptData(owner)) {
            if (owner.nodeType) {
              owner[this.expando] = value;
            } else {
              Object.defineProperty(owner, this.expando, {
                value,
                configurable: true
              });
            }
          }
        }
        return value;
      },
      set: function(owner, data, value) {
        var prop, cache = this.cache(owner);
        if (typeof data === "string") {
          cache[camelCase(data)] = value;
        } else {
          for (prop in data) {
            cache[camelCase(prop)] = data[prop];
          }
        }
        return cache;
      },
      get: function(owner, key) {
        return key === void 0 ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
      },
      access: function(owner, key, value) {
        if (key === void 0 || key && typeof key === "string" && value === void 0) {
          return this.get(owner, key);
        }
        this.set(owner, key, value);
        return value !== void 0 ? value : key;
      },
      remove: function(owner, key) {
        var i, cache = owner[this.expando];
        if (cache === void 0) {
          return;
        }
        if (key !== void 0) {
          if (Array.isArray(key)) {
            key = key.map(camelCase);
          } else {
            key = camelCase(key);
            key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
          }
          i = key.length;
          while (i--) {
            delete cache[key[i]];
          }
        }
        if (key === void 0 || jQuery.isEmptyObject(cache)) {
          if (owner.nodeType) {
            owner[this.expando] = void 0;
          } else {
            delete owner[this.expando];
          }
        }
      },
      hasData: function(owner) {
        var cache = owner[this.expando];
        return cache !== void 0 && !jQuery.isEmptyObject(cache);
      }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData2(data) {
      if (data === "true") {
        return true;
      }
      if (data === "false") {
        return false;
      }
      if (data === "null") {
        return null;
      }
      if (data === +data + "") {
        return +data;
      }
      if (rbrace.test(data)) {
        return JSON.parse(data);
      }
      return data;
    }
    function dataAttr(elem, key, data) {
      var name2;
      if (data === void 0 && elem.nodeType === 1) {
        name2 = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
        data = elem.getAttribute(name2);
        if (typeof data === "string") {
          try {
            data = getData2(data);
          } catch (e) {
          }
          dataUser.set(elem, key, data);
        } else {
          data = void 0;
        }
      }
      return data;
    }
    jQuery.extend({
      hasData: function(elem) {
        return dataUser.hasData(elem) || dataPriv.hasData(elem);
      },
      data: function(elem, name2, data) {
        return dataUser.access(elem, name2, data);
      },
      removeData: function(elem, name2) {
        dataUser.remove(elem, name2);
      },
      _data: function(elem, name2, data) {
        return dataPriv.access(elem, name2, data);
      },
      _removeData: function(elem, name2) {
        dataPriv.remove(elem, name2);
      }
    });
    jQuery.fn.extend({
      data: function(key, value) {
        var i, name2, data, elem = this[0], attrs = elem && elem.attributes;
        if (key === void 0) {
          if (this.length) {
            data = dataUser.get(elem);
            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
              i = attrs.length;
              while (i--) {
                if (attrs[i]) {
                  name2 = attrs[i].name;
                  if (name2.indexOf("data-") === 0) {
                    name2 = camelCase(name2.slice(5));
                    dataAttr(elem, name2, data[name2]);
                  }
                }
              }
              dataPriv.set(elem, "hasDataAttrs", true);
            }
          }
          return data;
        }
        if (typeof key === "object") {
          return this.each(function() {
            dataUser.set(this, key);
          });
        }
        return access(this, function(value2) {
          var data2;
          if (elem && value2 === void 0) {
            data2 = dataUser.get(elem, key);
            if (data2 !== void 0) {
              return data2;
            }
            data2 = dataAttr(elem, key);
            if (data2 !== void 0) {
              return data2;
            }
            return;
          }
          this.each(function() {
            dataUser.set(this, key, value2);
          });
        }, null, value, arguments.length > 1, null, true);
      },
      removeData: function(key) {
        return this.each(function() {
          dataUser.remove(this, key);
        });
      }
    });
    jQuery.extend({
      queue: function(elem, type, data) {
        var queue;
        if (elem) {
          type = (type || "fx") + "queue";
          queue = dataPriv.get(elem, type);
          if (data) {
            if (!queue || Array.isArray(data)) {
              queue = dataPriv.access(elem, type, jQuery.makeArray(data));
            } else {
              queue.push(data);
            }
          }
          return queue || [];
        }
      },
      dequeue: function(elem, type) {
        type = type || "fx";
        var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks2 = jQuery._queueHooks(elem, type), next = function() {
          jQuery.dequeue(elem, type);
        };
        if (fn === "inprogress") {
          fn = queue.shift();
          startLength--;
        }
        if (fn) {
          if (type === "fx") {
            queue.unshift("inprogress");
          }
          delete hooks2.stop;
          fn.call(elem, next, hooks2);
        }
        if (!startLength && hooks2) {
          hooks2.empty.fire();
        }
      },
      _queueHooks: function(elem, type) {
        var key = type + "queueHooks";
        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
          empty: jQuery.Callbacks("once memory").add(function() {
            dataPriv.remove(elem, [type + "queue", key]);
          })
        });
      }
    });
    jQuery.fn.extend({
      queue: function(type, data) {
        var setter = 2;
        if (typeof type !== "string") {
          data = type;
          type = "fx";
          setter--;
        }
        if (arguments.length < setter) {
          return jQuery.queue(this[0], type);
        }
        return data === void 0 ? this : this.each(function() {
          var queue = jQuery.queue(this, type, data);
          jQuery._queueHooks(this, type);
          if (type === "fx" && queue[0] !== "inprogress") {
            jQuery.dequeue(this, type);
          }
        });
      },
      dequeue: function(type) {
        return this.each(function() {
          jQuery.dequeue(this, type);
        });
      },
      clearQueue: function(type) {
        return this.queue(type || "fx", []);
      },
      promise: function(type, obj) {
        var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };
        if (typeof type !== "string") {
          obj = type;
          type = void 0;
        }
        type = type || "fx";
        while (i--) {
          tmp = dataPriv.get(elements[i], type + "queueHooks");
          if (tmp && tmp.empty) {
            count++;
            tmp.empty.add(resolve);
          }
        }
        resolve();
        return defer.promise(obj);
      }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = ["Top", "Right", "Bottom", "Left"];
    var documentElement = document2.documentElement;
    var isAttached2 = function(elem) {
      return jQuery.contains(elem.ownerDocument, elem);
    }, composed = { composed: true };
    if (documentElement.getRootNode) {
      isAttached2 = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
      };
    }
    var isHiddenWithinTree = function(elem, el) {
      elem = el || elem;
      return elem.style.display === "none" || elem.style.display === "" && isAttached2(elem) && jQuery.css(elem, "display") === "none";
    };
    function adjustCSS(elem, prop, valueParts, tween) {
      var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
        return tween.cur();
      } : function() {
        return jQuery.css(elem, prop, "");
      }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
      if (initialInUnit && initialInUnit[3] !== unit) {
        initial = initial / 2;
        unit = unit || initialInUnit[3];
        initialInUnit = +initial || 1;
        while (maxIterations--) {
          jQuery.style(elem, prop, initialInUnit + unit);
          if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
            maxIterations = 0;
          }
          initialInUnit = initialInUnit / scale;
        }
        initialInUnit = initialInUnit * 2;
        jQuery.style(elem, prop, initialInUnit + unit);
        valueParts = valueParts || [];
      }
      if (valueParts) {
        initialInUnit = +initialInUnit || +initial || 0;
        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
        if (tween) {
          tween.unit = unit;
          tween.start = initialInUnit;
          tween.end = adjusted;
        }
      }
      return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
      var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
      if (display) {
        return display;
      }
      temp = doc.body.appendChild(doc.createElement(nodeName2));
      display = jQuery.css(temp, "display");
      temp.parentNode.removeChild(temp);
      if (display === "none") {
        display = "block";
      }
      defaultDisplayMap[nodeName2] = display;
      return display;
    }
    function showHide(elements, show) {
      var display, elem, values2 = [], index2 = 0, length2 = elements.length;
      for (; index2 < length2; index2++) {
        elem = elements[index2];
        if (!elem.style) {
          continue;
        }
        display = elem.style.display;
        if (show) {
          if (display === "none") {
            values2[index2] = dataPriv.get(elem, "display") || null;
            if (!values2[index2]) {
              elem.style.display = "";
            }
          }
          if (elem.style.display === "" && isHiddenWithinTree(elem)) {
            values2[index2] = getDefaultDisplay(elem);
          }
        } else {
          if (display !== "none") {
            values2[index2] = "none";
            dataPriv.set(elem, "display", display);
          }
        }
      }
      for (index2 = 0; index2 < length2; index2++) {
        if (values2[index2] != null) {
          elements[index2].style.display = values2[index2];
        }
      }
      return elements;
    }
    jQuery.fn.extend({
      show: function() {
        return showHide(this, true);
      },
      hide: function() {
        return showHide(this);
      },
      toggle: function(state) {
        if (typeof state === "boolean") {
          return state ? this.show() : this.hide();
        }
        return this.each(function() {
          if (isHiddenWithinTree(this)) {
            jQuery(this).show();
          } else {
            jQuery(this).hide();
          }
        });
      }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
    (function() {
      var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
      input.setAttribute("type", "radio");
      input.setAttribute("checked", "checked");
      input.setAttribute("name", "t");
      div.appendChild(input);
      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
      div.innerHTML = "<textarea>x</textarea>";
      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
      div.innerHTML = "<option></option>";
      support.option = !!div.lastChild;
    })();
    var wrapMap = {
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    };
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    if (!support.option) {
      wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
    }
    function getAll(context, tag) {
      var ret;
      if (typeof context.getElementsByTagName !== "undefined") {
        ret = context.getElementsByTagName(tag || "*");
      } else if (typeof context.querySelectorAll !== "undefined") {
        ret = context.querySelectorAll(tag || "*");
      } else {
        ret = [];
      }
      if (tag === void 0 || tag && nodeName(context, tag)) {
        return jQuery.merge([context], ret);
      }
      return ret;
    }
    function setGlobalEval(elems, refElements) {
      var i = 0, l = elems.length;
      for (; i < l; i++) {
        dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
      }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
      var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (toType(elem) === "object") {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i = 0;
      while (elem = nodes[i++]) {
        if (selection && jQuery.inArray(elem, selection) > -1) {
          if (ignored) {
            ignored.push(elem);
          }
          continue;
        }
        attached = isAttached2(elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (attached) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    }
    var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
      return true;
    }
    function returnFalse() {
      return false;
    }
    function expectSync(elem, type) {
      return elem === safeActiveElement() === (type === "focus");
    }
    function safeActiveElement() {
      try {
        return document2.activeElement;
      } catch (err) {
      }
    }
    function on(elem, types2, selector2, data, fn, one) {
      var origFn, type;
      if (typeof types2 === "object") {
        if (typeof selector2 !== "string") {
          data = data || selector2;
          selector2 = void 0;
        }
        for (type in types2) {
          on(elem, type, selector2, data, types2[type], one);
        }
        return elem;
      }
      if (data == null && fn == null) {
        fn = selector2;
        data = selector2 = void 0;
      } else if (fn == null) {
        if (typeof selector2 === "string") {
          fn = data;
          data = void 0;
        } else {
          fn = data;
          data = selector2;
          selector2 = void 0;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return elem;
      }
      if (one === 1) {
        origFn = fn;
        fn = function(event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return elem.each(function() {
        jQuery.event.add(this, types2, fn, data, selector2);
      });
    }
    jQuery.event = {
      global: {},
      add: function(elem, types2, handler, data, selector2) {
        var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
        if (!acceptData(elem)) {
          return;
        }
        if (handler.handler) {
          handleObjIn = handler;
          handler = handleObjIn.handler;
          selector2 = handleObjIn.selector;
        }
        if (selector2) {
          jQuery.find.matchesSelector(documentElement, selector2);
        }
        if (!handler.guid) {
          handler.guid = jQuery.guid++;
        }
        if (!(events = elemData.events)) {
          events = elemData.events = /* @__PURE__ */ Object.create(null);
        }
        if (!(eventHandle = elemData.handle)) {
          eventHandle = elemData.handle = function(e) {
            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
          };
        }
        types2 = (types2 || "").match(rnothtmlwhite) || [""];
        t = types2.length;
        while (t--) {
          tmp = rtypenamespace.exec(types2[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            continue;
          }
          special = jQuery.event.special[type] || {};
          type = (selector2 ? special.delegateType : special.bindType) || type;
          special = jQuery.event.special[type] || {};
          handleObj = jQuery.extend({
            type,
            origType,
            data,
            handler,
            guid: handler.guid,
            selector: selector2,
            needsContext: selector2 && jQuery.expr.match.needsContext.test(selector2),
            namespace: namespaces.join(".")
          }, handleObjIn);
          if (!(handlers = events[type])) {
            handlers = events[type] = [];
            handlers.delegateCount = 0;
            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
              if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle);
              }
            }
          }
          if (special.add) {
            special.add.call(elem, handleObj);
            if (!handleObj.handler.guid) {
              handleObj.handler.guid = handler.guid;
            }
          }
          if (selector2) {
            handlers.splice(handlers.delegateCount++, 0, handleObj);
          } else {
            handlers.push(handleObj);
          }
          jQuery.event.global[type] = true;
        }
      },
      remove: function(elem, types2, handler, selector2, mappedTypes) {
        var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
        if (!elemData || !(events = elemData.events)) {
          return;
        }
        types2 = (types2 || "").match(rnothtmlwhite) || [""];
        t = types2.length;
        while (t--) {
          tmp = rtypenamespace.exec(types2[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            for (type in events) {
              jQuery.event.remove(elem, type + types2[t], handler, selector2, true);
            }
            continue;
          }
          special = jQuery.event.special[type] || {};
          type = (selector2 ? special.delegateType : special.bindType) || type;
          handlers = events[type] || [];
          tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
          origCount = j = handlers.length;
          while (j--) {
            handleObj = handlers[j];
            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector2 || selector2 === handleObj.selector || selector2 === "**" && handleObj.selector)) {
              handlers.splice(j, 1);
              if (handleObj.selector) {
                handlers.delegateCount--;
              }
              if (special.remove) {
                special.remove.call(elem, handleObj);
              }
            }
          }
          if (origCount && !handlers.length) {
            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
              jQuery.removeEvent(elem, type, elemData.handle);
            }
            delete events[type];
          }
        }
        if (jQuery.isEmptyObject(events)) {
          dataPriv.remove(elem, "handle events");
        }
      },
      dispatch: function(nativeEvent) {
        var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
        args[0] = event;
        for (i = 1; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        event.delegateTarget = this;
        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
          return;
        }
        handlerQueue = jQuery.event.handlers.call(this, event, handlers);
        i = 0;
        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
          event.currentTarget = matched.elem;
          j = 0;
          while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
            if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
              event.handleObj = handleObj;
              event.data = handleObj.data;
              ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
              if (ret !== void 0) {
                if ((event.result = ret) === false) {
                  event.preventDefault();
                  event.stopPropagation();
                }
              }
            }
          }
        }
        if (special.postDispatch) {
          special.postDispatch.call(this, event);
        }
        return event.result;
      },
      handlers: function(event, handlers) {
        var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
        if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
          for (; cur !== this; cur = cur.parentNode || this) {
            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
              matchedHandlers = [];
              matchedSelectors = {};
              for (i = 0; i < delegateCount; i++) {
                handleObj = handlers[i];
                sel = handleObj.selector + " ";
                if (matchedSelectors[sel] === void 0) {
                  matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                }
                if (matchedSelectors[sel]) {
                  matchedHandlers.push(handleObj);
                }
              }
              if (matchedHandlers.length) {
                handlerQueue.push({ elem: cur, handlers: matchedHandlers });
              }
            }
          }
        }
        cur = this;
        if (delegateCount < handlers.length) {
          handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
        }
        return handlerQueue;
      },
      addProp: function(name2, hook) {
        Object.defineProperty(jQuery.Event.prototype, name2, {
          enumerable: true,
          configurable: true,
          get: isFunction3(hook) ? function() {
            if (this.originalEvent) {
              return hook(this.originalEvent);
            }
          } : function() {
            if (this.originalEvent) {
              return this.originalEvent[name2];
            }
          },
          set: function(value) {
            Object.defineProperty(this, name2, {
              enumerable: true,
              configurable: true,
              writable: true,
              value
            });
          }
        });
      },
      fix: function(originalEvent) {
        return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
      },
      special: {
        load: {
          noBubble: true
        },
        click: {
          setup: function(data) {
            var el = this || data;
            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              leverageNative(el, "click", returnTrue);
            }
            return false;
          },
          trigger: function(data) {
            var el = this || data;
            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              leverageNative(el, "click");
            }
            return true;
          },
          _default: function(event) {
            var target = event.target;
            return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
          }
        },
        beforeunload: {
          postDispatch: function(event) {
            if (event.result !== void 0 && event.originalEvent) {
              event.originalEvent.returnValue = event.result;
            }
          }
        }
      }
    };
    function leverageNative(el, type, expectSync2) {
      if (!expectSync2) {
        if (dataPriv.get(el, type) === void 0) {
          jQuery.event.add(el, type, returnTrue);
        }
        return;
      }
      dataPriv.set(el, type, false);
      jQuery.event.add(el, type, {
        namespace: false,
        handler: function(event) {
          var notAsync, result, saved = dataPriv.get(this, type);
          if (event.isTrigger & 1 && this[type]) {
            if (!saved.length) {
              saved = slice2.call(arguments);
              dataPriv.set(this, type, saved);
              notAsync = expectSync2(this, type);
              this[type]();
              result = dataPriv.get(this, type);
              if (saved !== result || notAsync) {
                dataPriv.set(this, type, false);
              } else {
                result = {};
              }
              if (saved !== result) {
                event.stopImmediatePropagation();
                event.preventDefault();
                return result && result.value;
              }
            } else if ((jQuery.event.special[type] || {}).delegateType) {
              event.stopPropagation();
            }
          } else if (saved.length) {
            dataPriv.set(this, type, {
              value: jQuery.event.trigger(jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
            });
            event.stopImmediatePropagation();
          }
        }
      });
    }
    jQuery.removeEvent = function(elem, type, handle) {
      if (elem.removeEventListener) {
        elem.removeEventListener(type, handle);
      }
    };
    jQuery.Event = function(src, props) {
      if (!(this instanceof jQuery.Event)) {
        return new jQuery.Event(src, props);
      }
      if (src && src.type) {
        this.originalEvent = src;
        this.type = src.type;
        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && src.returnValue === false ? returnTrue : returnFalse;
        this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
        this.currentTarget = src.currentTarget;
        this.relatedTarget = src.relatedTarget;
      } else {
        this.type = src;
      }
      if (props) {
        jQuery.extend(this, props);
      }
      this.timeStamp = src && src.timeStamp || Date.now();
      this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
      constructor: jQuery.Event,
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse,
      isSimulated: false,
      preventDefault: function() {
        var e = this.originalEvent;
        this.isDefaultPrevented = returnTrue;
        if (e && !this.isSimulated) {
          e.preventDefault();
        }
      },
      stopPropagation: function() {
        var e = this.originalEvent;
        this.isPropagationStopped = returnTrue;
        if (e && !this.isSimulated) {
          e.stopPropagation();
        }
      },
      stopImmediatePropagation: function() {
        var e = this.originalEvent;
        this.isImmediatePropagationStopped = returnTrue;
        if (e && !this.isSimulated) {
          e.stopImmediatePropagation();
        }
        this.stopPropagation();
      }
    };
    jQuery.each({
      altKey: true,
      bubbles: true,
      cancelable: true,
      changedTouches: true,
      ctrlKey: true,
      detail: true,
      eventPhase: true,
      metaKey: true,
      pageX: true,
      pageY: true,
      shiftKey: true,
      view: true,
      "char": true,
      code: true,
      charCode: true,
      key: true,
      keyCode: true,
      button: true,
      buttons: true,
      clientX: true,
      clientY: true,
      offsetX: true,
      offsetY: true,
      pointerId: true,
      pointerType: true,
      screenX: true,
      screenY: true,
      targetTouches: true,
      toElement: true,
      touches: true,
      which: true
    }, jQuery.event.addProp);
    jQuery.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
      jQuery.event.special[type] = {
        setup: function() {
          leverageNative(this, type, expectSync);
          return false;
        },
        trigger: function() {
          leverageNative(this, type);
          return true;
        },
        _default: function() {
          return true;
        },
        delegateType
      };
    });
    jQuery.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    }, function(orig, fix) {
      jQuery.event.special[orig] = {
        delegateType: fix,
        bindType: fix,
        handle: function(event) {
          var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
          if (!related || related !== target && !jQuery.contains(target, related)) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }
          return ret;
        }
      };
    });
    jQuery.fn.extend({
      on: function(types2, selector2, data, fn) {
        return on(this, types2, selector2, data, fn);
      },
      one: function(types2, selector2, data, fn) {
        return on(this, types2, selector2, data, fn, 1);
      },
      off: function(types2, selector2, fn) {
        var handleObj, type;
        if (types2 && types2.preventDefault && types2.handleObj) {
          handleObj = types2.handleObj;
          jQuery(types2.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
          return this;
        }
        if (typeof types2 === "object") {
          for (type in types2) {
            this.off(type, selector2, types2[type]);
          }
          return this;
        }
        if (selector2 === false || typeof selector2 === "function") {
          fn = selector2;
          selector2 = void 0;
        }
        if (fn === false) {
          fn = returnFalse;
        }
        return this.each(function() {
          jQuery.event.remove(this, types2, fn, selector2);
        });
      }
    });
    var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    function manipulationTarget(elem, content) {
      if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
        return jQuery(elem).children("tbody")[0] || elem;
      }
      return elem;
    }
    function disableScript(elem) {
      elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
      return elem;
    }
    function restoreScript(elem) {
      if ((elem.type || "").slice(0, 5) === "true/") {
        elem.type = elem.type.slice(5);
      } else {
        elem.removeAttribute("type");
      }
      return elem;
    }
    function cloneCopyEvent(src, dest) {
      var i, l, type, pdataOld, udataOld, udataCur, events;
      if (dest.nodeType !== 1) {
        return;
      }
      if (dataPriv.hasData(src)) {
        pdataOld = dataPriv.get(src);
        events = pdataOld.events;
        if (events) {
          dataPriv.remove(dest, "handle events");
          for (type in events) {
            for (i = 0, l = events[type].length; i < l; i++) {
              jQuery.event.add(dest, type, events[type][i]);
            }
          }
        }
      }
      if (dataUser.hasData(src)) {
        udataOld = dataUser.access(src);
        udataCur = jQuery.extend({}, udataOld);
        dataUser.set(dest, udataCur);
      }
    }
    function fixInput(src, dest) {
      var nodeName2 = dest.nodeName.toLowerCase();
      if (nodeName2 === "input" && rcheckableType.test(src.type)) {
        dest.checked = src.checked;
      } else if (nodeName2 === "input" || nodeName2 === "textarea") {
        dest.defaultValue = src.defaultValue;
      }
    }
    function domManip(collection2, args, callback, ignored) {
      args = flat(args);
      var fragment, first, scripts, hasScripts, node2, doc, i = 0, l = collection2.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction3(value);
      if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
        return collection2.each(function(index2) {
          var self2 = collection2.eq(index2);
          if (valueIsFunction) {
            args[0] = value.call(this, index2, self2.html());
          }
          domManip(self2, args, callback, ignored);
        });
      }
      if (l) {
        fragment = buildFragment(args, collection2[0].ownerDocument, false, collection2, ignored);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first || ignored) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node2 = fragment;
            if (i !== iNoClone) {
              node2 = jQuery.clone(node2, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node2, "script"));
              }
            }
            callback.call(collection2[i], node2, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node2 = scripts[i];
              if (rscriptType.test(node2.type || "") && !dataPriv.access(node2, "globalEval") && jQuery.contains(doc, node2)) {
                if (node2.src && (node2.type || "").toLowerCase() !== "module") {
                  if (jQuery._evalUrl && !node2.noModule) {
                    jQuery._evalUrl(node2.src, {
                      nonce: node2.nonce || node2.getAttribute("nonce")
                    }, doc);
                  }
                } else {
                  DOMEval(node2.textContent.replace(rcleanScript, ""), node2, doc);
                }
              }
            }
          }
        }
      }
      return collection2;
    }
    function remove2(elem, selector2, keepData) {
      var node2, nodes = selector2 ? jQuery.filter(selector2, elem) : elem, i = 0;
      for (; (node2 = nodes[i]) != null; i++) {
        if (!keepData && node2.nodeType === 1) {
          jQuery.cleanData(getAll(node2));
        }
        if (node2.parentNode) {
          if (keepData && isAttached2(node2)) {
            setGlobalEval(getAll(node2, "script"));
          }
          node2.parentNode.removeChild(node2);
        }
      }
      return elem;
    }
    jQuery.extend({
      htmlPrefilter: function(html) {
        return html;
      },
      clone: function(elem, dataAndEvents, deepDataAndEvents) {
        var i, l, srcElements, destElements, clone2 = elem.cloneNode(true), inPage = isAttached2(elem);
        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
          destElements = getAll(clone2);
          srcElements = getAll(elem);
          for (i = 0, l = srcElements.length; i < l; i++) {
            fixInput(srcElements[i], destElements[i]);
          }
        }
        if (dataAndEvents) {
          if (deepDataAndEvents) {
            srcElements = srcElements || getAll(elem);
            destElements = destElements || getAll(clone2);
            for (i = 0, l = srcElements.length; i < l; i++) {
              cloneCopyEvent(srcElements[i], destElements[i]);
            }
          } else {
            cloneCopyEvent(elem, clone2);
          }
        }
        destElements = getAll(clone2, "script");
        if (destElements.length > 0) {
          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
        }
        return clone2;
      },
      cleanData: function(elems) {
        var data, elem, type, special = jQuery.event.special, i = 0;
        for (; (elem = elems[i]) !== void 0; i++) {
          if (acceptData(elem)) {
            if (data = elem[dataPriv.expando]) {
              if (data.events) {
                for (type in data.events) {
                  if (special[type]) {
                    jQuery.event.remove(elem, type);
                  } else {
                    jQuery.removeEvent(elem, type, data.handle);
                  }
                }
              }
              elem[dataPriv.expando] = void 0;
            }
            if (elem[dataUser.expando]) {
              elem[dataUser.expando] = void 0;
            }
          }
        }
      }
    });
    jQuery.fn.extend({
      detach: function(selector2) {
        return remove2(this, selector2, true);
      },
      remove: function(selector2) {
        return remove2(this, selector2);
      },
      text: function(value) {
        return access(this, function(value2) {
          return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              this.textContent = value2;
            }
          });
        }, null, value, arguments.length);
      },
      append: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.appendChild(elem);
          }
        });
      },
      prepend: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.insertBefore(elem, target.firstChild);
          }
        });
      },
      before: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this);
          }
        });
      },
      after: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this.nextSibling);
          }
        });
      },
      empty: function() {
        var elem, i = 0;
        for (; (elem = this[i]) != null; i++) {
          if (elem.nodeType === 1) {
            jQuery.cleanData(getAll(elem, false));
            elem.textContent = "";
          }
        }
        return this;
      },
      clone: function(dataAndEvents, deepDataAndEvents) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
        return this.map(function() {
          return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
        });
      },
      html: function(value) {
        return access(this, function(value2) {
          var elem = this[0] || {}, i = 0, l = this.length;
          if (value2 === void 0 && elem.nodeType === 1) {
            return elem.innerHTML;
          }
          if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
            value2 = jQuery.htmlPrefilter(value2);
            try {
              for (; i < l; i++) {
                elem = this[i] || {};
                if (elem.nodeType === 1) {
                  jQuery.cleanData(getAll(elem, false));
                  elem.innerHTML = value2;
                }
              }
              elem = 0;
            } catch (e) {
            }
          }
          if (elem) {
            this.empty().append(value2);
          }
        }, null, value, arguments.length);
      },
      replaceWith: function() {
        var ignored = [];
        return domManip(this, arguments, function(elem) {
          var parent2 = this.parentNode;
          if (jQuery.inArray(this, ignored) < 0) {
            jQuery.cleanData(getAll(this));
            if (parent2) {
              parent2.replaceChild(elem, this);
            }
          }
        }, ignored);
      }
    });
    jQuery.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    }, function(name2, original) {
      jQuery.fn[name2] = function(selector2) {
        var elems, ret = [], insert = jQuery(selector2), last2 = insert.length - 1, i = 0;
        for (; i <= last2; i++) {
          elems = i === last2 ? this : this.clone(true);
          jQuery(insert[i])[original](elems);
          push.apply(ret, elems.get());
        }
        return this.pushStack(ret);
      };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
      var view = elem.ownerDocument.defaultView;
      if (!view || !view.opener) {
        view = window2;
      }
      return view.getComputedStyle(elem);
    };
    var swap = function(elem, options, callback) {
      var ret, name2, old = {};
      for (name2 in options) {
        old[name2] = elem.style[name2];
        elem.style[name2] = options[name2];
      }
      ret = callback.call(elem);
      for (name2 in options) {
        elem.style[name2] = old[name2];
      }
      return ret;
    };
    var rboxStyle = new RegExp(cssExpand.join("|"), "i");
    (function() {
      function computeStyleTests() {
        if (!div) {
          return;
        }
        container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
        div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
        documentElement.appendChild(container).appendChild(div);
        var divStyle = window2.getComputedStyle(div);
        pixelPositionVal = divStyle.top !== "1%";
        reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
        div.style.right = "60%";
        pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
        boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
        div.style.position = "absolute";
        scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
        documentElement.removeChild(container);
        div = null;
      }
      function roundPixelMeasures(measure) {
        return Math.round(parseFloat(measure));
      }
      var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
      if (!div.style) {
        return;
      }
      div.style.backgroundClip = "content-box";
      div.cloneNode(true).style.backgroundClip = "";
      support.clearCloneStyle = div.style.backgroundClip === "content-box";
      jQuery.extend(support, {
        boxSizingReliable: function() {
          computeStyleTests();
          return boxSizingReliableVal;
        },
        pixelBoxStyles: function() {
          computeStyleTests();
          return pixelBoxStylesVal;
        },
        pixelPosition: function() {
          computeStyleTests();
          return pixelPositionVal;
        },
        reliableMarginLeft: function() {
          computeStyleTests();
          return reliableMarginLeftVal;
        },
        scrollboxSize: function() {
          computeStyleTests();
          return scrollboxSizeVal;
        },
        reliableTrDimensions: function() {
          var table, tr, trChild, trStyle;
          if (reliableTrDimensionsVal == null) {
            table = document2.createElement("table");
            tr = document2.createElement("tr");
            trChild = document2.createElement("div");
            table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
            tr.style.cssText = "border:1px solid";
            tr.style.height = "1px";
            trChild.style.height = "9px";
            trChild.style.display = "block";
            documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
            trStyle = window2.getComputedStyle(tr);
            reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
            documentElement.removeChild(table);
          }
          return reliableTrDimensionsVal;
        }
      });
    })();
    function curCSS(elem, name2, computed) {
      var width, minWidth, maxWidth, ret, style = elem.style;
      computed = computed || getStyles(elem);
      if (computed) {
        ret = computed.getPropertyValue(name2) || computed[name2];
        if (ret === "" && !isAttached2(elem)) {
          ret = jQuery.style(elem, name2);
        }
        if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name2)) {
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth;
          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed.width;
          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }
      return ret !== void 0 ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
      return {
        get: function() {
          if (conditionFn()) {
            delete this.get;
            return;
          }
          return (this.get = hookFn).apply(this, arguments);
        }
      };
    }
    var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
    function vendorPropName(name2) {
      var capName = name2[0].toUpperCase() + name2.slice(1), i = cssPrefixes.length;
      while (i--) {
        name2 = cssPrefixes[i] + capName;
        if (name2 in emptyStyle) {
          return name2;
        }
      }
    }
    function finalPropName(name2) {
      var final = jQuery.cssProps[name2] || vendorProps[name2];
      if (final) {
        return final;
      }
      if (name2 in emptyStyle) {
        return name2;
      }
      return vendorProps[name2] = vendorPropName(name2) || name2;
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    };
    function setPositiveNumber(_elem, value, subtract2) {
      var matches = rcssNum.exec(value);
      return matches ? Math.max(0, matches[2] - (subtract2 || 0)) + (matches[3] || "px") : value;
    }
    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
      var i = dimension === "width" ? 1 : 0, extra = 0, delta2 = 0;
      if (box === (isBorderBox ? "border" : "content")) {
        return 0;
      }
      for (; i < 4; i += 2) {
        if (box === "margin") {
          delta2 += jQuery.css(elem, box + cssExpand[i], true, styles);
        }
        if (!isBorderBox) {
          delta2 += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
          if (box !== "padding") {
            delta2 += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          } else {
            extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        } else {
          if (box === "content") {
            delta2 -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
          }
          if (box !== "margin") {
            delta2 -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        }
      }
      if (!isBorderBox && computedVal >= 0) {
        delta2 += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta2 - extra - 0.5)) || 0;
      }
      return delta2;
    }
    function getWidthOrHeight(elem, dimension, extra) {
      var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
      if (rnumnonpx.test(val)) {
        if (!extra) {
          return val;
        }
        val = "auto";
      }
      if ((!support.boxSizingReliable() && isBorderBox || !support.reliableTrDimensions() && nodeName(elem, "tr") || val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && elem.getClientRects().length) {
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        valueIsBorderBox = offsetProp in elem;
        if (valueIsBorderBox) {
          val = elem[offsetProp];
        }
      }
      val = parseFloat(val) || 0;
      return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val) + "px";
    }
    jQuery.extend({
      cssHooks: {
        opacity: {
          get: function(elem, computed) {
            if (computed) {
              var ret = curCSS(elem, "opacity");
              return ret === "" ? "1" : ret;
            }
          }
        }
      },
      cssNumber: {
        "animationIterationCount": true,
        "columnCount": true,
        "fillOpacity": true,
        "flexGrow": true,
        "flexShrink": true,
        "fontWeight": true,
        "gridArea": true,
        "gridColumn": true,
        "gridColumnEnd": true,
        "gridColumnStart": true,
        "gridRow": true,
        "gridRowEnd": true,
        "gridRowStart": true,
        "lineHeight": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "widows": true,
        "zIndex": true,
        "zoom": true
      },
      cssProps: {},
      style: function(elem, name2, value, extra) {
        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
          return;
        }
        var ret, type, hooks2, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2), style = elem.style;
        if (!isCustomProp) {
          name2 = finalPropName(origName);
        }
        hooks2 = jQuery.cssHooks[name2] || jQuery.cssHooks[origName];
        if (value !== void 0) {
          type = typeof value;
          if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
            value = adjustCSS(elem, name2, ret);
            type = "number";
          }
          if (value == null || value !== value) {
            return;
          }
          if (type === "number" && !isCustomProp) {
            value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
          }
          if (!support.clearCloneStyle && value === "" && name2.indexOf("background") === 0) {
            style[name2] = "inherit";
          }
          if (!hooks2 || !("set" in hooks2) || (value = hooks2.set(elem, value, extra)) !== void 0) {
            if (isCustomProp) {
              style.setProperty(name2, value);
            } else {
              style[name2] = value;
            }
          }
        } else {
          if (hooks2 && "get" in hooks2 && (ret = hooks2.get(elem, false, extra)) !== void 0) {
            return ret;
          }
          return style[name2];
        }
      },
      css: function(elem, name2, extra, styles) {
        var val, num, hooks2, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2);
        if (!isCustomProp) {
          name2 = finalPropName(origName);
        }
        hooks2 = jQuery.cssHooks[name2] || jQuery.cssHooks[origName];
        if (hooks2 && "get" in hooks2) {
          val = hooks2.get(elem, true, extra);
        }
        if (val === void 0) {
          val = curCSS(elem, name2, styles);
        }
        if (val === "normal" && name2 in cssNormalTransform) {
          val = cssNormalTransform[name2];
        }
        if (extra === "" || extra) {
          num = parseFloat(val);
          return extra === true || isFinite(num) ? num || 0 : val;
        }
        return val;
      }
    });
    jQuery.each(["height", "width"], function(_i, dimension) {
      jQuery.cssHooks[dimension] = {
        get: function(elem, computed, extra) {
          if (computed) {
            return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
              return getWidthOrHeight(elem, dimension, extra);
            }) : getWidthOrHeight(elem, dimension, extra);
          }
        },
        set: function(elem, value, extra) {
          var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract2 = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;
          if (isBorderBox && scrollboxSizeBuggy) {
            subtract2 -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
          }
          if (subtract2 && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
            elem.style[dimension] = value;
            value = jQuery.css(elem, dimension);
          }
          return setPositiveNumber(elem, value, subtract2);
        }
      };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
      if (computed) {
        return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
          return elem.getBoundingClientRect().left;
        })) + "px";
      }
    });
    jQuery.each({
      margin: "",
      padding: "",
      border: "Width"
    }, function(prefix2, suffix) {
      jQuery.cssHooks[prefix2 + suffix] = {
        expand: function(value) {
          var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
          for (; i < 4; i++) {
            expanded[prefix2 + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
          }
          return expanded;
        }
      };
      if (prefix2 !== "margin") {
        jQuery.cssHooks[prefix2 + suffix].set = setPositiveNumber;
      }
    });
    jQuery.fn.extend({
      css: function(name2, value) {
        return access(this, function(elem, name3, value2) {
          var styles, len, map2 = {}, i = 0;
          if (Array.isArray(name3)) {
            styles = getStyles(elem);
            len = name3.length;
            for (; i < len; i++) {
              map2[name3[i]] = jQuery.css(elem, name3[i], false, styles);
            }
            return map2;
          }
          return value2 !== void 0 ? jQuery.style(elem, name3, value2) : jQuery.css(elem, name3);
        }, name2, value, arguments.length > 1);
      }
    });
    function Tween(elem, options, prop, end, easing) {
      return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
      constructor: Tween,
      init: function(elem, options, prop, end, easing, unit) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || jQuery.easing._default;
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
      },
      cur: function() {
        var hooks2 = Tween.propHooks[this.prop];
        return hooks2 && hooks2.get ? hooks2.get(this) : Tween.propHooks._default.get(this);
      },
      run: function(percent) {
        var eased, hooks2 = Tween.propHooks[this.prop];
        if (this.options.duration) {
          this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
        } else {
          this.pos = eased = percent;
        }
        this.now = (this.end - this.start) * eased + this.start;
        if (this.options.step) {
          this.options.step.call(this.elem, this.now, this);
        }
        if (hooks2 && hooks2.set) {
          hooks2.set(this);
        } else {
          Tween.propHooks._default.set(this);
        }
        return this;
      }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
      _default: {
        get: function(tween) {
          var result;
          if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
            return tween.elem[tween.prop];
          }
          result = jQuery.css(tween.elem, tween.prop, "");
          return !result || result === "auto" ? 0 : result;
        },
        set: function(tween) {
          if (jQuery.fx.step[tween.prop]) {
            jQuery.fx.step[tween.prop](tween);
          } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
          } else {
            tween.elem[tween.prop] = tween.now;
          }
        }
      }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
      set: function(tween) {
        if (tween.elem.nodeType && tween.elem.parentNode) {
          tween.elem[tween.prop] = tween.now;
        }
      }
    };
    jQuery.easing = {
      linear: function(p) {
        return p;
      },
      swing: function(p) {
        return 0.5 - Math.cos(p * Math.PI) / 2;
      },
      _default: "swing"
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
      if (inProgress) {
        if (document2.hidden === false && window2.requestAnimationFrame) {
          window2.requestAnimationFrame(schedule);
        } else {
          window2.setTimeout(schedule, jQuery.fx.interval);
        }
        jQuery.fx.tick();
      }
    }
    function createFxNow() {
      window2.setTimeout(function() {
        fxNow = void 0;
      });
      return fxNow = Date.now();
    }
    function genFx(type, includeWidth) {
      var which, i = 0, attrs = { height: type };
      includeWidth = includeWidth ? 1 : 0;
      for (; i < 4; i += 2 - includeWidth) {
        which = cssExpand[i];
        attrs["margin" + which] = attrs["padding" + which] = type;
      }
      if (includeWidth) {
        attrs.opacity = attrs.width = type;
      }
      return attrs;
    }
    function createTween(value, prop, animation) {
      var tween, collection2 = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index2 = 0, length2 = collection2.length;
      for (; index2 < length2; index2++) {
        if (tween = collection2[index2].call(animation, prop, value)) {
          return tween;
        }
      }
    }
    function defaultPrefilter(elem, props, opts) {
      var prop, value, toggle2, hooks2, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
      if (!opts.queue) {
        hooks2 = jQuery._queueHooks(elem, "fx");
        if (hooks2.unqueued == null) {
          hooks2.unqueued = 0;
          oldfire = hooks2.empty.fire;
          hooks2.empty.fire = function() {
            if (!hooks2.unqueued) {
              oldfire();
            }
          };
        }
        hooks2.unqueued++;
        anim.always(function() {
          anim.always(function() {
            hooks2.unqueued--;
            if (!jQuery.queue(elem, "fx").length) {
              hooks2.empty.fire();
            }
          });
        });
      }
      for (prop in props) {
        value = props[prop];
        if (rfxtypes.test(value)) {
          delete props[prop];
          toggle2 = toggle2 || value === "toggle";
          if (value === (hidden ? "hide" : "show")) {
            if (value === "show" && dataShow && dataShow[prop] !== void 0) {
              hidden = true;
            } else {
              continue;
            }
          }
          orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
        }
      }
      propTween = !jQuery.isEmptyObject(props);
      if (!propTween && jQuery.isEmptyObject(orig)) {
        return;
      }
      if (isBox && elem.nodeType === 1) {
        opts.overflow = [style.overflow, style.overflowX, style.overflowY];
        restoreDisplay = dataShow && dataShow.display;
        if (restoreDisplay == null) {
          restoreDisplay = dataPriv.get(elem, "display");
        }
        display = jQuery.css(elem, "display");
        if (display === "none") {
          if (restoreDisplay) {
            display = restoreDisplay;
          } else {
            showHide([elem], true);
            restoreDisplay = elem.style.display || restoreDisplay;
            display = jQuery.css(elem, "display");
            showHide([elem]);
          }
        }
        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
          if (jQuery.css(elem, "float") === "none") {
            if (!propTween) {
              anim.done(function() {
                style.display = restoreDisplay;
              });
              if (restoreDisplay == null) {
                display = style.display;
                restoreDisplay = display === "none" ? "" : display;
              }
            }
            style.display = "inline-block";
          }
        }
      }
      if (opts.overflow) {
        style.overflow = "hidden";
        anim.always(function() {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      }
      propTween = false;
      for (prop in orig) {
        if (!propTween) {
          if (dataShow) {
            if ("hidden" in dataShow) {
              hidden = dataShow.hidden;
            }
          } else {
            dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
          }
          if (toggle2) {
            dataShow.hidden = !hidden;
          }
          if (hidden) {
            showHide([elem], true);
          }
          anim.done(function() {
            if (!hidden) {
              showHide([elem]);
            }
            dataPriv.remove(elem, "fxshow");
            for (prop in orig) {
              jQuery.style(elem, prop, orig[prop]);
            }
          });
        }
        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = propTween.start;
          if (hidden) {
            propTween.end = propTween.start;
            propTween.start = 0;
          }
        }
      }
    }
    function propFilter(props, specialEasing) {
      var index2, name2, easing, value, hooks2;
      for (index2 in props) {
        name2 = camelCase(index2);
        easing = specialEasing[name2];
        value = props[index2];
        if (Array.isArray(value)) {
          easing = value[1];
          value = props[index2] = value[0];
        }
        if (index2 !== name2) {
          props[name2] = value;
          delete props[index2];
        }
        hooks2 = jQuery.cssHooks[name2];
        if (hooks2 && "expand" in hooks2) {
          value = hooks2.expand(value);
          delete props[name2];
          for (index2 in value) {
            if (!(index2 in props)) {
              props[index2] = value[index2];
              specialEasing[index2] = easing;
            }
          }
        } else {
          specialEasing[name2] = easing;
        }
      }
    }
    function Animation(elem, properties2, options) {
      var result, stopped, index2 = 0, length2 = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
        delete tick.elem;
      }), tick = function() {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index3 = 0, length3 = animation.tweens.length;
        for (; index3 < length3; index3++) {
          animation.tweens[index3].run(percent);
        }
        deferred.notifyWith(elem, [animation, percent, remaining]);
        if (percent < 1 && length3) {
          return remaining;
        }
        if (!length3) {
          deferred.notifyWith(elem, [animation, 1, 0]);
        }
        deferred.resolveWith(elem, [animation]);
        return false;
      }, animation = deferred.promise({
        elem,
        props: jQuery.extend({}, properties2),
        opts: jQuery.extend(true, {
          specialEasing: {},
          easing: jQuery.easing._default
        }, options),
        originalProperties: properties2,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function(prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function(gotoEnd) {
          var index3 = 0, length3 = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index3 < length3; index3++) {
            animation.tweens[index3].run(1);
          }
          if (gotoEnd) {
            deferred.notifyWith(elem, [animation, 1, 0]);
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        }
      }), props = animation.props;
      propFilter(props, animation.opts.specialEasing);
      for (; index2 < length2; index2++) {
        result = Animation.prefilters[index2].call(animation, elem, props, animation.opts);
        if (result) {
          if (isFunction3(result.stop)) {
            jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
          }
          return result;
        }
      }
      jQuery.map(props, createTween, animation);
      if (isFunction3(animation.opts.start)) {
        animation.opts.start.call(elem, animation);
      }
      animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
      jQuery.fx.timer(jQuery.extend(tick, {
        elem,
        anim: animation,
        queue: animation.opts.queue
      }));
      return animation;
    }
    jQuery.Animation = jQuery.extend(Animation, {
      tweeners: {
        "*": [function(prop, value) {
          var tween = this.createTween(prop, value);
          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
          return tween;
        }]
      },
      tweener: function(props, callback) {
        if (isFunction3(props)) {
          callback = props;
          props = ["*"];
        } else {
          props = props.match(rnothtmlwhite);
        }
        var prop, index2 = 0, length2 = props.length;
        for (; index2 < length2; index2++) {
          prop = props[index2];
          Animation.tweeners[prop] = Animation.tweeners[prop] || [];
          Animation.tweeners[prop].unshift(callback);
        }
      },
      prefilters: [defaultPrefilter],
      prefilter: function(callback, prepend) {
        if (prepend) {
          Animation.prefilters.unshift(callback);
        } else {
          Animation.prefilters.push(callback);
        }
      }
    });
    jQuery.speed = function(speed, easing, fn) {
      var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || isFunction3(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !isFunction3(easing) && easing
      };
      if (jQuery.fx.off) {
        opt.duration = 0;
      } else {
        if (typeof opt.duration !== "number") {
          if (opt.duration in jQuery.fx.speeds) {
            opt.duration = jQuery.fx.speeds[opt.duration];
          } else {
            opt.duration = jQuery.fx.speeds._default;
          }
        }
      }
      if (opt.queue == null || opt.queue === true) {
        opt.queue = "fx";
      }
      opt.old = opt.complete;
      opt.complete = function() {
        if (isFunction3(opt.old)) {
          opt.old.call(this);
        }
        if (opt.queue) {
          jQuery.dequeue(this, opt.queue);
        }
      };
      return opt;
    };
    jQuery.fn.extend({
      fadeTo: function(speed, to, easing, callback) {
        return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
      },
      animate: function(prop, speed, easing, callback) {
        var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          if (empty || dataPriv.get(this, "finish")) {
            anim.stop(true);
          }
        };
        doAnimation.finish = doAnimation;
        return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
      },
      stop: function(type, clearQueue, gotoEnd) {
        var stopQueue = function(hooks2) {
          var stop = hooks2.stop;
          delete hooks2.stop;
          stop(gotoEnd);
        };
        if (typeof type !== "string") {
          gotoEnd = clearQueue;
          clearQueue = type;
          type = void 0;
        }
        if (clearQueue) {
          this.queue(type || "fx", []);
        }
        return this.each(function() {
          var dequeue = true, index2 = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
          if (index2) {
            if (data[index2] && data[index2].stop) {
              stopQueue(data[index2]);
            }
          } else {
            for (index2 in data) {
              if (data[index2] && data[index2].stop && rrun.test(index2)) {
                stopQueue(data[index2]);
              }
            }
          }
          for (index2 = timers.length; index2--; ) {
            if (timers[index2].elem === this && (type == null || timers[index2].queue === type)) {
              timers[index2].anim.stop(gotoEnd);
              dequeue = false;
              timers.splice(index2, 1);
            }
          }
          if (dequeue || !gotoEnd) {
            jQuery.dequeue(this, type);
          }
        });
      },
      finish: function(type) {
        if (type !== false) {
          type = type || "fx";
        }
        return this.each(function() {
          var index2, data = dataPriv.get(this), queue = data[type + "queue"], hooks2 = data[type + "queueHooks"], timers = jQuery.timers, length2 = queue ? queue.length : 0;
          data.finish = true;
          jQuery.queue(this, type, []);
          if (hooks2 && hooks2.stop) {
            hooks2.stop.call(this, true);
          }
          for (index2 = timers.length; index2--; ) {
            if (timers[index2].elem === this && timers[index2].queue === type) {
              timers[index2].anim.stop(true);
              timers.splice(index2, 1);
            }
          }
          for (index2 = 0; index2 < length2; index2++) {
            if (queue[index2] && queue[index2].finish) {
              queue[index2].finish.call(this);
            }
          }
          delete data.finish;
        });
      }
    });
    jQuery.each(["toggle", "show", "hide"], function(_i, name2) {
      var cssFn = jQuery.fn[name2];
      jQuery.fn[name2] = function(speed, easing, callback) {
        return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name2, true), speed, easing, callback);
      };
    });
    jQuery.each({
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: { opacity: "show" },
      fadeOut: { opacity: "hide" },
      fadeToggle: { opacity: "toggle" }
    }, function(name2, props) {
      jQuery.fn[name2] = function(speed, easing, callback) {
        return this.animate(props, speed, easing, callback);
      };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
      var timer2, i = 0, timers = jQuery.timers;
      fxNow = Date.now();
      for (; i < timers.length; i++) {
        timer2 = timers[i];
        if (!timer2() && timers[i] === timer2) {
          timers.splice(i--, 1);
        }
      }
      if (!timers.length) {
        jQuery.fx.stop();
      }
      fxNow = void 0;
    };
    jQuery.fx.timer = function(timer2) {
      jQuery.timers.push(timer2);
      jQuery.fx.start();
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
      if (inProgress) {
        return;
      }
      inProgress = true;
      schedule();
    };
    jQuery.fx.stop = function() {
      inProgress = null;
    };
    jQuery.fx.speeds = {
      slow: 600,
      fast: 200,
      _default: 400
    };
    jQuery.fn.delay = function(time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || "fx";
      return this.queue(type, function(next, hooks2) {
        var timeout = window2.setTimeout(next, time);
        hooks2.stop = function() {
          window2.clearTimeout(timeout);
        };
      });
    };
    (function() {
      var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
      input.type = "checkbox";
      support.checkOn = input.value !== "";
      support.optSelected = opt.selected;
      input = document2.createElement("input");
      input.value = "t";
      input.type = "radio";
      support.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
      attr: function(name2, value) {
        return access(this, jQuery.attr, name2, value, arguments.length > 1);
      },
      removeAttr: function(name2) {
        return this.each(function() {
          jQuery.removeAttr(this, name2);
        });
      }
    });
    jQuery.extend({
      attr: function(elem, name2, value) {
        var ret, hooks2, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (typeof elem.getAttribute === "undefined") {
          return jQuery.prop(elem, name2, value);
        }
        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          hooks2 = jQuery.attrHooks[name2.toLowerCase()] || (jQuery.expr.match.bool.test(name2) ? boolHook : void 0);
        }
        if (value !== void 0) {
          if (value === null) {
            jQuery.removeAttr(elem, name2);
            return;
          }
          if (hooks2 && "set" in hooks2 && (ret = hooks2.set(elem, value, name2)) !== void 0) {
            return ret;
          }
          elem.setAttribute(name2, value + "");
          return value;
        }
        if (hooks2 && "get" in hooks2 && (ret = hooks2.get(elem, name2)) !== null) {
          return ret;
        }
        ret = jQuery.find.attr(elem, name2);
        return ret == null ? void 0 : ret;
      },
      attrHooks: {
        type: {
          set: function(elem, value) {
            if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
              var val = elem.value;
              elem.setAttribute("type", value);
              if (val) {
                elem.value = val;
              }
              return value;
            }
          }
        }
      },
      removeAttr: function(elem, value) {
        var name2, i = 0, attrNames = value && value.match(rnothtmlwhite);
        if (attrNames && elem.nodeType === 1) {
          while (name2 = attrNames[i++]) {
            elem.removeAttribute(name2);
          }
        }
      }
    });
    boolHook = {
      set: function(elem, value, name2) {
        if (value === false) {
          jQuery.removeAttr(elem, name2);
        } else {
          elem.setAttribute(name2, name2);
        }
        return name2;
      }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name2) {
      var getter2 = attrHandle[name2] || jQuery.find.attr;
      attrHandle[name2] = function(elem, name3, isXML) {
        var ret, handle, lowercaseName = name3.toLowerCase();
        if (!isXML) {
          handle = attrHandle[lowercaseName];
          attrHandle[lowercaseName] = ret;
          ret = getter2(elem, name3, isXML) != null ? lowercaseName : null;
          attrHandle[lowercaseName] = handle;
        }
        return ret;
      };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
      prop: function(name2, value) {
        return access(this, jQuery.prop, name2, value, arguments.length > 1);
      },
      removeProp: function(name2) {
        return this.each(function() {
          delete this[jQuery.propFix[name2] || name2];
        });
      }
    });
    jQuery.extend({
      prop: function(elem, name2, value) {
        var ret, hooks2, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          name2 = jQuery.propFix[name2] || name2;
          hooks2 = jQuery.propHooks[name2];
        }
        if (value !== void 0) {
          if (hooks2 && "set" in hooks2 && (ret = hooks2.set(elem, value, name2)) !== void 0) {
            return ret;
          }
          return elem[name2] = value;
        }
        if (hooks2 && "get" in hooks2 && (ret = hooks2.get(elem, name2)) !== null) {
          return ret;
        }
        return elem[name2];
      },
      propHooks: {
        tabIndex: {
          get: function(elem) {
            var tabindex = jQuery.find.attr(elem, "tabindex");
            if (tabindex) {
              return parseInt(tabindex, 10);
            }
            if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
              return 0;
            }
            return -1;
          }
        }
      },
      propFix: {
        "for": "htmlFor",
        "class": "className"
      }
    });
    if (!support.optSelected) {
      jQuery.propHooks.selected = {
        get: function(elem) {
          var parent2 = elem.parentNode;
          if (parent2 && parent2.parentNode) {
            parent2.parentNode.selectedIndex;
          }
          return null;
        },
        set: function(elem) {
          var parent2 = elem.parentNode;
          if (parent2) {
            parent2.selectedIndex;
            if (parent2.parentNode) {
              parent2.parentNode.selectedIndex;
            }
          }
        }
      };
    }
    jQuery.each([
      "tabIndex",
      "readOnly",
      "maxLength",
      "cellSpacing",
      "cellPadding",
      "rowSpan",
      "colSpan",
      "useMap",
      "frameBorder",
      "contentEditable"
    ], function() {
      jQuery.propFix[this.toLowerCase()] = this;
    });
    function stripAndCollapse(value) {
      var tokens = value.match(rnothtmlwhite) || [];
      return tokens.join(" ");
    }
    function getClass(elem) {
      return elem.getAttribute && elem.getAttribute("class") || "";
    }
    function classesToArray(value) {
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "string") {
        return value.match(rnothtmlwhite) || [];
      }
      return [];
    }
    jQuery.fn.extend({
      addClass: function(value) {
        var classes2, elem, cur, curValue, clazz, j, finalValue, i = 0;
        if (isFunction3(value)) {
          return this.each(function(j2) {
            jQuery(this).addClass(value.call(this, j2, getClass(this)));
          });
        }
        classes2 = classesToArray(value);
        if (classes2.length) {
          while (elem = this[i++]) {
            curValue = getClass(elem);
            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              j = 0;
              while (clazz = classes2[j++]) {
                if (cur.indexOf(" " + clazz + " ") < 0) {
                  cur += clazz + " ";
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                elem.setAttribute("class", finalValue);
              }
            }
          }
        }
        return this;
      },
      removeClass: function(value) {
        var classes2, elem, cur, curValue, clazz, j, finalValue, i = 0;
        if (isFunction3(value)) {
          return this.each(function(j2) {
            jQuery(this).removeClass(value.call(this, j2, getClass(this)));
          });
        }
        if (!arguments.length) {
          return this.attr("class", "");
        }
        classes2 = classesToArray(value);
        if (classes2.length) {
          while (elem = this[i++]) {
            curValue = getClass(elem);
            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              j = 0;
              while (clazz = classes2[j++]) {
                while (cur.indexOf(" " + clazz + " ") > -1) {
                  cur = cur.replace(" " + clazz + " ", " ");
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                elem.setAttribute("class", finalValue);
              }
            }
          }
        }
        return this;
      },
      toggleClass: function(value, stateVal) {
        var type = typeof value, isValidValue = type === "string" || Array.isArray(value);
        if (typeof stateVal === "boolean" && isValidValue) {
          return stateVal ? this.addClass(value) : this.removeClass(value);
        }
        if (isFunction3(value)) {
          return this.each(function(i) {
            jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
          });
        }
        return this.each(function() {
          var className, i, self2, classNames;
          if (isValidValue) {
            i = 0;
            self2 = jQuery(this);
            classNames = classesToArray(value);
            while (className = classNames[i++]) {
              if (self2.hasClass(className)) {
                self2.removeClass(className);
              } else {
                self2.addClass(className);
              }
            }
          } else if (value === void 0 || type === "boolean") {
            className = getClass(this);
            if (className) {
              dataPriv.set(this, "__className__", className);
            }
            if (this.setAttribute) {
              this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
            }
          }
        });
      },
      hasClass: function(selector2) {
        var className, elem, i = 0;
        className = " " + selector2 + " ";
        while (elem = this[i++]) {
          if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
            return true;
          }
        }
        return false;
      }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
      val: function(value) {
        var hooks2, ret, valueIsFunction, elem = this[0];
        if (!arguments.length) {
          if (elem) {
            hooks2 = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
            if (hooks2 && "get" in hooks2 && (ret = hooks2.get(elem, "value")) !== void 0) {
              return ret;
            }
            ret = elem.value;
            if (typeof ret === "string") {
              return ret.replace(rreturn, "");
            }
            return ret == null ? "" : ret;
          }
          return;
        }
        valueIsFunction = isFunction3(value);
        return this.each(function(i) {
          var val;
          if (this.nodeType !== 1) {
            return;
          }
          if (valueIsFunction) {
            val = value.call(this, i, jQuery(this).val());
          } else {
            val = value;
          }
          if (val == null) {
            val = "";
          } else if (typeof val === "number") {
            val += "";
          } else if (Array.isArray(val)) {
            val = jQuery.map(val, function(value2) {
              return value2 == null ? "" : value2 + "";
            });
          }
          hooks2 = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
          if (!hooks2 || !("set" in hooks2) || hooks2.set(this, val, "value") === void 0) {
            this.value = val;
          }
        });
      }
    });
    jQuery.extend({
      valHooks: {
        option: {
          get: function(elem) {
            var val = jQuery.find.attr(elem, "value");
            return val != null ? val : stripAndCollapse(jQuery.text(elem));
          }
        },
        select: {
          get: function(elem) {
            var value, option2, i, options = elem.options, index2 = elem.selectedIndex, one = elem.type === "select-one", values2 = one ? null : [], max2 = one ? index2 + 1 : options.length;
            if (index2 < 0) {
              i = max2;
            } else {
              i = one ? index2 : 0;
            }
            for (; i < max2; i++) {
              option2 = options[i];
              if ((option2.selected || i === index2) && !option2.disabled && (!option2.parentNode.disabled || !nodeName(option2.parentNode, "optgroup"))) {
                value = jQuery(option2).val();
                if (one) {
                  return value;
                }
                values2.push(value);
              }
            }
            return values2;
          },
          set: function(elem, value) {
            var optionSet, option2, options = elem.options, values2 = jQuery.makeArray(value), i = options.length;
            while (i--) {
              option2 = options[i];
              if (option2.selected = jQuery.inArray(jQuery.valHooks.option.get(option2), values2) > -1) {
                optionSet = true;
              }
            }
            if (!optionSet) {
              elem.selectedIndex = -1;
            }
            return values2;
          }
        }
      }
    });
    jQuery.each(["radio", "checkbox"], function() {
      jQuery.valHooks[this] = {
        set: function(elem, value) {
          if (Array.isArray(value)) {
            return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
          }
        }
      };
      if (!support.checkOn) {
        jQuery.valHooks[this].get = function(elem) {
          return elem.getAttribute("value") === null ? "on" : elem.value;
        };
      }
    });
    support.focusin = "onfocusin" in window2;
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
      e.stopPropagation();
    };
    jQuery.extend(jQuery.event, {
      trigger: function(event, data, elem, onlyHandlers) {
        var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
        cur = lastElement = tmp = elem = elem || document2;
        if (elem.nodeType === 3 || elem.nodeType === 8) {
          return;
        }
        if (rfocusMorph.test(type + jQuery.event.triggered)) {
          return;
        }
        if (type.indexOf(".") > -1) {
          namespaces = type.split(".");
          type = namespaces.shift();
          namespaces.sort();
        }
        ontype = type.indexOf(":") < 0 && "on" + type;
        event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
        event.result = void 0;
        if (!event.target) {
          event.target = elem;
        }
        data = data == null ? [event] : jQuery.makeArray(data, [event]);
        special = jQuery.event.special[type] || {};
        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
          return;
        }
        if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
          bubbleType = special.delegateType || type;
          if (!rfocusMorph.test(bubbleType + type)) {
            cur = cur.parentNode;
          }
          for (; cur; cur = cur.parentNode) {
            eventPath.push(cur);
            tmp = cur;
          }
          if (tmp === (elem.ownerDocument || document2)) {
            eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
          }
        }
        i = 0;
        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
          lastElement = cur;
          event.type = i > 1 ? bubbleType : special.bindType || type;
          handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
          if (handle) {
            handle.apply(cur, data);
          }
          handle = ontype && cur[ontype];
          if (handle && handle.apply && acceptData(cur)) {
            event.result = handle.apply(cur, data);
            if (event.result === false) {
              event.preventDefault();
            }
          }
        }
        event.type = type;
        if (!onlyHandlers && !event.isDefaultPrevented()) {
          if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
            if (ontype && isFunction3(elem[type]) && !isWindow(elem)) {
              tmp = elem[ontype];
              if (tmp) {
                elem[ontype] = null;
              }
              jQuery.event.triggered = type;
              if (event.isPropagationStopped()) {
                lastElement.addEventListener(type, stopPropagationCallback);
              }
              elem[type]();
              if (event.isPropagationStopped()) {
                lastElement.removeEventListener(type, stopPropagationCallback);
              }
              jQuery.event.triggered = void 0;
              if (tmp) {
                elem[ontype] = tmp;
              }
            }
          }
        }
        return event.result;
      },
      simulate: function(type, elem, event) {
        var e = jQuery.extend(new jQuery.Event(), event, {
          type,
          isSimulated: true
        });
        jQuery.event.trigger(e, null, elem);
      }
    });
    jQuery.fn.extend({
      trigger: function(type, data) {
        return this.each(function() {
          jQuery.event.trigger(type, data, this);
        });
      },
      triggerHandler: function(type, data) {
        var elem = this[0];
        if (elem) {
          return jQuery.event.trigger(type, data, elem, true);
        }
      }
    });
    if (!support.focusin) {
      jQuery.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
        var handler = function(event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };
        jQuery.event.special[fix] = {
          setup: function() {
            var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix);
            if (!attaches) {
              doc.addEventListener(orig, handler, true);
            }
            dataPriv.access(doc, fix, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix) - 1;
            if (!attaches) {
              doc.removeEventListener(orig, handler, true);
              dataPriv.remove(doc, fix);
            } else {
              dataPriv.access(doc, fix, attaches);
            }
          }
        };
      });
    }
    var location = window2.location;
    var nonce = { guid: Date.now() };
    var rquery = /\?/;
    jQuery.parseXML = function(data) {
      var xml2, parserErrorElem;
      if (!data || typeof data !== "string") {
        return null;
      }
      try {
        xml2 = new window2.DOMParser().parseFromString(data, "text/xml");
      } catch (e) {
      }
      parserErrorElem = xml2 && xml2.getElementsByTagName("parsererror")[0];
      if (!xml2 || parserErrorElem) {
        jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
          return el.textContent;
        }).join("\n") : data));
      }
      return xml2;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix2, obj, traditional, add2) {
      var name2;
      if (Array.isArray(obj)) {
        jQuery.each(obj, function(i, v) {
          if (traditional || rbracket.test(prefix2)) {
            add2(prefix2, v);
          } else {
            buildParams(prefix2 + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add2);
          }
        });
      } else if (!traditional && toType(obj) === "object") {
        for (name2 in obj) {
          buildParams(prefix2 + "[" + name2 + "]", obj[name2], traditional, add2);
        }
      } else {
        add2(prefix2, obj);
      }
    }
    jQuery.param = function(a, traditional) {
      var prefix2, s = [], add2 = function(key, valueOrFunction) {
        var value = isFunction3(valueOrFunction) ? valueOrFunction() : valueOrFunction;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
      };
      if (a == null) {
        return "";
      }
      if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
        jQuery.each(a, function() {
          add2(this.name, this.value);
        });
      } else {
        for (prefix2 in a) {
          buildParams(prefix2, a[prefix2], traditional, add2);
        }
      }
      return s.join("&");
    };
    jQuery.fn.extend({
      serialize: function() {
        return jQuery.param(this.serializeArray());
      },
      serializeArray: function() {
        return this.map(function() {
          var elements = jQuery.prop(this, "elements");
          return elements ? jQuery.makeArray(elements) : this;
        }).filter(function() {
          var type = this.type;
          return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
        }).map(function(_i, elem) {
          var val = jQuery(this).val();
          if (val == null) {
            return null;
          }
          if (Array.isArray(val)) {
            return jQuery.map(val, function(val2) {
              return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
            });
          }
          return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
        }).get();
      }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
    originAnchor.href = location.href;
    function addToPrefiltersOrTransports(structure) {
      return function(dataTypeExpression, func) {
        if (typeof dataTypeExpression !== "string") {
          func = dataTypeExpression;
          dataTypeExpression = "*";
        }
        var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
        if (isFunction3(func)) {
          while (dataType = dataTypes[i++]) {
            if (dataType[0] === "+") {
              dataType = dataType.slice(1) || "*";
              (structure[dataType] = structure[dataType] || []).unshift(func);
            } else {
              (structure[dataType] = structure[dataType] || []).push(func);
            }
          }
        }
      };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
      var inspected = {}, seekingTransport = structure === transports;
      function inspect(dataType) {
        var selected;
        inspected[dataType] = true;
        jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
          var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
          if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
            options.dataTypes.unshift(dataTypeOrTransport);
            inspect(dataTypeOrTransport);
            return false;
          } else if (seekingTransport) {
            return !(selected = dataTypeOrTransport);
          }
        });
        return selected;
      }
      return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
      var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
      for (key in src) {
        if (src[key] !== void 0) {
          (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
        }
      }
      if (deep) {
        jQuery.extend(true, target, deep);
      }
      return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
      var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
      while (dataTypes[0] === "*") {
        dataTypes.shift();
        if (ct === void 0) {
          ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
      }
      if (ct) {
        for (type in contents) {
          if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
          }
        }
      }
      if (dataTypes[0] in responses) {
        finalDataType = dataTypes[0];
      } else {
        for (type in responses) {
          if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
            finalDataType = type;
            break;
          }
          if (!firstDataType) {
            firstDataType = type;
          }
        }
        finalDataType = finalDataType || firstDataType;
      }
      if (finalDataType) {
        if (finalDataType !== dataTypes[0]) {
          dataTypes.unshift(finalDataType);
        }
        return responses[finalDataType];
      }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
      var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
      if (dataTypes[1]) {
        for (conv in s.converters) {
          converters[conv.toLowerCase()] = s.converters[conv];
        }
      }
      current = dataTypes.shift();
      while (current) {
        if (s.responseFields[current]) {
          jqXHR[s.responseFields[current]] = response;
        }
        if (!prev && isSuccess && s.dataFilter) {
          response = s.dataFilter(response, s.dataType);
        }
        prev = current;
        current = dataTypes.shift();
        if (current) {
          if (current === "*") {
            current = prev;
          } else if (prev !== "*" && prev !== current) {
            conv = converters[prev + " " + current] || converters["* " + current];
            if (!conv) {
              for (conv2 in converters) {
                tmp = conv2.split(" ");
                if (tmp[1] === current) {
                  conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                  if (conv) {
                    if (conv === true) {
                      conv = converters[conv2];
                    } else if (converters[conv2] !== true) {
                      current = tmp[0];
                      dataTypes.unshift(tmp[1]);
                    }
                    break;
                  }
                }
              }
            }
            if (conv !== true) {
              if (conv && s.throws) {
                response = conv(response);
              } else {
                try {
                  response = conv(response);
                } catch (e) {
                  return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                  };
                }
              }
            }
          }
        }
      }
      return { state: "success", data: response };
    }
    jQuery.extend({
      active: 0,
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: location.href,
        type: "GET",
        isLocal: rlocalProtocol.test(location.protocol),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        accepts: {
          "*": allTypes,
          text: "text/plain",
          html: "text/html",
          xml: "application/xml, text/xml",
          json: "application/json, text/javascript"
        },
        contents: {
          xml: /\bxml\b/,
          html: /\bhtml/,
          json: /\bjson\b/
        },
        responseFields: {
          xml: "responseXML",
          text: "responseText",
          json: "responseJSON"
        },
        converters: {
          "* text": String,
          "text html": true,
          "text json": JSON.parse,
          "text xml": jQuery.parseXML
        },
        flatOptions: {
          url: true,
          context: true
        }
      },
      ajaxSetup: function(target, settings) {
        return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
      },
      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
      ajaxTransport: addToPrefiltersOrTransports(transports),
      ajax: function(url, options) {
        if (typeof url === "object") {
          options = url;
          url = void 0;
        }
        options = options || {};
        var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
          readyState: 0,
          getResponseHeader: function(key) {
            var match2;
            if (completed2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match2 = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match2[1].toLowerCase() + " "] = (responseHeaders[match2[1].toLowerCase() + " "] || []).concat(match2[2]);
                }
              }
              match2 = responseHeaders[key.toLowerCase() + " "];
            }
            return match2 == null ? null : match2.join(", ");
          },
          getAllResponseHeaders: function() {
            return completed2 ? responseHeadersString : null;
          },
          setRequestHeader: function(name2, value) {
            if (completed2 == null) {
              name2 = requestHeadersNames[name2.toLowerCase()] = requestHeadersNames[name2.toLowerCase()] || name2;
              requestHeaders[name2] = value;
            }
            return this;
          },
          overrideMimeType: function(type) {
            if (completed2 == null) {
              s.mimeType = type;
            }
            return this;
          },
          statusCode: function(map2) {
            var code;
            if (map2) {
              if (completed2) {
                jqXHR.always(map2[jqXHR.status]);
              } else {
                for (code in map2) {
                  statusCode[code] = [statusCode[code], map2[code]];
                }
              }
            }
            return this;
          },
          abort: function(statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
        deferred.promise(jqXHR);
        s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
        s.type = options.method || options.type || s.method || s.type;
        s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
        if (s.crossDomain == null) {
          urlAnchor = document2.createElement("a");
          try {
            urlAnchor.href = s.url;
            urlAnchor.href = urlAnchor.href;
            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
          } catch (e) {
            s.crossDomain = true;
          }
        }
        if (s.data && s.processData && typeof s.data !== "string") {
          s.data = jQuery.param(s.data, s.traditional);
        }
        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
        if (completed2) {
          return jqXHR;
        }
        fireGlobals = jQuery.event && s.global;
        if (fireGlobals && jQuery.active++ === 0) {
          jQuery.event.trigger("ajaxStart");
        }
        s.type = s.type.toUpperCase();
        s.hasContent = !rnoContent.test(s.type);
        cacheURL = s.url.replace(rhash, "");
        if (!s.hasContent) {
          uncached = s.url.slice(cacheURL.length);
          if (s.data && (s.processData || typeof s.data === "string")) {
            cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
            delete s.data;
          }
          if (s.cache === false) {
            cacheURL = cacheURL.replace(rantiCache, "$1");
            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
          }
          s.url = cacheURL + uncached;
        } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
          s.data = s.data.replace(r20, "+");
        }
        if (s.ifModified) {
          if (jQuery.lastModified[cacheURL]) {
            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
          }
          if (jQuery.etag[cacheURL]) {
            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
          }
        }
        if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
          jqXHR.setRequestHeader("Content-Type", s.contentType);
        }
        jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
        for (i in s.headers) {
          jqXHR.setRequestHeader(i, s.headers[i]);
        }
        if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
          return jqXHR.abort();
        }
        strAbort = "abort";
        completeDeferred.add(s.complete);
        jqXHR.done(s.success);
        jqXHR.fail(s.error);
        transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
        if (!transport) {
          done(-1, "No Transport");
        } else {
          jqXHR.readyState = 1;
          if (fireGlobals) {
            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
          }
          if (completed2) {
            return jqXHR;
          }
          if (s.async && s.timeout > 0) {
            timeoutTimer = window2.setTimeout(function() {
              jqXHR.abort("timeout");
            }, s.timeout);
          }
          try {
            completed2 = false;
            transport.send(requestHeaders, done);
          } catch (e) {
            if (completed2) {
              throw e;
            }
            done(-1, e);
          }
        }
        function done(status, nativeStatusText, responses, headers) {
          var isSuccess, success, error2, response, modified, statusText = nativeStatusText;
          if (completed2) {
            return;
          }
          completed2 = true;
          if (timeoutTimer) {
            window2.clearTimeout(timeoutTimer);
          }
          transport = void 0;
          responseHeadersString = headers || "";
          jqXHR.readyState = status > 0 ? 4 : 0;
          isSuccess = status >= 200 && status < 300 || status === 304;
          if (responses) {
            response = ajaxHandleResponses(s, jqXHR, responses);
          }
          if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
            s.converters["text script"] = function() {
            };
          }
          response = ajaxConvert(s, response, jqXHR, isSuccess);
          if (isSuccess) {
            if (s.ifModified) {
              modified = jqXHR.getResponseHeader("Last-Modified");
              if (modified) {
                jQuery.lastModified[cacheURL] = modified;
              }
              modified = jqXHR.getResponseHeader("etag");
              if (modified) {
                jQuery.etag[cacheURL] = modified;
              }
            }
            if (status === 204 || s.type === "HEAD") {
              statusText = "nocontent";
            } else if (status === 304) {
              statusText = "notmodified";
            } else {
              statusText = response.state;
              success = response.data;
              error2 = response.error;
              isSuccess = !error2;
            }
          } else {
            error2 = statusText;
            if (status || !statusText) {
              statusText = "error";
              if (status < 0) {
                status = 0;
              }
            }
          }
          jqXHR.status = status;
          jqXHR.statusText = (nativeStatusText || statusText) + "";
          if (isSuccess) {
            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
          } else {
            deferred.rejectWith(callbackContext, [jqXHR, statusText, error2]);
          }
          jqXHR.statusCode(statusCode);
          statusCode = void 0;
          if (fireGlobals) {
            globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error2]);
          }
          completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
          if (fireGlobals) {
            globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
            if (!--jQuery.active) {
              jQuery.event.trigger("ajaxStop");
            }
          }
        }
        return jqXHR;
      },
      getJSON: function(url, data, callback) {
        return jQuery.get(url, data, callback, "json");
      },
      getScript: function(url, callback) {
        return jQuery.get(url, void 0, callback, "script");
      }
    });
    jQuery.each(["get", "post"], function(_i, method) {
      jQuery[method] = function(url, data, callback, type) {
        if (isFunction3(data)) {
          type = type || callback;
          callback = data;
          data = void 0;
        }
        return jQuery.ajax(jQuery.extend({
          url,
          type: method,
          dataType: type,
          data,
          success: callback
        }, jQuery.isPlainObject(url) && url));
      };
    });
    jQuery.ajaxPrefilter(function(s) {
      var i;
      for (i in s.headers) {
        if (i.toLowerCase() === "content-type") {
          s.contentType = s.headers[i] || "";
        }
      }
    });
    jQuery._evalUrl = function(url, options, doc) {
      return jQuery.ajax({
        url,
        type: "GET",
        dataType: "script",
        cache: true,
        async: false,
        global: false,
        converters: {
          "text script": function() {
          }
        },
        dataFilter: function(response) {
          jQuery.globalEval(response, options, doc);
        }
      });
    };
    jQuery.fn.extend({
      wrapAll: function(html) {
        var wrap;
        if (this[0]) {
          if (isFunction3(html)) {
            html = html.call(this[0]);
          }
          wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
          if (this[0].parentNode) {
            wrap.insertBefore(this[0]);
          }
          wrap.map(function() {
            var elem = this;
            while (elem.firstElementChild) {
              elem = elem.firstElementChild;
            }
            return elem;
          }).append(this);
        }
        return this;
      },
      wrapInner: function(html) {
        if (isFunction3(html)) {
          return this.each(function(i) {
            jQuery(this).wrapInner(html.call(this, i));
          });
        }
        return this.each(function() {
          var self2 = jQuery(this), contents = self2.contents();
          if (contents.length) {
            contents.wrapAll(html);
          } else {
            self2.append(html);
          }
        });
      },
      wrap: function(html) {
        var htmlIsFunction = isFunction3(html);
        return this.each(function(i) {
          jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
        });
      },
      unwrap: function(selector2) {
        this.parent(selector2).not("body").each(function() {
          jQuery(this).replaceWith(this.childNodes);
        });
        return this;
      }
    });
    jQuery.expr.pseudos.hidden = function(elem) {
      return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function(elem) {
      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery.ajaxSettings.xhr = function() {
      try {
        return new window2.XMLHttpRequest();
      } catch (e) {
      }
    };
    var xhrSuccessStatus = {
      0: 200,
      1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
      var callback, errorCallback;
      if (support.cors || xhrSupported && !options.crossDomain) {
        return {
          send: function(headers, complete) {
            var i, xhr = options.xhr();
            xhr.open(options.type, options.url, options.async, options.username, options.password);
            if (options.xhrFields) {
              for (i in options.xhrFields) {
                xhr[i] = options.xhrFields[i];
              }
            }
            if (options.mimeType && xhr.overrideMimeType) {
              xhr.overrideMimeType(options.mimeType);
            }
            if (!options.crossDomain && !headers["X-Requested-With"]) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            }
            for (i in headers) {
              xhr.setRequestHeader(i, headers[i]);
            }
            callback = function(type) {
              return function() {
                if (callback) {
                  callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                  if (type === "abort") {
                    xhr.abort();
                  } else if (type === "error") {
                    if (typeof xhr.status !== "number") {
                      complete(0, "error");
                    } else {
                      complete(xhr.status, xhr.statusText);
                    }
                  } else {
                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
                  }
                }
              };
            };
            xhr.onload = callback();
            errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
            if (xhr.onabort !== void 0) {
              xhr.onabort = errorCallback;
            } else {
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  window2.setTimeout(function() {
                    if (callback) {
                      errorCallback();
                    }
                  });
                }
              };
            }
            callback = callback("abort");
            try {
              xhr.send(options.hasContent && options.data || null);
            } catch (e) {
              if (callback) {
                throw e;
              }
            }
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    jQuery.ajaxPrefilter(function(s) {
      if (s.crossDomain) {
        s.contents.script = false;
      }
    });
    jQuery.ajaxSetup({
      accepts: {
        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
      },
      contents: {
        script: /\b(?:java|ecma)script\b/
      },
      converters: {
        "text script": function(text) {
          jQuery.globalEval(text);
          return text;
        }
      }
    });
    jQuery.ajaxPrefilter("script", function(s) {
      if (s.cache === void 0) {
        s.cache = false;
      }
      if (s.crossDomain) {
        s.type = "GET";
      }
    });
    jQuery.ajaxTransport("script", function(s) {
      if (s.crossDomain || s.scriptAttrs) {
        var script, callback;
        return {
          send: function(_, complete) {
            script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
              script.remove();
              callback = null;
              if (evt) {
                complete(evt.type === "error" ? 404 : 200, evt.type);
              }
            });
            document2.head.appendChild(script[0]);
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
      jsonp: "callback",
      jsonpCallback: function() {
        var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
        this[callback] = true;
        return callback;
      }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
      var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
      if (jsonProp || s.dataTypes[0] === "jsonp") {
        callbackName = s.jsonpCallback = isFunction3(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
        if (jsonProp) {
          s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
        } else if (s.jsonp !== false) {
          s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
        }
        s.converters["script json"] = function() {
          if (!responseContainer) {
            jQuery.error(callbackName + " was not called");
          }
          return responseContainer[0];
        };
        s.dataTypes[0] = "json";
        overwritten = window2[callbackName];
        window2[callbackName] = function() {
          responseContainer = arguments;
        };
        jqXHR.always(function() {
          if (overwritten === void 0) {
            jQuery(window2).removeProp(callbackName);
          } else {
            window2[callbackName] = overwritten;
          }
          if (s[callbackName]) {
            s.jsonpCallback = originalSettings.jsonpCallback;
            oldCallbacks.push(callbackName);
          }
          if (responseContainer && isFunction3(overwritten)) {
            overwritten(responseContainer[0]);
          }
          responseContainer = overwritten = void 0;
        });
        return "script";
      }
    });
    support.createHTMLDocument = function() {
      var body = document2.implementation.createHTMLDocument("").body;
      body.innerHTML = "<form></form><form></form>";
      return body.childNodes.length === 2;
    }();
    jQuery.parseHTML = function(data, context, keepScripts) {
      if (typeof data !== "string") {
        return [];
      }
      if (typeof context === "boolean") {
        keepScripts = context;
        context = false;
      }
      var base2, parsed, scripts;
      if (!context) {
        if (support.createHTMLDocument) {
          context = document2.implementation.createHTMLDocument("");
          base2 = context.createElement("base");
          base2.href = document2.location.href;
          context.head.appendChild(base2);
        } else {
          context = document2;
        }
      }
      parsed = rsingleTag.exec(data);
      scripts = !keepScripts && [];
      if (parsed) {
        return [context.createElement(parsed[1])];
      }
      parsed = buildFragment([data], context, scripts);
      if (scripts && scripts.length) {
        jQuery(scripts).remove();
      }
      return jQuery.merge([], parsed.childNodes);
    };
    jQuery.fn.load = function(url, params, callback) {
      var selector2, type, response, self2 = this, off = url.indexOf(" ");
      if (off > -1) {
        selector2 = stripAndCollapse(url.slice(off));
        url = url.slice(0, off);
      }
      if (isFunction3(params)) {
        callback = params;
        params = void 0;
      } else if (params && typeof params === "object") {
        type = "POST";
      }
      if (self2.length > 0) {
        jQuery.ajax({
          url,
          type: type || "GET",
          dataType: "html",
          data: params
        }).done(function(responseText) {
          response = arguments;
          self2.html(selector2 ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector2) : responseText);
        }).always(callback && function(jqXHR, status) {
          self2.each(function() {
            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
          });
        });
      }
      return this;
    };
    jQuery.expr.pseudos.animated = function(elem) {
      return jQuery.grep(jQuery.timers, function(fn) {
        return elem === fn.elem;
      }).length;
    };
    jQuery.offset = {
      setOffset: function(elem, options, i) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
        if (position === "static") {
          elem.style.position = "relative";
        }
        curOffset = curElem.offset();
        curCSSTop = jQuery.css(elem, "top");
        curCSSLeft = jQuery.css(elem, "left");
        calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
        if (calculatePosition) {
          curPosition = curElem.position();
          curTop = curPosition.top;
          curLeft = curPosition.left;
        } else {
          curTop = parseFloat(curCSSTop) || 0;
          curLeft = parseFloat(curCSSLeft) || 0;
        }
        if (isFunction3(options)) {
          options = options.call(elem, i, jQuery.extend({}, curOffset));
        }
        if (options.top != null) {
          props.top = options.top - curOffset.top + curTop;
        }
        if (options.left != null) {
          props.left = options.left - curOffset.left + curLeft;
        }
        if ("using" in options) {
          options.using.call(elem, props);
        } else {
          curElem.css(props);
        }
      }
    };
    jQuery.fn.extend({
      offset: function(options) {
        if (arguments.length) {
          return options === void 0 ? this : this.each(function(i) {
            jQuery.offset.setOffset(this, options, i);
          });
        }
        var rect, win, elem = this[0];
        if (!elem) {
          return;
        }
        if (!elem.getClientRects().length) {
          return { top: 0, left: 0 };
        }
        rect = elem.getBoundingClientRect();
        win = elem.ownerDocument.defaultView;
        return {
          top: rect.top + win.pageYOffset,
          left: rect.left + win.pageXOffset
        };
      },
      position: function() {
        if (!this[0]) {
          return;
        }
        var offsetParent, offset2, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
        if (jQuery.css(elem, "position") === "fixed") {
          offset2 = elem.getBoundingClientRect();
        } else {
          offset2 = this.offset();
          doc = elem.ownerDocument;
          offsetParent = elem.offsetParent || doc.documentElement;
          while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.parentNode;
          }
          if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
            parentOffset = jQuery(offsetParent).offset();
            parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
            parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
          }
        }
        return {
          top: offset2.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
          left: offset2.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
        };
      },
      offsetParent: function() {
        return this.map(function() {
          var offsetParent = this.offsetParent;
          while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || documentElement;
        });
      }
    });
    jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
      var top = prop === "pageYOffset";
      jQuery.fn[method] = function(val) {
        return access(this, function(elem, method2, val2) {
          var win;
          if (isWindow(elem)) {
            win = elem;
          } else if (elem.nodeType === 9) {
            win = elem.defaultView;
          }
          if (val2 === void 0) {
            return win ? win[prop] : elem[method2];
          }
          if (win) {
            win.scrollTo(!top ? val2 : win.pageXOffset, top ? val2 : win.pageYOffset);
          } else {
            elem[method2] = val2;
          }
        }, method, val, arguments.length);
      };
    });
    jQuery.each(["top", "left"], function(_i, prop) {
      jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
        if (computed) {
          computed = curCSS(elem, prop);
          return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
        }
      });
    });
    jQuery.each({ Height: "height", Width: "width" }, function(name2, type) {
      jQuery.each({
        padding: "inner" + name2,
        content: type,
        "": "outer" + name2
      }, function(defaultExtra, funcName) {
        jQuery.fn[funcName] = function(margin, value) {
          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
          return access(this, function(elem, type2, value2) {
            var doc;
            if (isWindow(elem)) {
              return funcName.indexOf("outer") === 0 ? elem["inner" + name2] : elem.document.documentElement["client" + name2];
            }
            if (elem.nodeType === 9) {
              doc = elem.documentElement;
              return Math.max(elem.body["scroll" + name2], doc["scroll" + name2], elem.body["offset" + name2], doc["offset" + name2], doc["client" + name2]);
            }
            return value2 === void 0 ? jQuery.css(elem, type2, extra) : jQuery.style(elem, type2, value2, extra);
          }, type, chainable ? margin : void 0, chainable);
        };
      });
    });
    jQuery.each([
      "ajaxStart",
      "ajaxStop",
      "ajaxComplete",
      "ajaxError",
      "ajaxSuccess",
      "ajaxSend"
    ], function(_i, type) {
      jQuery.fn[type] = function(fn) {
        return this.on(type, fn);
      };
    });
    jQuery.fn.extend({
      bind: function(types2, data, fn) {
        return this.on(types2, null, data, fn);
      },
      unbind: function(types2, fn) {
        return this.off(types2, null, fn);
      },
      delegate: function(selector2, types2, data, fn) {
        return this.on(types2, selector2, data, fn);
      },
      undelegate: function(selector2, types2, fn) {
        return arguments.length === 1 ? this.off(selector2, "**") : this.off(types2, selector2 || "**", fn);
      },
      hover: function(fnOver, fnOut) {
        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
      }
    });
    jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(_i, name2) {
      jQuery.fn[name2] = function(data, fn) {
        return arguments.length > 0 ? this.on(name2, null, data, fn) : this.trigger(name2);
      };
    });
    var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    jQuery.proxy = function(fn, context) {
      var tmp, args, proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!isFunction3(fn)) {
        return void 0;
      }
      args = slice2.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice2.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    };
    jQuery.holdReady = function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction3;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;
    jQuery.now = Date.now;
    jQuery.isNumeric = function(obj) {
      var type = jQuery.type(obj);
      return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
    };
    jQuery.trim = function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    };
    var _jQuery = window2.jQuery, _$ = window2.$;
    jQuery.noConflict = function(deep) {
      if (window2.$ === jQuery) {
        window2.$ = _$;
      }
      if (deep && window2.jQuery === jQuery) {
        window2.jQuery = _jQuery;
      }
      return jQuery;
    };
    if (typeof noGlobal === "undefined") {
      window2.jQuery = window2.$ = jQuery;
    }
    return jQuery;
  });
})(jquery);
var $ = jquery.exports;
var bootstrap$1 = { exports: {} };
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && typeof navigator !== "undefined";
var timeoutDuration = function() {
  var longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();
function microtaskDebounce(fn) {
  var called = false;
  return function() {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function() {
      called = false;
      fn();
    });
  };
}
function taskDebounce(fn) {
  var scheduled = false;
  return function() {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function() {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}
var supportsMicroTasks = isBrowser && window.Promise;
var debounce$4 = supportsMicroTasks ? microtaskDebounce : taskDebounce;
function isFunction$8(functionToCheck) {
  var getType2 = {};
  return functionToCheck && getType2.toString.call(functionToCheck) === "[object Function]";
}
function getStyleComputedProperty(element, property2) {
  if (element.nodeType !== 1) {
    return [];
  }
  var window2 = element.ownerDocument.defaultView;
  var css2 = window2.getComputedStyle(element, null);
  return property2 ? css2[property2] : css2;
}
function getParentNode(element) {
  if (element.nodeName === "HTML") {
    return element;
  }
  return element.parentNode || element.host;
}
function getScrollParent(element) {
  if (!element) {
    return document.body;
  }
  switch (element.nodeName) {
    case "HTML":
    case "BODY":
      return element.ownerDocument.body;
    case "#document":
      return element.body;
  }
  var _getStyleComputedProp = getStyleComputedProperty(element), overflow = _getStyleComputedProp.overflow, overflowX = _getStyleComputedProp.overflowX, overflowY = _getStyleComputedProp.overflowY;
  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }
  return getScrollParent(getParentNode(element));
}
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}
var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
function isIE(version2) {
  if (version2 === 11) {
    return isIE11;
  }
  if (version2 === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }
  var noOffsetParent = isIE(10) ? document.body : null;
  var offsetParent = element.offsetParent || null;
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }
  var nodeName = offsetParent && offsetParent.nodeName;
  if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }
  if (["TH", "TD", "TABLE"].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") {
    return getOffsetParent(offsetParent);
  }
  return offsetParent;
}
function isOffsetContainer(element) {
  var nodeName = element.nodeName;
  if (nodeName === "BODY") {
    return false;
  }
  return nodeName === "HTML" || getOffsetParent(element.firstElementChild) === element;
}
function getRoot$4(node2) {
  if (node2.parentNode !== null) {
    return getRoot$4(node2.parentNode);
  }
  return node2;
}
function findCommonOffsetParent(element1, element2) {
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;
  var range2 = document.createRange();
  range2.setStart(start, 0);
  range2.setEnd(end, 0);
  var commonAncestorContainer = range2.commonAncestorContainer;
  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }
    return getOffsetParent(commonAncestorContainer);
  }
  var element1root = getRoot$4(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot$4(element2).host);
  }
}
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top";
  var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
  var nodeName = element.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }
  return element[upperSide];
}
function includeScroll(rect, element) {
  var subtract2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var scrollTop = getScroll(element, "top");
  var scrollLeft = getScroll(element, "left");
  var modifier = subtract2 ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}
function getBordersSize(styles, axis) {
  var sideA = axis === "x" ? "Left" : "Top";
  var sideB = sideA === "Left" ? "Right" : "Bottom";
  return parseFloat(styles["border" + sideA + "Width"]) + parseFloat(styles["border" + sideB + "Width"]);
}
function getSize(axis, body, html, computedStyle) {
  return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE(10) ? parseInt(html["offset" + axis]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Top" : "Left")]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")]) : 0);
}
function getWindowSizes(document2) {
  var body = document2.body;
  var html = document2.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);
  return {
    height: getSize("Height", body, html, computedStyle),
    width: getSize("Width", body, html, computedStyle)
  };
}
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var defineProperty$5 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _extends$1 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
function getClientRect(offsets) {
  return _extends$1({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}
function getBoundingClientRect(element) {
  var rect = {};
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, "top");
      var scrollLeft = getScroll(element, "left");
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {
  }
  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };
  var sizes = element.nodeName === "HTML" ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, "x");
    vertScrollbar -= getBordersSize(styles, "y");
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }
  return getClientRect(result);
}
function getOffsetRectRelativeToArbitraryNode(children, parent2) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isIE102 = isIE(10);
  var isHTML = parent2.nodeName === "HTML";
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent2);
  var scrollParent = getScrollParent(children);
  var styles = getStyleComputedProperty(parent2);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;
  if (!isIE102 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }
  if (isIE102 && !fixedPosition ? parent2.contains(scrollParent) : parent2 === scrollParent && scrollParent.nodeName !== "BODY") {
    offsets = includeScroll(offsets, parent2);
  }
  return offsets;
}
function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, "left") : 0;
  var offset2 = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width,
    height
  };
  return getClientRect(offset2);
}
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    return false;
  }
  if (getStyleComputedProperty(element, "position") === "fixed") {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}
function getFixedPositionOffsetParent(element) {
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, "transform") === "none") {
    el = el.parentElement;
  }
  return el || document.documentElement;
}
function getBoundaries(popper2, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper2) : findCommonOffsetParent(popper2, getReferenceNode(reference));
  if (boundariesElement === "viewport") {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    var boundariesNode = void 0;
    if (boundariesElement === "scrollParent") {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === "BODY") {
        boundariesNode = popper2.ownerDocument.documentElement;
      }
    } else if (boundariesElement === "window") {
      boundariesNode = popper2.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }
    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
    if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper2.ownerDocument), height = _getWindowSizes.height, width = _getWindowSizes.width;
      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      boundaries = offsets;
    }
  }
  padding = padding || 0;
  var isPaddingNumber = typeof padding === "number";
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}
function getArea(_ref) {
  var width = _ref.width, height = _ref.height;
  return width * height;
}
function computeAutoPlacement(placement, refRect, popper2, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
  if (placement.indexOf("auto") === -1) {
    return placement;
  }
  var boundaries = getBoundaries(popper2, reference, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function(key) {
    return _extends$1({
      key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function(a, b) {
    return b.area - a.area;
  });
  var filteredAreas = sortedAreas.filter(function(_ref2) {
    var width = _ref2.width, height = _ref2.height;
    return width >= popper2.clientWidth && height >= popper2.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split("-")[1];
  return computedPlacement + (variation ? "-" + variation : "");
}
function getReferenceOffsets(state, popper2, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper2) : findCommonOffsetParent(popper2, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}
function getOuterSizes(element) {
  var window2 = element.ownerDocument.defaultView;
  var styles = window2.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}
function getOppositePlacement(placement) {
  var hash = { left: "right", right: "left", bottom: "top", top: "bottom" };
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}
function getPopperOffsets(popper2, referenceOffsets, placement) {
  placement = placement.split("-")[0];
  var popperRect = getOuterSizes(popper2);
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };
  var isHoriz = ["right", "left"].indexOf(placement) !== -1;
  var mainSide = isHoriz ? "top" : "left";
  var secondarySide = isHoriz ? "left" : "top";
  var measurement = isHoriz ? "height" : "width";
  var secondaryMeasurement = !isHoriz ? "height" : "width";
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }
  return popperOffsets;
}
function find$f(arr, check) {
  if (Array.prototype.find) {
    return arr.find(check);
  }
  return arr.filter(check)[0];
}
function findIndex$5(arr, prop, value) {
  if (Array.prototype.findIndex) {
    return arr.findIndex(function(cur) {
      return cur[prop] === value;
    });
  }
  var match2 = find$f(arr, function(obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match2);
}
function runModifiers(modifiers2, data, ends) {
  var modifiersToRun = ends === void 0 ? modifiers2 : modifiers2.slice(0, findIndex$5(modifiers2, "name", ends));
  modifiersToRun.forEach(function(modifier) {
    if (modifier["function"]) {
      console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
    }
    var fn = modifier["function"] || modifier.fn;
    if (modifier.enabled && isFunction$8(fn)) {
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);
      data = fn(data, modifier);
    }
  });
  return data;
}
function update() {
  if (this.state.isDestroyed) {
    return;
  }
  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
  data.originalPlacement = data.placement;
  data.positionFixed = this.options.positionFixed;
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute";
  data = runModifiers(this.modifiers, data);
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}
function isModifierEnabled(modifiers2, modifierName) {
  return modifiers2.some(function(_ref) {
    var name2 = _ref.name, enabled = _ref.enabled;
    return enabled && name2 === modifierName;
  });
}
function getSupportedPropertyName(property2) {
  var prefixes = [false, "ms", "Webkit", "Moz", "O"];
  var upperProp = property2.charAt(0).toUpperCase() + property2.slice(1);
  for (var i = 0; i < prefixes.length; i++) {
    var prefix2 = prefixes[i];
    var toCheck = prefix2 ? "" + prefix2 + upperProp : property2;
    if (typeof document.body.style[toCheck] !== "undefined") {
      return toCheck;
    }
  }
  return null;
}
function destroy() {
  this.state.isDestroyed = true;
  if (isModifierEnabled(this.modifiers, "applyStyle")) {
    this.popper.removeAttribute("x-placement");
    this.popper.style.position = "";
    this.popper.style.top = "";
    this.popper.style.left = "";
    this.popper.style.right = "";
    this.popper.style.bottom = "";
    this.popper.style.willChange = "";
    this.popper.style[getSupportedPropertyName("transform")] = "";
  }
  this.disableEventListeners();
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}
function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === "BODY";
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });
  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}
function setupEventListeners(reference, options, state, updateBound) {
  state.updateBound = updateBound;
  getWindow(reference).addEventListener("resize", state.updateBound, { passive: true });
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
function removeEventListeners(reference, state) {
  getWindow(reference).removeEventListener("resize", state.updateBound);
  state.scrollParents.forEach(function(target) {
    target.removeEventListener("scroll", state.updateBound);
  });
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
function isNumeric(n) {
  return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
}
function setStyles(element, styles) {
  Object.keys(styles).forEach(function(prop) {
    var unit = "";
    if (["width", "height", "top", "right", "bottom", "left"].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = "px";
    }
    element.style[prop] = styles[prop] + unit;
  });
}
function setAttributes$1(element, attributes) {
  Object.keys(attributes).forEach(function(prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}
function applyStyle(data) {
  setStyles(data.instance.popper, data.styles);
  setAttributes$1(data.instance.popper, data.attributes);
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }
  return data;
}
function applyStyleOnLoad(reference, popper2, options, modifierOptions, state) {
  var referenceOffsets = getReferenceOffsets(state, popper2, reference, options.positionFixed);
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper2, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper2.setAttribute("x-placement", placement);
  setStyles(popper2, { position: options.positionFixed ? "fixed" : "absolute" });
  return options;
}
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets, popper2 = _data$offsets.popper, reference = _data$offsets.reference;
  var round2 = Math.round, floor = Math.floor;
  var noRound = function noRound2(v) {
    return v;
  };
  var referenceWidth = round2(reference.width);
  var popperWidth = round2(popper2.width);
  var isVertical2 = ["left", "right"].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf("-") !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical2 || isVariation || sameWidthParity ? round2 : floor;
  var verticalToInteger = !shouldRound ? noRound : round2;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper2.left - 1 : popper2.left),
    top: verticalToInteger(popper2.top),
    bottom: verticalToInteger(popper2.bottom),
    right: horizontalToInteger(popper2.right)
  };
}
var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
function computeStyle(data, options) {
  var x = options.x, y = options.y;
  var popper2 = data.offsets.popper;
  var legacyGpuAccelerationOption = find$f(data.instance.modifiers, function(modifier) {
    return modifier.name === "applyStyle";
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== void 0) {
    console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== void 0 ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);
  var styles = {
    position: popper2.position
  };
  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x === "bottom" ? "top" : "bottom";
  var sideB = y === "right" ? "left" : "right";
  var prefixedProperty = getSupportedPropertyName("transform");
  var left = void 0, top = void 0;
  if (sideA === "bottom") {
    if (offsetParent.nodeName === "HTML") {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === "right") {
    if (offsetParent.nodeName === "HTML") {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)";
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = "transform";
  } else {
    var invertTop = sideA === "bottom" ? -1 : 1;
    var invertLeft = sideB === "right" ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ", " + sideB;
  }
  var attributes = {
    "x-placement": data.placement
  };
  data.attributes = _extends$1({}, attributes, data.attributes);
  data.styles = _extends$1({}, styles, data.styles);
  data.arrowStyles = _extends$1({}, data.offsets.arrow, data.arrowStyles);
  return data;
}
function isModifierRequired(modifiers2, requestingName, requestedName) {
  var requesting = find$f(modifiers2, function(_ref) {
    var name2 = _ref.name;
    return name2 === requestingName;
  });
  var isRequired = !!requesting && modifiers2.some(function(modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });
  if (!isRequired) {
    var _requesting = "`" + requestingName + "`";
    var requested = "`" + requestedName + "`";
    console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!");
  }
  return isRequired;
}
function arrow(data, options) {
  var _data$offsets$arrow;
  if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) {
    return data;
  }
  var arrowElement = options.element;
  if (typeof arrowElement === "string") {
    arrowElement = data.instance.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return data;
    }
  } else {
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn("WARNING: `arrow.element` must be child of its popper element!");
      return data;
    }
  }
  var placement = data.placement.split("-")[0];
  var _data$offsets = data.offsets, popper2 = _data$offsets.popper, reference = _data$offsets.reference;
  var isVertical2 = ["left", "right"].indexOf(placement) !== -1;
  var len = isVertical2 ? "height" : "width";
  var sideCapitalized = isVertical2 ? "Top" : "Left";
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical2 ? "left" : "top";
  var opSide = isVertical2 ? "bottom" : "right";
  var arrowElementSize = getOuterSizes(arrowElement)[len];
  if (reference[opSide] - arrowElementSize < popper2[side]) {
    data.offsets.popper[side] -= popper2[side] - (reference[opSide] - arrowElementSize);
  }
  if (reference[side] + arrowElementSize > popper2[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper2[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);
  var center2 = reference[side] + reference[len] / 2 - arrowElementSize / 2;
  var css2 = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css2["margin" + sideCapitalized]);
  var popperBorderSide = parseFloat(css2["border" + sideCapitalized + "Width"]);
  var sideValue = center2 - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
  sideValue = Math.max(Math.min(popper2[len] - arrowElementSize, sideValue), 0);
  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$5(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$5(_data$offsets$arrow, altSide, ""), _data$offsets$arrow);
  return data;
}
function getOppositeVariation(variation) {
  if (variation === "end") {
    return "start";
  } else if (variation === "start") {
    return "end";
  }
  return variation;
}
var placements = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];
var validPlacements = placements.slice(3);
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var index2 = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index2 + 1).concat(validPlacements.slice(0, index2));
  return counter ? arr.reverse() : arr;
}
var BEHAVIORS = {
  FLIP: "flip",
  CLOCKWISE: "clockwise",
  COUNTERCLOCKWISE: "counterclockwise"
};
function flip(data, options) {
  if (isModifierEnabled(data.instance.modifiers, "inner")) {
    return data;
  }
  if (data.flipped && data.placement === data.originalPlacement) {
    return data;
  }
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  var placement = data.placement.split("-")[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split("-")[1] || "";
  var flipOrder = [];
  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }
  flipOrder.forEach(function(step, index2) {
    if (placement !== step || flipOrder.length === index2 + 1) {
      return data;
    }
    placement = data.placement.split("-")[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;
    var floor = Math.floor;
    var overlapsRef = placement === "left" && floor(popperOffsets.right) > floor(refOffsets.left) || placement === "right" && floor(popperOffsets.left) < floor(refOffsets.right) || placement === "top" && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === "bottom" && floor(popperOffsets.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;
    var isVertical2 = ["top", "bottom"].indexOf(placement) !== -1;
    var flippedVariationByRef = !!options.flipVariations && (isVertical2 && variation === "start" && overflowsLeft || isVertical2 && variation === "end" && overflowsRight || !isVertical2 && variation === "start" && overflowsTop || !isVertical2 && variation === "end" && overflowsBottom);
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical2 && variation === "start" && overflowsRight || isVertical2 && variation === "end" && overflowsLeft || !isVertical2 && variation === "start" && overflowsBottom || !isVertical2 && variation === "end" && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;
    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      data.flipped = true;
      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index2 + 1];
      }
      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }
      data.placement = placement + (variation ? "-" + variation : "");
      data.offsets.popper = _extends$1({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
      data = runModifiers(data.instance.modifiers, data, "flip");
    }
  });
  return data;
}
function keepTogether(data) {
  var _data$offsets = data.offsets, popper2 = _data$offsets.popper, reference = _data$offsets.reference;
  var placement = data.placement.split("-")[0];
  var floor = Math.floor;
  var isVertical2 = ["top", "bottom"].indexOf(placement) !== -1;
  var side = isVertical2 ? "right" : "bottom";
  var opSide = isVertical2 ? "left" : "top";
  var measurement = isVertical2 ? "width" : "height";
  if (popper2[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper2[measurement];
  }
  if (popper2[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }
  return data;
}
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];
  if (!value) {
    return str;
  }
  if (unit.indexOf("%") === 0) {
    var element = void 0;
    switch (unit) {
      case "%p":
        element = popperOffsets;
        break;
      case "%":
      case "%r":
      default:
        element = referenceOffsets;
    }
    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === "vh" || unit === "vw") {
    var size2 = void 0;
    if (unit === "vh") {
      size2 = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size2 = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size2 / 100 * value;
  } else {
    return value;
  }
}
function parseOffset(offset2, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];
  var useHeight = ["right", "left"].indexOf(basePlacement) !== -1;
  var fragments = offset2.split(/(\+|\-)/).map(function(frag) {
    return frag.trim();
  });
  var divider = fragments.indexOf(find$f(fragments, function(frag) {
    return frag.search(/,|\s/) !== -1;
  }));
  if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
    console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
  }
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
  ops = ops.map(function(op, index2) {
    var measurement = (index2 === 1 ? !useHeight : useHeight) ? "height" : "width";
    var mergeWithPrevious = false;
    return op.reduce(function(a, b) {
      if (a[a.length - 1] === "" && ["+", "-"].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, []).map(function(str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });
  ops.forEach(function(op, index2) {
    op.forEach(function(frag, index22) {
      if (isNumeric(frag)) {
        offsets[index2] += frag * (op[index22 - 1] === "-" ? -1 : 1);
      }
    });
  });
  return offsets;
}
function offset(data, _ref) {
  var offset2 = _ref.offset;
  var placement = data.placement, _data$offsets = data.offsets, popper2 = _data$offsets.popper, reference = _data$offsets.reference;
  var basePlacement = placement.split("-")[0];
  var offsets = void 0;
  if (isNumeric(+offset2)) {
    offsets = [+offset2, 0];
  } else {
    offsets = parseOffset(offset2, popper2, reference, basePlacement);
  }
  if (basePlacement === "left") {
    popper2.top += offsets[0];
    popper2.left -= offsets[1];
  } else if (basePlacement === "right") {
    popper2.top += offsets[0];
    popper2.left += offsets[1];
  } else if (basePlacement === "top") {
    popper2.left += offsets[0];
    popper2.top -= offsets[1];
  } else if (basePlacement === "bottom") {
    popper2.left += offsets[0];
    popper2.top += offsets[1];
  }
  data.popper = popper2;
  return data;
}
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }
  var transformProp = getSupportedPropertyName("transform");
  var popperStyles = data.instance.popper.style;
  var top = popperStyles.top, left = popperStyles.left, transform2 = popperStyles[transformProp];
  popperStyles.top = "";
  popperStyles.left = "";
  popperStyles[transformProp] = "";
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform2;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper2 = data.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper2[placement];
      if (popper2[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper2[placement], boundaries[placement]);
      }
      return defineProperty$5({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === "right" ? "left" : "top";
      var value = popper2[mainSide];
      if (popper2[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper2[mainSide], boundaries[placement] - (placement === "right" ? popper2.width : popper2.height));
      }
      return defineProperty$5({}, mainSide, value);
    }
  };
  order.forEach(function(placement) {
    var side = ["left", "top"].indexOf(placement) !== -1 ? "primary" : "secondary";
    popper2 = _extends$1({}, popper2, check[side](placement));
  });
  data.offsets.popper = popper2;
  return data;
}
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split("-")[0];
  var shiftvariation = placement.split("-")[1];
  if (shiftvariation) {
    var _data$offsets = data.offsets, reference = _data$offsets.reference, popper2 = _data$offsets.popper;
    var isVertical2 = ["bottom", "top"].indexOf(basePlacement) !== -1;
    var side = isVertical2 ? "left" : "top";
    var measurement = isVertical2 ? "width" : "height";
    var shiftOffsets = {
      start: defineProperty$5({}, side, reference[side]),
      end: defineProperty$5({}, side, reference[side] + reference[measurement] - popper2[measurement])
    };
    data.offsets.popper = _extends$1({}, popper2, shiftOffsets[shiftvariation]);
  }
  return data;
}
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) {
    return data;
  }
  var refRect = data.offsets.reference;
  var bound = find$f(data.instance.modifiers, function(modifier) {
    return modifier.name === "preventOverflow";
  }).boundaries;
  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    if (data.hide === true) {
      return data;
    }
    data.hide = true;
    data.attributes["x-out-of-boundaries"] = "";
  } else {
    if (data.hide === false) {
      return data;
    }
    data.hide = false;
    data.attributes["x-out-of-boundaries"] = false;
  }
  return data;
}
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split("-")[0];
  var _data$offsets = data.offsets, popper2 = _data$offsets.popper, reference = _data$offsets.reference;
  var isHoriz = ["left", "right"].indexOf(basePlacement) !== -1;
  var subtractLength = ["top", "left"].indexOf(basePlacement) === -1;
  popper2[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper2[isHoriz ? "width" : "height"] : 0);
  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper2);
  return data;
}
var modifiers = {
  shift: {
    order: 100,
    enabled: true,
    fn: shift
  },
  offset: {
    order: 200,
    enabled: true,
    fn: offset,
    offset: 0
  },
  preventOverflow: {
    order: 300,
    enabled: true,
    fn: preventOverflow,
    priority: ["left", "right", "top", "bottom"],
    padding: 5,
    boundariesElement: "scrollParent"
  },
  keepTogether: {
    order: 400,
    enabled: true,
    fn: keepTogether
  },
  arrow: {
    order: 500,
    enabled: true,
    fn: arrow,
    element: "[x-arrow]"
  },
  flip: {
    order: 600,
    enabled: true,
    fn: flip,
    behavior: "flip",
    padding: 5,
    boundariesElement: "viewport",
    flipVariations: false,
    flipVariationsByContent: false
  },
  inner: {
    order: 700,
    enabled: false,
    fn: inner
  },
  hide: {
    order: 800,
    enabled: true,
    fn: hide
  },
  computeStyle: {
    order: 850,
    enabled: true,
    fn: computeStyle,
    gpuAcceleration: true,
    x: "bottom",
    y: "right"
  },
  applyStyle: {
    order: 900,
    enabled: true,
    fn: applyStyle,
    onLoad: applyStyleOnLoad,
    gpuAcceleration: void 0
  }
};
var Defaults = {
  placement: "bottom",
  positionFixed: false,
  eventsEnabled: true,
  removeOnDestroy: false,
  onCreate: function onCreate() {
  },
  onUpdate: function onUpdate() {
  },
  modifiers
};
var Popper = function() {
  function Popper2(reference, popper2) {
    var _this = this;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    classCallCheck(this, Popper2);
    this.scheduleUpdate = function() {
      return requestAnimationFrame(_this.update);
    };
    this.update = debounce$4(this.update.bind(this));
    this.options = _extends$1({}, Popper2.Defaults, options);
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper2 && popper2.jquery ? popper2[0] : popper2;
    this.options.modifiers = {};
    Object.keys(_extends$1({}, Popper2.Defaults.modifiers, options.modifiers)).forEach(function(name2) {
      _this.options.modifiers[name2] = _extends$1({}, Popper2.Defaults.modifiers[name2] || {}, options.modifiers ? options.modifiers[name2] : {});
    });
    this.modifiers = Object.keys(this.options.modifiers).map(function(name2) {
      return _extends$1({
        name: name2
      }, _this.options.modifiers[name2]);
    }).sort(function(a, b) {
      return a.order - b.order;
    });
    this.modifiers.forEach(function(modifierOptions) {
      if (modifierOptions.enabled && isFunction$8(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });
    this.update();
    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      this.enableEventListeners();
    }
    this.state.eventsEnabled = eventsEnabled;
  }
  createClass(Popper2, [{
    key: "update",
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: "destroy",
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: "enableEventListeners",
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: "disableEventListeners",
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }
  }]);
  return Popper2;
}();
Popper.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;
var popper = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": Popper
}, Symbol.toStringTag, { value: "Module" }));
var require$$1$4 = /* @__PURE__ */ getAugmentedNamespace(popper);
/*!
  * Bootstrap v4.6.1 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function(module, exports) {
  (function(global2, factory2) {
    factory2(exports, jquery.exports, require$$1$4);
  })(commonjsGlobal, function(exports2, $2, Popper2) {
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var $__default = /* @__PURE__ */ _interopDefaultLegacy($2);
    var Popper__default = /* @__PURE__ */ _interopDefaultLegacy(Popper2);
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var TRANSITION_END = "transitionend";
    var MAX_UID = 1e6;
    var MILLISECONDS_MULTIPLIER = 1e3;
    function toType(obj) {
      if (obj === null || typeof obj === "undefined") {
        return "" + obj;
      }
      return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
    }
    function getSpecialTransitionEndEvent() {
      return {
        bindType: TRANSITION_END,
        delegateType: TRANSITION_END,
        handle: function handle(event) {
          if ($__default["default"](event.target).is(this)) {
            return event.handleObj.handler.apply(this, arguments);
          }
          return void 0;
        }
      };
    }
    function transitionEndEmulator(duration) {
      var _this = this;
      var called = false;
      $__default["default"](this).one(Util.TRANSITION_END, function() {
        called = true;
      });
      setTimeout(function() {
        if (!called) {
          Util.triggerTransitionEnd(_this);
        }
      }, duration);
      return this;
    }
    function setTransitionEndSupport() {
      $__default["default"].fn.emulateTransitionEnd = transitionEndEmulator;
      $__default["default"].event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
    }
    var Util = {
      TRANSITION_END: "bsTransitionEnd",
      getUID: function getUID(prefix2) {
        do {
          prefix2 += ~~(Math.random() * MAX_UID);
        } while (document.getElementById(prefix2));
        return prefix2;
      },
      getSelectorFromElement: function getSelectorFromElement(element) {
        var selector2 = element.getAttribute("data-target");
        if (!selector2 || selector2 === "#") {
          var hrefAttr = element.getAttribute("href");
          selector2 = hrefAttr && hrefAttr !== "#" ? hrefAttr.trim() : "";
        }
        try {
          return document.querySelector(selector2) ? selector2 : null;
        } catch (_) {
          return null;
        }
      },
      getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
        if (!element) {
          return 0;
        }
        var transitionDuration = $__default["default"](element).css("transition-duration");
        var transitionDelay = $__default["default"](element).css("transition-delay");
        var floatTransitionDuration = parseFloat(transitionDuration);
        var floatTransitionDelay = parseFloat(transitionDelay);
        if (!floatTransitionDuration && !floatTransitionDelay) {
          return 0;
        }
        transitionDuration = transitionDuration.split(",")[0];
        transitionDelay = transitionDelay.split(",")[0];
        return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
      },
      reflow: function reflow(element) {
        return element.offsetHeight;
      },
      triggerTransitionEnd: function triggerTransitionEnd(element) {
        $__default["default"](element).trigger(TRANSITION_END);
      },
      supportsTransitionEnd: function supportsTransitionEnd() {
        return Boolean(TRANSITION_END);
      },
      isElement: function isElement(obj) {
        return (obj[0] || obj).nodeType;
      },
      typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
        for (var property2 in configTypes) {
          if (Object.prototype.hasOwnProperty.call(configTypes, property2)) {
            var expectedTypes = configTypes[property2];
            var value = config[property2];
            var valueType = value && Util.isElement(value) ? "element" : toType(value);
            if (!new RegExp(expectedTypes).test(valueType)) {
              throw new Error(componentName.toUpperCase() + ": " + ('Option "' + property2 + '" provided type "' + valueType + '" ') + ('but expected type "' + expectedTypes + '".'));
            }
          }
        }
      },
      findShadowRoot: function findShadowRoot(element) {
        if (!document.documentElement.attachShadow) {
          return null;
        }
        if (typeof element.getRootNode === "function") {
          var root2 = element.getRootNode();
          return root2 instanceof ShadowRoot ? root2 : null;
        }
        if (element instanceof ShadowRoot) {
          return element;
        }
        if (!element.parentNode) {
          return null;
        }
        return Util.findShadowRoot(element.parentNode);
      },
      jQueryDetection: function jQueryDetection() {
        if (typeof $__default["default"] === "undefined") {
          throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
        }
        var version2 = $__default["default"].fn.jquery.split(" ")[0].split(".");
        var minMajor = 1;
        var ltMajor = 2;
        var minMinor = 9;
        var minPatch = 1;
        var maxMajor = 4;
        if (version2[0] < ltMajor && version2[1] < minMinor || version2[0] === minMajor && version2[1] === minMinor && version2[2] < minPatch || version2[0] >= maxMajor) {
          throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0");
        }
      }
    };
    Util.jQueryDetection();
    setTransitionEndSupport();
    var NAME$a = "alert";
    var VERSION$a = "4.6.1";
    var DATA_KEY$a = "bs.alert";
    var EVENT_KEY$a = "." + DATA_KEY$a;
    var DATA_API_KEY$7 = ".data-api";
    var JQUERY_NO_CONFLICT$a = $__default["default"].fn[NAME$a];
    var CLASS_NAME_ALERT = "alert";
    var CLASS_NAME_FADE$5 = "fade";
    var CLASS_NAME_SHOW$7 = "show";
    var EVENT_CLOSE = "close" + EVENT_KEY$a;
    var EVENT_CLOSED = "closed" + EVENT_KEY$a;
    var EVENT_CLICK_DATA_API$6 = "click" + EVENT_KEY$a + DATA_API_KEY$7;
    var SELECTOR_DISMISS = '[data-dismiss="alert"]';
    var Alert = /* @__PURE__ */ function() {
      function Alert2(element) {
        this._element = element;
      }
      var _proto = Alert2.prototype;
      _proto.close = function close(element) {
        var rootElement = this._element;
        if (element) {
          rootElement = this._getRootElement(element);
        }
        var customEvent = this._triggerCloseEvent(rootElement);
        if (customEvent.isDefaultPrevented()) {
          return;
        }
        this._removeElement(rootElement);
      };
      _proto.dispose = function dispose() {
        $__default["default"].removeData(this._element, DATA_KEY$a);
        this._element = null;
      };
      _proto._getRootElement = function _getRootElement(element) {
        var selector2 = Util.getSelectorFromElement(element);
        var parent2 = false;
        if (selector2) {
          parent2 = document.querySelector(selector2);
        }
        if (!parent2) {
          parent2 = $__default["default"](element).closest("." + CLASS_NAME_ALERT)[0];
        }
        return parent2;
      };
      _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
        var closeEvent = $__default["default"].Event(EVENT_CLOSE);
        $__default["default"](element).trigger(closeEvent);
        return closeEvent;
      };
      _proto._removeElement = function _removeElement(element) {
        var _this = this;
        $__default["default"](element).removeClass(CLASS_NAME_SHOW$7);
        if (!$__default["default"](element).hasClass(CLASS_NAME_FADE$5)) {
          this._destroyElement(element);
          return;
        }
        var transitionDuration = Util.getTransitionDurationFromElement(element);
        $__default["default"](element).one(Util.TRANSITION_END, function(event) {
          return _this._destroyElement(element, event);
        }).emulateTransitionEnd(transitionDuration);
      };
      _proto._destroyElement = function _destroyElement(element) {
        $__default["default"](element).detach().trigger(EVENT_CLOSED).remove();
      };
      Alert2._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function() {
          var $element = $__default["default"](this);
          var data = $element.data(DATA_KEY$a);
          if (!data) {
            data = new Alert2(this);
            $element.data(DATA_KEY$a, data);
          }
          if (config === "close") {
            data[config](this);
          }
        });
      };
      Alert2._handleDismiss = function _handleDismiss(alertInstance) {
        return function(event) {
          if (event) {
            event.preventDefault();
          }
          alertInstance.close(this);
        };
      };
      _createClass(Alert2, null, [{
        key: "VERSION",
        get: function get2() {
          return VERSION$a;
        }
      }]);
      return Alert2;
    }();
    $__default["default"](document).on(EVENT_CLICK_DATA_API$6, SELECTOR_DISMISS, Alert._handleDismiss(new Alert()));
    $__default["default"].fn[NAME$a] = Alert._jQueryInterface;
    $__default["default"].fn[NAME$a].Constructor = Alert;
    $__default["default"].fn[NAME$a].noConflict = function() {
      $__default["default"].fn[NAME$a] = JQUERY_NO_CONFLICT$a;
      return Alert._jQueryInterface;
    };
    var NAME$9 = "button";
    var VERSION$9 = "4.6.1";
    var DATA_KEY$9 = "bs.button";
    var EVENT_KEY$9 = "." + DATA_KEY$9;
    var DATA_API_KEY$6 = ".data-api";
    var JQUERY_NO_CONFLICT$9 = $__default["default"].fn[NAME$9];
    var CLASS_NAME_ACTIVE$3 = "active";
    var CLASS_NAME_BUTTON = "btn";
    var CLASS_NAME_FOCUS = "focus";
    var EVENT_CLICK_DATA_API$5 = "click" + EVENT_KEY$9 + DATA_API_KEY$6;
    var EVENT_FOCUS_BLUR_DATA_API = "focus" + EVENT_KEY$9 + DATA_API_KEY$6 + " " + ("blur" + EVENT_KEY$9 + DATA_API_KEY$6);
    var EVENT_LOAD_DATA_API$2 = "load" + EVENT_KEY$9 + DATA_API_KEY$6;
    var SELECTOR_DATA_TOGGLE_CARROT = '[data-toggle^="button"]';
    var SELECTOR_DATA_TOGGLES = '[data-toggle="buttons"]';
    var SELECTOR_DATA_TOGGLE$4 = '[data-toggle="button"]';
    var SELECTOR_DATA_TOGGLES_BUTTONS = '[data-toggle="buttons"] .btn';
    var SELECTOR_INPUT = 'input:not([type="hidden"])';
    var SELECTOR_ACTIVE$2 = ".active";
    var SELECTOR_BUTTON = ".btn";
    var Button = /* @__PURE__ */ function() {
      function Button2(element) {
        this._element = element;
        this.shouldAvoidTriggerChange = false;
      }
      var _proto = Button2.prototype;
      _proto.toggle = function toggle2() {
        var triggerChangeEvent = true;
        var addAriaPressed = true;
        var rootElement = $__default["default"](this._element).closest(SELECTOR_DATA_TOGGLES)[0];
        if (rootElement) {
          var input = this._element.querySelector(SELECTOR_INPUT);
          if (input) {
            if (input.type === "radio") {
              if (input.checked && this._element.classList.contains(CLASS_NAME_ACTIVE$3)) {
                triggerChangeEvent = false;
              } else {
                var activeElement = rootElement.querySelector(SELECTOR_ACTIVE$2);
                if (activeElement) {
                  $__default["default"](activeElement).removeClass(CLASS_NAME_ACTIVE$3);
                }
              }
            }
            if (triggerChangeEvent) {
              if (input.type === "checkbox" || input.type === "radio") {
                input.checked = !this._element.classList.contains(CLASS_NAME_ACTIVE$3);
              }
              if (!this.shouldAvoidTriggerChange) {
                $__default["default"](input).trigger("change");
              }
            }
            input.focus();
            addAriaPressed = false;
          }
        }
        if (!(this._element.hasAttribute("disabled") || this._element.classList.contains("disabled"))) {
          if (addAriaPressed) {
            this._element.setAttribute("aria-pressed", !this._element.classList.contains(CLASS_NAME_ACTIVE$3));
          }
          if (triggerChangeEvent) {
            $__default["default"](this._element).toggleClass(CLASS_NAME_ACTIVE$3);
          }
        }
      };
      _proto.dispose = function dispose() {
        $__default["default"].removeData(this._element, DATA_KEY$9);
        this._element = null;
      };
      Button2._jQueryInterface = function _jQueryInterface(config, avoidTriggerChange) {
        return this.each(function() {
          var $element = $__default["default"](this);
          var data = $element.data(DATA_KEY$9);
          if (!data) {
            data = new Button2(this);
            $element.data(DATA_KEY$9, data);
          }
          data.shouldAvoidTriggerChange = avoidTriggerChange;
          if (config === "toggle") {
            data[config]();
          }
        });
      };
      _createClass(Button2, null, [{
        key: "VERSION",
        get: function get2() {
          return VERSION$9;
        }
      }]);
      return Button2;
    }();
    $__default["default"](document).on(EVENT_CLICK_DATA_API$5, SELECTOR_DATA_TOGGLE_CARROT, function(event) {
      var button = event.target;
      var initialButton = button;
      if (!$__default["default"](button).hasClass(CLASS_NAME_BUTTON)) {
        button = $__default["default"](button).closest(SELECTOR_BUTTON)[0];
      }
      if (!button || button.hasAttribute("disabled") || button.classList.contains("disabled")) {
        event.preventDefault();
      } else {
        var inputBtn = button.querySelector(SELECTOR_INPUT);
        if (inputBtn && (inputBtn.hasAttribute("disabled") || inputBtn.classList.contains("disabled"))) {
          event.preventDefault();
          return;
        }
        if (initialButton.tagName === "INPUT" || button.tagName !== "LABEL") {
          Button._jQueryInterface.call($__default["default"](button), "toggle", initialButton.tagName === "INPUT");
        }
      }
    }).on(EVENT_FOCUS_BLUR_DATA_API, SELECTOR_DATA_TOGGLE_CARROT, function(event) {
      var button = $__default["default"](event.target).closest(SELECTOR_BUTTON)[0];
      $__default["default"](button).toggleClass(CLASS_NAME_FOCUS, /^focus(in)?$/.test(event.type));
    });
    $__default["default"](window).on(EVENT_LOAD_DATA_API$2, function() {
      var buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLES_BUTTONS));
      for (var i = 0, len = buttons.length; i < len; i++) {
        var button = buttons[i];
        var input = button.querySelector(SELECTOR_INPUT);
        if (input.checked || input.hasAttribute("checked")) {
          button.classList.add(CLASS_NAME_ACTIVE$3);
        } else {
          button.classList.remove(CLASS_NAME_ACTIVE$3);
        }
      }
      buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$4));
      for (var _i = 0, _len = buttons.length; _i < _len; _i++) {
        var _button = buttons[_i];
        if (_button.getAttribute("aria-pressed") === "true") {
          _button.classList.add(CLASS_NAME_ACTIVE$3);
        } else {
          _button.classList.remove(CLASS_NAME_ACTIVE$3);
        }
      }
    });
    $__default["default"].fn[NAME$9] = Button._jQueryInterface;
    $__default["default"].fn[NAME$9].Constructor = Button;
    $__default["default"].fn[NAME$9].noConflict = function() {
      $__default["default"].fn[NAME$9] = JQUERY_NO_CONFLICT$9;
      return Button._jQueryInterface;
    };
    var NAME$8 = "carousel";
    var VERSION$8 = "4.6.1";
    var DATA_KEY$8 = "bs.carousel";
    var EVENT_KEY$8 = "." + DATA_KEY$8;
    var DATA_API_KEY$5 = ".data-api";
    var JQUERY_NO_CONFLICT$8 = $__default["default"].fn[NAME$8];
    var ARROW_LEFT_KEYCODE = 37;
    var ARROW_RIGHT_KEYCODE = 39;
    var TOUCHEVENT_COMPAT_WAIT = 500;
    var SWIPE_THRESHOLD = 40;
    var CLASS_NAME_CAROUSEL = "carousel";
    var CLASS_NAME_ACTIVE$2 = "active";
    var CLASS_NAME_SLIDE = "slide";
    var CLASS_NAME_RIGHT = "carousel-item-right";
    var CLASS_NAME_LEFT = "carousel-item-left";
    var CLASS_NAME_NEXT = "carousel-item-next";
    var CLASS_NAME_PREV = "carousel-item-prev";
    var CLASS_NAME_POINTER_EVENT = "pointer-event";
    var DIRECTION_NEXT = "next";
    var DIRECTION_PREV = "prev";
    var DIRECTION_LEFT = "left";
    var DIRECTION_RIGHT = "right";
    var EVENT_SLIDE = "slide" + EVENT_KEY$8;
    var EVENT_SLID = "slid" + EVENT_KEY$8;
    var EVENT_KEYDOWN = "keydown" + EVENT_KEY$8;
    var EVENT_MOUSEENTER = "mouseenter" + EVENT_KEY$8;
    var EVENT_MOUSELEAVE = "mouseleave" + EVENT_KEY$8;
    var EVENT_TOUCHSTART = "touchstart" + EVENT_KEY$8;
    var EVENT_TOUCHMOVE = "touchmove" + EVENT_KEY$8;
    var EVENT_TOUCHEND = "touchend" + EVENT_KEY$8;
    var EVENT_POINTERDOWN = "pointerdown" + EVENT_KEY$8;
    var EVENT_POINTERUP = "pointerup" + EVENT_KEY$8;
    var EVENT_DRAG_START = "dragstart" + EVENT_KEY$8;
    var EVENT_LOAD_DATA_API$1 = "load" + EVENT_KEY$8 + DATA_API_KEY$5;
    var EVENT_CLICK_DATA_API$4 = "click" + EVENT_KEY$8 + DATA_API_KEY$5;
    var SELECTOR_ACTIVE$1 = ".active";
    var SELECTOR_ACTIVE_ITEM = ".active.carousel-item";
    var SELECTOR_ITEM = ".carousel-item";
    var SELECTOR_ITEM_IMG = ".carousel-item img";
    var SELECTOR_NEXT_PREV = ".carousel-item-next, .carousel-item-prev";
    var SELECTOR_INDICATORS = ".carousel-indicators";
    var SELECTOR_DATA_SLIDE = "[data-slide], [data-slide-to]";
    var SELECTOR_DATA_RIDE = '[data-ride="carousel"]';
    var Default$7 = {
      interval: 5e3,
      keyboard: true,
      slide: false,
      pause: "hover",
      wrap: true,
      touch: true
    };
    var DefaultType$7 = {
      interval: "(number|boolean)",
      keyboard: "boolean",
      slide: "(boolean|string)",
      pause: "(string|boolean)",
      wrap: "boolean",
      touch: "boolean"
    };
    var PointerType = {
      TOUCH: "touch",
      PEN: "pen"
    };
    var Carousel = /* @__PURE__ */ function() {
      function Carousel2(element, config) {
        this._items = null;
        this._interval = null;
        this._activeElement = null;
        this._isPaused = false;
        this._isSliding = false;
        this.touchTimeout = null;
        this.touchStartX = 0;
        this.touchDeltaX = 0;
        this._config = this._getConfig(config);
        this._element = element;
        this._indicatorsElement = this._element.querySelector(SELECTOR_INDICATORS);
        this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
        this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);
        this._addEventListeners();
      }
      var _proto = Carousel2.prototype;
      _proto.next = function next() {
        if (!this._isSliding) {
          this._slide(DIRECTION_NEXT);
        }
      };
      _proto.nextWhenVisible = function nextWhenVisible() {
        var $element = $__default["default"](this._element);
        if (!document.hidden && $element.is(":visible") && $element.css("visibility") !== "hidden") {
          this.next();
        }
      };
      _proto.prev = function prev() {
        if (!this._isSliding) {
          this._slide(DIRECTION_PREV);
        }
      };
      _proto.pause = function pause(event) {
        if (!event) {
          this._isPaused = true;
        }
        if (this._element.querySelector(SELECTOR_NEXT_PREV)) {
          Util.triggerTransitionEnd(this._element);
          this.cycle(true);
        }
        clearInterval(this._interval);
        this._interval = null;
      };
      _proto.cycle = function cycle(event) {
        if (!event) {
          this._isPaused = false;
        }
        if (this._interval) {
          clearInterval(this._interval);
          this._interval = null;
        }
        if (this._config.interval && !this._isPaused) {
          this._updateInterval();
          this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
        }
      };
      _proto.to = function to(index2) {
        var _this = this;
        this._activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);
        var activeIndex = this._getItemIndex(this._activeElement);
        if (index2 > this._items.length - 1 || index2 < 0) {
          return;
        }
        if (this._isSliding) {
          $__default["default"](this._element).one(EVENT_SLID, function() {
            return _this.to(index2);
          });
          return;
        }
        if (activeIndex === index2) {
          this.pause();
          this.cycle();
          return;
        }
        var direction = index2 > activeIndex ? DIRECTION_NEXT : DIRECTION_PREV;
        this._slide(direction, this._items[index2]);
      };
      _proto.dispose = function dispose() {
        $__default["default"](this._element).off(EVENT_KEY$8);
        $__default["default"].removeData(this._element, DATA_KEY$8);
        this._items = null;
        this._config = null;
        this._element = null;
        this._interval = null;
        this._isPaused = null;
        this._isSliding = null;
        this._activeElement = null;
        this._indicatorsElement = null;
      };
      _proto._getConfig = function _getConfig(config) {
        config = _extends2({}, Default$7, config);
        Util.typeCheckConfig(NAME$8, config, DefaultType$7);
        return config;
      };
      _proto._handleSwipe = function _handleSwipe() {
        var absDeltax = Math.abs(this.touchDeltaX);
        if (absDeltax <= SWIPE_THRESHOLD) {
          return;
        }
        var direction = absDeltax / this.touchDeltaX;
        this.touchDeltaX = 0;
        if (direction > 0) {
          this.prev();
        }
        if (direction < 0) {
          this.next();
        }
      };
      _proto._addEventListeners = function _addEventListeners() {
        var _this2 = this;
        if (this._config.keyboard) {
          $__default["default"](this._element).on(EVENT_KEYDOWN, function(event) {
            return _this2._keydown(event);
          });
        }
        if (this._config.pause === "hover") {
          $__default["default"](this._element).on(EVENT_MOUSEENTER, function(event) {
            return _this2.pause(event);
          }).on(EVENT_MOUSELEAVE, function(event) {
            return _this2.cycle(event);
          });
        }
        if (this._config.touch) {
          this._addTouchEventListeners();
        }
      };
      _proto._addTouchEventListeners = function _addTouchEventListeners() {
        var _this3 = this;
        if (!this._touchSupported) {
          return;
        }
        var start = function start2(event) {
          if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
            _this3.touchStartX = event.originalEvent.clientX;
          } else if (!_this3._pointerEvent) {
            _this3.touchStartX = event.originalEvent.touches[0].clientX;
          }
        };
        var move = function move2(event) {
          _this3.touchDeltaX = event.originalEvent.touches && event.originalEvent.touches.length > 1 ? 0 : event.originalEvent.touches[0].clientX - _this3.touchStartX;
        };
        var end = function end2(event) {
          if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
            _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;
          }
          _this3._handleSwipe();
          if (_this3._config.pause === "hover") {
            _this3.pause();
            if (_this3.touchTimeout) {
              clearTimeout(_this3.touchTimeout);
            }
            _this3.touchTimeout = setTimeout(function(event2) {
              return _this3.cycle(event2);
            }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);
          }
        };
        $__default["default"](this._element.querySelectorAll(SELECTOR_ITEM_IMG)).on(EVENT_DRAG_START, function(e) {
          return e.preventDefault();
        });
        if (this._pointerEvent) {
          $__default["default"](this._element).on(EVENT_POINTERDOWN, function(event) {
            return start(event);
          });
          $__default["default"](this._element).on(EVENT_POINTERUP, function(event) {
            return end(event);
          });
          this._element.classList.add(CLASS_NAME_POINTER_EVENT);
        } else {
          $__default["default"](this._element).on(EVENT_TOUCHSTART, function(event) {
            return start(event);
          });
          $__default["default"](this._element).on(EVENT_TOUCHMOVE, function(event) {
            return move(event);
          });
          $__default["default"](this._element).on(EVENT_TOUCHEND, function(event) {
            return end(event);
          });
        }
      };
      _proto._keydown = function _keydown(event) {
        if (/input|textarea/i.test(event.target.tagName)) {
          return;
        }
        switch (event.which) {
          case ARROW_LEFT_KEYCODE:
            event.preventDefault();
            this.prev();
            break;
          case ARROW_RIGHT_KEYCODE:
            event.preventDefault();
            this.next();
            break;
        }
      };
      _proto._getItemIndex = function _getItemIndex(element) {
        this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(SELECTOR_ITEM)) : [];
        return this._items.indexOf(element);
      };
      _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
        var isNextDirection = direction === DIRECTION_NEXT;
        var isPrevDirection = direction === DIRECTION_PREV;
        var activeIndex = this._getItemIndex(activeElement);
        var lastItemIndex = this._items.length - 1;
        var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;
        if (isGoingToWrap && !this._config.wrap) {
          return activeElement;
        }
        var delta2 = direction === DIRECTION_PREV ? -1 : 1;
        var itemIndex = (activeIndex + delta2) % this._items.length;
        return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
      };
      _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
        var targetIndex = this._getItemIndex(relatedTarget);
        var fromIndex = this._getItemIndex(this._element.querySelector(SELECTOR_ACTIVE_ITEM));
        var slideEvent = $__default["default"].Event(EVENT_SLIDE, {
          relatedTarget,
          direction: eventDirectionName,
          from: fromIndex,
          to: targetIndex
        });
        $__default["default"](this._element).trigger(slideEvent);
        return slideEvent;
      };
      _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
        if (this._indicatorsElement) {
          var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(SELECTOR_ACTIVE$1));
          $__default["default"](indicators).removeClass(CLASS_NAME_ACTIVE$2);
          var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];
          if (nextIndicator) {
            $__default["default"](nextIndicator).addClass(CLASS_NAME_ACTIVE$2);
          }
        }
      };
      _proto._updateInterval = function _updateInterval() {
        var element = this._activeElement || this._element.querySelector(SELECTOR_ACTIVE_ITEM);
        if (!element) {
          return;
        }
        var elementInterval = parseInt(element.getAttribute("data-interval"), 10);
        if (elementInterval) {
          this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
          this._config.interval = elementInterval;
        } else {
          this._config.interval = this._config.defaultInterval || this._config.interval;
        }
      };
      _proto._slide = function _slide(direction, element) {
        var _this4 = this;
        var activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);
        var activeElementIndex = this._getItemIndex(activeElement);
        var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);
        var nextElementIndex = this._getItemIndex(nextElement);
        var isCycling = Boolean(this._interval);
        var directionalClassName;
        var orderClassName;
        var eventDirectionName;
        if (direction === DIRECTION_NEXT) {
          directionalClassName = CLASS_NAME_LEFT;
          orderClassName = CLASS_NAME_NEXT;
          eventDirectionName = DIRECTION_LEFT;
        } else {
          directionalClassName = CLASS_NAME_RIGHT;
          orderClassName = CLASS_NAME_PREV;
          eventDirectionName = DIRECTION_RIGHT;
        }
        if (nextElement && $__default["default"](nextElement).hasClass(CLASS_NAME_ACTIVE$2)) {
          this._isSliding = false;
          return;
        }
        var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
        if (slideEvent.isDefaultPrevented()) {
          return;
        }
        if (!activeElement || !nextElement) {
          return;
        }
        this._isSliding = true;
        if (isCycling) {
          this.pause();
        }
        this._setActiveIndicatorElement(nextElement);
        this._activeElement = nextElement;
        var slidEvent = $__default["default"].Event(EVENT_SLID, {
          relatedTarget: nextElement,
          direction: eventDirectionName,
          from: activeElementIndex,
          to: nextElementIndex
        });
        if ($__default["default"](this._element).hasClass(CLASS_NAME_SLIDE)) {
          $__default["default"](nextElement).addClass(orderClassName);
          Util.reflow(nextElement);
          $__default["default"](activeElement).addClass(directionalClassName);
          $__default["default"](nextElement).addClass(directionalClassName);
          var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
          $__default["default"](activeElement).one(Util.TRANSITION_END, function() {
            $__default["default"](nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(CLASS_NAME_ACTIVE$2);
            $__default["default"](activeElement).removeClass(CLASS_NAME_ACTIVE$2 + " " + orderClassName + " " + directionalClassName);
            _this4._isSliding = false;
            setTimeout(function() {
              return $__default["default"](_this4._element).trigger(slidEvent);
            }, 0);
          }).emulateTransitionEnd(transitionDuration);
        } else {
          $__default["default"](activeElement).removeClass(CLASS_NAME_ACTIVE$2);
          $__default["default"](nextElement).addClass(CLASS_NAME_ACTIVE$2);
          this._isSliding = false;
          $__default["default"](this._element).trigger(slidEvent);
        }
        if (isCycling) {
          this.cycle();
        }
      };
      Carousel2._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function() {
          var data = $__default["default"](this).data(DATA_KEY$8);
          var _config = _extends2({}, Default$7, $__default["default"](this).data());
          if (typeof config === "object") {
            _config = _extends2({}, _config, config);
          }
          var action = typeof config === "string" ? config : _config.slide;
          if (!data) {
            data = new Carousel2(this, _config);
            $__default["default"](this).data(DATA_KEY$8, data);
          }
          if (typeof config === "number") {
            data.to(config);
          } else if (typeof action === "string") {
            if (typeof data[action] === "undefined") {
              throw new TypeError('No method named "' + action + '"');
            }
            data[action]();
          } else if (_config.interval && _config.ride) {
            data.pause();
            data.cycle();
          }
        });
      };
      Carousel2._dataApiClickHandler = function _dataApiClickHandler(event) {
        var selector2 = Util.getSelectorFromElement(this);
        if (!selector2) {
          return;
        }
        var target = $__default["default"](selector2)[0];
        if (!target || !$__default["default"](target).hasClass(CLASS_NAME_CAROUSEL)) {
          return;
        }
        var config = _extends2({}, $__default["default"](target).data(), $__default["default"](this).data());
        var slideIndex = this.getAttribute("data-slide-to");
        if (slideIndex) {
          config.interval = false;
        }
        Carousel2._jQueryInterface.call($__default["default"](target), config);
        if (slideIndex) {
          $__default["default"](target).data(DATA_KEY$8).to(slideIndex);
        }
        event.preventDefault();
      };
      _createClass(Carousel2, null, [{
        key: "VERSION",
        get: function get2() {
          return VERSION$8;
        }
      }, {
        key: "Default",
        get: function get2() {
          return Default$7;
        }
      }]);
      return Carousel2;
    }();
    $__default["default"](document).on(EVENT_CLICK_DATA_API$4, SELECTOR_DATA_SLIDE, Carousel._dataApiClickHandler);
    $__default["default"](window).on(EVENT_LOAD_DATA_API$1, function() {
      var carousels = [].slice.call(document.querySelectorAll(SELECTOR_DATA_RIDE));
      for (var i = 0, len = carousels.length; i < len; i++) {
        var $carousel = $__default["default"](carousels[i]);
        Carousel._jQueryInterface.call($carousel, $carousel.data());
      }
    });
    $__default["default"].fn[NAME$8] = Carousel._jQueryInterface;
    $__default["default"].fn[NAME$8].Constructor = Carousel;
    $__default["default"].fn[NAME$8].noConflict = function() {
      $__default["default"].fn[NAME$8] = JQUERY_NO_CONFLICT$8;
      return Carousel._jQueryInterface;
    };
    var NAME$7 = "collapse";
    var VERSION$7 = "4.6.1";
    var DATA_KEY$7 = "bs.collapse";
    var EVENT_KEY$7 = "." + DATA_KEY$7;
    var DATA_API_KEY$4 = ".data-api";
    var JQUERY_NO_CONFLICT$7 = $__default["default"].fn[NAME$7];
    var CLASS_NAME_SHOW$6 = "show";
    var CLASS_NAME_COLLAPSE = "collapse";
    var CLASS_NAME_COLLAPSING = "collapsing";
    var CLASS_NAME_COLLAPSED = "collapsed";
    var DIMENSION_WIDTH = "width";
    var DIMENSION_HEIGHT = "height";
    var EVENT_SHOW$4 = "show" + EVENT_KEY$7;
    var EVENT_SHOWN$4 = "shown" + EVENT_KEY$7;
    var EVENT_HIDE$4 = "hide" + EVENT_KEY$7;
    var EVENT_HIDDEN$4 = "hidden" + EVENT_KEY$7;
    var EVENT_CLICK_DATA_API$3 = "click" + EVENT_KEY$7 + DATA_API_KEY$4;
    var SELECTOR_ACTIVES = ".show, .collapsing";
    var SELECTOR_DATA_TOGGLE$3 = '[data-toggle="collapse"]';
    var Default$6 = {
      toggle: true,
      parent: ""
    };
    var DefaultType$6 = {
      toggle: "boolean",
      parent: "(string|element)"
    };
    var Collapse = /* @__PURE__ */ function() {
      function Collapse2(element, config) {
        this._isTransitioning = false;
        this._element = element;
        this._config = this._getConfig(config);
        this._triggerArray = [].slice.call(document.querySelectorAll('[data-toggle="collapse"][href="#' + element.id + '"],' + ('[data-toggle="collapse"][data-target="#' + element.id + '"]')));
        var toggleList = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$3));
        for (var i = 0, len = toggleList.length; i < len; i++) {
          var elem = toggleList[i];
          var selector2 = Util.getSelectorFromElement(elem);
          var filterElement = [].slice.call(document.querySelectorAll(selector2)).filter(function(foundElem) {
            return foundElem === element;
          });
          if (selector2 !== null && filterElement.length > 0) {
            this._selector = selector2;
            this._triggerArray.push(elem);
          }
        }
        this._parent = this._config.parent ? this._getParent() : null;
        if (!this._config.parent) {
          this._addAriaAndCollapsedClass(this._element, this._triggerArray);
        }
        if (this._config.toggle) {
          this.toggle();
        }
      }
      var _proto = Collapse2.prototype;
      _proto.toggle = function toggle2() {
        if ($__default["default"](this._element).hasClass(CLASS_NAME_SHOW$6)) {
          this.hide();
        } else {
          this.show();
        }
      };
      _proto.show = function show() {
        var _this = this;
        if (this._isTransitioning || $__default["default"](this._element).hasClass(CLASS_NAME_SHOW$6)) {
          return;
        }
        var actives;
        var activesData;
        if (this._parent) {
          actives = [].slice.call(this._parent.querySelectorAll(SELECTOR_ACTIVES)).filter(function(elem) {
            if (typeof _this._config.parent === "string") {
              return elem.getAttribute("data-parent") === _this._config.parent;
            }
            return elem.classList.contains(CLASS_NAME_COLLAPSE);
          });
          if (actives.length === 0) {
            actives = null;
          }
        }
        if (actives) {
          activesData = $__default["default"](actives).not(this._selector).data(DATA_KEY$7);
          if (activesData && activesData._isTransitioning) {
            return;
          }
        }
        var startEvent = $__default["default"].Event(EVENT_SHOW$4);
        $__default["default"](this._element).trigger(startEvent);
        if (startEvent.isDefaultPrevented()) {
          return;
        }
        if (actives) {
          Collapse2._jQueryInterface.call($__default["default"](actives).not(this._selector), "hide");
          if (!activesData) {
            $__default["default"](actives).data(DATA_KEY$7, null);
          }
        }
        var dimension = this._getDimension();
        $__default["default"](this._element).removeClass(CLASS_NAME_COLLAPSE).addClass(CLASS_NAME_COLLAPSING);
        this._element.style[dimension] = 0;
        if (this._triggerArray.length) {
          $__default["default"](this._triggerArray).removeClass(CLASS_NAME_COLLAPSED).attr("aria-expanded", true);
        }
        this.setTransitioning(true);
        var complete = function complete2() {
          $__default["default"](_this._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE + " " + CLASS_NAME_SHOW$6);
          _this._element.style[dimension] = "";
          _this.setTransitioning(false);
          $__default["default"](_this._element).trigger(EVENT_SHOWN$4);
        };
        var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        var scrollSize = "scroll" + capitalizedDimension;
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        this._element.style[dimension] = this._element[scrollSize] + "px";
      };
      _proto.hide = function hide2() {
        var _this2 = this;
        if (this._isTransitioning || !$__default["default"](this._element).hasClass(CLASS_NAME_SHOW$6)) {
          return;
        }
        var startEvent = $__default["default"].Event(EVENT_HIDE$4);
        $__default["default"](this._element).trigger(startEvent);
        if (startEvent.isDefaultPrevented()) {
          return;
        }
        var dimension = this._getDimension();
        this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
        Util.reflow(this._element);
        $__default["default"](this._element).addClass(CLASS_NAME_COLLAPSING).removeClass(CLASS_NAME_COLLAPSE + " " + CLASS_NAME_SHOW$6);
        var triggerArrayLength = this._triggerArray.length;
        if (triggerArrayLength > 0) {
          for (var i = 0; i < triggerArrayLength; i++) {
            var trigger = this._triggerArray[i];
            var selector2 = Util.getSelectorFromElement(trigger);
            if (selector2 !== null) {
              var $elem = $__default["default"]([].slice.call(document.querySelectorAll(selector2)));
              if (!$elem.hasClass(CLASS_NAME_SHOW$6)) {
                $__default["default"](trigger).addClass(CLASS_NAME_COLLAPSED).attr("aria-expanded", false);
              }
            }
          }
        }
        this.setTransitioning(true);
        var complete = function complete2() {
          _this2.setTransitioning(false);
          $__default["default"](_this2._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE).trigger(EVENT_HIDDEN$4);
        };
        this._element.style[dimension] = "";
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      };
      _proto.setTransitioning = function setTransitioning(isTransitioning) {
        this._isTransitioning = isTransitioning;
      };
      _proto.dispose = function dispose() {
        $__default["default"].removeData(this._element, DATA_KEY$7);
        this._config = null;
        this._parent = null;
        this._element = null;
        this._triggerArray = null;
        this._isTransitioning = null;
      };
      _proto._getConfig = function _getConfig(config) {
        config = _extends2({}, Default$6, config);
        config.toggle = Boolean(config.toggle);
        Util.typeCheckConfig(NAME$7, config, DefaultType$6);
        return config;
      };
      _proto._getDimension = function _getDimension() {
        var hasWidth = $__default["default"](this._element).hasClass(DIMENSION_WIDTH);
        return hasWidth ? DIMENSION_WIDTH : DIMENSION_HEIGHT;
      };
      _proto._getParent = function _getParent() {
        var _this3 = this;
        var parent2;
        if (Util.isElement(this._config.parent)) {
          parent2 = this._config.parent;
          if (typeof this._config.parent.jquery !== "undefined") {
            parent2 = this._config.parent[0];
          }
        } else {
          parent2 = document.querySelector(this._config.parent);
        }
        var selector2 = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]';
        var children = [].slice.call(parent2.querySelectorAll(selector2));
        $__default["default"](children).each(function(i, element) {
          _this3._addAriaAndCollapsedClass(Collapse2._getTargetFromElement(element), [element]);
        });
        return parent2;
      };
      _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
        var isOpen = $__default["default"](element).hasClass(CLASS_NAME_SHOW$6);
        if (triggerArray.length) {
          $__default["default"](triggerArray).toggleClass(CLASS_NAME_COLLAPSED, !isOpen).attr("aria-expanded", isOpen);
        }
      };
      Collapse2._getTargetFromElement = function _getTargetFromElement(element) {
        var selector2 = Util.getSelectorFromElement(element);
        return selector2 ? document.querySelector(selector2) : null;
      };
      Collapse2._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function() {
          var $element = $__default["default"](this);
          var data = $element.data(DATA_KEY$7);
          var _config = _extends2({}, Default$6, $element.data(), typeof config === "object" && config ? config : {});
          if (!data && _config.toggle && typeof config === "string" && /show|hide/.test(config)) {
            _config.toggle = false;
          }
          if (!data) {
            data = new Collapse2(this, _config);
            $element.data(DATA_KEY$7, data);
          }
          if (typeof config === "string") {
            if (typeof data[config] === "undefined") {
              throw new TypeError('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };
      _createClass(Collapse2, null, [{
        key: "VERSION",
        get: function get2() {
          return VERSION$7;
        }
      }, {
        key: "Default",
        get: function get2() {
          return Default$6;
        }
      }]);
      return Collapse2;
    }();
    $__default["default"](document).on(EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
      if (event.currentTarget.tagName === "A") {
        event.preventDefault();
      }
      var $trigger = $__default["default"](this);
      var selector2 = Util.getSelectorFromElement(this);
      var selectors = [].slice.call(document.querySelectorAll(selector2));
      $__default["default"](selectors).each(function() {
        var $target = $__default["default"](this);
        var data = $target.data(DATA_KEY$7);
        var config = data ? "toggle" : $trigger.data();
        Collapse._jQueryInterface.call($target, config);
      });
    });
    $__default["default"].fn[NAME$7] = Collapse._jQueryInterface;
    $__default["default"].fn[NAME$7].Constructor = Collapse;
    $__default["default"].fn[NAME$7].noConflict = function() {
      $__default["default"].fn[NAME$7] = JQUERY_NO_CONFLICT$7;
      return Collapse._jQueryInterface;
    };
    var NAME$6 = "dropdown";
    var VERSION$6 = "4.6.1";
    var DATA_KEY$6 = "bs.dropdown";
    var EVENT_KEY$6 = "." + DATA_KEY$6;
    var DATA_API_KEY$3 = ".data-api";
    var JQUERY_NO_CONFLICT$6 = $__default["default"].fn[NAME$6];
    var ESCAPE_KEYCODE$1 = 27;
    var SPACE_KEYCODE = 32;
    var TAB_KEYCODE = 9;
    var ARROW_UP_KEYCODE = 38;
    var ARROW_DOWN_KEYCODE = 40;
    var RIGHT_MOUSE_BUTTON_WHICH = 3;
    var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE$1);
    var CLASS_NAME_DISABLED$1 = "disabled";
    var CLASS_NAME_SHOW$5 = "show";
    var CLASS_NAME_DROPUP = "dropup";
    var CLASS_NAME_DROPRIGHT = "dropright";
    var CLASS_NAME_DROPLEFT = "dropleft";
    var CLASS_NAME_MENURIGHT = "dropdown-menu-right";
    var CLASS_NAME_POSITION_STATIC = "position-static";
    var EVENT_HIDE$3 = "hide" + EVENT_KEY$6;
    var EVENT_HIDDEN$3 = "hidden" + EVENT_KEY$6;
    var EVENT_SHOW$3 = "show" + EVENT_KEY$6;
    var EVENT_SHOWN$3 = "shown" + EVENT_KEY$6;
    var EVENT_CLICK = "click" + EVENT_KEY$6;
    var EVENT_CLICK_DATA_API$2 = "click" + EVENT_KEY$6 + DATA_API_KEY$3;
    var EVENT_KEYDOWN_DATA_API = "keydown" + EVENT_KEY$6 + DATA_API_KEY$3;
    var EVENT_KEYUP_DATA_API = "keyup" + EVENT_KEY$6 + DATA_API_KEY$3;
    var SELECTOR_DATA_TOGGLE$2 = '[data-toggle="dropdown"]';
    var SELECTOR_FORM_CHILD = ".dropdown form";
    var SELECTOR_MENU = ".dropdown-menu";
    var SELECTOR_NAVBAR_NAV = ".navbar-nav";
    var SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
    var PLACEMENT_TOP = "top-start";
    var PLACEMENT_TOPEND = "top-end";
    var PLACEMENT_BOTTOM = "bottom-start";
    var PLACEMENT_BOTTOMEND = "bottom-end";
    var PLACEMENT_RIGHT = "right-start";
    var PLACEMENT_LEFT = "left-start";
    var Default$5 = {
      offset: 0,
      flip: true,
      boundary: "scrollParent",
      reference: "toggle",
      display: "dynamic",
      popperConfig: null
    };
    var DefaultType$5 = {
      offset: "(number|string|function)",
      flip: "boolean",
      boundary: "(string|element)",
      reference: "(string|element)",
      display: "string",
      popperConfig: "(null|object)"
    };
    var Dropdown = /* @__PURE__ */ function() {
      function Dropdown2(element, config) {
        this._element = element;
        this._popper = null;
        this._config = this._getConfig(config);
        this._menu = this._getMenuElement();
        this._inNavbar = this._detectNavbar();
        this._addEventListeners();
      }
      var _proto = Dropdown2.prototype;
      _proto.toggle = function toggle2() {
        if (this._element.disabled || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED$1)) {
          return;
        }
        var isActive = $__default["default"](this._menu).hasClass(CLASS_NAME_SHOW$5);
        Dropdown2._clearMenus();
        if (isActive) {
          return;
        }
        this.show(true);
      };
      _proto.show = function show(usePopper) {
        if (usePopper === void 0) {
          usePopper = false;
        }
        if (this._element.disabled || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED$1) || $__default["default"](this._menu).hasClass(CLASS_NAME_SHOW$5)) {
          return;
        }
        var relatedTarget = {
          relatedTarget: this._element
        };
        var showEvent = $__default["default"].Event(EVENT_SHOW$3, relatedTarget);
        var parent2 = Dropdown2._getParentFromElement(this._element);
        $__default["default"](parent2).trigger(showEvent);
        if (showEvent.isDefaultPrevented()) {
          return;
        }
        if (!this._inNavbar && usePopper) {
          if (typeof Popper__default["default"] === "undefined") {
            throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
          }
          var referenceElement = this._element;
          if (this._config.reference === "parent") {
            referenceElement = parent2;
          } else if (Util.isElement(this._config.reference)) {
            referenceElement = this._config.reference;
            if (typeof this._config.reference.jquery !== "undefined") {
              referenceElement = this._config.reference[0];
            }
          }
          if (this._config.boundary !== "scrollParent") {
            $__default["default"](parent2).addClass(CLASS_NAME_POSITION_STATIC);
          }
          this._popper = new Popper__default["default"](referenceElement, this._menu, this._getPopperConfig());
        }
        if ("ontouchstart" in document.documentElement && $__default["default"](parent2).closest(SELECTOR_NAVBAR_NAV).length === 0) {
          $__default["default"](document.body).children().on("mouseover", null, $__default["default"].noop);
        }
        this._element.focus();
        this._element.setAttribute("aria-expanded", true);
        $__default["default"](this._menu).toggleClass(CLASS_NAME_SHOW$5);
        $__default["default"](parent2).toggleClass(CLASS_NAME_SHOW$5).trigger($__default["default"].Event(EVENT_SHOWN$3, relatedTarget));
      };
      _proto.hide = function hide2() {
        if (this._element.disabled || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED$1) || !$__default["default"](this._menu).hasClass(CLASS_NAME_SHOW$5)) {
          return;
        }
        var relatedTarget = {
          relatedTarget: this._element
        };
        var hideEvent = $__default["default"].Event(EVENT_HIDE$3, relatedTarget);
        var parent2 = Dropdown2._getParentFromElement(this._element);
        $__default["default"](parent2).trigger(hideEvent);
        if (hideEvent.isDefaultPrevented()) {
          return;
        }
        if (this._popper) {
          this._popper.destroy();
        }
        $__default["default"](this._menu).toggleClass(CLASS_NAME_SHOW$5);
        $__default["default"](parent2).toggleClass(CLASS_NAME_SHOW$5).trigger($__default["default"].Event(EVENT_HIDDEN$3, relatedTarget));
      };
      _proto.dispose = function dispose() {
        $__default["default"].removeData(this._element, DATA_KEY$6);
        $__default["default"](this._element).off(EVENT_KEY$6);
        this._element = null;
        this._menu = null;
        if (this._popper !== null) {
          this._popper.destroy();
          this._popper = null;
        }
      };
      _proto.update = function update2() {
        this._inNavbar = this._detectNavbar();
        if (this._popper !== null) {
          this._popper.scheduleUpdate();
        }
      };
      _proto._addEventListeners = function _addEventListeners() {
        var _this = this;
        $__default["default"](this._element).on(EVENT_CLICK, function(event) {
          event.preventDefault();
          event.stopPropagation();
          _this.toggle();
        });
      };
      _proto._getConfig = function _getConfig(config) {
        config = _extends2({}, this.constructor.Default, $__default["default"](this._element).data(), config);
        Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);
        return config;
      };
      _proto._getMenuElement = function _getMenuElement() {
        if (!this._menu) {
          var parent2 = Dropdown2._getParentFromElement(this._element);
          if (parent2) {
            this._menu = parent2.querySelector(SELECTOR_MENU);
          }
        }
        return this._menu;
      };
      _proto._getPlacement = function _getPlacement() {
        var $parentDropdown = $__default["default"](this._element.parentNode);
        var placement = PLACEMENT_BOTTOM;
        if ($parentDropdown.hasClass(CLASS_NAME_DROPUP)) {
          placement = $__default["default"](this._menu).hasClass(CLASS_NAME_MENURIGHT) ? PLACEMENT_TOPEND : PLACEMENT_TOP;
        } else if ($parentDropdown.hasClass(CLASS_NAME_DROPRIGHT)) {
          placement = PLACEMENT_RIGHT;
        } else if ($parentDropdown.hasClass(CLASS_NAME_DROPLEFT)) {
          placement = PLACEMENT_LEFT;
        } else if ($__default["default"](this._menu).hasClass(CLASS_NAME_MENURIGHT)) {
          placement = PLACEMENT_BOTTOMEND;
        }
        return placement;
      };
      _proto._detectNavbar = function _detectNavbar() {
        return $__default["default"](this._element).closest(".navbar").length > 0;
      };
      _proto._getOffset = function _getOffset() {
        var _this2 = this;
        var offset2 = {};
        if (typeof this._config.offset === "function") {
          offset2.fn = function(data) {
            data.offsets = _extends2({}, data.offsets, _this2._config.offset(data.offsets, _this2._element));
            return data;
          };
        } else {
          offset2.offset = this._config.offset;
        }
        return offset2;
      };
      _proto._getPopperConfig = function _getPopperConfig() {
        var popperConfig = {
          placement: this._getPlacement(),
          modifiers: {
            offset: this._getOffset(),
            flip: {
              enabled: this._config.flip
            },
            preventOverflow: {
              boundariesElement: this._config.boundary
            }
          }
        };
        if (this._config.display === "static") {
          popperConfig.modifiers.applyStyle = {
            enabled: false
          };
        }
        return _extends2({}, popperConfig, this._config.popperConfig);
      };
      Dropdown2._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function() {
          var data = $__default["default"](this).data(DATA_KEY$6);
          var _config = typeof config === "object" ? config : null;
          if (!data) {
            data = new Dropdown2(this, _config);
            $__default["default"](this).data(DATA_KEY$6, data);
          }
          if (typeof config === "string") {
            if (typeof data[config] === "undefined") {
              throw new TypeError('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };
      Dropdown2._clearMenus = function _clearMenus(event) {
        if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === "keyup" && event.which !== TAB_KEYCODE)) {
          return;
        }
        var toggles = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$2));
        for (var i = 0, len = toggles.length; i < len; i++) {
          var parent2 = Dropdown2._getParentFromElement(toggles[i]);
          var context = $__default["default"](toggles[i]).data(DATA_KEY$6);
          var relatedTarget = {
            relatedTarget: toggles[i]
          };
          if (event && event.type === "click") {
            relatedTarget.clickEvent = event;
          }
          if (!context) {
            continue;
          }
          var dropdownMenu = context._menu;
          if (!$__default["default"](parent2).hasClass(CLASS_NAME_SHOW$5)) {
            continue;
          }
          if (event && (event.type === "click" && /input|textarea/i.test(event.target.tagName) || event.type === "keyup" && event.which === TAB_KEYCODE) && $__default["default"].contains(parent2, event.target)) {
            continue;
          }
          var hideEvent = $__default["default"].Event(EVENT_HIDE$3, relatedTarget);
          $__default["default"](parent2).trigger(hideEvent);
          if (hideEvent.isDefaultPrevented()) {
            continue;
          }
          if ("ontouchstart" in document.documentElement) {
            $__default["default"](document.body).children().off("mouseover", null, $__default["default"].noop);
          }
          toggles[i].setAttribute("aria-expanded", "false");
          if (context._popper) {
            context._popper.destroy();
          }
          $__default["default"](dropdownMenu).removeClass(CLASS_NAME_SHOW$5);
          $__default["default"](parent2).removeClass(CLASS_NAME_SHOW$5).trigger($__default["default"].Event(EVENT_HIDDEN$3, relatedTarget));
        }
      };
      Dropdown2._getParentFromElement = function _getParentFromElement(element) {
        var parent2;
        var selector2 = Util.getSelectorFromElement(element);
        if (selector2) {
          parent2 = document.querySelector(selector2);
        }
        return parent2 || element.parentNode;
      };
      Dropdown2._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
        if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE$1 && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $__default["default"](event.target).closest(SELECTOR_MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
          return;
        }
        if (this.disabled || $__default["default"](this).hasClass(CLASS_NAME_DISABLED$1)) {
          return;
        }
        var parent2 = Dropdown2._getParentFromElement(this);
        var isActive = $__default["default"](parent2).hasClass(CLASS_NAME_SHOW$5);
        if (!isActive && event.which === ESCAPE_KEYCODE$1) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (!isActive || event.which === ESCAPE_KEYCODE$1 || event.which === SPACE_KEYCODE) {
          if (event.which === ESCAPE_KEYCODE$1) {
            $__default["default"](parent2.querySelector(SELECTOR_DATA_TOGGLE$2)).trigger("focus");
          }
          $__default["default"](this).trigger("click");
          return;
        }
        var items = [].slice.call(parent2.querySelectorAll(SELECTOR_VISIBLE_ITEMS)).filter(function(item) {
          return $__default["default"](item).is(":visible");
        });
        if (items.length === 0) {
          return;
        }
        var index2 = items.indexOf(event.target);
        if (event.which === ARROW_UP_KEYCODE && index2 > 0) {
          index2--;
        }
        if (event.which === ARROW_DOWN_KEYCODE && index2 < items.length - 1) {
          index2++;
        }
        if (index2 < 0) {
          index2 = 0;
        }
        items[index2].focus();
      };
      _createClass(Dropdown2, null, [{
        key: "VERSION",
        get: function get2() {
          return VERSION$6;
        }
      }, {
        key: "Default",
        get: function get2() {
          return Default$5;
        }
      }, {
        key: "DefaultType",
        get: function get2() {
          return DefaultType$5;
        }
      }]);
      return Dropdown2;
    }();
    $__default["default"](document).on(EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$2, Dropdown._dataApiKeydownHandler).on(EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown._dataApiKeydownHandler).on(EVENT_CLICK_DATA_API$2 + " " + EVENT_KEYUP_DATA_API, Dropdown._clearMenus).on(EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
      event.preventDefault();
      event.stopPropagation();
      Dropdown._jQueryInterface.call($__default["default"](this), "toggle");
    }).on(EVENT_CLICK_DATA_API$2, SELECTOR_FORM_CHILD, function(e) {
      e.stopPropagation();
    });
    $__default["default"].fn[NAME$6] = Dropdown._jQueryInterface;
    $__default["default"].fn[NAME$6].Constructor = Dropdown;
    $__default["default"].fn[NAME$6].noConflict = function() {
      $__default["default"].fn[NAME$6] = JQUERY_NO_CONFLICT$6;
      return Dropdown._jQueryInterface;
    };
    var NAME$5 = "modal";
    var VERSION$5 = "4.6.1";
    var DATA_KEY$5 = "bs.modal";
    var EVENT_KEY$5 = "." + DATA_KEY$5;
    var DATA_API_KEY$2 = ".data-api";
    var JQUERY_NO_CONFLICT$5 = $__default["default"].fn[NAME$5];
    var ESCAPE_KEYCODE = 27;
    var CLASS_NAME_SCROLLABLE = "modal-dialog-scrollable";
    var CLASS_NAME_SCROLLBAR_MEASURER = "modal-scrollbar-measure";
    var CLASS_NAME_BACKDROP = "modal-backdrop";
    var CLASS_NAME_OPEN = "modal-open";
    var CLASS_NAME_FADE$4 = "fade";
    var CLASS_NAME_SHOW$4 = "show";
    var CLASS_NAME_STATIC = "modal-static";
    var EVENT_HIDE$2 = "hide" + EVENT_KEY$5;
    var EVENT_HIDE_PREVENTED = "hidePrevented" + EVENT_KEY$5;
    var EVENT_HIDDEN$2 = "hidden" + EVENT_KEY$5;
    var EVENT_SHOW$2 = "show" + EVENT_KEY$5;
    var EVENT_SHOWN$2 = "shown" + EVENT_KEY$5;
    var EVENT_FOCUSIN = "focusin" + EVENT_KEY$5;
    var EVENT_RESIZE = "resize" + EVENT_KEY$5;
    var EVENT_CLICK_DISMISS$1 = "click.dismiss" + EVENT_KEY$5;
    var EVENT_KEYDOWN_DISMISS = "keydown.dismiss" + EVENT_KEY$5;
    var EVENT_MOUSEUP_DISMISS = "mouseup.dismiss" + EVENT_KEY$5;
    var EVENT_MOUSEDOWN_DISMISS = "mousedown.dismiss" + EVENT_KEY$5;
    var EVENT_CLICK_DATA_API$1 = "click" + EVENT_KEY$5 + DATA_API_KEY$2;
    var SELECTOR_DIALOG = ".modal-dialog";
    var SELECTOR_MODAL_BODY = ".modal-body";
    var SELECTOR_DATA_TOGGLE$1 = '[data-toggle="modal"]';
    var SELECTOR_DATA_DISMISS$1 = '[data-dismiss="modal"]';
    var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
    var SELECTOR_STICKY_CONTENT = ".sticky-top";
    var Default$4 = {
      backdrop: true,
      keyboard: true,
      focus: true,
      show: true
    };
    var DefaultType$4 = {
      backdrop: "(boolean|string)",
      keyboard: "boolean",
      focus: "boolean",
      show: "boolean"
    };
    var Modal = /* @__PURE__ */ function() {
      function Modal2(element, config) {
        this._config = this._getConfig(config);
        this._element = element;
        this._dialog = element.querySelector(SELECTOR_DIALOG);
        this._backdrop = null;
        this._isShown = false;
        this._isBodyOverflowing = false;
        this._ignoreBackdropClick = false;
        this._isTransitioning = false;
        this._scrollbarWidth = 0;
      }
      var _proto = Modal2.prototype;
      _proto.toggle = function toggle2(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
      };
      _proto.show = function show(relatedTarget) {
        var _this = this;
        if (this._isShown || this._isTransitioning) {
          return;
        }
        var showEvent = $__default["default"].Event(EVENT_SHOW$2, {
          relatedTarget
        });
        $__default["default"](this._element).trigger(showEvent);
        if (showEvent.isDefaultPrevented()) {
          return;
        }
        this._isShown = true;
        if ($__default["default"](this._element).hasClass(CLASS_NAME_FADE$4)) {
          this._isTransitioning = true;
        }
        this._checkScrollbar();
        this._setScrollbar();
        this._adjustDialog();
        this._setEscapeEvent();
        this._setResizeEvent();
        $__default["default"](this._element).on(EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, function(event) {
          return _this.hide(event);
        });
        $__default["default"](this._dialog).on(EVENT_MOUSEDOWN_DISMISS, function() {
          $__default["default"](_this._element).one(EVENT_MOUSEUP_DISMISS, function(event) {
            if ($__default["default"](event.target).is(_this._element)) {
              _this._ignoreBackdropClick = true;
            }
          });
        });
        this._showBackdrop(function() {
          return _this._showElement(relatedTarget);
        });
      };
      _proto.hide = function hide2(event) {
        var _this2 = this;
        if (event) {
          event.preventDefault();
        }
        if (!this._isShown || this._isTransitioning) {
          return;
        }
        var hideEvent = $__default["default"].Event(EVENT_HIDE$2);
        $__default["default"](this._element).trigger(hideEvent);
        if (!this._isShown || hideEvent.isDefaultPrevented()) {
          return;
        }
        this._isShown = false;
        var transition = $__default["default"](this._element).hasClass(CLASS_NAME_FADE$4);
        if (transition) {
          this._isTransitioning = true;
        }
        this._setEscapeEvent();
        this._setResizeEvent();
        $__default["default"](document).off(EVENT_FOCUSIN);
        $__default["default"](this._element).removeClass(CLASS_NAME_SHOW$4);
        $__default["default"](this._element).off(EVENT_CLICK_DISMISS$1);
        $__default["default"](this._dialog).off(EVENT_MOUSEDOWN_DISMISS);
        if (transition) {
          var transitionDuration = Util.getTransitionDurationFromElement(this._element);
          $__default["default"](this._element).one(Util.TRANSITION_END, function(event2) {
            return _this2._hideModal(event2);
          }).emulateTransitionEnd(transitionDuration);
        } else {
          this._hideModal();
        }
      };
      _proto.dispose = function dispose() {
        [window, this._element, this._dialog].forEach(function(htmlElement) {
          return $__default["default"](htmlElement).off(EVENT_KEY$5);
        });
        $__default["default"](document).off(EVENT_FOCUSIN);
        $__default["default"].removeData(this._element, DATA_KEY$5);
        this._config = null;
        this._element = null;
        this._dialog = null;
        this._backdrop = null;
        this._isShown = null;
        this._isBodyOverflowing = null;
        this._ignoreBackdropClick = null;
        this._isTransitioning = null;
        this._scrollbarWidth = null;
      };
      _proto.handleUpdate = function handleUpdate() {
        this._adjustDialog();
      };
      _proto._getConfig = function _getConfig(config) {
        config = _extends2({}, Default$4, config);
        Util.typeCheckConfig(NAME$5, config, DefaultType$4);
        return config;
      };
      _proto._triggerBackdropTransition = function _triggerBackdropTransition() {
        var _this3 = this;
        var hideEventPrevented = $__default["default"].Event(EVENT_HIDE_PREVENTED);
        $__default["default"](this._element).trigger(hideEventPrevented);
        if (hideEventPrevented.isDefaultPrevented()) {
          return;
        }
        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
        if (!isModalOverflowing) {
          this._element.style.overflowY = "hidden";
        }
        this._element.classList.add(CLASS_NAME_STATIC);
        var modalTransitionDuration = Util.getTransitionDurationFromElement(this._dialog);
        $__default["default"](this._element).off(Util.TRANSITION_END);
        $__default["default"](this._element).one(Util.TRANSITION_END, function() {
          _this3._element.classList.remove(CLASS_NAME_STATIC);
          if (!isModalOverflowing) {
            $__default["default"](_this3._element).one(Util.TRANSITION_END, function() {
              _this3._element.style.overflowY = "";
            }).emulateTransitionEnd(_this3._element, modalTransitionDuration);
          }
        }).emulateTransitionEnd(modalTransitionDuration);
        this._element.focus();
      };
      _proto._showElement = function _showElement(relatedTarget) {
        var _this4 = this;
        var transition = $__default["default"](this._element).hasClass(CLASS_NAME_FADE$4);
        var modalBody = this._dialog ? this._dialog.querySelector(SELECTOR_MODAL_BODY) : null;
        if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
          document.body.appendChild(this._element);
        }
        this._element.style.display = "block";
        this._element.removeAttribute("aria-hidden");
        this._element.setAttribute("aria-modal", true);
        this._element.setAttribute("role", "dialog");
        if ($__default["default"](this._dialog).hasClass(CLASS_NAME_SCROLLABLE) && modalBody) {
          modalBody.scrollTop = 0;
        } else {
          this._element.scrollTop = 0;
        }
        if (transition) {
          Util.reflow(this._element);
        }
        $__default["default"](this._element).addClass(CLASS_NAME_SHOW$4);
        if (this._config.focus) {
          this._enforceFocus();
        }
        var shownEvent = $__default["default"].Event(EVENT_SHOWN$2, {
          relatedTarget
        });
        var transitionComplete = function transitionComplete2() {
          if (_this4._config.focus) {
            _this4._element.focus();
          }
          _this4._isTransitioning = false;
          $__default["default"](_this4._element).trigger(shownEvent);
        };
        if (transition) {
          var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);
          $__default["default"](this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
        } else {
          transitionComplete();
        }
      };
      _proto._enforceFocus = function _enforceFocus() {
        var _this5 = this;
        $__default["default"](document).off(EVENT_FOCUSIN).on(EVENT_FOCUSIN, function(event) {
          if (document !== event.target && _this5._element !== event.target && $__default["default"](_this5._element).has(event.target).length === 0) {
            _this5._element.focus();
          }
        });
      };
      _proto._setEscapeEvent = function _setEscapeEvent() {
        var _this6 = this;
        if (this._isShown) {
          $__default["default"](this._element).on(EVENT_KEYDOWN_DISMISS, function(event) {
            if (_this6._config.keyboard && event.which === ESCAPE_KEYCODE) {
              event.preventDefault();
              _this6.hide();
            } else if (!_this6._config.keyboard && event.which === ESCAPE_KEYCODE) {
              _this6._triggerBackdropTransition();
            }
          });
        } else if (!this._isShown) {
          $__default["default"](this._element).off(EVENT_KEYDOWN_DISMISS);
        }
      };
      _proto._setResizeEvent = function _setResizeEvent() {
        var _this7 = this;
        if (this._isShown) {
          $__default["default"](window).on(EVENT_RESIZE, function(event) {
            return _this7.handleUpdate(event);
          });
        } else {
          $__default["default"](window).off(EVENT_RESIZE);
        }
      };
      _proto._hideModal = function _hideModal() {
        var _this8 = this;
        this._element.style.display = "none";
        this._element.setAttribute("aria-hidden", true);
        this._element.removeAttribute("aria-modal");
        this._element.removeAttribute("role");
        this._isTransitioning = false;
        this._showBackdrop(function() {
          $__default["default"](document.body).removeClass(CLASS_NAME_OPEN);
          _this8._resetAdjustments();
          _this8._resetScrollbar();
          $__default["default"](_this8._element).trigger(EVENT_HIDDEN$2);
        });
      };
      _proto._removeBackdrop = function _removeBackdrop() {
        if (this._backdrop) {
          $__default["default"](this._backdrop).remove();
          this._backdrop = null;
        }
      };
      _proto._showBackdrop = function _showBackdrop(callback) {
        var _this9 = this;
        var animate = $__default["default"](this._element).hasClass(CLASS_NAME_FADE$4) ? CLASS_NAME_FADE$4 : "";
        if (this._isShown && this._config.backdrop) {
          this._backdrop = document.createElement("div");
          this._backdrop.className = CLASS_NAME_BACKDROP;
          if (animate) {
            this._backdrop.classList.add(animate);
          }
          $__default["default"](this._backdrop).appendTo(document.body);
          $__default["default"](this._element).on(EVENT_CLICK_DISMISS$1, function(event) {
            if (_this9._ignoreBackdropClick) {
              _this9._ignoreBackdropClick = false;
              return;
            }
            if (event.target !== event.currentTarget) {
              return;
            }
            if (_this9._config.backdrop === "static") {
              _this9._triggerBackdropTransition();
            } else {
              _this9.hide();
            }
          });
          if (animate) {
            Util.reflow(this._backdrop);
          }
          $__default["default"](this._backdrop).addClass(CLASS_NAME_SHOW$4);
          if (!callback) {
            return;
          }
          if (!animate) {
            callback();
            return;
          }
          var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
          $__default["default"](this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
        } else if (!this._isShown && this._backdrop) {
          $__default["default"](this._backdrop).removeClass(CLASS_NAME_SHOW$4);
          var callbackRemove = function callbackRemove2() {
            _this9._removeBackdrop();
            if (callback) {
              callback();
            }
          };
          if ($__default["default"](this._element).hasClass(CLASS_NAME_FADE$4)) {
            var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
            $__default["default"](this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
          } else {
            callbackRemove();
          }
        } else if (callback) {
          callback();
        }
      };
      _proto._adjustDialog = function _adjustDialog() {
        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
        if (!this._isBodyOverflowing && isModalOverflowing) {
          this._element.style.paddingLeft = this._scrollbarWidth + "px";
        }
        if (this._isBodyOverflowing && !isModalOverflowing) {
          this._element.style.paddingRight = this._scrollbarWidth + "px";
        }
      };
      _proto._resetAdjustments = function _resetAdjustments() {
        this._element.style.paddingLeft = "";
        this._element.style.paddingRight = "";
      };
      _proto._checkScrollbar = function _checkScrollbar() {
        var rect = document.body.getBoundingClientRect();
        this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;
        this._scrollbarWidth = this._getScrollbarWidth();
      };
      _proto._setScrollbar = function _setScrollbar() {
        var _this10 = this;
        if (this._isBodyOverflowing) {
          var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
          var stickyContent = [].slice.call(document.querySelectorAll(SELECTOR_STICKY_CONTENT));
          $__default["default"](fixedContent).each(function(index2, element) {
            var actualPadding2 = element.style.paddingRight;
            var calculatedPadding2 = $__default["default"](element).css("padding-right");
            $__default["default"](element).data("padding-right", actualPadding2).css("padding-right", parseFloat(calculatedPadding2) + _this10._scrollbarWidth + "px");
          });
          $__default["default"](stickyContent).each(function(index2, element) {
            var actualMargin = element.style.marginRight;
            var calculatedMargin = $__default["default"](element).css("margin-right");
            $__default["default"](element).data("margin-right", actualMargin).css("margin-right", parseFloat(calculatedMargin) - _this10._scrollbarWidth + "px");
          });
          var actualPadding = document.body.style.paddingRight;
          var calculatedPadding = $__default["default"](document.body).css("padding-right");
          $__default["default"](document.body).data("padding-right", actualPadding).css("padding-right", parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
        }
        $__default["default"](document.body).addClass(CLASS_NAME_OPEN);
      };
      _proto._resetScrollbar = function _resetScrollbar() {
        var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
        $__default["default"](fixedContent).each(function(index2, element) {
          var padding2 = $__default["default"](element).data("padding-right");
          $__default["default"](element).removeData("padding-right");
          element.style.paddingRight = padding2 ? padding2 : "";
        });
        var elements = [].slice.call(document.querySelectorAll("" + SELECTOR_STICKY_CONTENT));
        $__default["default"](elements).each(function(index2, element) {
          var margin = $__default["default"](element).data("margin-right");
          if (typeof margin !== "undefined") {
            $__default["default"](element).css("margin-right", margin).removeData("margin-right");
          }
        });
        var padding = $__default["default"](document.body).data("padding-right");
        $__default["default"](document.body).removeData("padding-right");
        document.body.style.paddingRight = padding ? padding : "";
      };
      _proto._getScrollbarWidth = function _getScrollbarWidth() {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
      };
      Modal2._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
        return this.each(function() {
          var data = $__default["default"](this).data(DATA_KEY$5);
          var _config = _extends2({}, Default$4, $__default["default"](this).data(), typeof config === "object" && config ? config : {});
          if (!data) {
            data = new Modal2(this, _config);
            $__default["default"](this).data(DATA_KEY$5, data);
          }
          if (typeof config === "string") {
            if (typeof data[config] === "undefined") {
              throw new TypeError('No method named "' + config + '"');
            }
            data[config](relatedTarget);
          } else if (_config.show) {
            data.show(relatedTarget);
          }
        });
      };
      _createClass(Modal2, null, [{
        key: "VERSION",
        get: function get2() {
          return VERSION$5;
        }
      }, {
        key: "Default",
        get: function get2() {
          return Default$4;
        }
      }]);
      return Modal2;
    }();
    $__default["default"](document).on(EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
      var _this11 = this;
      var target;
      var selector2 = Util.getSelectorFromElement(this);
      if (selector2) {
        target = document.querySelector(selector2);
      }
      var config = $__default["default"](target).data(DATA_KEY$5) ? "toggle" : _extends2({}, $__default["default"](target).data(), $__default["default"](this).data());
      if (this.tagName === "A" || this.tagName === "AREA") {
        event.preventDefault();
      }
      var $target = $__default["default"](target).one(EVENT_SHOW$2, function(showEvent) {
        if (showEvent.isDefaultPrevented()) {
          return;
        }
        $target.one(EVENT_HIDDEN$2, function() {
          if ($__default["default"](_this11).is(":visible")) {
            _this11.focus();
          }
        });
      });
      Modal._jQueryInterface.call($__default["default"](target), config, this);
    });
    $__default["default"].fn[NAME$5] = Modal._jQueryInterface;
    $__default["default"].fn[NAME$5].Constructor = Modal;
    $__default["default"].fn[NAME$5].noConflict = function() {
      $__default["default"].fn[NAME$5] = JQUERY_NO_CONFLICT$5;
      return Modal._jQueryInterface;
    };
    var uriAttrs = ["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"];
    var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
    var DefaultWhitelist = {
      "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
      a: ["target", "href", "title", "rel"],
      area: [],
      b: [],
      br: [],
      col: [],
      code: [],
      div: [],
      em: [],
      hr: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      i: [],
      img: ["src", "srcset", "alt", "title", "width", "height"],
      li: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      small: [],
      span: [],
      sub: [],
      sup: [],
      strong: [],
      u: [],
      ul: []
    };
    var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
    var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
    function allowedAttribute(attr2, allowedAttributeList) {
      var attrName = attr2.nodeName.toLowerCase();
      if (allowedAttributeList.indexOf(attrName) !== -1) {
        if (uriAttrs.indexOf(attrName) !== -1) {
          return Boolean(SAFE_URL_PATTERN.test(attr2.nodeValue) || DATA_URL_PATTERN.test(attr2.nodeValue));
        }
        return true;
      }
      var regExp = allowedAttributeList.filter(function(attrRegex) {
        return attrRegex instanceof RegExp;
      });
      for (var i = 0, len = regExp.length; i < len; i++) {
        if (regExp[i].test(attrName)) {
          return true;
        }
      }
      return false;
    }
    function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
      if (unsafeHtml.length === 0) {
        return unsafeHtml;
      }
      if (sanitizeFn && typeof sanitizeFn === "function") {
        return sanitizeFn(unsafeHtml);
      }
      var domParser = new window.DOMParser();
      var createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
      var whitelistKeys = Object.keys(whiteList);
      var elements = [].slice.call(createdDocument.body.querySelectorAll("*"));
      var _loop = function _loop2(i2, len2) {
        var el = elements[i2];
        var elName = el.nodeName.toLowerCase();
        if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {
          el.parentNode.removeChild(el);
          return "continue";
        }
        var attributeList = [].slice.call(el.attributes);
        var whitelistedAttributes = [].concat(whiteList["*"] || [], whiteList[elName] || []);
        attributeList.forEach(function(attr2) {
          if (!allowedAttribute(attr2, whitelistedAttributes)) {
            el.removeAttribute(attr2.nodeName);
          }
        });
      };
      for (var i = 0, len = elements.length; i < len; i++) {
        var _ret = _loop(i);
        if (_ret === "continue")
          continue;
      }
      return createdDocument.body.innerHTML;
    }
    var NAME$4 = "tooltip";
    var VERSION$4 = "4.6.1";
    var DATA_KEY$4 = "bs.tooltip";
    var EVENT_KEY$4 = "." + DATA_KEY$4;
    var JQUERY_NO_CONFLICT$4 = $__default["default"].fn[NAME$4];
    var CLASS_PREFIX$1 = "bs-tooltip";
    var BSCLS_PREFIX_REGEX$1 = new RegExp("(^|\\s)" + CLASS_PREFIX$1 + "\\S+", "g");
    var DISALLOWED_ATTRIBUTES = ["sanitize", "whiteList", "sanitizeFn"];
    var CLASS_NAME_FADE$3 = "fade";
    var CLASS_NAME_SHOW$3 = "show";
    var HOVER_STATE_SHOW = "show";
    var HOVER_STATE_OUT = "out";
    var SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
    var SELECTOR_ARROW = ".arrow";
    var TRIGGER_HOVER = "hover";
    var TRIGGER_FOCUS = "focus";
    var TRIGGER_CLICK = "click";
    var TRIGGER_MANUAL = "manual";
    var AttachmentMap = {
      AUTO: "auto",
      TOP: "top",
      RIGHT: "right",
      BOTTOM: "bottom",
      LEFT: "left"
    };
    var Default$3 = {
      animation: true,
      template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
      trigger: "hover focus",
      title: "",
      delay: 0,
      html: false,
      selector: false,
      placement: "top",
      offset: 0,
      container: false,
      fallbackPlacement: "flip",
      boundary: "scrollParent",
      customClass: "",
      sanitize: true,
      sanitizeFn: null,
      whiteList: DefaultWhitelist,
      popperConfig: null
    };
    var DefaultType$3 = {
      animation: "boolean",
      template: "string",
      title: "(string|element|function)",
      trigger: "string",
      delay: "(number|object)",
      html: "boolean",
      selector: "(string|boolean)",
      placement: "(string|function)",
      offset: "(number|string|function)",
      container: "(string|element|boolean)",
      fallbackPlacement: "(string|array)",
      boundary: "(string|element)",
      customClass: "(string|function)",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      whiteList: "object",
      popperConfig: "(null|object)"
    };
    var Event$1 = {
      HIDE: "hide" + EVENT_KEY$4,
      HIDDEN: "hidden" + EVENT_KEY$4,
      SHOW: "show" + EVENT_KEY$4,
      SHOWN: "shown" + EVENT_KEY$4,
      INSERTED: "inserted" + EVENT_KEY$4,
      CLICK: "click" + EVENT_KEY$4,
      FOCUSIN: "focusin" + EVENT_KEY$4,
      FOCUSOUT: "focusout" + EVENT_KEY$4,
      MOUSEENTER: "mouseenter" + EVENT_KEY$4,
      MOUSELEAVE: "mouseleave" + EVENT_KEY$4
    };
    var Tooltip = /* @__PURE__ */ function() {
      function Tooltip2(element, config) {
        if (typeof Popper__default["default"] === "undefined") {
          throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
        }
        this._isEnabled = true;
        this._timeout = 0;
        this._hoverState = "";
        this._activeTrigger = {};
        this._popper = null;
        this.element = element;
        this.config = this._getConfig(config);
        this.tip = null;
        this._setListeners();
      }
      var _proto = Tooltip2.prototype;
      _proto.enable = function enable() {
        this._isEnabled = true;
      };
      _proto.disable = function disable() {
        this._isEnabled = false;
      };
      _proto.toggleEnabled = function toggleEnabled() {
        this._isEnabled = !this._isEnabled;
      };
      _proto.toggle = function toggle2(event) {
        if (!this._isEnabled) {
          return;
        }
        if (event) {
          var dataKey = this.constructor.DATA_KEY;
          var context = $__default["default"](event.currentTarget).data(dataKey);
          if (!context) {
            context = new this.constructor(event.currentTarget, this._getDelegateConfig());
            $__default["default"](event.currentTarget).data(dataKey, context);
          }
          context._activeTrigger.click = !context._activeTrigger.click;
          if (context._isWithActiveTrigger()) {
            context._enter(null, context);
          } else {
            context._leave(null, context);
          }
        } else {
          if ($__default["default"](this.getTipElement()).hasClass(CLASS_NAME_SHOW$3)) {
            this._leave(null, this);
            return;
          }
          this._enter(null, this);
        }
      };
      _proto.dispose = function dispose() {
        clearTimeout(this._timeout);
        $__default["default"].removeData(this.element, this.constructor.DATA_KEY);
        $__default["default"](this.element).off(this.constructor.EVENT_KEY);
        $__default["default"](this.element).closest(".modal").off("hide.bs.modal", this._hideModalHandler);
        if (this.tip) {
          $__default["default"](this.tip).remove();
        }
        this._isEnabled = null;
        this._timeout = null;
        this._hoverState = null;
        this._activeTrigger = null;
        if (this._popper) {
          this._popper.destroy();
        }
        this._popper = null;
        this.element = null;
        this.config = null;
        this.tip = null;
      };
      _proto.show = function show() {
        var _this = this;
        if ($__default["default"](this.element).css("display") === "none") {
          throw new Error("Please use show on visible elements");
        }
        var showEvent = $__default["default"].Event(this.constructor.Event.SHOW);
        if (this.isWithContent() && this._isEnabled) {
          $__default["default"](this.element).trigger(showEvent);
          var shadowRoot = Util.findShadowRoot(this.element);
          var isInTheDom = $__default["default"].contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);
          if (showEvent.isDefaultPrevented() || !isInTheDom) {
            return;
          }
          var tip = this.getTipElement();
          var tipId = Util.getUID(this.constructor.NAME);
          tip.setAttribute("id", tipId);
          this.element.setAttribute("aria-describedby", tipId);
          this.setContent();
          if (this.config.animation) {
            $__default["default"](tip).addClass(CLASS_NAME_FADE$3);
          }
          var placement = typeof this.config.placement === "function" ? this.config.placement.call(this, tip, this.element) : this.config.placement;
          var attachment = this._getAttachment(placement);
          this.addAttachmentClass(attachment);
          var container = this._getContainer();
          $__default["default"](tip).data(this.constructor.DATA_KEY, this);
          if (!$__default["default"].contains(this.element.ownerDocument.documentElement, this.tip)) {
            $__default["default"](tip).appendTo(container);
          }
          $__default["default"](this.element).trigger(this.constructor.Event.INSERTED);
          this._popper = new Popper__default["default"](this.element, tip, this._getPopperConfig(attachment));
          $__default["default"](tip).addClass(CLASS_NAME_SHOW$3);
          $__default["default"](tip).addClass(this.config.customClass);
          if ("ontouchstart" in document.documentElement) {
            $__default["default"](document.body).children().on("mouseover", null, $__default["default"].noop);
          }
          var complete = function complete2() {
            if (_this.config.animation) {
              _this._fixTransition();
            }
            var prevHoverState = _this._hoverState;
            _this._hoverState = null;
            $__default["default"](_this.element).trigger(_this.constructor.Event.SHOWN);
            if (prevHoverState === HOVER_STATE_OUT) {
              _this._leave(null, _this);
            }
          };
          if ($__default["default"](this.tip).hasClass(CLASS_NAME_FADE$3)) {
            var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
            $__default["default"](this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
          } else {
            complete();
          }
        }
      };
      _proto.hide = function hide2(callback) {
        var _this2 = this;
        var tip = this.getTipElement();
        var hideEvent = $__default["default"].Event(this.constructor.Event.HIDE);
        var complete = function complete2() {
          if (_this2._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {
            tip.parentNode.removeChild(tip);
          }
          _this2._cleanTipClass();
          _this2.element.removeAttribute("aria-describedby");
          $__default["default"](_this2.element).trigger(_this2.constructor.Event.HIDDEN);
          if (_this2._popper !== null) {
            _this2._popper.destroy();
          }
          if (callback) {
            callback();
          }
        };
        $__default["default"](this.element).trigger(hideEvent);
        if (hideEvent.isDefaultPrevented()) {
          return;
        }
        $__default["default"](tip).removeClass(CLASS_NAME_SHOW$3);
        if ("ontouchstart" in document.documentElement) {
          $__default["default"](document.body).children().off("mouseover", null, $__default["default"].noop);
        }
        this._activeTrigger[TRIGGER_CLICK] = false;
        this._activeTrigger[TRIGGER_FOCUS] = false;
        this._activeTrigger[TRIGGER_HOVER] = false;
        if ($__default["default"](this.tip).hasClass(CLASS_NAME_FADE$3)) {
          var transitionDuration = Util.getTransitionDurationFromElement(tip);
          $__default["default"](tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
        this._hoverState = "";
      };
      _proto.update = function update2() {
        if (this._popper !== null) {
          this._popper.scheduleUpdate();
        }
      };
      _proto.isWithContent = function isWithContent() {
        return Boolean(this.getTitle());
      };
      _proto.addAttachmentClass = function addAttachmentClass(attachment) {
        $__default["default"](this.getTipElement()).addClass(CLASS_PREFIX$1 + "-" + attachment);
      };
      _proto.getTipElement = function getTipElement() {
        this.tip = this.tip || $__default["default"](this.config.template)[0];
        return this.tip;
      };
      _proto.setContent = function setContent() {
        var tip = this.getTipElement();
        this.setElementContent($__default["default"](tip.querySelectorAll(SELECTOR_TOOLTIP_INNER)), this.getTitle());
        $__default["default"](tip).removeClass(CLASS_NAME_FADE$3 + " " + CLASS_NAME_SHOW$3);
      };
      _proto.setElementContent = function setElementContent($element, content) {
        if (typeof content === "object" && (content.nodeType || content.jquery)) {
          if (this.config.html) {
            if (!$__default["default"](content).parent().is($element)) {
              $element.empty().append(content);
            }
          } else {
            $element.text($__default["default"](content).text());
          }
          return;
        }
        if (this.config.html) {
          if (this.config.sanitize) {
            content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);
          }
          $element.html(content);
        } else {
          $element.text(content);
        }
      };
      _proto.getTitle = function getTitle() {
        var title = this.element.getAttribute("data-original-title");
        if (!title) {
          title = typeof this.config.title === "function" ? this.config.title.call(this.element) : this.config.title;
        }
        return title;
      };
      _proto._getPopperConfig = function _getPopperConfig(attachment) {
        var _this3 = this;
        var defaultBsConfig = {
          placement: attachment,
          modifiers: {
            offset: this._getOffset(),
            flip: {
              behavior: this.config.fallbackPlacement
            },
            arrow: {
              element: SELECTOR_ARROW
            },
            preventOverflow: {
              boundariesElement: this.config.boundary
            }
          },
          onCreate: function onCreate2(data) {
            if (data.originalPlacement !== data.placement) {
              _this3._handlePopperPlacementChange(data);
            }
          },
          onUpdate: function onUpdate2(data) {
            return _this3._handlePopperPlacementChange(data);
          }
        };
        return _extends2({}, defaultBsConfig, this.config.popperConfig);
      };
      _proto._getOffset = function _getOffset() {
        var _this4 = this;
        var offset2 = {};
        if (typeof this.config.offset === "function") {
          offset2.fn = function(data) {
            data.offsets = _extends2({}, data.offsets, _this4.config.offset(data.offsets, _this4.element));
            return data;
          };
        } else {
          offset2.offset = this.config.offset;
        }
        return offset2;
      };
      _proto._getContainer = function _getContainer() {
        if (this.config.container === false) {
          return document.body;
        }
        if (Util.isElement(this.config.container)) {
          return $__default["default"](this.config.container);
        }
        return $__default["default"](document).find(this.config.container);
      };
      _proto._getAttachment = function _getAttachment(placement) {
        return AttachmentMap[placement.toUpperCase()];
      };
      _proto._setListeners = function _setListeners() {
        var _this5 = this;
        var triggers = this.config.trigger.split(" ");
        triggers.forEach(function(trigger) {
          if (trigger === "click") {
            $__default["default"](_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function(event) {
              return _this5.toggle(event);
            });
          } else if (trigger !== TRIGGER_MANUAL) {
            var eventIn = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;
            var eventOut = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;
            $__default["default"](_this5.element).on(eventIn, _this5.config.selector, function(event) {
              return _this5._enter(event);
            }).on(eventOut, _this5.config.selector, function(event) {
              return _this5._leave(event);
            });
          }
        });
        this._hideModalHandler = function() {
          if (_this5.element) {
            _this5.hide();
          }
        };
        $__default["default"](this.element).closest(".modal").on("hide.bs.modal", this._hideModalHandler);
        if (this.config.selector) {
          this.config = _extends2({}, this.config, {
            trigger: "manual",
            selector: ""
          });
        } else {
          this._fixTitle();
        }
      };
      _proto._fixTitle = function _fixTitle() {
        var titleType = typeof this.element.getAttribute("data-original-title");
        if (this.element.getAttribute("title") || titleType !== "string") {
          this.element.setAttribute("data-original-title", this.element.getAttribute("title") || "");
          this.element.setAttribute("title", "");
        }
      };
      _proto._enter = function _enter(event, context) {
        var dataKey = this.constructor.DATA_KEY;
        context = context || $__default["default"](event.currentTarget).data(dataKey);
        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $__default["default"](event.currentTarget).data(dataKey, context);
        }
        if (event) {
          context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
        }
        if ($__default["default"](context.getTipElement()).hasClass(CLASS_NAME_SHOW$3) || context._hoverState === HOVER_STATE_SHOW) {
          context._hoverState = HOVER_STATE_SHOW;
          return;
        }
        clearTimeout(context._timeout);
        context._hoverState = HOVER_STATE_SHOW;
        if (!context.config.delay || !context.config.delay.show) {
          context.show();
          return;
        }
        context._timeout = setTimeout(function() {
          if (context._hoverState === HOVER_STATE_SHOW) {
            context.show();
          }
        }, context.config.delay.show);
      };
      _proto._leave = function _leave(event, context) {
        var dataKey = this.constructor.DATA_KEY;
        context = context || $__default["default"](event.currentTarget).data(dataKey);
        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $__default["default"](event.currentTarget).data(dataKey, context);
        }
        if (event) {
          context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = false;
        }
        if (context._isWithActiveTrigger()) {
          return;
        }
        clearTimeout(context._timeout);
        context._hoverState = HOVER_STATE_OUT;
        if (!context.config.delay || !context.config.delay.hide) {
          context.hide();
          return;
        }
        context._timeout = setTimeout(function() {
          if (context._hoverState === HOVER_STATE_OUT) {
            context.hide();
          }
        }, context.config.delay.hide);
      };
      _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
        for (var trigger in this._activeTrigger) {
          if (this._activeTrigger[trigger]) {
            return true;
          }
        }
        return false;
      };
      _proto._getConfig = function _getConfig(config) {
        var dataAttributes = $__default["default"](this.element).data();
        Object.keys(dataAttributes).forEach(function(dataAttr) {
          if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {
            delete dataAttributes[dataAttr];
          }
        });
        config = _extends2({}, this.constructor.Default, dataAttributes, typeof config === "object" && config ? config : {});
        if (typeof config.delay === "number") {
          config.delay = {
            show: config.delay,
            hide: config.delay
          };
        }
        if (typeof config.title === "number") {
          config.title = config.title.toString();
        }
        if (typeof config.content === "number") {
          config.content = config.content.toString();
        }
        Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
        if (config.sanitize) {
          config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);
        }
        return config;
      };
      _proto._getDelegateConfig = function _getDelegateConfig() {
        var config = {};
        if (this.config) {
          for (var key in this.config) {
            if (this.constructor.Default[key] !== this.config[key]) {
              config[key] = this.config[key];
            }
          }
        }
        return config;
      };
      _proto._cleanTipClass = function _cleanTipClass() {
        var $tip = $__default["default"](this.getTipElement());
        var tabClass = $tip.attr("class").match(BSCLS_PREFIX_REGEX$1);
        if (tabClass !== null && tabClass.length) {
          $tip.removeClass(tabClass.join(""));
        }
      };
      _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {
        this.tip = popperData.instance.popper;
        this._cleanTipClass();
        this.addAttachmentClass(this._getAttachment(popperData.placement));
      };
      _proto._fixTransition = function _fixTransition() {
        var tip = this.getTipElement();
        var initConfigAnimation = this.config.animation;
        if (tip.getAttribute("x-placement") !== null) {
          return;
        }
        $__default["default"](tip).removeClass(CLASS_NAME_FADE$3);
        this.config.animation = false;
        this.hide();
        this.show();
        this.config.animation = initConfigAnimation;
      };
      Tooltip2._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function() {
          var $element = $__default["default"](this);
          var data = $element.data(DATA_KEY$4);
          var _config = typeof config === "object" && config;
          if (!data && /dispose|hide/.test(config)) {
            return;
          }
          if (!data) {
            data = new Tooltip2(this, _config);
            $element.data(DATA_KEY$4, data);
          }
          if (typeof config === "string") {
            if (typeof data[config] === "undefined") {
              throw new TypeError('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };
      _createClass(Tooltip2, null, [{
        key: "VERSION",
        get: function get2() {
          return VERSION$4;
        }
      }, {
        key: "Default",
        get: function get2() {
          return Default$3;
        }
      }, {
        key: "NAME",
        get: function get2() {
          return NAME$4;
        }
      }, {
        key: "DATA_KEY",
        get: function get2() {
          return DATA_KEY$4;
        }
      }, {
        key: "Event",
        get: function get2() {
          return Event$1;
        }
      }, {
        key: "EVENT_KEY",
        get: function get2() {
          return EVENT_KEY$4;
        }
      }, {
        key: "DefaultType",
        get: function get2() {
          return DefaultType$3;
        }
      }]);
      return Tooltip2;
    }();
    $__default["default"].fn[NAME$4] = Tooltip._jQueryInterface;
    $__default["default"].fn[NAME$4].Constructor = Tooltip;
    $__default["default"].fn[NAME$4].noConflict = function() {
      $__default["default"].fn[NAME$4] = JQUERY_NO_CONFLICT$4;
      return Tooltip._jQueryInterface;
    };
    var NAME$3 = "popover";
    var VERSION$3 = "4.6.1";
    var DATA_KEY$3 = "bs.popover";
    var EVENT_KEY$3 = "." + DATA_KEY$3;
    var JQUERY_NO_CONFLICT$3 = $__default["default"].fn[NAME$3];
    var CLASS_PREFIX = "bs-popover";
    var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", "g");
    var CLASS_NAME_FADE$2 = "fade";
    var CLASS_NAME_SHOW$2 = "show";
    var SELECTOR_TITLE = ".popover-header";
    var SELECTOR_CONTENT = ".popover-body";
    var Default$2 = _extends2({}, Tooltip.Default, {
      placement: "right",
      trigger: "click",
      content: "",
      template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
    });
    var DefaultType$2 = _extends2({}, Tooltip.DefaultType, {
      content: "(string|element|function)"
    });
    var Event = {
      HIDE: "hide" + EVENT_KEY$3,
      HIDDEN: "hidden" + EVENT_KEY$3,
      SHOW: "show" + EVENT_KEY$3,
      SHOWN: "shown" + EVENT_KEY$3,
      INSERTED: "inserted" + EVENT_KEY$3,
      CLICK: "click" + EVENT_KEY$3,
      FOCUSIN: "focusin" + EVENT_KEY$3,
      FOCUSOUT: "focusout" + EVENT_KEY$3,
      MOUSEENTER: "mouseenter" + EVENT_KEY$3,
      MOUSELEAVE: "mouseleave" + EVENT_KEY$3
    };
    var Popover = /* @__PURE__ */ function(_Tooltip) {
      _inheritsLoose(Popover2, _Tooltip);
      function Popover2() {
        return _Tooltip.apply(this, arguments) || this;
      }
      var _proto = Popover2.prototype;
      _proto.isWithContent = function isWithContent() {
        return this.getTitle() || this._getContent();
      };
      _proto.addAttachmentClass = function addAttachmentClass(attachment) {
        $__default["default"](this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
      };
      _proto.getTipElement = function getTipElement() {
        this.tip = this.tip || $__default["default"](this.config.template)[0];
        return this.tip;
      };
      _proto.setContent = function setContent() {
        var $tip = $__default["default"](this.getTipElement());
        this.setElementContent($tip.find(SELECTOR_TITLE), this.getTitle());
        var content = this._getContent();
        if (typeof content === "function") {
          content = content.call(this.element);
        }
        this.setElementContent($tip.find(SELECTOR_CONTENT), content);
        $tip.removeClass(CLASS_NAME_FADE$2 + " " + CLASS_NAME_SHOW$2);
      };
      _proto._getContent = function _getContent() {
        return this.element.getAttribute("data-content") || this.config.content;
      };
      _proto._cleanTipClass = function _cleanTipClass() {
        var $tip = $__default["default"](this.getTipElement());
        var tabClass = $tip.attr("class").match(BSCLS_PREFIX_REGEX);
        if (tabClass !== null && tabClass.length > 0) {
          $tip.removeClass(tabClass.join(""));
        }
      };
      Popover2._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function() {
          var data = $__default["default"](this).data(DATA_KEY$3);
          var _config = typeof config === "object" ? config : null;
          if (!data && /dispose|hide/.test(config)) {
            return;
          }
          if (!data) {
            data = new Popover2(this, _config);
            $__default["default"](this).data(DATA_KEY$3, data);
          }
          if (typeof config === "string") {
            if (typeof data[config] === "undefined") {
              throw new TypeError('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };
      _createClass(Popover2, null, [{
        key: "VERSION",
        get: function get2() {
          return VERSION$3;
        }
      }, {
        key: "Default",
        get: function get2() {
          return Default$2;
        }
      }, {
        key: "NAME",
        get: function get2() {
          return NAME$3;
        }
      }, {
        key: "DATA_KEY",
        get: function get2() {
          return DATA_KEY$3;
        }
      }, {
        key: "Event",
        get: function get2() {
          return Event;
        }
      }, {
        key: "EVENT_KEY",
        get: function get2() {
          return EVENT_KEY$3;
        }
      }, {
        key: "DefaultType",
        get: function get2() {
          return DefaultType$2;
        }
      }]);
      return Popover2;
    }(Tooltip);
    $__default["default"].fn[NAME$3] = Popover._jQueryInterface;
    $__default["default"].fn[NAME$3].Constructor = Popover;
    $__default["default"].fn[NAME$3].noConflict = function() {
      $__default["default"].fn[NAME$3] = JQUERY_NO_CONFLICT$3;
      return Popover._jQueryInterface;
    };
    var NAME$2 = "scrollspy";
    var VERSION$2 = "4.6.1";
    var DATA_KEY$2 = "bs.scrollspy";
    var EVENT_KEY$2 = "." + DATA_KEY$2;
    var DATA_API_KEY$1 = ".data-api";
    var JQUERY_NO_CONFLICT$2 = $__default["default"].fn[NAME$2];
    var CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
    var CLASS_NAME_ACTIVE$1 = "active";
    var EVENT_ACTIVATE = "activate" + EVENT_KEY$2;
    var EVENT_SCROLL = "scroll" + EVENT_KEY$2;
    var EVENT_LOAD_DATA_API = "load" + EVENT_KEY$2 + DATA_API_KEY$1;
    var METHOD_OFFSET = "offset";
    var METHOD_POSITION = "position";
    var SELECTOR_DATA_SPY = '[data-spy="scroll"]';
    var SELECTOR_NAV_LIST_GROUP$1 = ".nav, .list-group";
    var SELECTOR_NAV_LINKS = ".nav-link";
    var SELECTOR_NAV_ITEMS = ".nav-item";
    var SELECTOR_LIST_ITEMS = ".list-group-item";
    var SELECTOR_DROPDOWN$1 = ".dropdown";
    var SELECTOR_DROPDOWN_ITEMS = ".dropdown-item";
    var SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
    var Default$1 = {
      offset: 10,
      method: "auto",
      target: ""
    };
    var DefaultType$1 = {
      offset: "number",
      method: "string",
      target: "(string|element)"
    };
    var ScrollSpy = /* @__PURE__ */ function() {
      function ScrollSpy2(element, config) {
        var _this = this;
        this._element = element;
        this._scrollElement = element.tagName === "BODY" ? window : element;
        this._config = this._getConfig(config);
        this._selector = this._config.target + " " + SELECTOR_NAV_LINKS + "," + (this._config.target + " " + SELECTOR_LIST_ITEMS + ",") + (this._config.target + " " + SELECTOR_DROPDOWN_ITEMS);
        this._offsets = [];
        this._targets = [];
        this._activeTarget = null;
        this._scrollHeight = 0;
        $__default["default"](this._scrollElement).on(EVENT_SCROLL, function(event) {
          return _this._process(event);
        });
        this.refresh();
        this._process();
      }
      var _proto = ScrollSpy2.prototype;
      _proto.refresh = function refresh() {
        var _this2 = this;
        var autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
        var offsetMethod = this._config.method === "auto" ? autoMethod : this._config.method;
        var offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
        this._offsets = [];
        this._targets = [];
        this._scrollHeight = this._getScrollHeight();
        var targets = [].slice.call(document.querySelectorAll(this._selector));
        targets.map(function(element) {
          var target;
          var targetSelector = Util.getSelectorFromElement(element);
          if (targetSelector) {
            target = document.querySelector(targetSelector);
          }
          if (target) {
            var targetBCR = target.getBoundingClientRect();
            if (targetBCR.width || targetBCR.height) {
              return [$__default["default"](target)[offsetMethod]().top + offsetBase, targetSelector];
            }
          }
          return null;
        }).filter(function(item) {
          return item;
        }).sort(function(a, b) {
          return a[0] - b[0];
        }).forEach(function(item) {
          _this2._offsets.push(item[0]);
          _this2._targets.push(item[1]);
        });
      };
      _proto.dispose = function dispose() {
        $__default["default"].removeData(this._element, DATA_KEY$2);
        $__default["default"](this._scrollElement).off(EVENT_KEY$2);
        this._element = null;
        this._scrollElement = null;
        this._config = null;
        this._selector = null;
        this._offsets = null;
        this._targets = null;
        this._activeTarget = null;
        this._scrollHeight = null;
      };
      _proto._getConfig = function _getConfig(config) {
        config = _extends2({}, Default$1, typeof config === "object" && config ? config : {});
        if (typeof config.target !== "string" && Util.isElement(config.target)) {
          var id2 = $__default["default"](config.target).attr("id");
          if (!id2) {
            id2 = Util.getUID(NAME$2);
            $__default["default"](config.target).attr("id", id2);
          }
          config.target = "#" + id2;
        }
        Util.typeCheckConfig(NAME$2, config, DefaultType$1);
        return config;
      };
      _proto._getScrollTop = function _getScrollTop() {
        return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
      };
      _proto._getScrollHeight = function _getScrollHeight() {
        return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
      };
      _proto._getOffsetHeight = function _getOffsetHeight() {
        return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
      };
      _proto._process = function _process() {
        var scrollTop = this._getScrollTop() + this._config.offset;
        var scrollHeight = this._getScrollHeight();
        var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
        if (this._scrollHeight !== scrollHeight) {
          this.refresh();
        }
        if (scrollTop >= maxScroll) {
          var target = this._targets[this._targets.length - 1];
          if (this._activeTarget !== target) {
            this._activate(target);
          }
          return;
        }
        if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
          this._activeTarget = null;
          this._clear();
          return;
        }
        for (var i = this._offsets.length; i--; ) {
          var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === "undefined" || scrollTop < this._offsets[i + 1]);
          if (isActiveTarget) {
            this._activate(this._targets[i]);
          }
        }
      };
      _proto._activate = function _activate(target) {
        this._activeTarget = target;
        this._clear();
        var queries = this._selector.split(",").map(function(selector2) {
          return selector2 + '[data-target="' + target + '"],' + selector2 + '[href="' + target + '"]';
        });
        var $link = $__default["default"]([].slice.call(document.querySelectorAll(queries.join(","))));
        if ($link.hasClass(CLASS_NAME_DROPDOWN_ITEM)) {
          $link.closest(SELECTOR_DROPDOWN$1).find(SELECTOR_DROPDOWN_TOGGLE$1).addClass(CLASS_NAME_ACTIVE$1);
          $link.addClass(CLASS_NAME_ACTIVE$1);
        } else {
          $link.addClass(CLASS_NAME_ACTIVE$1);
          $link.parents(SELECTOR_NAV_LIST_GROUP$1).prev(SELECTOR_NAV_LINKS + ", " + SELECTOR_LIST_ITEMS).addClass(CLASS_NAME_ACTIVE$1);
          $link.parents(SELECTOR_NAV_LIST_GROUP$1).prev(SELECTOR_NAV_ITEMS).children(SELECTOR_NAV_LINKS).addClass(CLASS_NAME_ACTIVE$1);
        }
        $__default["default"](this._scrollElement).trigger(EVENT_ACTIVATE, {
          relatedTarget: target
        });
      };
      _proto._clear = function _clear() {
        [].slice.call(document.querySelectorAll(this._selector)).filter(function(node2) {
          return node2.classList.contains(CLASS_NAME_ACTIVE$1);
        }).forEach(function(node2) {
          return node2.classList.remove(CLASS_NAME_ACTIVE$1);
        });
      };
      ScrollSpy2._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function() {
          var data = $__default["default"](this).data(DATA_KEY$2);
          var _config = typeof config === "object" && config;
          if (!data) {
            data = new ScrollSpy2(this, _config);
            $__default["default"](this).data(DATA_KEY$2, data);
          }
          if (typeof config === "string") {
            if (typeof data[config] === "undefined") {
              throw new TypeError('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };
      _createClass(ScrollSpy2, null, [{
        key: "VERSION",
        get: function get2() {
          return VERSION$2;
        }
      }, {
        key: "Default",
        get: function get2() {
          return Default$1;
        }
      }]);
      return ScrollSpy2;
    }();
    $__default["default"](window).on(EVENT_LOAD_DATA_API, function() {
      var scrollSpys = [].slice.call(document.querySelectorAll(SELECTOR_DATA_SPY));
      var scrollSpysLength = scrollSpys.length;
      for (var i = scrollSpysLength; i--; ) {
        var $spy = $__default["default"](scrollSpys[i]);
        ScrollSpy._jQueryInterface.call($spy, $spy.data());
      }
    });
    $__default["default"].fn[NAME$2] = ScrollSpy._jQueryInterface;
    $__default["default"].fn[NAME$2].Constructor = ScrollSpy;
    $__default["default"].fn[NAME$2].noConflict = function() {
      $__default["default"].fn[NAME$2] = JQUERY_NO_CONFLICT$2;
      return ScrollSpy._jQueryInterface;
    };
    var NAME$1 = "tab";
    var VERSION$1 = "4.6.1";
    var DATA_KEY$1 = "bs.tab";
    var EVENT_KEY$1 = "." + DATA_KEY$1;
    var DATA_API_KEY = ".data-api";
    var JQUERY_NO_CONFLICT$1 = $__default["default"].fn[NAME$1];
    var CLASS_NAME_DROPDOWN_MENU = "dropdown-menu";
    var CLASS_NAME_ACTIVE = "active";
    var CLASS_NAME_DISABLED = "disabled";
    var CLASS_NAME_FADE$1 = "fade";
    var CLASS_NAME_SHOW$1 = "show";
    var EVENT_HIDE$1 = "hide" + EVENT_KEY$1;
    var EVENT_HIDDEN$1 = "hidden" + EVENT_KEY$1;
    var EVENT_SHOW$1 = "show" + EVENT_KEY$1;
    var EVENT_SHOWN$1 = "shown" + EVENT_KEY$1;
    var EVENT_CLICK_DATA_API = "click" + EVENT_KEY$1 + DATA_API_KEY;
    var SELECTOR_DROPDOWN = ".dropdown";
    var SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
    var SELECTOR_ACTIVE = ".active";
    var SELECTOR_ACTIVE_UL = "> li > .active";
    var SELECTOR_DATA_TOGGLE = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]';
    var SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
    var SELECTOR_DROPDOWN_ACTIVE_CHILD = "> .dropdown-menu .active";
    var Tab = /* @__PURE__ */ function() {
      function Tab2(element) {
        this._element = element;
      }
      var _proto = Tab2.prototype;
      _proto.show = function show() {
        var _this = this;
        if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $__default["default"](this._element).hasClass(CLASS_NAME_ACTIVE) || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED)) {
          return;
        }
        var target;
        var previous;
        var listElement = $__default["default"](this._element).closest(SELECTOR_NAV_LIST_GROUP)[0];
        var selector2 = Util.getSelectorFromElement(this._element);
        if (listElement) {
          var itemSelector = listElement.nodeName === "UL" || listElement.nodeName === "OL" ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
          previous = $__default["default"].makeArray($__default["default"](listElement).find(itemSelector));
          previous = previous[previous.length - 1];
        }
        var hideEvent = $__default["default"].Event(EVENT_HIDE$1, {
          relatedTarget: this._element
        });
        var showEvent = $__default["default"].Event(EVENT_SHOW$1, {
          relatedTarget: previous
        });
        if (previous) {
          $__default["default"](previous).trigger(hideEvent);
        }
        $__default["default"](this._element).trigger(showEvent);
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
          return;
        }
        if (selector2) {
          target = document.querySelector(selector2);
        }
        this._activate(this._element, listElement);
        var complete = function complete2() {
          var hiddenEvent = $__default["default"].Event(EVENT_HIDDEN$1, {
            relatedTarget: _this._element
          });
          var shownEvent = $__default["default"].Event(EVENT_SHOWN$1, {
            relatedTarget: previous
          });
          $__default["default"](previous).trigger(hiddenEvent);
          $__default["default"](_this._element).trigger(shownEvent);
        };
        if (target) {
          this._activate(target, target.parentNode, complete);
        } else {
          complete();
        }
      };
      _proto.dispose = function dispose() {
        $__default["default"].removeData(this._element, DATA_KEY$1);
        this._element = null;
      };
      _proto._activate = function _activate(element, container, callback) {
        var _this2 = this;
        var activeElements = container && (container.nodeName === "UL" || container.nodeName === "OL") ? $__default["default"](container).find(SELECTOR_ACTIVE_UL) : $__default["default"](container).children(SELECTOR_ACTIVE);
        var active = activeElements[0];
        var isTransitioning = callback && active && $__default["default"](active).hasClass(CLASS_NAME_FADE$1);
        var complete = function complete2() {
          return _this2._transitionComplete(element, active, callback);
        };
        if (active && isTransitioning) {
          var transitionDuration = Util.getTransitionDurationFromElement(active);
          $__default["default"](active).removeClass(CLASS_NAME_SHOW$1).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      };
      _proto._transitionComplete = function _transitionComplete(element, active, callback) {
        if (active) {
          $__default["default"](active).removeClass(CLASS_NAME_ACTIVE);
          var dropdownChild = $__default["default"](active.parentNode).find(SELECTOR_DROPDOWN_ACTIVE_CHILD)[0];
          if (dropdownChild) {
            $__default["default"](dropdownChild).removeClass(CLASS_NAME_ACTIVE);
          }
          if (active.getAttribute("role") === "tab") {
            active.setAttribute("aria-selected", false);
          }
        }
        $__default["default"](element).addClass(CLASS_NAME_ACTIVE);
        if (element.getAttribute("role") === "tab") {
          element.setAttribute("aria-selected", true);
        }
        Util.reflow(element);
        if (element.classList.contains(CLASS_NAME_FADE$1)) {
          element.classList.add(CLASS_NAME_SHOW$1);
        }
        var parent2 = element.parentNode;
        if (parent2 && parent2.nodeName === "LI") {
          parent2 = parent2.parentNode;
        }
        if (parent2 && $__default["default"](parent2).hasClass(CLASS_NAME_DROPDOWN_MENU)) {
          var dropdownElement = $__default["default"](element).closest(SELECTOR_DROPDOWN)[0];
          if (dropdownElement) {
            var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(SELECTOR_DROPDOWN_TOGGLE));
            $__default["default"](dropdownToggleList).addClass(CLASS_NAME_ACTIVE);
          }
          element.setAttribute("aria-expanded", true);
        }
        if (callback) {
          callback();
        }
      };
      Tab2._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function() {
          var $this = $__default["default"](this);
          var data = $this.data(DATA_KEY$1);
          if (!data) {
            data = new Tab2(this);
            $this.data(DATA_KEY$1, data);
          }
          if (typeof config === "string") {
            if (typeof data[config] === "undefined") {
              throw new TypeError('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      };
      _createClass(Tab2, null, [{
        key: "VERSION",
        get: function get2() {
          return VERSION$1;
        }
      }]);
      return Tab2;
    }();
    $__default["default"](document).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
      event.preventDefault();
      Tab._jQueryInterface.call($__default["default"](this), "show");
    });
    $__default["default"].fn[NAME$1] = Tab._jQueryInterface;
    $__default["default"].fn[NAME$1].Constructor = Tab;
    $__default["default"].fn[NAME$1].noConflict = function() {
      $__default["default"].fn[NAME$1] = JQUERY_NO_CONFLICT$1;
      return Tab._jQueryInterface;
    };
    var NAME = "toast";
    var VERSION2 = "4.6.1";
    var DATA_KEY = "bs.toast";
    var EVENT_KEY = "." + DATA_KEY;
    var JQUERY_NO_CONFLICT = $__default["default"].fn[NAME];
    var CLASS_NAME_FADE = "fade";
    var CLASS_NAME_HIDE = "hide";
    var CLASS_NAME_SHOW = "show";
    var CLASS_NAME_SHOWING = "showing";
    var EVENT_CLICK_DISMISS = "click.dismiss" + EVENT_KEY;
    var EVENT_HIDE = "hide" + EVENT_KEY;
    var EVENT_HIDDEN = "hidden" + EVENT_KEY;
    var EVENT_SHOW = "show" + EVENT_KEY;
    var EVENT_SHOWN = "shown" + EVENT_KEY;
    var SELECTOR_DATA_DISMISS = '[data-dismiss="toast"]';
    var Default = {
      animation: true,
      autohide: true,
      delay: 500
    };
    var DefaultType = {
      animation: "boolean",
      autohide: "boolean",
      delay: "number"
    };
    var Toast = /* @__PURE__ */ function() {
      function Toast2(element, config) {
        this._element = element;
        this._config = this._getConfig(config);
        this._timeout = null;
        this._setListeners();
      }
      var _proto = Toast2.prototype;
      _proto.show = function show() {
        var _this = this;
        var showEvent = $__default["default"].Event(EVENT_SHOW);
        $__default["default"](this._element).trigger(showEvent);
        if (showEvent.isDefaultPrevented()) {
          return;
        }
        this._clearTimeout();
        if (this._config.animation) {
          this._element.classList.add(CLASS_NAME_FADE);
        }
        var complete = function complete2() {
          _this._element.classList.remove(CLASS_NAME_SHOWING);
          _this._element.classList.add(CLASS_NAME_SHOW);
          $__default["default"](_this._element).trigger(EVENT_SHOWN);
          if (_this._config.autohide) {
            _this._timeout = setTimeout(function() {
              _this.hide();
            }, _this._config.delay);
          }
        };
        this._element.classList.remove(CLASS_NAME_HIDE);
        Util.reflow(this._element);
        this._element.classList.add(CLASS_NAME_SHOWING);
        if (this._config.animation) {
          var transitionDuration = Util.getTransitionDurationFromElement(this._element);
          $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      };
      _proto.hide = function hide2() {
        if (!this._element.classList.contains(CLASS_NAME_SHOW)) {
          return;
        }
        var hideEvent = $__default["default"].Event(EVENT_HIDE);
        $__default["default"](this._element).trigger(hideEvent);
        if (hideEvent.isDefaultPrevented()) {
          return;
        }
        this._close();
      };
      _proto.dispose = function dispose() {
        this._clearTimeout();
        if (this._element.classList.contains(CLASS_NAME_SHOW)) {
          this._element.classList.remove(CLASS_NAME_SHOW);
        }
        $__default["default"](this._element).off(EVENT_CLICK_DISMISS);
        $__default["default"].removeData(this._element, DATA_KEY);
        this._element = null;
        this._config = null;
      };
      _proto._getConfig = function _getConfig(config) {
        config = _extends2({}, Default, $__default["default"](this._element).data(), typeof config === "object" && config ? config : {});
        Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
        return config;
      };
      _proto._setListeners = function _setListeners() {
        var _this2 = this;
        $__default["default"](this._element).on(EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, function() {
          return _this2.hide();
        });
      };
      _proto._close = function _close() {
        var _this3 = this;
        var complete = function complete2() {
          _this3._element.classList.add(CLASS_NAME_HIDE);
          $__default["default"](_this3._element).trigger(EVENT_HIDDEN);
        };
        this._element.classList.remove(CLASS_NAME_SHOW);
        if (this._config.animation) {
          var transitionDuration = Util.getTransitionDurationFromElement(this._element);
          $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      };
      _proto._clearTimeout = function _clearTimeout() {
        clearTimeout(this._timeout);
        this._timeout = null;
      };
      Toast2._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function() {
          var $element = $__default["default"](this);
          var data = $element.data(DATA_KEY);
          var _config = typeof config === "object" && config;
          if (!data) {
            data = new Toast2(this, _config);
            $element.data(DATA_KEY, data);
          }
          if (typeof config === "string") {
            if (typeof data[config] === "undefined") {
              throw new TypeError('No method named "' + config + '"');
            }
            data[config](this);
          }
        });
      };
      _createClass(Toast2, null, [{
        key: "VERSION",
        get: function get2() {
          return VERSION2;
        }
      }, {
        key: "DefaultType",
        get: function get2() {
          return DefaultType;
        }
      }, {
        key: "Default",
        get: function get2() {
          return Default;
        }
      }]);
      return Toast2;
    }();
    $__default["default"].fn[NAME] = Toast._jQueryInterface;
    $__default["default"].fn[NAME].Constructor = Toast;
    $__default["default"].fn[NAME].noConflict = function() {
      $__default["default"].fn[NAME] = JQUERY_NO_CONFLICT;
      return Toast._jQueryInterface;
    };
    exports2.Alert = Alert;
    exports2.Button = Button;
    exports2.Carousel = Carousel;
    exports2.Collapse = Collapse;
    exports2.Dropdown = Dropdown;
    exports2.Modal = Modal;
    exports2.Popover = Popover;
    exports2.Scrollspy = ScrollSpy;
    exports2.Tab = Tab;
    exports2.Toast = Toast;
    exports2.Tooltip = Tooltip;
    exports2.Util = Util;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
})(bootstrap$1, bootstrap$1.exports);
class SessionStateStore {
  static loadState(id2) {
    try {
      const serializedState = sessionStorage.getItem(id2);
      return JSON.parse(serializedState);
    } catch (err) {
      return void 0;
    }
  }
  static saveState(id2, state) {
    try {
      const serializedState = JSON.stringify(state);
      sessionStorage.setItem(id2, serializedState);
    } catch (err) {
    }
  }
}
class DataUtil {
}
__publicField(DataUtil, "fetchData", async (url) => {
  return fetch(url).then((response) => response.text());
});
var handlebars = { exports: {} };
var handlebars_runtime = { exports: {} };
var base$1 = {};
var utils$g = {};
utils$g.__esModule = true;
utils$g.extend = extend$2;
utils$g.indexOf = indexOf$3;
utils$g.escapeExpression = escapeExpression;
utils$g.isEmpty = isEmpty$3;
utils$g.createFrame = createFrame;
utils$g.blockParams = blockParams;
utils$g.appendContextPath = appendContextPath;
var escape$2 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
var badChars = /[&<>"'`=]/g, possible = /[&<>"'`=]/;
function escapeChar(chr) {
  return escape$2[chr];
}
function extend$2(obj) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }
  return obj;
}
var toString$4 = Object.prototype.toString;
utils$g.toString = toString$4;
var isFunction$7 = function isFunction2(value) {
  return typeof value === "function";
};
if (isFunction$7(/x/)) {
  utils$g.isFunction = isFunction$7 = function(value) {
    return typeof value === "function" && toString$4.call(value) === "[object Function]";
  };
}
utils$g.isFunction = isFunction$7;
var isArray$o = Array.isArray || function(value) {
  return value && typeof value === "object" ? toString$4.call(value) === "[object Array]" : false;
};
utils$g.isArray = isArray$o;
function indexOf$3(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}
function escapeExpression(string) {
  if (typeof string !== "string") {
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return "";
    } else if (!string) {
      return string + "";
    }
    string = "" + string;
  }
  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}
function isEmpty$3(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray$o(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}
function createFrame(object) {
  var frame = extend$2({}, object);
  frame._parent = object;
  return frame;
}
function blockParams(params, ids2) {
  params.path = ids2;
  return params;
}
function appendContextPath(contextPath, id2) {
  return (contextPath ? contextPath + "." : "") + id2;
}
var exception = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  var errorProps2 = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
  function Exception(message2, node2) {
    var loc = node2 && node2.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
    if (loc) {
      line = loc.start.line;
      endLineNumber = loc.end.line;
      column = loc.start.column;
      endColumn = loc.end.column;
      message2 += " - " + line + ":" + column;
    }
    var tmp = Error.prototype.constructor.call(this, message2);
    for (var idx = 0; idx < errorProps2.length; idx++) {
      this[errorProps2[idx]] = tmp[errorProps2[idx]];
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, Exception);
    }
    try {
      if (loc) {
        this.lineNumber = line;
        this.endLineNumber = endLineNumber;
        if (Object.defineProperty) {
          Object.defineProperty(this, "column", {
            value: column,
            enumerable: true
          });
          Object.defineProperty(this, "endColumn", {
            value: endColumn,
            enumerable: true
          });
        } else {
          this.column = column;
          this.endColumn = endColumn;
        }
      }
    } catch (nop) {
    }
  }
  Exception.prototype = new Error();
  exports["default"] = Exception;
  module.exports = exports["default"];
})(exception, exception.exports);
var helpers$1 = {};
var blockHelperMissing = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  var _utils2 = utils$g;
  exports["default"] = function(instance) {
    instance.registerHelper("blockHelperMissing", function(context, options) {
      var inverse = options.inverse, fn = options.fn;
      if (context === true) {
        return fn(this);
      } else if (context === false || context == null) {
        return inverse(this);
      } else if (_utils2.isArray(context)) {
        if (context.length > 0) {
          if (options.ids) {
            options.ids = [options.name];
          }
          return instance.helpers.each(context, options);
        } else {
          return inverse(this);
        }
      } else {
        if (options.data && options.ids) {
          var data = _utils2.createFrame(options.data);
          data.contextPath = _utils2.appendContextPath(options.data.contextPath, options.name);
          options = { data };
        }
        return fn(context, options);
      }
    });
  };
  module.exports = exports["default"];
})(blockHelperMissing, blockHelperMissing.exports);
var each$1 = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _utils2 = utils$g;
  var _exception3 = exception.exports;
  var _exception22 = _interopRequireDefault2(_exception3);
  exports["default"] = function(instance) {
    instance.registerHelper("each", function(context, options) {
      if (!options) {
        throw new _exception22["default"]("Must pass iterator to #each");
      }
      var fn = options.fn, inverse = options.inverse, i = 0, ret = "", data = void 0, contextPath = void 0;
      if (options.data && options.ids) {
        contextPath = _utils2.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
      }
      if (_utils2.isFunction(context)) {
        context = context.call(this);
      }
      if (options.data) {
        data = _utils2.createFrame(options.data);
      }
      function execIteration(field, index2, last2) {
        if (data) {
          data.key = field;
          data.index = index2;
          data.first = index2 === 0;
          data.last = !!last2;
          if (contextPath) {
            data.contextPath = contextPath + field;
          }
        }
        ret = ret + fn(context[field], {
          data,
          blockParams: _utils2.blockParams([context[field], field], [contextPath + field, null])
        });
      }
      if (context && typeof context === "object") {
        if (_utils2.isArray(context)) {
          for (var j = context.length; i < j; i++) {
            if (i in context) {
              execIteration(i, i, i === context.length - 1);
            }
          }
        } else if (commonjsGlobal.Symbol && context[commonjsGlobal.Symbol.iterator]) {
          var newContext = [];
          var iterator = context[commonjsGlobal.Symbol.iterator]();
          for (var it = iterator.next(); !it.done; it = iterator.next()) {
            newContext.push(it.value);
          }
          context = newContext;
          for (var j = context.length; i < j; i++) {
            execIteration(i, i, i === context.length - 1);
          }
        } else {
          (function() {
            var priorKey = void 0;
            Object.keys(context).forEach(function(key) {
              if (priorKey !== void 0) {
                execIteration(priorKey, i - 1);
              }
              priorKey = key;
              i++;
            });
            if (priorKey !== void 0) {
              execIteration(priorKey, i - 1, true);
            }
          })();
        }
      }
      if (i === 0) {
        ret = inverse(this);
      }
      return ret;
    });
  };
  module.exports = exports["default"];
})(each$1, each$1.exports);
var helperMissing = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _exception3 = exception.exports;
  var _exception22 = _interopRequireDefault2(_exception3);
  exports["default"] = function(instance) {
    instance.registerHelper("helperMissing", function() {
      if (arguments.length === 1) {
        return void 0;
      } else {
        throw new _exception22["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
      }
    });
  };
  module.exports = exports["default"];
})(helperMissing, helperMissing.exports);
var _if = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _utils2 = utils$g;
  var _exception3 = exception.exports;
  var _exception22 = _interopRequireDefault2(_exception3);
  exports["default"] = function(instance) {
    instance.registerHelper("if", function(conditional, options) {
      if (arguments.length != 2) {
        throw new _exception22["default"]("#if requires exactly one argument");
      }
      if (_utils2.isFunction(conditional)) {
        conditional = conditional.call(this);
      }
      if (!options.hash.includeZero && !conditional || _utils2.isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });
    instance.registerHelper("unless", function(conditional, options) {
      if (arguments.length != 2) {
        throw new _exception22["default"]("#unless requires exactly one argument");
      }
      return instance.helpers["if"].call(this, conditional, {
        fn: options.inverse,
        inverse: options.fn,
        hash: options.hash
      });
    });
  };
  module.exports = exports["default"];
})(_if, _if.exports);
var log$1 = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = function(instance) {
    instance.registerHelper("log", function() {
      var args = [void 0], options = arguments[arguments.length - 1];
      for (var i = 0; i < arguments.length - 1; i++) {
        args.push(arguments[i]);
      }
      var level = 1;
      if (options.hash.level != null) {
        level = options.hash.level;
      } else if (options.data && options.data.level != null) {
        level = options.data.level;
      }
      args[0] = level;
      instance.log.apply(instance, args);
    });
  };
  module.exports = exports["default"];
})(log$1, log$1.exports);
var lookup = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = function(instance) {
    instance.registerHelper("lookup", function(obj, field, options) {
      if (!obj) {
        return obj;
      }
      return options.lookupProperty(obj, field);
    });
  };
  module.exports = exports["default"];
})(lookup, lookup.exports);
var _with = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _utils2 = utils$g;
  var _exception3 = exception.exports;
  var _exception22 = _interopRequireDefault2(_exception3);
  exports["default"] = function(instance) {
    instance.registerHelper("with", function(context, options) {
      if (arguments.length != 2) {
        throw new _exception22["default"]("#with requires exactly one argument");
      }
      if (_utils2.isFunction(context)) {
        context = context.call(this);
      }
      var fn = options.fn;
      if (!_utils2.isEmpty(context)) {
        var data = options.data;
        if (options.data && options.ids) {
          data = _utils2.createFrame(options.data);
          data.contextPath = _utils2.appendContextPath(options.data.contextPath, options.ids[0]);
        }
        return fn(context, {
          data,
          blockParams: _utils2.blockParams([context], [data && data.contextPath])
        });
      } else {
        return options.inverse(this);
      }
    });
  };
  module.exports = exports["default"];
})(_with, _with.exports);
helpers$1.__esModule = true;
helpers$1.registerDefaultHelpers = registerDefaultHelpers;
helpers$1.moveHelperToHooks = moveHelperToHooks;
function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
var _helpersBlockHelperMissing = blockHelperMissing.exports;
var _helpersBlockHelperMissing2 = _interopRequireDefault$6(_helpersBlockHelperMissing);
var _helpersEach = each$1.exports;
var _helpersEach2 = _interopRequireDefault$6(_helpersEach);
var _helpersHelperMissing = helperMissing.exports;
var _helpersHelperMissing2 = _interopRequireDefault$6(_helpersHelperMissing);
var _helpersIf = _if.exports;
var _helpersIf2 = _interopRequireDefault$6(_helpersIf);
var _helpersLog = log$1.exports;
var _helpersLog2 = _interopRequireDefault$6(_helpersLog);
var _helpersLookup = lookup.exports;
var _helpersLookup2 = _interopRequireDefault$6(_helpersLookup);
var _helpersWith = _with.exports;
var _helpersWith2 = _interopRequireDefault$6(_helpersWith);
function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2["default"](instance);
  _helpersEach2["default"](instance);
  _helpersHelperMissing2["default"](instance);
  _helpersIf2["default"](instance);
  _helpersLog2["default"](instance);
  _helpersLookup2["default"](instance);
  _helpersWith2["default"](instance);
}
function moveHelperToHooks(instance, helperName, keepHelper) {
  if (instance.helpers[helperName]) {
    instance.hooks[helperName] = instance.helpers[helperName];
    if (!keepHelper) {
      delete instance.helpers[helperName];
    }
  }
}
var decorators = {};
var inline = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  var _utils2 = utils$g;
  exports["default"] = function(instance) {
    instance.registerDecorator("inline", function(fn, props, container, options) {
      var ret = fn;
      if (!props.partials) {
        props.partials = {};
        ret = function(context, options2) {
          var original = container.partials;
          container.partials = _utils2.extend({}, original, props.partials);
          var ret2 = fn(context, options2);
          container.partials = original;
          return ret2;
        };
      }
      props.partials[options.args[0]] = options.fn;
      return ret;
    });
  };
  module.exports = exports["default"];
})(inline, inline.exports);
decorators.__esModule = true;
decorators.registerDefaultDecorators = registerDefaultDecorators;
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
var _decoratorsInline = inline.exports;
var _decoratorsInline2 = _interopRequireDefault$5(_decoratorsInline);
function registerDefaultDecorators(instance) {
  _decoratorsInline2["default"](instance);
}
var logger$1 = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  var _utils2 = utils$g;
  var logger2 = {
    methodMap: ["debug", "info", "warn", "error"],
    level: "info",
    lookupLevel: function lookupLevel(level) {
      if (typeof level === "string") {
        var levelMap = _utils2.indexOf(logger2.methodMap, level.toLowerCase());
        if (levelMap >= 0) {
          level = levelMap;
        } else {
          level = parseInt(level, 10);
        }
      }
      return level;
    },
    log: function log2(level) {
      level = logger2.lookupLevel(level);
      if (typeof console !== "undefined" && logger2.lookupLevel(logger2.level) <= level) {
        var method = logger2.methodMap[level];
        if (!console[method]) {
          method = "log";
        }
        for (var _len = arguments.length, message2 = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          message2[_key - 1] = arguments[_key];
        }
        console[method].apply(console, message2);
      }
    }
  };
  exports["default"] = logger2;
  module.exports = exports["default"];
})(logger$1, logger$1.exports);
var protoAccess = {};
var createNewLookupObject$1 = {};
createNewLookupObject$1.__esModule = true;
createNewLookupObject$1.createNewLookupObject = createNewLookupObject;
var _utils$4 = utils$g;
function createNewLookupObject() {
  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  return _utils$4.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(sources));
}
protoAccess.__esModule = true;
protoAccess.createProtoAccessControl = createProtoAccessControl;
protoAccess.resultIsAllowed = resultIsAllowed;
protoAccess.resetLoggedProperties = resetLoggedProperties;
function _interopRequireWildcard$2(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          newObj[key] = obj[key];
      }
    }
    newObj["default"] = obj;
    return newObj;
  }
}
var _createNewLookupObject = createNewLookupObject$1;
var _logger$1 = logger$1.exports;
var logger = _interopRequireWildcard$2(_logger$1);
var loggedProperties = /* @__PURE__ */ Object.create(null);
function createProtoAccessControl(runtimeOptions) {
  var defaultMethodWhiteList = /* @__PURE__ */ Object.create(null);
  defaultMethodWhiteList["constructor"] = false;
  defaultMethodWhiteList["__defineGetter__"] = false;
  defaultMethodWhiteList["__defineSetter__"] = false;
  defaultMethodWhiteList["__lookupGetter__"] = false;
  var defaultPropertyWhiteList = /* @__PURE__ */ Object.create(null);
  defaultPropertyWhiteList["__proto__"] = false;
  return {
    properties: {
      whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
      defaultValue: runtimeOptions.allowProtoPropertiesByDefault
    },
    methods: {
      whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
      defaultValue: runtimeOptions.allowProtoMethodsByDefault
    }
  };
}
function resultIsAllowed(result, protoAccessControl, propertyName) {
  if (typeof result === "function") {
    return checkWhiteList(protoAccessControl.methods, propertyName);
  } else {
    return checkWhiteList(protoAccessControl.properties, propertyName);
  }
}
function checkWhiteList(protoAccessControlForType, propertyName) {
  if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
    return protoAccessControlForType.whitelist[propertyName] === true;
  }
  if (protoAccessControlForType.defaultValue !== void 0) {
    return protoAccessControlForType.defaultValue;
  }
  logUnexpecedPropertyAccessOnce(propertyName);
  return false;
}
function logUnexpecedPropertyAccessOnce(propertyName) {
  if (loggedProperties[propertyName] !== true) {
    loggedProperties[propertyName] = true;
    logger.log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
  }
}
function resetLoggedProperties() {
  Object.keys(loggedProperties).forEach(function(propertyName) {
    delete loggedProperties[propertyName];
  });
}
base$1.__esModule = true;
base$1.HandlebarsEnvironment = HandlebarsEnvironment;
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
var _utils$3 = utils$g;
var _exception$3 = exception.exports;
var _exception2$3 = _interopRequireDefault$4(_exception$3);
var _helpers$2 = helpers$1;
var _decorators = decorators;
var _logger = logger$1.exports;
var _logger2 = _interopRequireDefault$4(_logger);
var _internalProtoAccess$1 = protoAccess;
var VERSION = "4.7.7";
base$1.VERSION = VERSION;
var COMPILER_REVISION = 8;
base$1.COMPILER_REVISION = COMPILER_REVISION;
var LAST_COMPATIBLE_COMPILER_REVISION = 7;
base$1.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
var REVISION_CHANGES = {
  1: "<= 1.0.rc.2",
  2: "== 1.0.0-rc.3",
  3: "== 1.0.0-rc.4",
  4: "== 1.x.x",
  5: "== 2.0.0-alpha.x",
  6: ">= 2.0.0-beta.1",
  7: ">= 4.0.0 <4.3.0",
  8: ">= 4.3.0"
};
base$1.REVISION_CHANGES = REVISION_CHANGES;
var objectType = "[object Object]";
function HandlebarsEnvironment(helpers2, partials, decorators2) {
  this.helpers = helpers2 || {};
  this.partials = partials || {};
  this.decorators = decorators2 || {};
  _helpers$2.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}
HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,
  logger: _logger2["default"],
  log: _logger2["default"].log,
  registerHelper: function registerHelper(name2, fn) {
    if (_utils$3.toString.call(name2) === objectType) {
      if (fn) {
        throw new _exception2$3["default"]("Arg not supported with multiple helpers");
      }
      _utils$3.extend(this.helpers, name2);
    } else {
      this.helpers[name2] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name2) {
    delete this.helpers[name2];
  },
  registerPartial: function registerPartial(name2, partial) {
    if (_utils$3.toString.call(name2) === objectType) {
      _utils$3.extend(this.partials, name2);
    } else {
      if (typeof partial === "undefined") {
        throw new _exception2$3["default"]('Attempting to register a partial called "' + name2 + '" as undefined');
      }
      this.partials[name2] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name2) {
    delete this.partials[name2];
  },
  registerDecorator: function registerDecorator(name2, fn) {
    if (_utils$3.toString.call(name2) === objectType) {
      if (fn) {
        throw new _exception2$3["default"]("Arg not supported with multiple decorators");
      }
      _utils$3.extend(this.decorators, name2);
    } else {
      this.decorators[name2] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name2) {
    delete this.decorators[name2];
  },
  resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
    _internalProtoAccess$1.resetLoggedProperties();
  }
};
var log = _logger2["default"].log;
base$1.log = log;
base$1.createFrame = _utils$3.createFrame;
base$1.logger = _logger2["default"];
var safeString = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  function SafeString(string) {
    this.string = string;
  }
  SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
    return "" + this.string;
  };
  exports["default"] = SafeString;
  module.exports = exports["default"];
})(safeString, safeString.exports);
var runtime = {};
var wrapHelper$1 = {};
wrapHelper$1.__esModule = true;
wrapHelper$1.wrapHelper = wrapHelper;
function wrapHelper(helper, transformOptionsFn) {
  if (typeof helper !== "function") {
    return helper;
  }
  var wrapper = function wrapper2() {
    var options = arguments[arguments.length - 1];
    arguments[arguments.length - 1] = transformOptionsFn(options);
    return helper.apply(this, arguments);
  };
  return wrapper;
}
runtime.__esModule = true;
runtime.checkRevision = checkRevision;
runtime.template = template;
runtime.wrapProgram = wrapProgram;
runtime.resolvePartial = resolvePartial;
runtime.invokePartial = invokePartial;
runtime.noop = noop$5;
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
function _interopRequireWildcard$1(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          newObj[key] = obj[key];
      }
    }
    newObj["default"] = obj;
    return newObj;
  }
}
var _utils$2 = utils$g;
var Utils$1 = _interopRequireWildcard$1(_utils$2);
var _exception$2 = exception.exports;
var _exception2$2 = _interopRequireDefault$3(_exception$2);
var _base = base$1;
var _helpers$1 = helpers$1;
var _internalWrapHelper = wrapHelper$1;
var _internalProtoAccess = protoAccess;
function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
  if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
    return;
  }
  if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
    var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
    throw new _exception2$2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
  } else {
    throw new _exception2$2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
  }
}
function template(templateSpec, env) {
  if (!env) {
    throw new _exception2$2["default"]("No environment passed to template");
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2$2["default"]("Unknown template object: " + typeof templateSpec);
  }
  templateSpec.main.decorator = templateSpec.main_d;
  env.VM.checkRevision(templateSpec.compiler);
  var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils$1.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }
    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var extendedOptions = Utils$1.extend({}, options, {
      hooks: this.hooks,
      protoAccessControl: this.protoAccessControl
    });
    var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);
    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, extendedOptions);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split("\n");
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }
          lines[i] = options.indent + lines[i];
        }
        result = lines.join("\n");
      }
      return result;
    } else {
      throw new _exception2$2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
    }
  }
  var container = {
    strict: function strict(obj, name2, loc) {
      if (!obj || !(name2 in obj)) {
        throw new _exception2$2["default"]('"' + name2 + '" not defined in ' + obj, {
          loc
        });
      }
      return container.lookupProperty(obj, name2);
    },
    lookupProperty: function lookupProperty(parent2, propertyName) {
      var result = parent2[propertyName];
      if (result == null) {
        return result;
      }
      if (Object.prototype.hasOwnProperty.call(parent2, propertyName)) {
        return result;
      }
      if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
        return result;
      }
      return void 0;
    },
    lookup: function lookup2(depths, name2) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        var result = depths[i] && container.lookupProperty(depths[i], name2);
        if (result != null) {
          return depths[i][name2];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === "function" ? current.call(context) : current;
    },
    escapeExpression: Utils$1.escapeExpression,
    invokePartial: invokePartialWrapper,
    fn: function fn(i) {
      var ret2 = templateSpec[i];
      ret2.decorator = templateSpec[i + "_d"];
      return ret2;
    },
    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams2, depths) {
      var programWrapper = this.programs[i], fn = this.fn(i);
      if (data || depths || blockParams2 || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams2, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },
    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    mergeIfNeeded: function mergeIfNeeded(param, common) {
      var obj = param || common;
      if (param && common && param !== common) {
        obj = Utils$1.extend({}, common, param);
      }
      return obj;
    },
    nullContext: Object.seal({}),
    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };
  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
    var data = options.data;
    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = void 0, blockParams2 = templateSpec.useBlockParams ? [] : void 0;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }
    function main(context2) {
      return "" + templateSpec.main(container, context2, container.helpers, container.partials, data, blockParams2, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams2);
    return main(context, options);
  }
  ret.isTop = true;
  ret._setup = function(options) {
    if (!options.partial) {
      var mergedHelpers = Utils$1.extend({}, env.helpers, options.helpers);
      wrapHelpersToPassLookupProperty(mergedHelpers, container);
      container.helpers = mergedHelpers;
      if (templateSpec.usePartial) {
        container.partials = container.mergeIfNeeded(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = Utils$1.extend({}, env.decorators, options.decorators);
      }
      container.hooks = {};
      container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
      var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
      _helpers$1.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
      _helpers$1.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
    } else {
      container.protoAccessControl = options.protoAccessControl;
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
      container.hooks = options.hooks;
    }
  };
  ret._child = function(i, data, blockParams2, depths) {
    if (templateSpec.useBlockParams && !blockParams2) {
      throw new _exception2$2["default"]("must pass block params");
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2$2["default"]("must pass parent depths");
    }
    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams2, depths);
  };
  return ret;
}
function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams2, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
    var currentDepths = depths;
    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }
    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams2 && [options.blockParams].concat(blockParams2), currentDepths);
  }
  prog = executeDecorators(fn, prog, container, depths, data, blockParams2);
  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}
function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === "@partial-block") {
      partial = options.data["partial-block"];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}
function invokePartial(partial, context, options) {
  var currentPartialBlock = options.data && options.data["partial-block"];
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }
  var partialBlock = void 0;
  if (options.fn && options.fn !== noop$5) {
    (function() {
      options.data = _base.createFrame(options.data);
      var fn = options.fn;
      partialBlock = options.data["partial-block"] = function partialBlockWrapper(context2) {
        var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        options2.data = _base.createFrame(options2.data);
        options2.data["partial-block"] = currentPartialBlock;
        return fn(context2, options2);
      };
      if (fn.partials) {
        options.partials = Utils$1.extend({}, options.partials, fn.partials);
      }
    })();
  }
  if (partial === void 0 && partialBlock) {
    partial = partialBlock;
  }
  if (partial === void 0) {
    throw new _exception2$2["default"]("The partial " + options.name + " could not be found");
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}
function noop$5() {
  return "";
}
function initData(context, data) {
  if (!data || !("root" in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}
function executeDecorators(fn, prog, container, depths, data, blockParams2) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams2, depths);
    Utils$1.extend(prog, props);
  }
  return prog;
}
function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
  Object.keys(mergedHelpers).forEach(function(helperName) {
    var helper = mergedHelpers[helperName];
    mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
  });
}
function passLookupPropertyOption(helper, container) {
  var lookupProperty = container.lookupProperty;
  return _internalWrapHelper.wrapHelper(helper, function(options) {
    return Utils$1.extend({ lookupProperty }, options);
  });
}
var noConflict = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = function(Handlebars) {
    var root2 = typeof commonjsGlobal !== "undefined" ? commonjsGlobal : window, $Handlebars = root2.Handlebars;
    Handlebars.noConflict = function() {
      if (root2.Handlebars === Handlebars) {
        root2.Handlebars = $Handlebars;
      }
      return Handlebars;
    };
  };
  module.exports = exports["default"];
})(noConflict, noConflict.exports);
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  function _interopRequireWildcard2(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj["default"] = obj;
      return newObj;
    }
  }
  var _handlebarsBase = base$1;
  var base2 = _interopRequireWildcard2(_handlebarsBase);
  var _handlebarsSafeString = safeString.exports;
  var _handlebarsSafeString2 = _interopRequireDefault2(_handlebarsSafeString);
  var _handlebarsException = exception.exports;
  var _handlebarsException2 = _interopRequireDefault2(_handlebarsException);
  var _handlebarsUtils = utils$g;
  var Utils2 = _interopRequireWildcard2(_handlebarsUtils);
  var _handlebarsRuntime = runtime;
  var runtime$1 = _interopRequireWildcard2(_handlebarsRuntime);
  var _handlebarsNoConflict = noConflict.exports;
  var _handlebarsNoConflict2 = _interopRequireDefault2(_handlebarsNoConflict);
  function create2() {
    var hb = new base2.HandlebarsEnvironment();
    Utils2.extend(hb, base2);
    hb.SafeString = _handlebarsSafeString2["default"];
    hb.Exception = _handlebarsException2["default"];
    hb.Utils = Utils2;
    hb.escapeExpression = Utils2.escapeExpression;
    hb.VM = runtime$1;
    hb.template = function(spec) {
      return runtime$1.template(spec, hb);
    };
    return hb;
  }
  var inst = create2();
  inst.create = create2;
  _handlebarsNoConflict2["default"](inst);
  inst["default"] = inst;
  exports["default"] = inst;
  module.exports = exports["default"];
})(handlebars_runtime, handlebars_runtime.exports);
var ast = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  var AST = {
    helpers: {
      helperExpression: function helperExpression(node2) {
        return node2.type === "SubExpression" || (node2.type === "MustacheStatement" || node2.type === "BlockStatement") && !!(node2.params && node2.params.length || node2.hash);
      },
      scopedId: function scopedId(path) {
        return /^\.|this\b/.test(path.original);
      },
      simpleId: function simpleId(path) {
        return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
      }
    }
  };
  exports["default"] = AST;
  module.exports = exports["default"];
})(ast, ast.exports);
var base = {};
var parser = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  var handlebars2 = function() {
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
      productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy2, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 1:
            return $$[$0 - 1];
          case 2:
            this.$ = yy2.prepareProgram($$[$0]);
            break;
          case 3:
            this.$ = $$[$0];
            break;
          case 4:
            this.$ = $$[$0];
            break;
          case 5:
            this.$ = $$[$0];
            break;
          case 6:
            this.$ = $$[$0];
            break;
          case 7:
            this.$ = $$[$0];
            break;
          case 8:
            this.$ = $$[$0];
            break;
          case 9:
            this.$ = {
              type: "CommentStatement",
              value: yy2.stripComment($$[$0]),
              strip: yy2.stripFlags($$[$0], $$[$0]),
              loc: yy2.locInfo(this._$)
            };
            break;
          case 10:
            this.$ = {
              type: "ContentStatement",
              original: $$[$0],
              value: $$[$0],
              loc: yy2.locInfo(this._$)
            };
            break;
          case 11:
            this.$ = yy2.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
            break;
          case 12:
            this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
            break;
          case 13:
            this.$ = yy2.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
            break;
          case 14:
            this.$ = yy2.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
            break;
          case 15:
            this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy2.stripFlags($$[$0 - 5], $$[$0]) };
            break;
          case 16:
            this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy2.stripFlags($$[$0 - 5], $$[$0]) };
            break;
          case 17:
            this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy2.stripFlags($$[$0 - 5], $$[$0]) };
            break;
          case 18:
            this.$ = { strip: yy2.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
            break;
          case 19:
            var inverse = yy2.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$), program = yy2.prepareProgram([inverse], $$[$0 - 1].loc);
            program.chained = true;
            this.$ = { strip: $$[$0 - 2].strip, program, chain: true };
            break;
          case 20:
            this.$ = $$[$0];
            break;
          case 21:
            this.$ = { path: $$[$0 - 1], strip: yy2.stripFlags($$[$0 - 2], $$[$0]) };
            break;
          case 22:
            this.$ = yy2.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy2.stripFlags($$[$0 - 4], $$[$0]), this._$);
            break;
          case 23:
            this.$ = yy2.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy2.stripFlags($$[$0 - 4], $$[$0]), this._$);
            break;
          case 24:
            this.$ = {
              type: "PartialStatement",
              name: $$[$0 - 3],
              params: $$[$0 - 2],
              hash: $$[$0 - 1],
              indent: "",
              strip: yy2.stripFlags($$[$0 - 4], $$[$0]),
              loc: yy2.locInfo(this._$)
            };
            break;
          case 25:
            this.$ = yy2.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
            break;
          case 26:
            this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy2.stripFlags($$[$0 - 4], $$[$0]) };
            break;
          case 27:
            this.$ = $$[$0];
            break;
          case 28:
            this.$ = $$[$0];
            break;
          case 29:
            this.$ = {
              type: "SubExpression",
              path: $$[$0 - 3],
              params: $$[$0 - 2],
              hash: $$[$0 - 1],
              loc: yy2.locInfo(this._$)
            };
            break;
          case 30:
            this.$ = { type: "Hash", pairs: $$[$0], loc: yy2.locInfo(this._$) };
            break;
          case 31:
            this.$ = { type: "HashPair", key: yy2.id($$[$0 - 2]), value: $$[$0], loc: yy2.locInfo(this._$) };
            break;
          case 32:
            this.$ = yy2.id($$[$0 - 1]);
            break;
          case 33:
            this.$ = $$[$0];
            break;
          case 34:
            this.$ = $$[$0];
            break;
          case 35:
            this.$ = { type: "StringLiteral", value: $$[$0], original: $$[$0], loc: yy2.locInfo(this._$) };
            break;
          case 36:
            this.$ = { type: "NumberLiteral", value: Number($$[$0]), original: Number($$[$0]), loc: yy2.locInfo(this._$) };
            break;
          case 37:
            this.$ = { type: "BooleanLiteral", value: $$[$0] === "true", original: $$[$0] === "true", loc: yy2.locInfo(this._$) };
            break;
          case 38:
            this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: yy2.locInfo(this._$) };
            break;
          case 39:
            this.$ = { type: "NullLiteral", original: null, value: null, loc: yy2.locInfo(this._$) };
            break;
          case 40:
            this.$ = $$[$0];
            break;
          case 41:
            this.$ = $$[$0];
            break;
          case 42:
            this.$ = yy2.preparePath(true, $$[$0], this._$);
            break;
          case 43:
            this.$ = yy2.preparePath(false, $$[$0], this._$);
            break;
          case 44:
            $$[$0 - 2].push({ part: yy2.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });
            this.$ = $$[$0 - 2];
            break;
          case 45:
            this.$ = [{ part: yy2.id($$[$0]), original: $$[$0] }];
            break;
          case 46:
            this.$ = [];
            break;
          case 47:
            $$[$0 - 1].push($$[$0]);
            break;
          case 48:
            this.$ = [];
            break;
          case 49:
            $$[$0 - 1].push($$[$0]);
            break;
          case 50:
            this.$ = [];
            break;
          case 51:
            $$[$0 - 1].push($$[$0]);
            break;
          case 58:
            this.$ = [];
            break;
          case 59:
            $$[$0 - 1].push($$[$0]);
            break;
          case 64:
            this.$ = [];
            break;
          case 65:
            $$[$0 - 1].push($$[$0]);
            break;
          case 70:
            this.$ = [];
            break;
          case 71:
            $$[$0 - 1].push($$[$0]);
            break;
          case 78:
            this.$ = [];
            break;
          case 79:
            $$[$0 - 1].push($$[$0]);
            break;
          case 82:
            this.$ = [];
            break;
          case 83:
            $$[$0 - 1].push($$[$0]);
            break;
          case 86:
            this.$ = [];
            break;
          case 87:
            $$[$0 - 1].push($$[$0]);
            break;
          case 90:
            this.$ = [];
            break;
          case 91:
            $$[$0 - 1].push($$[$0]);
            break;
          case 94:
            this.$ = [];
            break;
          case 95:
            $$[$0 - 1].push($$[$0]);
            break;
          case 98:
            this.$ = [$$[$0]];
            break;
          case 99:
            $$[$0 - 1].push($$[$0]);
            break;
          case 100:
            this.$ = [$$[$0]];
            break;
          case 101:
            $$[$0 - 1].push($$[$0]);
            break;
        }
      },
      table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
      defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
      parseError: function parseError(str, hash) {
        throw new Error(str);
      },
      parse: function parse2(input) {
        var self2 = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0;
        this.lexer.setInput(input);
        this.lexer.yy = this.yy;
        this.yy.lexer = this.lexer;
        this.yy.parser = this;
        if (typeof this.lexer.yylloc == "undefined")
          this.lexer.yylloc = {};
        var yyloc = this.lexer.yylloc;
        lstack.push(yyloc);
        var ranges = this.lexer.options && this.lexer.options.ranges;
        if (typeof this.yy.parseError === "function")
          this.parseError = this.yy.parseError;
        function lex() {
          var token;
          token = self2.lexer.lex() || 1;
          if (typeof token !== "number") {
            token = self2.symbols_[token] || token;
          }
          return token;
        }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            {
              expected = [];
              for (p in table[state])
                if (this.terminals_[p] && p > 2) {
                  expected.push("'" + this.terminals_[p] + "'");
                }
              if (this.lexer.showPosition) {
                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
              } else {
                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
              }
              this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected });
            }
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function setInput(input) {
          this._input = input;
          this._more = this._less = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
          if (this.options.ranges)
            this.yylloc.range = [0, 0];
          this.offset = 0;
          return this;
        },
        input: function input() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges)
            this.yylloc.range[1]++;
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1)
            this.yylineno -= lines.length - 1;
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          return this;
        },
        more: function more() {
          this._more = true;
          return this;
        },
        less: function less(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function pastInput() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function upcomingInput() {
          var next = this.match;
          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }
          return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function showPosition() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        next: function next() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input)
            this.done = true;
          var token, match2, tempMatch, index2, lines;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match2 || tempMatch[0].length > match2[0].length)) {
              match2 = tempMatch;
              index2 = i;
              if (!this.options.flex)
                break;
            }
          }
          if (match2) {
            lines = match2[0].match(/(?:\r\n?|\n).*/g);
            if (lines)
              this.yylineno += lines.length;
            this.yylloc = {
              first_line: this.yylloc.last_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.last_column,
              last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match2[0].length
            };
            this.yytext += match2[0];
            this.match += match2[0];
            this.matches = match2;
            this.yyleng = this.yytext.length;
            if (this.options.ranges) {
              this.yylloc.range = [this.offset, this.offset += this.yyleng];
            }
            this._more = false;
            this._input = this._input.slice(match2[0].length);
            this.matched += match2[0];
            token = this.performAction.call(this, this.yy, this, rules[index2], this.conditionStack[this.conditionStack.length - 1]);
            if (this.done && this._input)
              this.done = false;
            if (token)
              return token;
            else
              return;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (typeof r !== "undefined") {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition2) {
          this.conditionStack.push(condition2);
        },
        popState: function popState() {
          return this.conditionStack.pop();
        },
        _currentRules: function _currentRules() {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        },
        topState: function topState() {
          return this.conditionStack[this.conditionStack.length - 2];
        },
        pushState: function begin(condition2) {
          this.begin(condition2);
        }
      };
      lexer2.options = {};
      lexer2.performAction = function anonymous(yy2, yy_, $avoiding_name_collisions, YY_START) {
        function strip(start, end) {
          return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
        }
        switch ($avoiding_name_collisions) {
          case 0:
            if (yy_.yytext.slice(-2) === "\\\\") {
              strip(0, 1);
              this.begin("mu");
            } else if (yy_.yytext.slice(-1) === "\\") {
              strip(0, 1);
              this.begin("emu");
            } else {
              this.begin("mu");
            }
            if (yy_.yytext)
              return 15;
            break;
          case 1:
            return 15;
          case 2:
            this.popState();
            return 15;
          case 3:
            this.begin("raw");
            return 15;
          case 4:
            this.popState();
            if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
              return 15;
            } else {
              strip(5, 9);
              return "END_RAW_BLOCK";
            }
          case 5:
            return 15;
          case 6:
            this.popState();
            return 14;
          case 7:
            return 65;
          case 8:
            return 68;
          case 9:
            return 19;
          case 10:
            this.popState();
            this.begin("raw");
            return 23;
          case 11:
            return 55;
          case 12:
            return 60;
          case 13:
            return 29;
          case 14:
            return 47;
          case 15:
            this.popState();
            return 44;
          case 16:
            this.popState();
            return 44;
          case 17:
            return 34;
          case 18:
            return 39;
          case 19:
            return 51;
          case 20:
            return 48;
          case 21:
            this.unput(yy_.yytext);
            this.popState();
            this.begin("com");
            break;
          case 22:
            this.popState();
            return 14;
          case 23:
            return 48;
          case 24:
            return 73;
          case 25:
            return 72;
          case 26:
            return 72;
          case 27:
            return 87;
          case 28:
            break;
          case 29:
            this.popState();
            return 54;
          case 30:
            this.popState();
            return 33;
          case 31:
            yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
            return 80;
          case 32:
            yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
            return 80;
          case 33:
            return 85;
          case 34:
            return 82;
          case 35:
            return 82;
          case 36:
            return 83;
          case 37:
            return 84;
          case 38:
            return 81;
          case 39:
            return 75;
          case 40:
            return 77;
          case 41:
            return 72;
          case 42:
            yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
            return 72;
          case 43:
            return "INVALID";
          case 44:
            return 5;
        }
      };
      lexer2.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
      lexer2.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser2() {
      this.yy = {};
    }
    Parser2.prototype = parser2;
    parser2.Parser = Parser2;
    return new Parser2();
  }();
  exports["default"] = handlebars2;
  module.exports = exports["default"];
})(parser, parser.exports);
var whitespaceControl = { exports: {} };
var visitor = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _exception3 = exception.exports;
  var _exception22 = _interopRequireDefault2(_exception3);
  function Visitor() {
    this.parents = [];
  }
  Visitor.prototype = {
    constructor: Visitor,
    mutating: false,
    acceptKey: function acceptKey(node2, name2) {
      var value = this.accept(node2[name2]);
      if (this.mutating) {
        if (value && !Visitor.prototype[value.type]) {
          throw new _exception22["default"]('Unexpected node type "' + value.type + '" found when accepting ' + name2 + " on " + node2.type);
        }
        node2[name2] = value;
      }
    },
    acceptRequired: function acceptRequired(node2, name2) {
      this.acceptKey(node2, name2);
      if (!node2[name2]) {
        throw new _exception22["default"](node2.type + " requires " + name2);
      }
    },
    acceptArray: function acceptArray(array) {
      for (var i = 0, l = array.length; i < l; i++) {
        this.acceptKey(array, i);
        if (!array[i]) {
          array.splice(i, 1);
          i--;
          l--;
        }
      }
    },
    accept: function accept2(object) {
      if (!object) {
        return;
      }
      if (!this[object.type]) {
        throw new _exception22["default"]("Unknown type: " + object.type, object);
      }
      if (this.current) {
        this.parents.unshift(this.current);
      }
      this.current = object;
      var ret = this[object.type](object);
      this.current = this.parents.shift();
      if (!this.mutating || ret) {
        return ret;
      } else if (ret !== false) {
        return object;
      }
    },
    Program: function Program2(program) {
      this.acceptArray(program.body);
    },
    MustacheStatement: visitSubExpression,
    Decorator: visitSubExpression,
    BlockStatement: visitBlock,
    DecoratorBlock: visitBlock,
    PartialStatement: visitPartial,
    PartialBlockStatement: function PartialBlockStatement2(partial) {
      visitPartial.call(this, partial);
      this.acceptKey(partial, "program");
    },
    ContentStatement: function ContentStatement2() {
    },
    CommentStatement: function CommentStatement2() {
    },
    SubExpression: visitSubExpression,
    PathExpression: function PathExpression2() {
    },
    StringLiteral: function StringLiteral2() {
    },
    NumberLiteral: function NumberLiteral2() {
    },
    BooleanLiteral: function BooleanLiteral2() {
    },
    UndefinedLiteral: function UndefinedLiteral2() {
    },
    NullLiteral: function NullLiteral2() {
    },
    Hash: function Hash3(hash) {
      this.acceptArray(hash.pairs);
    },
    HashPair: function HashPair(pair) {
      this.acceptRequired(pair, "value");
    }
  };
  function visitSubExpression(mustache) {
    this.acceptRequired(mustache, "path");
    this.acceptArray(mustache.params);
    this.acceptKey(mustache, "hash");
  }
  function visitBlock(block) {
    visitSubExpression.call(this, block);
    this.acceptKey(block, "program");
    this.acceptKey(block, "inverse");
  }
  function visitPartial(partial) {
    this.acceptRequired(partial, "name");
    this.acceptArray(partial.params);
    this.acceptKey(partial, "hash");
  }
  exports["default"] = Visitor;
  module.exports = exports["default"];
})(visitor, visitor.exports);
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _visitor = visitor.exports;
  var _visitor2 = _interopRequireDefault2(_visitor);
  function WhitespaceControl() {
    var options = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
    this.options = options;
  }
  WhitespaceControl.prototype = new _visitor2["default"]();
  WhitespaceControl.prototype.Program = function(program) {
    var doStandalone = !this.options.ignoreStandalone;
    var isRoot = !this.isRootSeen;
    this.isRootSeen = true;
    var body = program.body;
    for (var i = 0, l = body.length; i < l; i++) {
      var current = body[i], strip = this.accept(current);
      if (!strip) {
        continue;
      }
      var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
      if (strip.close) {
        omitRight(body, i, true);
      }
      if (strip.open) {
        omitLeft(body, i, true);
      }
      if (doStandalone && inlineStandalone) {
        omitRight(body, i);
        if (omitLeft(body, i)) {
          if (current.type === "PartialStatement") {
            current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
          }
        }
      }
      if (doStandalone && openStandalone) {
        omitRight((current.program || current.inverse).body);
        omitLeft(body, i);
      }
      if (doStandalone && closeStandalone) {
        omitRight(body, i);
        omitLeft((current.inverse || current.program).body);
      }
    }
    return program;
  };
  WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block) {
    this.accept(block.program);
    this.accept(block.inverse);
    var program = block.program || block.inverse, inverse = block.program && block.inverse, firstInverse = inverse, lastInverse = inverse;
    if (inverse && inverse.chained) {
      firstInverse = inverse.body[0].program;
      while (lastInverse.chained) {
        lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
      }
    }
    var strip = {
      open: block.openStrip.open,
      close: block.closeStrip.close,
      openStandalone: isNextWhitespace(program.body),
      closeStandalone: isPrevWhitespace((firstInverse || program).body)
    };
    if (block.openStrip.close) {
      omitRight(program.body, null, true);
    }
    if (inverse) {
      var inverseStrip = block.inverseStrip;
      if (inverseStrip.open) {
        omitLeft(program.body, null, true);
      }
      if (inverseStrip.close) {
        omitRight(firstInverse.body, null, true);
      }
      if (block.closeStrip.open) {
        omitLeft(lastInverse.body, null, true);
      }
      if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
        omitLeft(program.body);
        omitRight(firstInverse.body);
      }
    } else if (block.closeStrip.open) {
      omitLeft(program.body, null, true);
    }
    return strip;
  };
  WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
    return mustache.strip;
  };
  WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node2) {
    var strip = node2.strip || {};
    return {
      inlineStandalone: true,
      open: strip.open,
      close: strip.close
    };
  };
  function isPrevWhitespace(body, i, isRoot) {
    if (i === void 0) {
      i = body.length;
    }
    var prev = body[i - 1], sibling = body[i - 2];
    if (!prev) {
      return isRoot;
    }
    if (prev.type === "ContentStatement") {
      return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
    }
  }
  function isNextWhitespace(body, i, isRoot) {
    if (i === void 0) {
      i = -1;
    }
    var next = body[i + 1], sibling = body[i + 2];
    if (!next) {
      return isRoot;
    }
    if (next.type === "ContentStatement") {
      return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
    }
  }
  function omitRight(body, i, multiple) {
    var current = body[i == null ? 0 : i + 1];
    if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
      return;
    }
    var original = current.value;
    current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
    current.rightStripped = current.value !== original;
  }
  function omitLeft(body, i, multiple) {
    var current = body[i == null ? body.length - 1 : i - 1];
    if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
      return;
    }
    var original = current.value;
    current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
    current.leftStripped = current.value !== original;
    return current.leftStripped;
  }
  exports["default"] = WhitespaceControl;
  module.exports = exports["default"];
})(whitespaceControl, whitespaceControl.exports);
var helpers = {};
helpers.__esModule = true;
helpers.SourceLocation = SourceLocation;
helpers.id = id;
helpers.stripFlags = stripFlags;
helpers.stripComment = stripComment;
helpers.preparePath = preparePath;
helpers.prepareMustache = prepareMustache;
helpers.prepareRawBlock = prepareRawBlock;
helpers.prepareBlock = prepareBlock;
helpers.prepareProgram = prepareProgram;
helpers.preparePartialBlock = preparePartialBlock;
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
var _exception$1 = exception.exports;
var _exception2$1 = _interopRequireDefault$2(_exception$1);
function validateClose(open3, close) {
  close = close.path ? close.path.original : close;
  if (open3.path.original !== close) {
    var errorNode = { loc: open3.path.loc };
    throw new _exception2$1["default"](open3.path.original + " doesn't match " + close, errorNode);
  }
}
function SourceLocation(source, locInfo) {
  this.source = source;
  this.start = {
    line: locInfo.first_line,
    column: locInfo.first_column
  };
  this.end = {
    line: locInfo.last_line,
    column: locInfo.last_column
  };
}
function id(token) {
  if (/^\[.*\]$/.test(token)) {
    return token.substring(1, token.length - 1);
  } else {
    return token;
  }
}
function stripFlags(open3, close) {
  return {
    open: open3.charAt(2) === "~",
    close: close.charAt(close.length - 3) === "~"
  };
}
function stripComment(comment) {
  return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
}
function preparePath(data, parts, loc) {
  loc = this.locInfo(loc);
  var original = data ? "@" : "", dig = [], depth = 0;
  for (var i = 0, l = parts.length; i < l; i++) {
    var part = parts[i].part, isLiteral = parts[i].original !== part;
    original += (parts[i].separator || "") + part;
    if (!isLiteral && (part === ".." || part === "." || part === "this")) {
      if (dig.length > 0) {
        throw new _exception2$1["default"]("Invalid path: " + original, { loc });
      } else if (part === "..") {
        depth++;
      }
    } else {
      dig.push(part);
    }
  }
  return {
    type: "PathExpression",
    data,
    depth,
    parts: dig,
    original,
    loc
  };
}
function prepareMustache(path, params, hash, open3, strip, locInfo) {
  var escapeFlag = open3.charAt(3) || open3.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
  var decorator = /\*/.test(open3);
  return {
    type: decorator ? "Decorator" : "MustacheStatement",
    path,
    params,
    hash,
    escaped,
    strip,
    loc: this.locInfo(locInfo)
  };
}
function prepareRawBlock(openRawBlock, contents, close, locInfo) {
  validateClose(openRawBlock, close);
  locInfo = this.locInfo(locInfo);
  var program = {
    type: "Program",
    body: contents,
    strip: {},
    loc: locInfo
  };
  return {
    type: "BlockStatement",
    path: openRawBlock.path,
    params: openRawBlock.params,
    hash: openRawBlock.hash,
    program,
    openStrip: {},
    inverseStrip: {},
    closeStrip: {},
    loc: locInfo
  };
}
function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
  if (close && close.path) {
    validateClose(openBlock, close);
  }
  var decorator = /\*/.test(openBlock.open);
  program.blockParams = openBlock.blockParams;
  var inverse = void 0, inverseStrip = void 0;
  if (inverseAndProgram) {
    if (decorator) {
      throw new _exception2$1["default"]("Unexpected inverse block on decorator", inverseAndProgram);
    }
    if (inverseAndProgram.chain) {
      inverseAndProgram.program.body[0].closeStrip = close.strip;
    }
    inverseStrip = inverseAndProgram.strip;
    inverse = inverseAndProgram.program;
  }
  if (inverted) {
    inverted = inverse;
    inverse = program;
    program = inverted;
  }
  return {
    type: decorator ? "DecoratorBlock" : "BlockStatement",
    path: openBlock.path,
    params: openBlock.params,
    hash: openBlock.hash,
    program,
    inverse,
    openStrip: openBlock.strip,
    inverseStrip,
    closeStrip: close && close.strip,
    loc: this.locInfo(locInfo)
  };
}
function prepareProgram(statements, loc) {
  if (!loc && statements.length) {
    var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
    if (firstLoc && lastLoc) {
      loc = {
        source: firstLoc.source,
        start: {
          line: firstLoc.start.line,
          column: firstLoc.start.column
        },
        end: {
          line: lastLoc.end.line,
          column: lastLoc.end.column
        }
      };
    }
  }
  return {
    type: "Program",
    body: statements,
    strip: {},
    loc
  };
}
function preparePartialBlock(open3, program, close, locInfo) {
  validateClose(open3, close);
  return {
    type: "PartialBlockStatement",
    name: open3.path,
    params: open3.params,
    hash: open3.hash,
    program,
    openStrip: open3.strip,
    closeStrip: close && close.strip,
    loc: this.locInfo(locInfo)
  };
}
base.__esModule = true;
base.parseWithoutProcessing = parseWithoutProcessing;
base.parse = parse$3;
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          newObj[key] = obj[key];
      }
    }
    newObj["default"] = obj;
    return newObj;
  }
}
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
var _parser = parser.exports;
var _parser2 = _interopRequireDefault$1(_parser);
var _whitespaceControl = whitespaceControl.exports;
var _whitespaceControl2 = _interopRequireDefault$1(_whitespaceControl);
var _helpers = helpers;
var Helpers = _interopRequireWildcard(_helpers);
var _utils$1 = utils$g;
base.parser = _parser2["default"];
var yy = {};
_utils$1.extend(yy, Helpers);
function parseWithoutProcessing(input, options) {
  if (input.type === "Program") {
    return input;
  }
  _parser2["default"].yy = yy;
  yy.locInfo = function(locInfo) {
    return new yy.SourceLocation(options && options.srcName, locInfo);
  };
  var ast2 = _parser2["default"].parse(input);
  return ast2;
}
function parse$3(input, options) {
  var ast2 = parseWithoutProcessing(input, options);
  var strip = new _whitespaceControl2["default"](options);
  return strip.accept(ast2);
}
var compiler = {};
compiler.__esModule = true;
compiler.Compiler = Compiler;
compiler.precompile = precompile;
compiler.compile = compile;
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
var _exception = exception.exports;
var _exception2 = _interopRequireDefault(_exception);
var _utils = utils$g;
var _ast = ast.exports;
var _ast2 = _interopRequireDefault(_ast);
var slice$2 = [].slice;
function Compiler() {
}
Compiler.prototype = {
  compiler: Compiler,
  equals: function equals(other) {
    var len = this.opcodes.length;
    if (other.opcodes.length !== len) {
      return false;
    }
    for (var i = 0; i < len; i++) {
      var opcode2 = this.opcodes[i], otherOpcode = other.opcodes[i];
      if (opcode2.opcode !== otherOpcode.opcode || !argEquals(opcode2.args, otherOpcode.args)) {
        return false;
      }
    }
    len = this.children.length;
    for (var i = 0; i < len; i++) {
      if (!this.children[i].equals(other.children[i])) {
        return false;
      }
    }
    return true;
  },
  guid: 0,
  compile: function compile2(program, options) {
    this.sourceNode = [];
    this.opcodes = [];
    this.children = [];
    this.options = options;
    this.stringParams = options.stringParams;
    this.trackIds = options.trackIds;
    options.blockParams = options.blockParams || [];
    options.knownHelpers = _utils.extend(/* @__PURE__ */ Object.create(null), {
      helperMissing: true,
      blockHelperMissing: true,
      each: true,
      "if": true,
      unless: true,
      "with": true,
      log: true,
      lookup: true
    }, options.knownHelpers);
    return this.accept(program);
  },
  compileProgram: function compileProgram(program) {
    var childCompiler = new this.compiler(), result = childCompiler.compile(program, this.options), guid = this.guid++;
    this.usePartial = this.usePartial || result.usePartial;
    this.children[guid] = result;
    this.useDepths = this.useDepths || result.useDepths;
    return guid;
  },
  accept: function accept(node2) {
    if (!this[node2.type]) {
      throw new _exception2["default"]("Unknown type: " + node2.type, node2);
    }
    this.sourceNode.unshift(node2);
    var ret = this[node2.type](node2);
    this.sourceNode.shift();
    return ret;
  },
  Program: function Program(program) {
    this.options.blockParams.unshift(program.blockParams);
    var body = program.body, bodyLength = body.length;
    for (var i = 0; i < bodyLength; i++) {
      this.accept(body[i]);
    }
    this.options.blockParams.shift();
    this.isSimple = bodyLength === 1;
    this.blockParams = program.blockParams ? program.blockParams.length : 0;
    return this;
  },
  BlockStatement: function BlockStatement(block) {
    transformLiteralToPath(block);
    var program = block.program, inverse = block.inverse;
    program = program && this.compileProgram(program);
    inverse = inverse && this.compileProgram(inverse);
    var type = this.classifySexpr(block);
    if (type === "helper") {
      this.helperSexpr(block, program, inverse);
    } else if (type === "simple") {
      this.simpleSexpr(block);
      this.opcode("pushProgram", program);
      this.opcode("pushProgram", inverse);
      this.opcode("emptyHash");
      this.opcode("blockValue", block.path.original);
    } else {
      this.ambiguousSexpr(block, program, inverse);
      this.opcode("pushProgram", program);
      this.opcode("pushProgram", inverse);
      this.opcode("emptyHash");
      this.opcode("ambiguousBlockValue");
    }
    this.opcode("append");
  },
  DecoratorBlock: function DecoratorBlock(decorator) {
    var program = decorator.program && this.compileProgram(decorator.program);
    var params = this.setupFullMustacheParams(decorator, program, void 0), path = decorator.path;
    this.useDecorators = true;
    this.opcode("registerDecorator", params.length, path.original);
  },
  PartialStatement: function PartialStatement(partial) {
    this.usePartial = true;
    var program = partial.program;
    if (program) {
      program = this.compileProgram(partial.program);
    }
    var params = partial.params;
    if (params.length > 1) {
      throw new _exception2["default"]("Unsupported number of partial arguments: " + params.length, partial);
    } else if (!params.length) {
      if (this.options.explicitPartialContext) {
        this.opcode("pushLiteral", "undefined");
      } else {
        params.push({ type: "PathExpression", parts: [], depth: 0 });
      }
    }
    var partialName = partial.name.original, isDynamic = partial.name.type === "SubExpression";
    if (isDynamic) {
      this.accept(partial.name);
    }
    this.setupFullMustacheParams(partial, program, void 0, true);
    var indent = partial.indent || "";
    if (this.options.preventIndent && indent) {
      this.opcode("appendContent", indent);
      indent = "";
    }
    this.opcode("invokePartial", isDynamic, partialName, indent);
    this.opcode("append");
  },
  PartialBlockStatement: function PartialBlockStatement(partialBlock) {
    this.PartialStatement(partialBlock);
  },
  MustacheStatement: function MustacheStatement(mustache) {
    this.SubExpression(mustache);
    if (mustache.escaped && !this.options.noEscape) {
      this.opcode("appendEscaped");
    } else {
      this.opcode("append");
    }
  },
  Decorator: function Decorator(decorator) {
    this.DecoratorBlock(decorator);
  },
  ContentStatement: function ContentStatement(content) {
    if (content.value) {
      this.opcode("appendContent", content.value);
    }
  },
  CommentStatement: function CommentStatement() {
  },
  SubExpression: function SubExpression(sexpr) {
    transformLiteralToPath(sexpr);
    var type = this.classifySexpr(sexpr);
    if (type === "simple") {
      this.simpleSexpr(sexpr);
    } else if (type === "helper") {
      this.helperSexpr(sexpr);
    } else {
      this.ambiguousSexpr(sexpr);
    }
  },
  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
    var path = sexpr.path, name2 = path.parts[0], isBlock = program != null || inverse != null;
    this.opcode("getContext", path.depth);
    this.opcode("pushProgram", program);
    this.opcode("pushProgram", inverse);
    path.strict = true;
    this.accept(path);
    this.opcode("invokeAmbiguous", name2, isBlock);
  },
  simpleSexpr: function simpleSexpr(sexpr) {
    var path = sexpr.path;
    path.strict = true;
    this.accept(path);
    this.opcode("resolvePossibleLambda");
  },
  helperSexpr: function helperSexpr(sexpr, program, inverse) {
    var params = this.setupFullMustacheParams(sexpr, program, inverse), path = sexpr.path, name2 = path.parts[0];
    if (this.options.knownHelpers[name2]) {
      this.opcode("invokeKnownHelper", params.length, name2);
    } else if (this.options.knownHelpersOnly) {
      throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name2, sexpr);
    } else {
      path.strict = true;
      path.falsy = true;
      this.accept(path);
      this.opcode("invokeHelper", params.length, path.original, _ast2["default"].helpers.simpleId(path));
    }
  },
  PathExpression: function PathExpression(path) {
    this.addDepth(path.depth);
    this.opcode("getContext", path.depth);
    var name2 = path.parts[0], scoped = _ast2["default"].helpers.scopedId(path), blockParamId = !path.depth && !scoped && this.blockParamIndex(name2);
    if (blockParamId) {
      this.opcode("lookupBlockParam", blockParamId, path.parts);
    } else if (!name2) {
      this.opcode("pushContext");
    } else if (path.data) {
      this.options.data = true;
      this.opcode("lookupData", path.depth, path.parts, path.strict);
    } else {
      this.opcode("lookupOnContext", path.parts, path.falsy, path.strict, scoped);
    }
  },
  StringLiteral: function StringLiteral(string) {
    this.opcode("pushString", string.value);
  },
  NumberLiteral: function NumberLiteral(number) {
    this.opcode("pushLiteral", number.value);
  },
  BooleanLiteral: function BooleanLiteral(bool) {
    this.opcode("pushLiteral", bool.value);
  },
  UndefinedLiteral: function UndefinedLiteral() {
    this.opcode("pushLiteral", "undefined");
  },
  NullLiteral: function NullLiteral() {
    this.opcode("pushLiteral", "null");
  },
  Hash: function Hash2(hash) {
    var pairs = hash.pairs, i = 0, l = pairs.length;
    this.opcode("pushHash");
    for (; i < l; i++) {
      this.pushParam(pairs[i].value);
    }
    while (i--) {
      this.opcode("assignToHash", pairs[i].key);
    }
    this.opcode("popHash");
  },
  opcode: function opcode(name2) {
    this.opcodes.push({
      opcode: name2,
      args: slice$2.call(arguments, 1),
      loc: this.sourceNode[0].loc
    });
  },
  addDepth: function addDepth(depth) {
    if (!depth) {
      return;
    }
    this.useDepths = true;
  },
  classifySexpr: function classifySexpr(sexpr) {
    var isSimple2 = _ast2["default"].helpers.simpleId(sexpr.path);
    var isBlockParam = isSimple2 && !!this.blockParamIndex(sexpr.path.parts[0]);
    var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
    var isEligible = !isBlockParam && (isHelper || isSimple2);
    if (isEligible && !isHelper) {
      var _name = sexpr.path.parts[0], options = this.options;
      if (options.knownHelpers[_name]) {
        isHelper = true;
      } else if (options.knownHelpersOnly) {
        isEligible = false;
      }
    }
    if (isHelper) {
      return "helper";
    } else if (isEligible) {
      return "ambiguous";
    } else {
      return "simple";
    }
  },
  pushParams: function pushParams(params) {
    for (var i = 0, l = params.length; i < l; i++) {
      this.pushParam(params[i]);
    }
  },
  pushParam: function pushParam(val) {
    var value = val.value != null ? val.value : val.original || "";
    if (this.stringParams) {
      if (value.replace) {
        value = value.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
      }
      if (val.depth) {
        this.addDepth(val.depth);
      }
      this.opcode("getContext", val.depth || 0);
      this.opcode("pushStringParam", value, val.type);
      if (val.type === "SubExpression") {
        this.accept(val);
      }
    } else {
      if (this.trackIds) {
        var blockParamIndex2 = void 0;
        if (val.parts && !_ast2["default"].helpers.scopedId(val) && !val.depth) {
          blockParamIndex2 = this.blockParamIndex(val.parts[0]);
        }
        if (blockParamIndex2) {
          var blockParamChild = val.parts.slice(1).join(".");
          this.opcode("pushId", "BlockParam", blockParamIndex2, blockParamChild);
        } else {
          value = val.original || value;
          if (value.replace) {
            value = value.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
          }
          this.opcode("pushId", val.type, value);
        }
      }
      this.accept(val);
    }
  },
  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
    var params = sexpr.params;
    this.pushParams(params);
    this.opcode("pushProgram", program);
    this.opcode("pushProgram", inverse);
    if (sexpr.hash) {
      this.accept(sexpr.hash);
    } else {
      this.opcode("emptyHash", omitEmpty);
    }
    return params;
  },
  blockParamIndex: function blockParamIndex(name2) {
    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
      var blockParams2 = this.options.blockParams[depth], param = blockParams2 && _utils.indexOf(blockParams2, name2);
      if (blockParams2 && param >= 0) {
        return [depth, param];
      }
    }
  }
};
function precompile(input, options, env) {
  if (input == null || typeof input !== "string" && input.type !== "Program") {
    throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
  }
  options = options || {};
  if (!("data" in options)) {
    options.data = true;
  }
  if (options.compat) {
    options.useDepths = true;
  }
  var ast2 = env.parse(input, options), environment = new env.Compiler().compile(ast2, options);
  return new env.JavaScriptCompiler().compile(environment, options);
}
function compile(input, options, env) {
  if (options === void 0)
    options = {};
  if (input == null || typeof input !== "string" && input.type !== "Program") {
    throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
  }
  options = _utils.extend({}, options);
  if (!("data" in options)) {
    options.data = true;
  }
  if (options.compat) {
    options.useDepths = true;
  }
  var compiled = void 0;
  function compileInput() {
    var ast2 = env.parse(input, options), environment = new env.Compiler().compile(ast2, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, void 0, true);
    return env.template(templateSpec);
  }
  function ret(context, execOptions) {
    if (!compiled) {
      compiled = compileInput();
    }
    return compiled.call(this, context, execOptions);
  }
  ret._setup = function(setupOptions) {
    if (!compiled) {
      compiled = compileInput();
    }
    return compiled._setup(setupOptions);
  };
  ret._child = function(i, data, blockParams2, depths) {
    if (!compiled) {
      compiled = compileInput();
    }
    return compiled._child(i, data, blockParams2, depths);
  };
  return ret;
}
function argEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
    for (var i = 0; i < a.length; i++) {
      if (!argEquals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
}
function transformLiteralToPath(sexpr) {
  if (!sexpr.path.parts) {
    var literal = sexpr.path;
    sexpr.path = {
      type: "PathExpression",
      data: false,
      depth: 0,
      parts: [literal.original + ""],
      original: literal.original + "",
      loc: literal.loc
    };
  }
}
var javascriptCompiler = { exports: {} };
var codeGen = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  var _utils2 = utils$g;
  var SourceNode = void 0;
  try {
    if (true) {
      var SourceMap = require("source-map");
      SourceNode = SourceMap.SourceNode;
    }
  } catch (err) {
  }
  if (!SourceNode) {
    SourceNode = function(line, column, srcFile, chunks) {
      this.src = "";
      if (chunks) {
        this.add(chunks);
      }
    };
    SourceNode.prototype = {
      add: function add2(chunks) {
        if (_utils2.isArray(chunks)) {
          chunks = chunks.join("");
        }
        this.src += chunks;
      },
      prepend: function prepend(chunks) {
        if (_utils2.isArray(chunks)) {
          chunks = chunks.join("");
        }
        this.src = chunks + this.src;
      },
      toStringWithSourceMap: function toStringWithSourceMap() {
        return { code: this.toString() };
      },
      toString: function toString2() {
        return this.src;
      }
    };
  }
  function castChunk(chunk, codeGen2, loc) {
    if (_utils2.isArray(chunk)) {
      var ret = [];
      for (var i = 0, len = chunk.length; i < len; i++) {
        ret.push(codeGen2.wrap(chunk[i], loc));
      }
      return ret;
    } else if (typeof chunk === "boolean" || typeof chunk === "number") {
      return chunk + "";
    }
    return chunk;
  }
  function CodeGen(srcFile) {
    this.srcFile = srcFile;
    this.source = [];
  }
  CodeGen.prototype = {
    isEmpty: function isEmpty2() {
      return !this.source.length;
    },
    prepend: function prepend(source, loc) {
      this.source.unshift(this.wrap(source, loc));
    },
    push: function push(source, loc) {
      this.source.push(this.wrap(source, loc));
    },
    merge: function merge2() {
      var source = this.empty();
      this.each(function(line) {
        source.add(["  ", line, "\n"]);
      });
      return source;
    },
    each: function each2(iter) {
      for (var i = 0, len = this.source.length; i < len; i++) {
        iter(this.source[i]);
      }
    },
    empty: function empty() {
      var loc = this.currentLocation || { start: {} };
      return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
    },
    wrap: function wrap(chunk) {
      var loc = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
      if (chunk instanceof SourceNode) {
        return chunk;
      }
      chunk = castChunk(chunk, this, loc);
      return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
    },
    functionCall: function functionCall(fn, type, params) {
      params = this.generateList(params);
      return this.wrap([fn, type ? "." + type + "(" : "(", params, ")"]);
    },
    quotedString: function quotedString(str) {
      return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
    },
    objectLiteral: function objectLiteral(obj) {
      var _this = this;
      var pairs = [];
      Object.keys(obj).forEach(function(key) {
        var value = castChunk(obj[key], _this);
        if (value !== "undefined") {
          pairs.push([_this.quotedString(key), ":", value]);
        }
      });
      var ret = this.generateList(pairs);
      ret.prepend("{");
      ret.add("}");
      return ret;
    },
    generateList: function generateList(entries) {
      var ret = this.empty();
      for (var i = 0, len = entries.length; i < len; i++) {
        if (i) {
          ret.add(",");
        }
        ret.add(castChunk(entries[i], this));
      }
      return ret;
    },
    generateArray: function generateArray(entries) {
      var ret = this.generateList(entries);
      ret.prepend("[");
      ret.add("]");
      return ret;
    }
  };
  exports["default"] = CodeGen;
  module.exports = exports["default"];
})(codeGen, codeGen.exports);
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _base2 = base$1;
  var _exception3 = exception.exports;
  var _exception22 = _interopRequireDefault2(_exception3);
  var _utils2 = utils$g;
  var _codeGen = codeGen.exports;
  var _codeGen2 = _interopRequireDefault2(_codeGen);
  function Literal(value) {
    this.value = value;
  }
  function JavaScriptCompiler() {
  }
  JavaScriptCompiler.prototype = {
    nameLookup: function nameLookup(parent2, name2) {
      return this.internalNameLookup(parent2, name2);
    },
    depthedLookup: function depthedLookup(name2) {
      return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(name2), ")"];
    },
    compilerInfo: function compilerInfo() {
      var revision = _base2.COMPILER_REVISION, versions = _base2.REVISION_CHANGES[revision];
      return [revision, versions];
    },
    appendToBuffer: function appendToBuffer(source, location, explicit) {
      if (!_utils2.isArray(source)) {
        source = [source];
      }
      source = this.source.wrap(source, location);
      if (this.environment.isSimple) {
        return ["return ", source, ";"];
      } else if (explicit) {
        return ["buffer += ", source, ";"];
      } else {
        source.appendToBuffer = true;
        return source;
      }
    },
    initializeBuffer: function initializeBuffer() {
      return this.quotedString("");
    },
    internalNameLookup: function internalNameLookup(parent2, name2) {
      this.lookupPropertyFunctionIsUsed = true;
      return ["lookupProperty(", parent2, ",", JSON.stringify(name2), ")"];
    },
    lookupPropertyFunctionIsUsed: false,
    compile: function compile3(environment, options, context, asObject) {
      this.environment = environment;
      this.options = options;
      this.stringParams = this.options.stringParams;
      this.trackIds = this.options.trackIds;
      this.precompile = !asObject;
      this.name = this.environment.name;
      this.isChild = !!context;
      this.context = context || {
        decorators: [],
        programs: [],
        environments: []
      };
      this.preamble();
      this.stackSlot = 0;
      this.stackVars = [];
      this.aliases = {};
      this.registers = { list: [] };
      this.hashes = [];
      this.compileStack = [];
      this.inlineStack = [];
      this.blockParams = [];
      this.compileChildren(environment, options);
      this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
      this.useBlockParams = this.useBlockParams || environment.useBlockParams;
      var opcodes = environment.opcodes, opcode2 = void 0, firstLoc = void 0, i = void 0, l = void 0;
      for (i = 0, l = opcodes.length; i < l; i++) {
        opcode2 = opcodes[i];
        this.source.currentLocation = opcode2.loc;
        firstLoc = firstLoc || opcode2.loc;
        this[opcode2.opcode].apply(this, opcode2.args);
      }
      this.source.currentLocation = firstLoc;
      this.pushSource("");
      if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
        throw new _exception22["default"]("Compile completed with content left on stack");
      }
      if (!this.decorators.isEmpty()) {
        this.useDecorators = true;
        this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
        this.decorators.push("return fn;");
        if (asObject) {
          this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
        } else {
          this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
          this.decorators.push("}\n");
          this.decorators = this.decorators.merge();
        }
      } else {
        this.decorators = void 0;
      }
      var fn = this.createFunctionContext(asObject);
      if (!this.isChild) {
        var ret = {
          compiler: this.compilerInfo(),
          main: fn
        };
        if (this.decorators) {
          ret.main_d = this.decorators;
          ret.useDecorators = true;
        }
        var _context = this.context;
        var programs = _context.programs;
        var decorators2 = _context.decorators;
        for (i = 0, l = programs.length; i < l; i++) {
          if (programs[i]) {
            ret[i] = programs[i];
            if (decorators2[i]) {
              ret[i + "_d"] = decorators2[i];
              ret.useDecorators = true;
            }
          }
        }
        if (this.environment.usePartial) {
          ret.usePartial = true;
        }
        if (this.options.data) {
          ret.useData = true;
        }
        if (this.useDepths) {
          ret.useDepths = true;
        }
        if (this.useBlockParams) {
          ret.useBlockParams = true;
        }
        if (this.options.compat) {
          ret.compat = true;
        }
        if (!asObject) {
          ret.compiler = JSON.stringify(ret.compiler);
          this.source.currentLocation = { start: { line: 1, column: 0 } };
          ret = this.objectLiteral(ret);
          if (options.srcName) {
            ret = ret.toStringWithSourceMap({ file: options.destName });
            ret.map = ret.map && ret.map.toString();
          } else {
            ret = ret.toString();
          }
        } else {
          ret.compilerOptions = this.options;
        }
        return ret;
      } else {
        return fn;
      }
    },
    preamble: function preamble() {
      this.lastContext = 0;
      this.source = new _codeGen2["default"](this.options.srcName);
      this.decorators = new _codeGen2["default"](this.options.srcName);
    },
    createFunctionContext: function createFunctionContext(asObject) {
      var _this = this;
      var varDeclarations = "";
      var locals = this.stackVars.concat(this.registers.list);
      if (locals.length > 0) {
        varDeclarations += ", " + locals.join(", ");
      }
      var aliasCount = 0;
      Object.keys(this.aliases).forEach(function(alias) {
        var node2 = _this.aliases[alias];
        if (node2.children && node2.referenceCount > 1) {
          varDeclarations += ", alias" + ++aliasCount + "=" + alias;
          node2.children[0] = "alias" + aliasCount;
        }
      });
      if (this.lookupPropertyFunctionIsUsed) {
        varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
      }
      var params = ["container", "depth0", "helpers", "partials", "data"];
      if (this.useBlockParams || this.useDepths) {
        params.push("blockParams");
      }
      if (this.useDepths) {
        params.push("depths");
      }
      var source = this.mergeSource(varDeclarations);
      if (asObject) {
        params.push(source);
        return Function.apply(this, params);
      } else {
        return this.source.wrap(["function(", params.join(","), ") {\n  ", source, "}"]);
      }
    },
    mergeSource: function mergeSource(varDeclarations) {
      var isSimple2 = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = void 0, sourceSeen = void 0, bufferStart = void 0, bufferEnd = void 0;
      this.source.each(function(line) {
        if (line.appendToBuffer) {
          if (bufferStart) {
            line.prepend("  + ");
          } else {
            bufferStart = line;
          }
          bufferEnd = line;
        } else {
          if (bufferStart) {
            if (!sourceSeen) {
              appendFirst = true;
            } else {
              bufferStart.prepend("buffer += ");
            }
            bufferEnd.add(";");
            bufferStart = bufferEnd = void 0;
          }
          sourceSeen = true;
          if (!isSimple2) {
            appendOnly = false;
          }
        }
      });
      if (appendOnly) {
        if (bufferStart) {
          bufferStart.prepend("return ");
          bufferEnd.add(";");
        } else if (!sourceSeen) {
          this.source.push('return "";');
        }
      } else {
        varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
        if (bufferStart) {
          bufferStart.prepend("return buffer + ");
          bufferEnd.add(";");
        } else {
          this.source.push("return buffer;");
        }
      }
      if (varDeclarations) {
        this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
      }
      return this.source.merge();
    },
    lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
      return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
    },
    blockValue: function blockValue(name2) {
      var blockHelperMissing2 = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
      this.setupHelperArgs(name2, 0, params);
      var blockName = this.popStack();
      params.splice(1, 0, blockName);
      this.push(this.source.functionCall(blockHelperMissing2, "call", params));
    },
    ambiguousBlockValue: function ambiguousBlockValue() {
      var blockHelperMissing2 = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
      this.setupHelperArgs("", 0, params, true);
      this.flushInline();
      var current = this.topStack();
      params.splice(1, 0, current);
      this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing2, "call", params), "}"]);
    },
    appendContent: function appendContent(content) {
      if (this.pendingContent) {
        content = this.pendingContent + content;
      } else {
        this.pendingLocation = this.source.currentLocation;
      }
      this.pendingContent = content;
    },
    append: function append2() {
      if (this.isInline()) {
        this.replaceStack(function(current) {
          return [" != null ? ", current, ' : ""'];
        });
        this.pushSource(this.appendToBuffer(this.popStack()));
      } else {
        var local = this.popStack();
        this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, void 0, true), " }"]);
        if (this.environment.isSimple) {
          this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
        }
      }
    },
    appendEscaped: function appendEscaped() {
      this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
    },
    getContext: function getContext(depth) {
      this.lastContext = depth;
    },
    pushContext: function pushContext() {
      this.pushStackLiteral(this.contextName(this.lastContext));
    },
    lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
      var i = 0;
      if (!scoped && this.options.compat && !this.lastContext) {
        this.push(this.depthedLookup(parts[i++]));
      } else {
        this.pushContext();
      }
      this.resolvePath("context", parts, i, falsy, strict);
    },
    lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
      this.useBlockParams = true;
      this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
      this.resolvePath("context", parts, 1);
    },
    lookupData: function lookupData(depth, parts, strict) {
      if (!depth) {
        this.pushStackLiteral("data");
      } else {
        this.pushStackLiteral("container.data(data, " + depth + ")");
      }
      this.resolvePath("data", parts, 0, true, strict);
    },
    resolvePath: function resolvePath(type, parts, i, falsy, strict) {
      var _this2 = this;
      if (this.options.strict || this.options.assumeObjects) {
        this.push(strictLookup(this.options.strict && strict, this, parts, type));
        return;
      }
      var len = parts.length;
      for (; i < len; i++) {
        this.replaceStack(function(current) {
          var lookup2 = _this2.nameLookup(current, parts[i], type);
          if (!falsy) {
            return [" != null ? ", lookup2, " : ", current];
          } else {
            return [" && ", lookup2];
          }
        });
      }
    },
    resolvePossibleLambda: function resolvePossibleLambda() {
      this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
    },
    pushStringParam: function pushStringParam(string, type) {
      this.pushContext();
      this.pushString(type);
      if (type !== "SubExpression") {
        if (typeof string === "string") {
          this.pushString(string);
        } else {
          this.pushStackLiteral(string);
        }
      }
    },
    emptyHash: function emptyHash(omitEmpty) {
      if (this.trackIds) {
        this.push("{}");
      }
      if (this.stringParams) {
        this.push("{}");
        this.push("{}");
      }
      this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
    },
    pushHash: function pushHash() {
      if (this.hash) {
        this.hashes.push(this.hash);
      }
      this.hash = { values: {}, types: [], contexts: [], ids: [] };
    },
    popHash: function popHash() {
      var hash = this.hash;
      this.hash = this.hashes.pop();
      if (this.trackIds) {
        this.push(this.objectLiteral(hash.ids));
      }
      if (this.stringParams) {
        this.push(this.objectLiteral(hash.contexts));
        this.push(this.objectLiteral(hash.types));
      }
      this.push(this.objectLiteral(hash.values));
    },
    pushString: function pushString(string) {
      this.pushStackLiteral(this.quotedString(string));
    },
    pushLiteral: function pushLiteral(value) {
      this.pushStackLiteral(value);
    },
    pushProgram: function pushProgram(guid) {
      if (guid != null) {
        this.pushStackLiteral(this.programExpression(guid));
      } else {
        this.pushStackLiteral(null);
      }
    },
    registerDecorator: function registerDecorator2(paramSize, name2) {
      var foundDecorator = this.nameLookup("decorators", name2, "decorator"), options = this.setupHelperArgs(name2, paramSize);
      this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options]), " || fn;"]);
    },
    invokeHelper: function invokeHelper(paramSize, name2, isSimple2) {
      var nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name2);
      var possibleFunctionCalls = [];
      if (isSimple2) {
        possibleFunctionCalls.push(helper.name);
      }
      possibleFunctionCalls.push(nonHelper);
      if (!this.options.strict) {
        possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
      }
      var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
      var functionCall = this.source.functionCall(functionLookupCode, "call", helper.callParams);
      this.push(functionCall);
    },
    itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
      var result = [];
      result.push(items[0]);
      for (var i = 1; i < items.length; i++) {
        result.push(separator, items[i]);
      }
      return result;
    },
    invokeKnownHelper: function invokeKnownHelper(paramSize, name2) {
      var helper = this.setupHelper(paramSize, name2);
      this.push(this.source.functionCall(helper.name, "call", helper.callParams));
    },
    invokeAmbiguous: function invokeAmbiguous(name2, helperCall) {
      this.useRegister("helper");
      var nonHelper = this.popStack();
      this.emptyHash();
      var helper = this.setupHelper(0, name2, helperCall);
      var helperName = this.lastHelper = this.nameLookup("helpers", name2, "helper");
      var lookup2 = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
      if (!this.options.strict) {
        lookup2[0] = "(helper = ";
        lookup2.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
      }
      this.push(["(", lookup2, helper.paramsInit ? ["),(", helper.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper.callParams), " : helper))"]);
    },
    invokePartial: function invokePartial2(isDynamic, name2, indent) {
      var params = [], options = this.setupParams(name2, 1, params);
      if (isDynamic) {
        name2 = this.popStack();
        delete options.name;
      }
      if (indent) {
        options.indent = JSON.stringify(indent);
      }
      options.helpers = "helpers";
      options.partials = "partials";
      options.decorators = "container.decorators";
      if (!isDynamic) {
        params.unshift(this.nameLookup("partials", name2, "partial"));
      } else {
        params.unshift(name2);
      }
      if (this.options.compat) {
        options.depths = "depths";
      }
      options = this.objectLiteral(options);
      params.push(options);
      this.push(this.source.functionCall("container.invokePartial", "", params));
    },
    assignToHash: function assignToHash(key) {
      var value = this.popStack(), context = void 0, type = void 0, id2 = void 0;
      if (this.trackIds) {
        id2 = this.popStack();
      }
      if (this.stringParams) {
        type = this.popStack();
        context = this.popStack();
      }
      var hash = this.hash;
      if (context) {
        hash.contexts[key] = context;
      }
      if (type) {
        hash.types[key] = type;
      }
      if (id2) {
        hash.ids[key] = id2;
      }
      hash.values[key] = value;
    },
    pushId: function pushId(type, name2, child) {
      if (type === "BlockParam") {
        this.pushStackLiteral("blockParams[" + name2[0] + "].path[" + name2[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
      } else if (type === "PathExpression") {
        this.pushString(name2);
      } else if (type === "SubExpression") {
        this.pushStackLiteral("true");
      } else {
        this.pushStackLiteral("null");
      }
    },
    compiler: JavaScriptCompiler,
    compileChildren: function compileChildren(environment, options) {
      var children = environment.children, child = void 0, compiler2 = void 0;
      for (var i = 0, l = children.length; i < l; i++) {
        child = children[i];
        compiler2 = new this.compiler();
        var existing = this.matchExistingProgram(child);
        if (existing == null) {
          this.context.programs.push("");
          var index2 = this.context.programs.length;
          child.index = index2;
          child.name = "program" + index2;
          this.context.programs[index2] = compiler2.compile(child, options, this.context, !this.precompile);
          this.context.decorators[index2] = compiler2.decorators;
          this.context.environments[index2] = child;
          this.useDepths = this.useDepths || compiler2.useDepths;
          this.useBlockParams = this.useBlockParams || compiler2.useBlockParams;
          child.useDepths = this.useDepths;
          child.useBlockParams = this.useBlockParams;
        } else {
          child.index = existing.index;
          child.name = "program" + existing.index;
          this.useDepths = this.useDepths || existing.useDepths;
          this.useBlockParams = this.useBlockParams || existing.useBlockParams;
        }
      }
    },
    matchExistingProgram: function matchExistingProgram(child) {
      for (var i = 0, len = this.context.environments.length; i < len; i++) {
        var environment = this.context.environments[i];
        if (environment && environment.equals(child)) {
          return environment;
        }
      }
    },
    programExpression: function programExpression(guid) {
      var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
      if (this.useBlockParams || this.useDepths) {
        programParams.push("blockParams");
      }
      if (this.useDepths) {
        programParams.push("depths");
      }
      return "container.program(" + programParams.join(", ") + ")";
    },
    useRegister: function useRegister(name2) {
      if (!this.registers[name2]) {
        this.registers[name2] = true;
        this.registers.list.push(name2);
      }
    },
    push: function push(expr) {
      if (!(expr instanceof Literal)) {
        expr = this.source.wrap(expr);
      }
      this.inlineStack.push(expr);
      return expr;
    },
    pushStackLiteral: function pushStackLiteral(item) {
      this.push(new Literal(item));
    },
    pushSource: function pushSource(source) {
      if (this.pendingContent) {
        this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
        this.pendingContent = void 0;
      }
      if (source) {
        this.source.push(source);
      }
    },
    replaceStack: function replaceStack(callback) {
      var prefix2 = ["("], stack = void 0, createdStack = void 0, usedLiteral = void 0;
      if (!this.isInline()) {
        throw new _exception22["default"]("replaceStack on non-inline");
      }
      var top = this.popStack(true);
      if (top instanceof Literal) {
        stack = [top.value];
        prefix2 = ["(", stack];
        usedLiteral = true;
      } else {
        createdStack = true;
        var _name = this.incrStack();
        prefix2 = ["((", this.push(_name), " = ", top, ")"];
        stack = this.topStack();
      }
      var item = callback.call(this, stack);
      if (!usedLiteral) {
        this.popStack();
      }
      if (createdStack) {
        this.stackSlot--;
      }
      this.push(prefix2.concat(item, ")"));
    },
    incrStack: function incrStack() {
      this.stackSlot++;
      if (this.stackSlot > this.stackVars.length) {
        this.stackVars.push("stack" + this.stackSlot);
      }
      return this.topStackName();
    },
    topStackName: function topStackName() {
      return "stack" + this.stackSlot;
    },
    flushInline: function flushInline() {
      var inlineStack = this.inlineStack;
      this.inlineStack = [];
      for (var i = 0, len = inlineStack.length; i < len; i++) {
        var entry = inlineStack[i];
        if (entry instanceof Literal) {
          this.compileStack.push(entry);
        } else {
          var stack = this.incrStack();
          this.pushSource([stack, " = ", entry, ";"]);
          this.compileStack.push(stack);
        }
      }
    },
    isInline: function isInline() {
      return this.inlineStack.length;
    },
    popStack: function popStack(wrapped) {
      var inline2 = this.isInline(), item = (inline2 ? this.inlineStack : this.compileStack).pop();
      if (!wrapped && item instanceof Literal) {
        return item.value;
      } else {
        if (!inline2) {
          if (!this.stackSlot) {
            throw new _exception22["default"]("Invalid stack pop");
          }
          this.stackSlot--;
        }
        return item;
      }
    },
    topStack: function topStack() {
      var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
      if (item instanceof Literal) {
        return item.value;
      } else {
        return item;
      }
    },
    contextName: function contextName(context) {
      if (this.useDepths && context) {
        return "depths[" + context + "]";
      } else {
        return "depth" + context;
      }
    },
    quotedString: function quotedString(str) {
      return this.source.quotedString(str);
    },
    objectLiteral: function objectLiteral(obj) {
      return this.source.objectLiteral(obj);
    },
    aliasable: function aliasable(name2) {
      var ret = this.aliases[name2];
      if (ret) {
        ret.referenceCount++;
        return ret;
      }
      ret = this.aliases[name2] = this.source.wrap(name2);
      ret.aliasable = true;
      ret.referenceCount = 1;
      return ret;
    },
    setupHelper: function setupHelper(paramSize, name2, blockHelper) {
      var params = [], paramsInit = this.setupHelperArgs(name2, paramSize, params, blockHelper);
      var foundHelper = this.nameLookup("helpers", name2, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
      return {
        params,
        paramsInit,
        name: foundHelper,
        callParams: [callContext].concat(params)
      };
    },
    setupParams: function setupParams(helper, paramSize, params) {
      var options = {}, contexts = [], types2 = [], ids2 = [], objectArgs = !params, param = void 0;
      if (objectArgs) {
        params = [];
      }
      options.name = this.quotedString(helper);
      options.hash = this.popStack();
      if (this.trackIds) {
        options.hashIds = this.popStack();
      }
      if (this.stringParams) {
        options.hashTypes = this.popStack();
        options.hashContexts = this.popStack();
      }
      var inverse = this.popStack(), program = this.popStack();
      if (program || inverse) {
        options.fn = program || "container.noop";
        options.inverse = inverse || "container.noop";
      }
      var i = paramSize;
      while (i--) {
        param = this.popStack();
        params[i] = param;
        if (this.trackIds) {
          ids2[i] = this.popStack();
        }
        if (this.stringParams) {
          types2[i] = this.popStack();
          contexts[i] = this.popStack();
        }
      }
      if (objectArgs) {
        options.args = this.source.generateArray(params);
      }
      if (this.trackIds) {
        options.ids = this.source.generateArray(ids2);
      }
      if (this.stringParams) {
        options.types = this.source.generateArray(types2);
        options.contexts = this.source.generateArray(contexts);
      }
      if (this.options.data) {
        options.data = "data";
      }
      if (this.useBlockParams) {
        options.blockParams = "blockParams";
      }
      return options;
    },
    setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
      var options = this.setupParams(helper, paramSize, params);
      options.loc = JSON.stringify(this.source.currentLocation);
      options = this.objectLiteral(options);
      if (useRegister) {
        this.useRegister("options");
        params.push("options");
        return ["options=", options];
      } else if (params) {
        params.push(options);
        return "";
      } else {
        return options;
      }
    }
  };
  (function() {
    var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
    var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
    for (var i = 0, l = reservedWords.length; i < l; i++) {
      compilerWords[reservedWords[i]] = true;
    }
  })();
  JavaScriptCompiler.isValidJavaScriptVariableName = function(name2) {
    return !JavaScriptCompiler.RESERVED_WORDS[name2] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name2);
  };
  function strictLookup(requireTerminal, compiler2, parts, type) {
    var stack = compiler2.popStack(), i = 0, len = parts.length;
    if (requireTerminal) {
      len--;
    }
    for (; i < len; i++) {
      stack = compiler2.nameLookup(stack, parts[i], type);
    }
    if (requireTerminal) {
      return [compiler2.aliasable("container.strict"), "(", stack, ", ", compiler2.quotedString(parts[i]), ", ", JSON.stringify(compiler2.source.currentLocation), " )"];
    } else {
      return stack;
    }
  }
  exports["default"] = JavaScriptCompiler;
  module.exports = exports["default"];
})(javascriptCompiler, javascriptCompiler.exports);
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _handlebarsRuntime = handlebars_runtime.exports;
  var _handlebarsRuntime2 = _interopRequireDefault2(_handlebarsRuntime);
  var _handlebarsCompilerAst = ast.exports;
  var _handlebarsCompilerAst2 = _interopRequireDefault2(_handlebarsCompilerAst);
  var _handlebarsCompilerBase = base;
  var _handlebarsCompilerCompiler = compiler;
  var _handlebarsCompilerJavascriptCompiler = javascriptCompiler.exports;
  var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault2(_handlebarsCompilerJavascriptCompiler);
  var _handlebarsCompilerVisitor = visitor.exports;
  var _handlebarsCompilerVisitor2 = _interopRequireDefault2(_handlebarsCompilerVisitor);
  var _handlebarsNoConflict = noConflict.exports;
  var _handlebarsNoConflict2 = _interopRequireDefault2(_handlebarsNoConflict);
  var _create = _handlebarsRuntime2["default"].create;
  function create2() {
    var hb = _create();
    hb.compile = function(input, options) {
      return _handlebarsCompilerCompiler.compile(input, options, hb);
    };
    hb.precompile = function(input, options) {
      return _handlebarsCompilerCompiler.precompile(input, options, hb);
    };
    hb.AST = _handlebarsCompilerAst2["default"];
    hb.Compiler = _handlebarsCompilerCompiler.Compiler;
    hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
    hb.Parser = _handlebarsCompilerBase.parser;
    hb.parse = _handlebarsCompilerBase.parse;
    hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
    return hb;
  }
  var inst = create2();
  inst.create = create2;
  _handlebarsNoConflict2["default"](inst);
  inst.Visitor = _handlebarsCompilerVisitor2["default"];
  inst["default"] = inst;
  exports["default"] = inst;
  module.exports = exports["default"];
})(handlebars, handlebars.exports);
class HbsUtil {
}
__publicField(HbsUtil, "renderComponent", async (el, hbs_file_name, data) => {
  async function renderTemplate(el2, templateSrc2, data2) {
    const template2 = handlebars.exports.compile(templateSrc2);
    $(el2).html(template2(data2));
  }
  const templateUrl = "./src/" + hbs_file_name;
  const templateSrc = await DataUtil.fetchData(templateUrl);
  await renderTemplate(el, templateSrc, data);
});
const openLocal = () => {
  console.log("click btn_openLocal");
};
const createNew = async (elm) => {
  try {
    let ret = confirm("Create new file.");
    if (ret) {
      await elm.data.bpmnModeler.importXML(elm.data.initialDiagram);
      $("#file_name").text(elm.data.fileName);
      $("#id").text("");
      console.log(elm.data.fileName);
    }
  } catch (err) {
    console.error(err);
  }
};
const uploadBpmn = () => {
  console.log("click btn_uploadBpmn");
};
const saveLocal = () => {
  console.log("click btn_saveLocal");
};
const saveSvg = () => {
  console.log("click btn_saveSvg");
};
const zoomReset = () => {
  console.log("click btn_zoomReset");
};
const zoomIn = () => {
  console.log("click btn_zoomIn");
};
const zoomOut = () => {
  console.log("click btn_zoomOut");
};
const displayKeyMap = () => {
  console.log("click btn_displayKeyMap");
};
const toggleFullscreen = () => {
  console.log("click btn_toggleFullscreen");
};
const togglePanel = () => {
  $("#properties-panel-parent").toggleClass("collapsed");
  $("#js-canvas").toggleClass("col-md-12 col-md-8");
  $("#btn-toggle > i").toggleClass("bi bi-toggle-on bi bi-toggle-off");
  return false;
};
const registerFileDrop = (containerArea, cbFunc) => {
  const handleFileSelect = (e) => {
    e.stopPropagation();
    e.preventDefault();
    const files = e.dataTransfer.files;
    const file = files[0];
    const reader = new FileReader();
    reader.onload = function(e2) {
      var xml2 = e2.target.result;
      cbFunc(xml2, file.name);
    };
    reader.readAsText(file);
  };
  const handleDragOver = (e) => {
    e.stopPropagation();
    e.preventDefault();
    e.dataTransfer.dropEffect = "copy";
  };
  containerArea.get(0).addEventListener("dragover", handleDragOver, false);
  containerArea.get(0).addEventListener("drop", handleFileSelect, false);
};
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits$6 = inherits_browser.exports;
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var hat_1 = createCommonjsModule(function(module) {
  var hat = module.exports = function(bits, base2) {
    if (!base2)
      base2 = 16;
    if (bits === void 0)
      bits = 128;
    if (bits <= 0)
      return "0";
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base2);
    for (var i = 2; digits === Infinity; i *= 2) {
      digits = Math.log(Math.pow(2, bits / i)) / Math.log(base2) * i;
    }
    var rem = digits - Math.floor(digits);
    var res = "";
    for (var i = 0; i < Math.floor(digits); i++) {
      var x = Math.floor(Math.random() * base2).toString(base2);
      res = x + res;
    }
    if (rem) {
      var b = Math.pow(base2, rem);
      var x = Math.floor(Math.random() * b).toString(base2);
      res = x + res;
    }
    var parsed = parseInt(res, base2);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
      return hat(bits, base2);
    } else
      return res;
  };
  hat.rack = function(bits, base2, expandBy) {
    var fn = function(data) {
      var iters = 0;
      do {
        if (iters++ > 10) {
          if (expandBy)
            bits += expandBy;
          else
            throw new Error("too many ID collisions, use more bits");
        }
        var id2 = hat(bits, base2);
      } while (Object.hasOwnProperty.call(hats, id2));
      hats[id2] = data;
      return id2;
    };
    var hats = fn.hats = {};
    fn.get = function(id2) {
      return fn.hats[id2];
    };
    fn.set = function(id2, value) {
      fn.hats[id2] = value;
      return fn;
    };
    fn.bits = bits || 128;
    fn.base = base2 || 16;
    return fn;
  };
});
function Ids$1(seed) {
  if (!(this instanceof Ids$1)) {
    return new Ids$1(seed);
  }
  seed = seed || [128, 36, 1];
  this._seed = seed.length ? hat_1.rack(seed[0], seed[1], seed[2]) : seed;
}
Ids$1.prototype.next = function(element) {
  return this._seed(element || true);
};
Ids$1.prototype.nextPrefixed = function(prefix2, element) {
  var id2;
  do {
    id2 = prefix2 + this.next(true);
  } while (this.assigned(id2));
  this.claim(id2, element);
  return id2;
};
Ids$1.prototype.claim = function(id2, element) {
  this._seed.set(id2, element || true);
};
Ids$1.prototype.assigned = function(id2) {
  return this._seed.get(id2) || false;
};
Ids$1.prototype.unclaim = function(id2) {
  delete this._seed.hats[id2];
};
Ids$1.prototype.clear = function() {
  var hats = this._seed.hats, id2;
  for (id2 in hats) {
    this.unclaim(id2);
  }
};
var index_esm$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": Ids$1
}, Symbol.toStringTag, { value: "Module" }));
function flatten$a(arr) {
  return Array.prototype.concat.apply([], arr);
}
var nativeToString = Object.prototype.toString;
var nativeHasOwnProperty = Object.prototype.hasOwnProperty;
function isUndefined$7(obj) {
  return obj === void 0;
}
function isDefined(obj) {
  return obj !== void 0;
}
function isNil(obj) {
  return obj == null;
}
function isArray$n(obj) {
  return nativeToString.call(obj) === "[object Array]";
}
function isObject$e(obj) {
  return nativeToString.call(obj) === "[object Object]";
}
function isNumber$1(obj) {
  return nativeToString.call(obj) === "[object Number]";
}
function isFunction$6(obj) {
  var tag = nativeToString.call(obj);
  return tag === "[object Function]" || tag === "[object AsyncFunction]" || tag === "[object GeneratorFunction]" || tag === "[object AsyncGeneratorFunction]" || tag === "[object Proxy]";
}
function isString$3(obj) {
  return nativeToString.call(obj) === "[object String]";
}
function ensureArray(obj) {
  if (isArray$n(obj)) {
    return;
  }
  throw new Error("must supply array");
}
function has(target, key) {
  return nativeHasOwnProperty.call(target, key);
}
function find$e(collection2, matcher) {
  matcher = toMatcher(matcher);
  var match2;
  forEach$q(collection2, function(val, key) {
    if (matcher(val, key)) {
      match2 = val;
      return false;
    }
  });
  return match2;
}
function findIndex$4(collection2, matcher) {
  matcher = toMatcher(matcher);
  var idx = isArray$n(collection2) ? -1 : void 0;
  forEach$q(collection2, function(val, key) {
    if (matcher(val, key)) {
      idx = key;
      return false;
    }
  });
  return idx;
}
function filter$a(collection2, matcher) {
  var result = [];
  forEach$q(collection2, function(val, key) {
    if (matcher(val, key)) {
      result.push(val);
    }
  });
  return result;
}
function forEach$q(collection2, iterator) {
  var val, result;
  if (isUndefined$7(collection2)) {
    return;
  }
  var convertKey = isArray$n(collection2) ? toNum : identity$6;
  for (var key in collection2) {
    if (has(collection2, key)) {
      val = collection2[key];
      result = iterator(val, convertKey(key));
      if (result === false) {
        return val;
      }
    }
  }
}
function without(arr, matcher) {
  if (isUndefined$7(arr)) {
    return [];
  }
  ensureArray(arr);
  matcher = toMatcher(matcher);
  return arr.filter(function(el, idx) {
    return !matcher(el, idx);
  });
}
function reduce$3(collection2, iterator, result) {
  forEach$q(collection2, function(value, idx) {
    result = iterator(result, value, idx);
  });
  return result;
}
function every(collection2, matcher) {
  return !!reduce$3(collection2, function(matches, val, key) {
    return matches && matcher(val, key);
  }, true);
}
function some$1(collection2, matcher) {
  return !!find$e(collection2, matcher);
}
function map$7(collection2, fn) {
  var result = [];
  forEach$q(collection2, function(val, key) {
    result.push(fn(val, key));
  });
  return result;
}
function keys$d(collection2) {
  return collection2 && Object.keys(collection2) || [];
}
function size(collection2) {
  return keys$d(collection2).length;
}
function values$2(collection2) {
  return map$7(collection2, function(val) {
    return val;
  });
}
function groupBy$1(collection2, extractor) {
  var grouped = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  extractor = toExtractor(extractor);
  forEach$q(collection2, function(val) {
    var discriminator = extractor(val) || "_";
    var group = grouped[discriminator];
    if (!group) {
      group = grouped[discriminator] = [];
    }
    group.push(val);
  });
  return grouped;
}
function uniqueBy(extractor) {
  extractor = toExtractor(extractor);
  var grouped = {};
  for (var _len = arguments.length, collections = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    collections[_key - 1] = arguments[_key];
  }
  forEach$q(collections, function(c) {
    return groupBy$1(c, extractor, grouped);
  });
  var result = map$7(grouped, function(val, key) {
    return val[0];
  });
  return result;
}
var unionBy = uniqueBy;
function sortBy$2(collection2, extractor) {
  extractor = toExtractor(extractor);
  var sorted = [];
  forEach$q(collection2, function(value, key) {
    var disc = extractor(value, key);
    var entry = {
      d: disc,
      v: value
    };
    for (var idx = 0; idx < sorted.length; idx++) {
      var d = sorted[idx].d;
      if (disc < d) {
        sorted.splice(idx, 0, entry);
        return;
      }
    }
    sorted.push(entry);
  });
  return map$7(sorted, function(e) {
    return e.v;
  });
}
function matchPattern$1(pattern) {
  return function(el) {
    return every(pattern, function(val, key) {
      return el[key] === val;
    });
  };
}
function toExtractor(extractor) {
  return isFunction$6(extractor) ? extractor : function(e) {
    return e[extractor];
  };
}
function toMatcher(matcher) {
  return isFunction$6(matcher) ? matcher : function(e) {
    return e === matcher;
  };
}
function identity$6(arg) {
  return arg;
}
function toNum(arg) {
  return Number(arg);
}
function debounce$3(fn, timeout) {
  var timer2;
  var lastArgs;
  var lastThis;
  var lastNow;
  function fire(force) {
    var now2 = Date.now();
    var scheduledDiff = force ? 0 : lastNow + timeout - now2;
    if (scheduledDiff > 0) {
      return schedule(scheduledDiff);
    }
    fn.apply(lastThis, lastArgs);
    clear2();
  }
  function schedule(timeout2) {
    timer2 = setTimeout(fire, timeout2);
  }
  function clear2() {
    if (timer2) {
      clearTimeout(timer2);
    }
    timer2 = lastNow = lastArgs = lastThis = void 0;
  }
  function flush() {
    if (timer2) {
      fire(true);
    }
    clear2();
  }
  function callback() {
    lastNow = Date.now();
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    lastThis = this;
    if (!timer2) {
      schedule(timeout);
    }
  }
  callback.flush = flush;
  callback.cancel = clear2;
  return callback;
}
function throttle(fn, interval) {
  var throttling = false;
  return function() {
    if (throttling) {
      return;
    }
    fn.apply(void 0, arguments);
    throttling = true;
    setTimeout(function() {
      throttling = false;
    }, interval);
  };
}
function bind$3(fn, target) {
  return fn.bind(target);
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function assign$e(target) {
  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    others[_key - 1] = arguments[_key];
  }
  return _extends.apply(void 0, [target].concat(others));
}
function set$2(target, path, value) {
  var currentTarget = target;
  forEach$q(path, function(key, idx) {
    if (typeof key !== "number" && typeof key !== "string") {
      throw new Error("illegal key type: " + _typeof(key) + ". Key should be of type number or string.");
    }
    if (key === "constructor") {
      throw new Error("illegal key: constructor");
    }
    if (key === "__proto__") {
      throw new Error("illegal key: __proto__");
    }
    var nextKey = path[idx + 1];
    var nextTarget = currentTarget[key];
    if (isDefined(nextKey) && isNil(nextTarget)) {
      nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];
    }
    if (isUndefined$7(nextKey)) {
      if (isUndefined$7(value)) {
        delete currentTarget[key];
      } else {
        currentTarget[key] = value;
      }
    } else {
      currentTarget = nextTarget;
    }
  });
  return target;
}
function get$6(target, path, defaultValue) {
  var currentTarget = target;
  forEach$q(path, function(key) {
    if (isNil(currentTarget)) {
      currentTarget = void 0;
      return false;
    }
    currentTarget = currentTarget[key];
  });
  return isUndefined$7(currentTarget) ? defaultValue : currentTarget;
}
function pick$3(target, properties2) {
  var result = {};
  var obj = Object(target);
  forEach$q(properties2, function(prop) {
    if (prop in obj) {
      result[prop] = target[prop];
    }
  });
  return result;
}
function omit(target, properties2) {
  var result = {};
  var obj = Object(target);
  forEach$q(obj, function(prop, key) {
    if (properties2.indexOf(key) === -1) {
      result[key] = prop;
    }
  });
  return result;
}
function merge(target) {
  for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    sources[_key2 - 1] = arguments[_key2];
  }
  if (!sources.length) {
    return target;
  }
  forEach$q(sources, function(source) {
    if (!source || !isObject$e(source)) {
      return;
    }
    forEach$q(source, function(sourceVal, key) {
      if (key === "__proto__") {
        return;
      }
      var targetVal = target[key];
      if (isObject$e(sourceVal)) {
        if (!isObject$e(targetVal)) {
          targetVal = {};
        }
        target[key] = merge(targetVal, sourceVal);
      } else {
        target[key] = sourceVal;
      }
    });
  });
  return target;
}
var index_esm$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assign: assign$e,
  bind: bind$3,
  debounce: debounce$3,
  ensureArray,
  every,
  filter: filter$a,
  find: find$e,
  findIndex: findIndex$4,
  flatten: flatten$a,
  forEach: forEach$q,
  get: get$6,
  groupBy: groupBy$1,
  has,
  isArray: isArray$n,
  isDefined,
  isFunction: isFunction$6,
  isNil,
  isNumber: isNumber$1,
  isObject: isObject$e,
  isString: isString$3,
  isUndefined: isUndefined$7,
  keys: keys$d,
  map: map$7,
  matchPattern: matchPattern$1,
  merge,
  omit,
  pick: pick$3,
  reduce: reduce$3,
  set: set$2,
  size,
  some: some$1,
  sortBy: sortBy$2,
  throttle,
  unionBy,
  uniqueBy,
  values: values$2,
  without
}, Symbol.toStringTag, { value: "Module" }));
function attr$1(el, name2, val) {
  if (arguments.length == 2) {
    return el.getAttribute(name2);
  }
  if (val === null) {
    return el.removeAttribute(name2);
  }
  el.setAttribute(name2, val);
  return el;
}
var indexOf$2 = [].indexOf;
var indexof = function(arr, obj) {
  if (indexOf$2)
    return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj)
      return i;
  }
  return -1;
};
var re$1 = /\s+/;
var toString$3 = Object.prototype.toString;
function classes$1(el) {
  return new ClassList$1(el);
}
function ClassList$1(el) {
  if (!el || !el.nodeType) {
    throw new Error("A DOM element reference is required");
  }
  this.el = el;
  this.list = el.classList;
}
ClassList$1.prototype.add = function(name2) {
  if (this.list) {
    this.list.add(name2);
    return this;
  }
  var arr = this.array();
  var i = indexof(arr, name2);
  if (!~i)
    arr.push(name2);
  this.el.className = arr.join(" ");
  return this;
};
ClassList$1.prototype.remove = function(name2) {
  if (toString$3.call(name2) == "[object RegExp]") {
    return this.removeMatching(name2);
  }
  if (this.list) {
    this.list.remove(name2);
    return this;
  }
  var arr = this.array();
  var i = indexof(arr, name2);
  if (~i)
    arr.splice(i, 1);
  this.el.className = arr.join(" ");
  return this;
};
ClassList$1.prototype.removeMatching = function(re2) {
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re2.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};
ClassList$1.prototype.toggle = function(name2, force) {
  if (this.list) {
    if (typeof force !== "undefined") {
      if (force !== this.list.toggle(name2, force)) {
        this.list.toggle(name2);
      }
    } else {
      this.list.toggle(name2);
    }
    return this;
  }
  if (typeof force !== "undefined") {
    if (!force) {
      this.remove(name2);
    } else {
      this.add(name2);
    }
  } else {
    if (this.has(name2)) {
      this.remove(name2);
    } else {
      this.add(name2);
    }
  }
  return this;
};
ClassList$1.prototype.array = function() {
  var className = this.el.getAttribute("class") || "";
  var str = className.replace(/^\s+|\s+$/g, "");
  var arr = str.split(re$1);
  if (arr[0] === "")
    arr.shift();
  return arr;
};
ClassList$1.prototype.has = ClassList$1.prototype.contains = function(name2) {
  return this.list ? this.list.contains(name2) : !!~indexof(this.array(), name2);
};
function clear$1(el) {
  var c;
  while (el.childNodes.length) {
    c = el.childNodes[0];
    el.removeChild(c);
  }
  return el;
}
var proto = typeof Element !== "undefined" ? Element.prototype : {};
var vendor = proto.matches || proto.matchesSelector || proto.webkitMatchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector;
var matchesSelector = match;
function match(el, selector2) {
  if (!el || el.nodeType !== 1)
    return false;
  if (vendor)
    return vendor.call(el, selector2);
  var nodes = el.parentNode.querySelectorAll(selector2);
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i] == el)
      return true;
  }
  return false;
}
function closest(element, selector2, checkYourSelf) {
  var currentElem = checkYourSelf ? element : element.parentNode;
  while (currentElem && currentElem.nodeType !== document.DOCUMENT_NODE && currentElem.nodeType !== document.DOCUMENT_FRAGMENT_NODE) {
    if (matchesSelector(currentElem, selector2)) {
      return currentElem;
    }
    currentElem = currentElem.parentNode;
  }
  return matchesSelector(currentElem, selector2) ? currentElem : null;
}
var bind$2 = window.addEventListener ? "addEventListener" : "attachEvent", unbind = window.removeEventListener ? "removeEventListener" : "detachEvent", prefix$6 = bind$2 !== "addEventListener" ? "on" : "";
var bind_1$1 = function(el, type, fn, capture) {
  el[bind$2](prefix$6 + type, fn, capture || false);
  return fn;
};
var unbind_1 = function(el, type, fn, capture) {
  el[unbind](prefix$6 + type, fn, capture || false);
  return fn;
};
var componentEvent = {
  bind: bind_1$1,
  unbind: unbind_1
};
var forceCaptureEvents = ["focus", "blur"];
function bind$1$1(el, selector2, type, fn, capture) {
  if (forceCaptureEvents.indexOf(type) !== -1) {
    capture = true;
  }
  return componentEvent.bind(el, type, function(e) {
    var target = e.target || e.srcElement;
    e.delegateTarget = closest(target, selector2, true);
    if (e.delegateTarget) {
      fn.call(el, e);
    }
  }, capture);
}
function unbind$1(el, type, fn, capture) {
  if (forceCaptureEvents.indexOf(type) !== -1) {
    capture = true;
  }
  return componentEvent.unbind(el, type, fn, capture);
}
var delegate$1 = {
  bind: bind$1$1,
  unbind: unbind$1
};
var domify$h = parse$2;
var innerHTMLBug = false;
var bugTestDiv;
if (typeof document !== "undefined") {
  bugTestDiv = document.createElement("div");
  bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
  innerHTMLBug = !bugTestDiv.getElementsByTagName("link").length;
  bugTestDiv = void 0;
}
var map$6 = {
  legend: [1, "<fieldset>", "</fieldset>"],
  tr: [2, "<table><tbody>", "</tbody></table>"],
  col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
  _default: innerHTMLBug ? [1, "X<div>", "</div>"] : [0, "", ""]
};
map$6.td = map$6.th = [3, "<table><tbody><tr>", "</tr></tbody></table>"];
map$6.option = map$6.optgroup = [1, '<select multiple="multiple">', "</select>"];
map$6.thead = map$6.tbody = map$6.colgroup = map$6.caption = map$6.tfoot = [1, "<table>", "</table>"];
map$6.polyline = map$6.ellipse = map$6.polygon = map$6.circle = map$6.text = map$6.line = map$6.path = map$6.rect = map$6.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', "</svg>"];
function parse$2(html, doc) {
  if (typeof html != "string")
    throw new TypeError("String expected");
  if (!doc)
    doc = document;
  var m = /<([\w:]+)/.exec(html);
  if (!m)
    return doc.createTextNode(html);
  html = html.replace(/^\s+|\s+$/g, "");
  var tag = m[1];
  if (tag == "body") {
    var el = doc.createElement("html");
    el.innerHTML = html;
    return el.removeChild(el.lastChild);
  }
  var wrap = map$6[tag] || map$6._default;
  var depth = wrap[0];
  var prefix2 = wrap[1];
  var suffix = wrap[2];
  var el = doc.createElement("div");
  el.innerHTML = prefix2 + html + suffix;
  while (depth--)
    el = el.lastChild;
  if (el.firstChild == el.lastChild) {
    return el.removeChild(el.firstChild);
  }
  var fragment = doc.createDocumentFragment();
  while (el.firstChild) {
    fragment.appendChild(el.removeChild(el.firstChild));
  }
  return fragment;
}
function query(selector2, el) {
  el = el || document;
  return el.querySelector(selector2);
}
function all(selector2, el) {
  el = el || document;
  return el.querySelectorAll(selector2);
}
function remove$5(el) {
  el.parentNode && el.parentNode.removeChild(el);
}
var index_esm$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attr: attr$1,
  classes: classes$1,
  clear: clear$1,
  closest,
  delegate: delegate$1,
  domify: domify$h,
  event: componentEvent,
  matches: matchesSelector,
  query,
  queryAll: all,
  remove: remove$5
}, Symbol.toStringTag, { value: "Module" }));
function ensureImported(element, target) {
  if (element.ownerDocument !== target.ownerDocument) {
    try {
      return target.ownerDocument.importNode(element, true);
    } catch (e) {
    }
  }
  return element;
}
function appendTo(element, target) {
  return target.appendChild(ensureImported(element, target));
}
function append$3(target, node2) {
  appendTo(node2, target);
  return target;
}
var LENGTH_ATTR = 2;
var CSS_PROPERTIES = {
  "alignment-baseline": 1,
  "baseline-shift": 1,
  "clip": 1,
  "clip-path": 1,
  "clip-rule": 1,
  "color": 1,
  "color-interpolation": 1,
  "color-interpolation-filters": 1,
  "color-profile": 1,
  "color-rendering": 1,
  "cursor": 1,
  "direction": 1,
  "display": 1,
  "dominant-baseline": 1,
  "enable-background": 1,
  "fill": 1,
  "fill-opacity": 1,
  "fill-rule": 1,
  "filter": 1,
  "flood-color": 1,
  "flood-opacity": 1,
  "font": 1,
  "font-family": 1,
  "font-size": LENGTH_ATTR,
  "font-size-adjust": 1,
  "font-stretch": 1,
  "font-style": 1,
  "font-variant": 1,
  "font-weight": 1,
  "glyph-orientation-horizontal": 1,
  "glyph-orientation-vertical": 1,
  "image-rendering": 1,
  "kerning": 1,
  "letter-spacing": 1,
  "lighting-color": 1,
  "marker": 1,
  "marker-end": 1,
  "marker-mid": 1,
  "marker-start": 1,
  "mask": 1,
  "opacity": 1,
  "overflow": 1,
  "pointer-events": 1,
  "shape-rendering": 1,
  "stop-color": 1,
  "stop-opacity": 1,
  "stroke": 1,
  "stroke-dasharray": 1,
  "stroke-dashoffset": 1,
  "stroke-linecap": 1,
  "stroke-linejoin": 1,
  "stroke-miterlimit": 1,
  "stroke-opacity": 1,
  "stroke-width": LENGTH_ATTR,
  "text-anchor": 1,
  "text-decoration": 1,
  "text-rendering": 1,
  "unicode-bidi": 1,
  "visibility": 1,
  "word-spacing": 1,
  "writing-mode": 1
};
function getAttribute$1(node2, name2) {
  if (CSS_PROPERTIES[name2]) {
    return node2.style[name2];
  } else {
    return node2.getAttributeNS(null, name2);
  }
}
function setAttribute(node2, name2, value) {
  var hyphenated = name2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  var type = CSS_PROPERTIES[hyphenated];
  if (type) {
    if (type === LENGTH_ATTR && typeof value === "number") {
      value = String(value) + "px";
    }
    node2.style[hyphenated] = value;
  } else {
    node2.setAttributeNS(null, name2, value);
  }
}
function setAttributes(node2, attrs) {
  var names = Object.keys(attrs), i, name2;
  for (i = 0, name2; name2 = names[i]; i++) {
    setAttribute(node2, name2, attrs[name2]);
  }
}
function attr(node2, name2, value) {
  if (typeof name2 === "string") {
    if (value !== void 0) {
      setAttribute(node2, name2, value);
    } else {
      return getAttribute$1(node2, name2);
    }
  } else {
    setAttributes(node2, name2);
  }
  return node2;
}
function index$1(arr, obj) {
  if (arr.indexOf) {
    return arr.indexOf(obj);
  }
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) {
      return i;
    }
  }
  return -1;
}
var re = /\s+/;
var toString$2 = Object.prototype.toString;
function defined(o) {
  return typeof o !== "undefined";
}
function classes(el) {
  return new ClassList(el);
}
function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error("A DOM element reference is required");
  }
  this.el = el;
  this.list = el.classList;
}
ClassList.prototype.add = function(name2) {
  if (this.list) {
    this.list.add(name2);
    return this;
  }
  var arr = this.array();
  var i = index$1(arr, name2);
  if (!~i) {
    arr.push(name2);
  }
  if (defined(this.el.className.baseVal)) {
    this.el.className.baseVal = arr.join(" ");
  } else {
    this.el.className = arr.join(" ");
  }
  return this;
};
ClassList.prototype.remove = function(name2) {
  if (toString$2.call(name2) === "[object RegExp]") {
    return this.removeMatching(name2);
  }
  if (this.list) {
    this.list.remove(name2);
    return this;
  }
  var arr = this.array();
  var i = index$1(arr, name2);
  if (~i) {
    arr.splice(i, 1);
  }
  this.el.className.baseVal = arr.join(" ");
  return this;
};
ClassList.prototype.removeMatching = function(re2) {
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re2.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};
ClassList.prototype.toggle = function(name2, force) {
  if (this.list) {
    if (defined(force)) {
      if (force !== this.list.toggle(name2, force)) {
        this.list.toggle(name2);
      }
    } else {
      this.list.toggle(name2);
    }
    return this;
  }
  if (defined(force)) {
    if (!force) {
      this.remove(name2);
    } else {
      this.add(name2);
    }
  } else {
    if (this.has(name2)) {
      this.remove(name2);
    } else {
      this.add(name2);
    }
  }
  return this;
};
ClassList.prototype.array = function() {
  var className = this.el.getAttribute("class") || "";
  var str = className.replace(/^\s+|\s+$/g, "");
  var arr = str.split(re);
  if (arr[0] === "") {
    arr.shift();
  }
  return arr;
};
ClassList.prototype.has = ClassList.prototype.contains = function(name2) {
  return this.list ? this.list.contains(name2) : !!~index$1(this.array(), name2);
};
function remove$4(element) {
  var parent2 = element.parentNode;
  if (parent2) {
    parent2.removeChild(element);
  }
  return element;
}
function clear(element) {
  var child;
  while (child = element.firstChild) {
    remove$4(child);
  }
  return element;
}
function clone$1(element) {
  return element.cloneNode(true);
}
var ns = {
  svg: "http://www.w3.org/2000/svg"
};
var SVG_START = '<svg xmlns="' + ns.svg + '"';
function parse$1(svg) {
  var unwrap = false;
  if (svg.substring(0, 4) === "<svg") {
    if (svg.indexOf(ns.svg) === -1) {
      svg = SVG_START + svg.substring(4);
    }
  } else {
    svg = SVG_START + ">" + svg + "</svg>";
    unwrap = true;
  }
  var parsed = parseDocument(svg);
  if (!unwrap) {
    return parsed;
  }
  var fragment = document.createDocumentFragment();
  var parent2 = parsed.firstChild;
  while (parent2.firstChild) {
    fragment.appendChild(parent2.firstChild);
  }
  return fragment;
}
function parseDocument(svg) {
  var parser2;
  parser2 = new DOMParser();
  parser2.async = false;
  return parser2.parseFromString(svg, "text/xml");
}
function create$2(name2, attrs) {
  var element;
  if (name2.charAt(0) === "<") {
    element = parse$1(name2).firstChild;
    element = document.importNode(element, true);
  } else {
    element = document.createElementNS(ns.svg, name2);
  }
  if (attrs) {
    attr(element, attrs);
  }
  return element;
}
var node = create$2("svg");
function extend$1(object, props) {
  var i, k, keys2 = Object.keys(props);
  for (i = 0; k = keys2[i]; i++) {
    object[k] = props[k];
  }
  return object;
}
function createMatrix(a, b, c, d, e, f) {
  var matrix = node.createSVGMatrix();
  switch (arguments.length) {
    case 0:
      return matrix;
    case 1:
      return extend$1(matrix, a);
    case 6:
      return extend$1(matrix, {
        a,
        b,
        c,
        d,
        e,
        f
      });
  }
}
function createTransform(matrix) {
  if (matrix) {
    return node.createSVGTransformFromMatrix(matrix);
  } else {
    return node.createSVGTransform();
  }
}
var TEXT_ENTITIES = /([&<>]{1})/g;
var ATTR_ENTITIES = /([\n\r"]{1})/g;
var ENTITY_REPLACEMENT = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "'"
};
function escape$1(str, pattern) {
  function replaceFn(match2, entity) {
    return ENTITY_REPLACEMENT[entity] || entity;
  }
  return str.replace(pattern, replaceFn);
}
function serialize(node2, output) {
  var i, len, attrMap, attrNode, childNodes;
  switch (node2.nodeType) {
    case 3:
      output.push(escape$1(node2.textContent, TEXT_ENTITIES));
      break;
    case 1:
      output.push("<", node2.tagName);
      if (node2.hasAttributes()) {
        attrMap = node2.attributes;
        for (i = 0, len = attrMap.length; i < len; ++i) {
          attrNode = attrMap.item(i);
          output.push(" ", attrNode.name, '="', escape$1(attrNode.value, ATTR_ENTITIES), '"');
        }
      }
      if (node2.hasChildNodes()) {
        output.push(">");
        childNodes = node2.childNodes;
        for (i = 0, len = childNodes.length; i < len; ++i) {
          serialize(childNodes.item(i), output);
        }
        output.push("</", node2.tagName, ">");
      } else {
        output.push("/>");
      }
      break;
    case 8:
      output.push("<!--", escape$1(node2.nodeValue, TEXT_ENTITIES), "-->");
      break;
    case 4:
      output.push("<![CDATA[", node2.nodeValue, "]]>");
      break;
    default:
      throw new Error("unable to handle node " + node2.nodeType);
  }
  return output;
}
function set$1(element, svg) {
  var parsed = parse$1(svg);
  clear(element);
  if (!svg) {
    return;
  }
  if (!isFragment(parsed)) {
    parsed = parsed.documentElement;
  }
  var nodes = slice$1(parsed.childNodes);
  for (var i = 0; i < nodes.length; i++) {
    appendTo(nodes[i], element);
  }
}
function get$5(element) {
  var child = element.firstChild, output = [];
  while (child) {
    serialize(child, output);
    child = child.nextSibling;
  }
  return output.join("");
}
function isFragment(node2) {
  return node2.nodeName === "#document-fragment";
}
function innerSVG(element, svg) {
  if (svg !== void 0) {
    try {
      set$1(element, svg);
    } catch (e) {
      throw new Error("error parsing SVG: " + e.message);
    }
    return element;
  } else {
    return get$5(element);
  }
}
function slice$1(arr) {
  return Array.prototype.slice.call(arr);
}
function wrapMatrix(transformList, transform2) {
  if (transform2 instanceof SVGMatrix) {
    return transformList.createSVGTransformFromMatrix(transform2);
  }
  return transform2;
}
function setTransforms(transformList, transforms) {
  var i, t;
  transformList.clear();
  for (i = 0; t = transforms[i]; i++) {
    transformList.appendItem(wrapMatrix(transformList, t));
  }
}
function transform$2(node2, transforms) {
  var transformList = node2.transform.baseVal;
  if (transforms) {
    if (!Array.isArray(transforms)) {
      transforms = [transforms];
    }
    setTransforms(transformList, transforms);
  }
  return transformList.consolidate();
}
var CLASS_PATTERN = /^class /;
function isClass(fn) {
  return CLASS_PATTERN.test(fn.toString());
}
function isArray$m(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
}
function hasOwnProp(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function annotate() {
  var args = Array.prototype.slice.call(arguments);
  if (args.length === 1 && isArray$m(args[0])) {
    args = args[0];
  }
  var fn = args.pop();
  fn.$inject = args;
  return fn;
}
var CONSTRUCTOR_ARGS = /constructor\s*[^(]*\(\s*([^)]*)\)/m;
var FN_ARGS = /^(?:async )?(?:function\s*)?[^(]*\(\s*([^)]*)\)/m;
var FN_ARG = /\/\*([^*]*)\*\//m;
function parseAnnotations(fn) {
  if (typeof fn !== "function") {
    throw new Error('Cannot annotate "' + fn + '". Expected a function!');
  }
  var match2 = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);
  if (!match2) {
    return [];
  }
  return match2[1] && match2[1].split(",").map(function(arg) {
    match2 = arg.match(FN_ARG);
    return match2 ? match2[1].trim() : arg.trim();
  }) || [];
}
function Module() {
  var providers = [];
  this.factory = function(name2, factory2) {
    providers.push([name2, "factory", factory2]);
    return this;
  };
  this.value = function(name2, value) {
    providers.push([name2, "value", value]);
    return this;
  };
  this.type = function(name2, type) {
    providers.push([name2, "type", type]);
    return this;
  };
  this.forEach = function(iterator) {
    providers.forEach(iterator);
  };
}
function Injector(modules, parent2) {
  parent2 = parent2 || {
    get: function(name2, strict) {
      currentlyResolving.push(name2);
      if (strict === false) {
        return null;
      } else {
        throw error2('No provider for "' + name2 + '"!');
      }
    }
  };
  var currentlyResolving = [];
  var providers = this._providers = Object.create(parent2._providers || null);
  var instances = this._instances = /* @__PURE__ */ Object.create(null);
  var self2 = instances.injector = this;
  var error2 = function(msg) {
    var stack = currentlyResolving.join(" -> ");
    currentlyResolving.length = 0;
    return new Error(stack ? msg + " (Resolving: " + stack + ")" : msg);
  };
  var get2 = function(name2, strict) {
    if (!providers[name2] && name2.indexOf(".") !== -1) {
      var parts = name2.split(".");
      var pivot = get2(parts.shift());
      while (parts.length) {
        pivot = pivot[parts.shift()];
      }
      return pivot;
    }
    if (hasOwnProp(instances, name2)) {
      return instances[name2];
    }
    if (hasOwnProp(providers, name2)) {
      if (currentlyResolving.indexOf(name2) !== -1) {
        currentlyResolving.push(name2);
        throw error2("Cannot resolve circular dependency!");
      }
      currentlyResolving.push(name2);
      instances[name2] = providers[name2][0](providers[name2][1]);
      currentlyResolving.pop();
      return instances[name2];
    }
    return parent2.get(name2, strict);
  };
  var fnDef = function(fn, locals) {
    if (typeof locals === "undefined") {
      locals = {};
    }
    if (typeof fn !== "function") {
      if (isArray$m(fn)) {
        fn = annotate(fn.slice());
      } else {
        throw new Error('Cannot invoke "' + fn + '". Expected a function!');
      }
    }
    var inject = fn.$inject || parseAnnotations(fn);
    var dependencies = inject.map(function(dep) {
      if (hasOwnProp(locals, dep)) {
        return locals[dep];
      } else {
        return get2(dep);
      }
    });
    return {
      fn,
      dependencies
    };
  };
  var instantiate = function(Type) {
    var def = fnDef(Type);
    var fn = def.fn, dependencies = def.dependencies;
    var Constructor = Function.prototype.bind.apply(fn, [null].concat(dependencies));
    return new Constructor();
  };
  var invoke = function(func, context, locals) {
    var def = fnDef(func, locals);
    var fn = def.fn, dependencies = def.dependencies;
    return fn.apply(context, dependencies);
  };
  var createPrivateInjectorFactory = function(privateChildInjector) {
    return annotate(function(key) {
      return privateChildInjector.get(key);
    });
  };
  var createChild = function(modules2, forceNewInstances) {
    if (forceNewInstances && forceNewInstances.length) {
      var fromParentModule = /* @__PURE__ */ Object.create(null);
      var matchedScopes = /* @__PURE__ */ Object.create(null);
      var privateInjectorsCache = [];
      var privateChildInjectors = [];
      var privateChildFactories = [];
      var provider;
      var cacheIdx;
      var privateChildInjector;
      var privateChildInjectorFactory;
      for (var name2 in providers) {
        provider = providers[name2];
        if (forceNewInstances.indexOf(name2) !== -1) {
          if (provider[2] === "private") {
            cacheIdx = privateInjectorsCache.indexOf(provider[3]);
            if (cacheIdx === -1) {
              privateChildInjector = provider[3].createChild([], forceNewInstances);
              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);
              privateInjectorsCache.push(provider[3]);
              privateChildInjectors.push(privateChildInjector);
              privateChildFactories.push(privateChildInjectorFactory);
              fromParentModule[name2] = [privateChildInjectorFactory, name2, "private", privateChildInjector];
            } else {
              fromParentModule[name2] = [privateChildFactories[cacheIdx], name2, "private", privateChildInjectors[cacheIdx]];
            }
          } else {
            fromParentModule[name2] = [provider[2], provider[1]];
          }
          matchedScopes[name2] = true;
        }
        if ((provider[2] === "factory" || provider[2] === "type") && provider[1].$scope) {
          forceNewInstances.forEach(function(scope) {
            if (provider[1].$scope.indexOf(scope) !== -1) {
              fromParentModule[name2] = [provider[2], provider[1]];
              matchedScopes[scope] = true;
            }
          });
        }
      }
      forceNewInstances.forEach(function(scope) {
        if (!matchedScopes[scope]) {
          throw new Error('No provider for "' + scope + '". Cannot use provider from the parent!');
        }
      });
      modules2.unshift(fromParentModule);
    }
    return new Injector(modules2, self2);
  };
  var factoryMap = {
    factory: invoke,
    type: instantiate,
    value: function(value) {
      return value;
    }
  };
  modules.forEach(function(module) {
    function arrayUnwrap(type, value) {
      if (type !== "value" && isArray$m(value)) {
        value = annotate(value.slice());
      }
      return value;
    }
    if (module instanceof Module) {
      module.forEach(function(provider) {
        var name2 = provider[0];
        var type = provider[1];
        var value = provider[2];
        providers[name2] = [factoryMap[type], arrayUnwrap(type, value), type];
      });
    } else if (typeof module === "object") {
      if (module.__exports__) {
        var clonedModule = Object.keys(module).reduce(function(m, key) {
          if (key.substring(0, 2) !== "__") {
            m[key] = module[key];
          }
          return m;
        }, /* @__PURE__ */ Object.create(null));
        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self2);
        var getFromPrivateInjector = annotate(function(key) {
          return privateInjector.get(key);
        });
        module.__exports__.forEach(function(key) {
          providers[key] = [getFromPrivateInjector, key, "private", privateInjector];
        });
      } else {
        Object.keys(module).forEach(function(name2) {
          if (module[name2][2] === "private") {
            providers[name2] = module[name2];
            return;
          }
          var type = module[name2][0];
          var value = module[name2][1];
          providers[name2] = [factoryMap[type], arrayUnwrap(type, value), type];
        });
      }
    }
  });
  this.get = get2;
  this.invoke = invoke;
  this.instantiate = instantiate;
  this.createChild = createChild;
}
var DEFAULT_RENDER_PRIORITY$1 = 1e3;
function BaseRenderer(eventBus, renderPriority) {
  var self2 = this;
  renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY$1;
  eventBus.on(["render.shape", "render.connection"], renderPriority, function(evt, context) {
    var type = evt.type, element = context.element, visuals = context.gfx, attrs = context.attrs;
    if (self2.canRender(element)) {
      if (type === "render.shape") {
        return self2.drawShape(visuals, element, attrs);
      } else {
        return self2.drawConnection(visuals, element, attrs);
      }
    }
  });
  eventBus.on(["render.getShapePath", "render.getConnectionPath"], renderPriority, function(evt, element) {
    if (self2.canRender(element)) {
      if (evt.type === "render.getShapePath") {
        return self2.getShapePath(element);
      } else {
        return self2.getConnectionPath(element);
      }
    }
  });
}
BaseRenderer.prototype.canRender = function() {
};
BaseRenderer.prototype.drawShape = function() {
};
BaseRenderer.prototype.drawConnection = function() {
};
BaseRenderer.prototype.getShapePath = function() {
};
BaseRenderer.prototype.getConnectionPath = function() {
};
function componentsToPath(elements) {
  return elements.join(",").replace(/,?([A-z]),?/g, "$1");
}
function toSVGPoints$1(points) {
  var result = "";
  for (var i = 0, p; p = points[i]; i++) {
    result += p.x + "," + p.y + " ";
  }
  return result;
}
function createLine$1(points, attrs) {
  var line = create$2("polyline");
  attr(line, { points: toSVGPoints$1(points) });
  if (attrs) {
    attr(line, attrs);
  }
  return line;
}
function updateLine$1(gfx, points) {
  attr(gfx, { points: toSVGPoints$1(points) });
  return gfx;
}
function getParents$2(elements) {
  return filter$a(elements, function(element) {
    return !find$e(elements, function(e) {
      return e !== element && getParent$2(element, e);
    });
  });
}
function getParent$2(element, parent2) {
  if (!parent2) {
    return;
  }
  if (element === parent2) {
    return parent2;
  }
  if (!element.parent) {
    return;
  }
  return getParent$2(element.parent, parent2);
}
function add$3(elements, e, unique) {
  var canAdd = !unique || elements.indexOf(e) === -1;
  if (canAdd) {
    elements.push(e);
  }
  return canAdd;
}
function eachElement$1(elements, fn, depth) {
  depth = depth || 0;
  if (!isArray$n(elements)) {
    elements = [elements];
  }
  forEach$q(elements, function(s, i) {
    var filter2 = fn(s, i, depth);
    if (isArray$n(filter2) && filter2.length) {
      eachElement$1(filter2, fn, depth + 1);
    }
  });
}
function selfAndChildren(elements, unique, maxDepth) {
  var result = [], processedChildren = [];
  eachElement$1(elements, function(element, i, depth) {
    add$3(result, element, unique);
    var children = element.children;
    if (maxDepth === -1 || depth < maxDepth) {
      if (children && add$3(processedChildren, children, unique)) {
        return children;
      }
    }
  });
  return result;
}
function selfAndAllChildren(elements, allowDuplicates) {
  return selfAndChildren(elements, !allowDuplicates, -1);
}
function getClosure(elements, isTopLevel, closure) {
  if (isUndefined$7(isTopLevel)) {
    isTopLevel = true;
  }
  if (isObject$e(isTopLevel)) {
    closure = isTopLevel;
    isTopLevel = true;
  }
  closure = closure || {};
  var allShapes = copyObject$2(closure.allShapes), allConnections = copyObject$2(closure.allConnections), enclosedElements = copyObject$2(closure.enclosedElements), enclosedConnections = copyObject$2(closure.enclosedConnections);
  var topLevel = copyObject$2(closure.topLevel, isTopLevel && groupBy$1(elements, function(e) {
    return e.id;
  }));
  function handleConnection(c) {
    if (topLevel[c.source.id] && topLevel[c.target.id]) {
      topLevel[c.id] = [c];
    }
    if (allShapes[c.source.id] && allShapes[c.target.id]) {
      enclosedConnections[c.id] = enclosedElements[c.id] = c;
    }
    allConnections[c.id] = c;
  }
  function handleElement(element) {
    enclosedElements[element.id] = element;
    if (element.waypoints) {
      enclosedConnections[element.id] = allConnections[element.id] = element;
    } else {
      allShapes[element.id] = element;
      forEach$q(element.incoming, handleConnection);
      forEach$q(element.outgoing, handleConnection);
      return element.children;
    }
  }
  eachElement$1(elements, handleElement);
  return {
    allShapes,
    allConnections,
    topLevel,
    enclosedConnections,
    enclosedElements
  };
}
function getBBox(elements, stopRecursion) {
  stopRecursion = !!stopRecursion;
  if (!isArray$n(elements)) {
    elements = [elements];
  }
  var minX, minY, maxX, maxY;
  forEach$q(elements, function(element) {
    var bbox = element;
    if (element.waypoints && !stopRecursion) {
      bbox = getBBox(element.waypoints, true);
    }
    var x = bbox.x, y = bbox.y, height = bbox.height || 0, width = bbox.width || 0;
    if (x < minX || minX === void 0) {
      minX = x;
    }
    if (y < minY || minY === void 0) {
      minY = y;
    }
    if (x + width > maxX || maxX === void 0) {
      maxX = x + width;
    }
    if (y + height > maxY || maxY === void 0) {
      maxY = y + height;
    }
  });
  return {
    x: minX,
    y: minY,
    height: maxY - minY,
    width: maxX - minX
  };
}
function getEnclosedElements(elements, bbox) {
  var filteredElements = {};
  forEach$q(elements, function(element) {
    var e = element;
    if (e.waypoints) {
      e = getBBox(e);
    }
    if (!isNumber$1(bbox.y) && e.x > bbox.x) {
      filteredElements[element.id] = element;
    }
    if (!isNumber$1(bbox.x) && e.y > bbox.y) {
      filteredElements[element.id] = element;
    }
    if (e.x > bbox.x && e.y > bbox.y) {
      if (isNumber$1(bbox.width) && isNumber$1(bbox.height) && e.width + e.x < bbox.width + bbox.x && e.height + e.y < bbox.height + bbox.y) {
        filteredElements[element.id] = element;
      } else if (!isNumber$1(bbox.width) || !isNumber$1(bbox.height)) {
        filteredElements[element.id] = element;
      }
    }
  });
  return filteredElements;
}
function getType(element) {
  if ("waypoints" in element) {
    return "connection";
  }
  if ("x" in element) {
    return "shape";
  }
  return "root";
}
function isFrameElement$1(element) {
  return !!(element && element.isFrame);
}
function copyObject$2(src1, src2) {
  return assign$e({}, src1 || {}, src2 || {});
}
var DEFAULT_RENDER_PRIORITY = 1;
function DefaultRenderer(eventBus, styles) {
  BaseRenderer.call(this, eventBus, DEFAULT_RENDER_PRIORITY);
  this.CONNECTION_STYLE = styles.style(["no-fill"], { strokeWidth: 5, stroke: "fuchsia" });
  this.SHAPE_STYLE = styles.style({ fill: "white", stroke: "fuchsia", strokeWidth: 2 });
  this.FRAME_STYLE = styles.style(["no-fill"], { stroke: "fuchsia", strokeDasharray: 4, strokeWidth: 2 });
}
inherits$6(DefaultRenderer, BaseRenderer);
DefaultRenderer.prototype.canRender = function() {
  return true;
};
DefaultRenderer.prototype.drawShape = function drawShape(visuals, element, attrs) {
  var rect = create$2("rect");
  attr(rect, {
    x: 0,
    y: 0,
    width: element.width || 0,
    height: element.height || 0
  });
  if (isFrameElement$1(element)) {
    attr(rect, assign$e({}, this.FRAME_STYLE, attrs || {}));
  } else {
    attr(rect, assign$e({}, this.SHAPE_STYLE, attrs || {}));
  }
  append$3(visuals, rect);
  return rect;
};
DefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection, attrs) {
  var line = createLine$1(connection.waypoints, assign$e({}, this.CONNECTION_STYLE, attrs || {}));
  append$3(visuals, line);
  return line;
};
DefaultRenderer.prototype.getShapePath = function getShapePath(shape) {
  var x = shape.x, y = shape.y, width = shape.width, height = shape.height;
  var shapePath = [
    ["M", x, y],
    ["l", width, 0],
    ["l", 0, height],
    ["l", -width, 0],
    ["z"]
  ];
  return componentsToPath(shapePath);
};
DefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {
  var waypoints = connection.waypoints;
  var idx, point, connectionPath = [];
  for (idx = 0; point = waypoints[idx]; idx++) {
    point = point.original || point;
    connectionPath.push([idx === 0 ? "M" : "L", point.x, point.y]);
  }
  return componentsToPath(connectionPath);
};
DefaultRenderer.$inject = ["eventBus", "styles"];
function Styles() {
  var defaultTraits = {
    "no-fill": {
      fill: "none"
    },
    "no-border": {
      strokeOpacity: 0
    },
    "no-events": {
      pointerEvents: "none"
    }
  };
  var self2 = this;
  this.cls = function(className, traits, additionalAttrs) {
    var attrs = this.style(traits, additionalAttrs);
    return assign$e(attrs, { "class": className });
  };
  this.style = function(traits, additionalAttrs) {
    if (!isArray$n(traits) && !additionalAttrs) {
      additionalAttrs = traits;
      traits = [];
    }
    var attrs = reduce$3(traits, function(attrs2, t) {
      return assign$e(attrs2, defaultTraits[t] || {});
    }, {});
    return additionalAttrs ? assign$e(attrs, additionalAttrs) : attrs;
  };
  this.computeStyle = function(custom, traits, defaultStyles) {
    if (!isArray$n(traits)) {
      defaultStyles = traits;
      traits = [];
    }
    return self2.style(traits || [], assign$e({}, defaultStyles, custom || {}));
  };
}
var DrawModule$1 = {
  __init__: ["defaultRenderer"],
  defaultRenderer: ["type", DefaultRenderer],
  styles: ["type", Styles]
};
function remove$3(collection2, element) {
  if (!collection2 || !element) {
    return -1;
  }
  var idx = collection2.indexOf(element);
  if (idx !== -1) {
    collection2.splice(idx, 1);
  }
  return idx;
}
function add$2(collection2, element, idx) {
  if (!collection2 || !element) {
    return;
  }
  if (typeof idx !== "number") {
    idx = -1;
  }
  var currentIdx = collection2.indexOf(element);
  if (currentIdx !== -1) {
    if (currentIdx === idx) {
      return;
    } else {
      if (idx !== -1) {
        collection2.splice(currentIdx, 1);
      } else {
        return;
      }
    }
  }
  if (idx !== -1) {
    collection2.splice(idx, 0, element);
  } else {
    collection2.push(element);
  }
}
function indexOf$1(collection2, element) {
  if (!collection2 || !element) {
    return -1;
  }
  return collection2.indexOf(element);
}
function pointDistance(a, b) {
  if (!a || !b) {
    return -1;
  }
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}
function pointsOnLine(p, q, r, accuracy) {
  if (typeof accuracy === "undefined") {
    accuracy = 5;
  }
  if (!p || !q || !r) {
    return false;
  }
  var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x), dist = pointDistance(p, q);
  return Math.abs(val / dist) <= accuracy;
}
var ALIGNED_THRESHOLD = 2;
function pointsAligned(a, b) {
  var points;
  if (isArray$n(a)) {
    points = a;
  } else {
    points = [a, b];
  }
  if (pointsAlignedHorizontally(points)) {
    return "h";
  }
  if (pointsAlignedVertically(points)) {
    return "v";
  }
  return false;
}
function pointsAlignedHorizontally(a, b) {
  var points;
  if (isArray$n(a)) {
    points = a;
  } else {
    points = [a, b];
  }
  var firstPoint = points.slice().shift();
  return every(points, function(point) {
    return Math.abs(firstPoint.y - point.y) <= ALIGNED_THRESHOLD;
  });
}
function pointsAlignedVertically(a, b) {
  var points;
  if (isArray$n(a)) {
    points = a;
  } else {
    points = [a, b];
  }
  var firstPoint = points.slice().shift();
  return every(points, function(point) {
    return Math.abs(firstPoint.x - point.x) <= ALIGNED_THRESHOLD;
  });
}
function pointInRect(p, rect, tolerance) {
  tolerance = tolerance || 0;
  return p.x > rect.x - tolerance && p.y > rect.y - tolerance && p.x < rect.x + rect.width + tolerance && p.y < rect.y + rect.height + tolerance;
}
function getMidPoint(p, q) {
  return {
    x: Math.round(p.x + (q.x - p.x) / 2),
    y: Math.round(p.y + (q.y - p.y) / 2)
  };
}
var p2s = /,?([a-z]),?/gi, toFloat = parseFloat, math = Math, PI = math.PI, mmin = math.min, mmax = math.max, pow = math.pow, abs$7 = math.abs, pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?[\s]*,?[\s]*)+)/ig, pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)[\s]*,?[\s]*/ig;
var isArray$l = Array.isArray || function(o) {
  return o instanceof Array;
};
function hasProperty(obj, property2) {
  return Object.prototype.hasOwnProperty.call(obj, property2);
}
function clone(obj) {
  if (typeof obj == "function" || Object(obj) !== obj) {
    return obj;
  }
  var res = new obj.constructor();
  for (var key in obj) {
    if (hasProperty(obj, key)) {
      res[key] = clone(obj[key]);
    }
  }
  return res;
}
function repush(array, item) {
  for (var i = 0, ii = array.length; i < ii; i++)
    if (array[i] === item) {
      return array.push(array.splice(i, 1)[0]);
    }
}
function cacher(f) {
  function newf() {
    var arg = Array.prototype.slice.call(arguments, 0), args = arg.join("\u2400"), cache = newf.cache = newf.cache || {}, count = newf.count = newf.count || [];
    if (hasProperty(cache, args)) {
      repush(count, args);
      return cache[args];
    }
    count.length >= 1e3 && delete cache[count.shift()];
    count.push(args);
    cache[args] = f.apply(0, arg);
    return cache[args];
  }
  return newf;
}
function parsePathString(pathString) {
  if (!pathString) {
    return null;
  }
  var pth = paths(pathString);
  if (pth.arr) {
    return clone(pth.arr);
  }
  var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, data = [];
  if (isArray$l(pathString) && isArray$l(pathString[0])) {
    data = clone(pathString);
  }
  if (!data.length) {
    String(pathString).replace(pathCommand, function(a, b, c) {
      var params = [], name2 = b.toLowerCase();
      c.replace(pathValues, function(a2, b2) {
        b2 && params.push(+b2);
      });
      if (name2 == "m" && params.length > 2) {
        data.push([b].concat(params.splice(0, 2)));
        name2 = "l";
        b = b == "m" ? "l" : "L";
      }
      while (params.length >= paramCounts[name2]) {
        data.push([b].concat(params.splice(0, paramCounts[name2])));
        if (!paramCounts[name2]) {
          break;
        }
      }
    });
  }
  data.toString = paths.toString;
  pth.arr = clone(data);
  return data;
}
function paths(ps) {
  var p = paths.ps = paths.ps || {};
  if (p[ps]) {
    p[ps].sleep = 100;
  } else {
    p[ps] = {
      sleep: 100
    };
  }
  setTimeout(function() {
    for (var key in p) {
      if (hasProperty(p, key) && key != ps) {
        p[key].sleep--;
        !p[key].sleep && delete p[key];
      }
    }
  });
  return p[ps];
}
function rectBBox(x, y, width, height) {
  if (arguments.length === 1) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }
  return {
    x,
    y,
    width,
    height,
    x2: x + width,
    y2: y + height
  };
}
function pathToString() {
  return this.join(",").replace(p2s, "$1");
}
function pathClone(pathArray) {
  var res = clone(pathArray);
  res.toString = pathToString;
  return res;
}
function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t, t13 = pow(t1, 3), t12 = pow(t1, 2), t2 = t * t, t3 = t2 * t, x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x, y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
  return {
    x: fixError(x),
    y: fixError(y)
  };
}
function bezierBBox(points) {
  var bbox = curveBBox.apply(null, points);
  return rectBBox(bbox.x0, bbox.y0, bbox.x1 - bbox.x0, bbox.y1 - bbox.y0);
}
function isPointInsideBBox$2(bbox, x, y) {
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
}
function isBBoxIntersect(bbox1, bbox2) {
  bbox1 = rectBBox(bbox1);
  bbox2 = rectBBox(bbox2);
  return isPointInsideBBox$2(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox$2(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox$2(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox$2(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox$2(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox$2(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox$2(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox$2(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
}
function base3(t, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4, t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t2 - 3 * p1 + 3 * p2;
}
function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
  if (z == null) {
    z = 1;
  }
  z = z > 1 ? 1 : z < 0 ? 0 : z;
  var z2 = z / 2, n = 12, Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816], Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472], sum = 0;
  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2, xbase = base3(ct, x1, x2, x3, x4), ybase = base3(ct, y1, y2, y3, y4), comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i] * math.sqrt(comb);
  }
  return z2 * sum;
}
function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) {
    return;
  }
  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (!denominator) {
    return;
  }
  var px = fixError(nx / denominator), py = fixError(ny / denominator), px2 = +px.toFixed(2), py2 = +py.toFixed(2);
  if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) {
    return;
  }
  return { x: px, y: py };
}
function fixError(number) {
  return Math.round(number * 1e11) / 1e11;
}
function findBezierIntersections(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1), bbox2 = bezierBBox(bez2);
  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }
  var l1 = bezlen.apply(0, bez1), l2 = bezlen.apply(0, bez2), n1 = isLine(bez1) ? 1 : ~~(l1 / 5) || 1, n2 = isLine(bez2) ? 1 : ~~(l2 / 5) || 1, dots1 = [], dots2 = [], xy = {}, res = justCount ? 0 : [];
  for (var i = 0; i < n1 + 1; i++) {
    var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({ x: p.x, y: p.y, t: i / n1 });
  }
  for (i = 0; i < n2 + 1; i++) {
    p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
    dots2.push({ x: p.x, y: p.y, t: i / n2 });
  }
  for (i = 0; i < n1; i++) {
    for (var j = 0; j < n2; j++) {
      var di = dots1[i], di1 = dots1[i + 1], dj = dots2[j], dj1 = dots2[j + 1], ci = abs$7(di1.x - di.x) < 0.01 ? "y" : "x", cj = abs$7(dj1.x - dj.x) < 0.01 ? "y" : "x", is2 = intersectLines(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y), key;
      if (is2) {
        key = is2.x.toFixed(9) + "#" + is2.y.toFixed(9);
        if (xy[key]) {
          continue;
        }
        xy[key] = true;
        var t1 = di.t + abs$7((is2[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t), t2 = dj.t + abs$7((is2[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
          if (justCount) {
            res++;
          } else {
            res.push({
              x: is2.x,
              y: is2.y,
              t1,
              t2
            });
          }
        }
      }
    }
  }
  return res;
}
function findPathIntersections(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);
  var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2, res = justCount ? 0 : [];
  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi = path1[i];
    if (pi[0] == "M") {
      x1 = x1m = pi[1];
      y1 = y1m = pi[2];
    } else {
      if (pi[0] == "C") {
        bez1 = [x1, y1].concat(pi.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }
      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];
        if (pj[0] == "M") {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {
          if (pj[0] == "C") {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }
          var intr = findBezierIntersections(bez1, bez2, justCount);
          if (justCount) {
            res += intr;
          } else {
            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            }
            res = res.concat(intr);
          }
        }
      }
    }
  }
  return res;
}
function pathToAbsolute(pathArray) {
  var pth = paths(pathArray);
  if (pth.abs) {
    return pathClone(pth.abs);
  }
  if (!isArray$l(pathArray) || !isArray$l(pathArray && pathArray[0])) {
    pathArray = parsePathString(pathArray);
  }
  if (!pathArray || !pathArray.length) {
    return [["M", 0, 0]];
  }
  var res = [], x = 0, y = 0, mx = 0, my = 0, start = 0, pa0;
  if (pathArray[0][0] == "M") {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res[0] = ["M", x, y];
  }
  for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
    res.push(r = []);
    pa = pathArray[i];
    pa0 = pa[0];
    if (pa0 != pa0.toUpperCase()) {
      r[0] = pa0.toUpperCase();
      switch (r[0]) {
        case "A":
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case "V":
          r[1] = +pa[1] + y;
          break;
        case "H":
          r[1] = +pa[1] + x;
          break;
        case "M":
          mx = +pa[1] + x;
          my = +pa[2] + y;
        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }
      }
    } else {
      for (var k = 0, kk = pa.length; k < kk; k++) {
        r[k] = pa[k];
      }
    }
    pa0 = pa0.toUpperCase();
    switch (r[0]) {
      case "Z":
        x = +mx;
        y = +my;
        break;
      case "H":
        x = r[1];
        break;
      case "V":
        y = r[1];
        break;
      case "M":
        mx = r[r.length - 2];
        my = r[r.length - 1];
      default:
        x = r[r.length - 2];
        y = r[r.length - 1];
    }
  }
  res.toString = pathToString;
  pth.abs = pathClone(res);
  return res;
}
function isLine(bez) {
  return bez[0] === bez[2] && bez[1] === bez[3] && bez[4] === bez[6] && bez[5] === bez[7];
}
function lineToCurve(x1, y1, x2, y2) {
  return [
    x1,
    y1,
    x2,
    y2,
    x2,
    y2
  ];
}
function qubicToCurve(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3, _23 = 2 / 3;
  return [
    _13 * x1 + _23 * ax,
    _13 * y1 + _23 * ay,
    _13 * x2 + _23 * ax,
    _13 * y2 + _23 * ay,
    x2,
    y2
  ];
}
function arcToCurve(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
  var _120 = PI * 120 / 180, rad = PI / 180 * (+angle || 0), res = [], xy, rotate2 = cacher(function(x3, y3, rad2) {
    var X = x3 * math.cos(rad2) - y3 * math.sin(rad2), Y = x3 * math.sin(rad2) + y3 * math.cos(rad2);
    return { x: X, y: Y };
  });
  if (!recursive) {
    xy = rotate2(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate2(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    var x = (x1 - x2) / 2, y = (y1 - y2) / 2;
    var h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    var rx2 = rx * rx, ry2 = ry * ry, k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs$7((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))), cx = k * rx * y / ry + (x1 + x2) / 2, cy = k * -ry * x / rx + (y1 + y2) / 2, f1 = math.asin(((y1 - cy) / ry).toFixed(9)), f2 = math.asin(((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? PI - f1 : f1;
    f2 = x2 < cx ? PI - f2 : f2;
    f1 < 0 && (f1 = PI * 2 + f1);
    f2 < 0 && (f2 = PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (abs$7(df) > _120) {
    var f2old = f2, x2old = x2, y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * math.cos(f2);
    y2 = cy + ry * math.sin(f2);
    res = arcToCurve(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = math.cos(f1), s1 = math.sin(f1), c2 = math.cos(f2), s2 = math.sin(f2), t = math.tan(df / 4), hx = 4 / 3 * rx * t, hy = 4 / 3 * ry * t, m1 = [x1, y1], m2 = [x1 + hx * s1, y1 - hy * c1], m3 = [x2 + hx * s2, y2 - hy * c2], m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  } else {
    res = [m2, m3, m4].concat(res).join().split(",");
    var newres = [];
    for (var i = 0, ii = res.length; i < ii; i++) {
      newres[i] = i % 2 ? rotate2(res[i - 1], res[i], rad).y : rotate2(res[i], res[i + 1], rad).x;
    }
    return newres;
  }
}
function curveBBox(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [], bounds = [[], []], a, b, c, t, t1, t2, b2ac, sqrtb2ac;
  for (var i = 0; i < 2; ++i) {
    if (i == 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }
    if (abs$7(a) < 1e-12) {
      if (abs$7(b) < 1e-12) {
        continue;
      }
      t = -c / b;
      if (0 < t && t < 1) {
        tvalues.push(t);
      }
      continue;
    }
    b2ac = b * b - 4 * c * a;
    sqrtb2ac = math.sqrt(b2ac);
    if (b2ac < 0) {
      continue;
    }
    t1 = (-b + sqrtb2ac) / (2 * a);
    if (0 < t1 && t1 < 1) {
      tvalues.push(t1);
    }
    t2 = (-b - sqrtb2ac) / (2 * a);
    if (0 < t2 && t2 < 1) {
      tvalues.push(t2);
    }
  }
  var j = tvalues.length, jlen = j, mt;
  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
  }
  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    x0: mmin.apply(0, bounds[0]),
    y0: mmin.apply(0, bounds[1]),
    x1: mmax.apply(0, bounds[0]),
    y1: mmax.apply(0, bounds[1])
  };
}
function pathToCurve(path) {
  var pth = paths(path);
  if (pth.curve) {
    return pathClone(pth.curve);
  }
  var curvedPath = pathToAbsolute(path), attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, processPath = function(path2, d, pathCommand3) {
    var nx, ny;
    if (!path2) {
      return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
    }
    !(path2[0] in { T: 1, Q: 1 }) && (d.qx = d.qy = null);
    switch (path2[0]) {
      case "M":
        d.X = path2[1];
        d.Y = path2[2];
        break;
      case "A":
        path2 = ["C"].concat(arcToCurve.apply(0, [d.x, d.y].concat(path2.slice(1))));
        break;
      case "S":
        if (pathCommand3 == "C" || pathCommand3 == "S") {
          nx = d.x * 2 - d.bx;
          ny = d.y * 2 - d.by;
        } else {
          nx = d.x;
          ny = d.y;
        }
        path2 = ["C", nx, ny].concat(path2.slice(1));
        break;
      case "T":
        if (pathCommand3 == "Q" || pathCommand3 == "T") {
          d.qx = d.x * 2 - d.qx;
          d.qy = d.y * 2 - d.qy;
        } else {
          d.qx = d.x;
          d.qy = d.y;
        }
        path2 = ["C"].concat(qubicToCurve(d.x, d.y, d.qx, d.qy, path2[1], path2[2]));
        break;
      case "Q":
        d.qx = path2[1];
        d.qy = path2[2];
        path2 = ["C"].concat(qubicToCurve(d.x, d.y, path2[1], path2[2], path2[3], path2[4]));
        break;
      case "L":
        path2 = ["C"].concat(lineToCurve(d.x, d.y, path2[1], path2[2]));
        break;
      case "H":
        path2 = ["C"].concat(lineToCurve(d.x, d.y, path2[1], d.y));
        break;
      case "V":
        path2 = ["C"].concat(lineToCurve(d.x, d.y, d.x, path2[1]));
        break;
      case "Z":
        path2 = ["C"].concat(lineToCurve(d.x, d.y, d.X, d.Y));
        break;
    }
    return path2;
  }, fixArc = function(pp, i2) {
    if (pp[i2].length > 7) {
      pp[i2].shift();
      var pi = pp[i2];
      while (pi.length) {
        pathCommands[i2] = "A";
        pp.splice(i2++, 0, ["C"].concat(pi.splice(0, 6)));
      }
      pp.splice(i2, 1);
      ii = curvedPath.length;
    }
  }, pathCommands = [], pfirst = "", pathCommand2 = "";
  for (var i = 0, ii = curvedPath.length; i < ii; i++) {
    curvedPath[i] && (pfirst = curvedPath[i][0]);
    if (pfirst != "C") {
      pathCommands[i] = pfirst;
      i && (pathCommand2 = pathCommands[i - 1]);
    }
    curvedPath[i] = processPath(curvedPath[i], attrs, pathCommand2);
    if (pathCommands[i] != "A" && pfirst == "C")
      pathCommands[i] = "C";
    fixArc(curvedPath, i);
    var seg = curvedPath[i], seglen = seg.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
  }
  pth.curve = pathClone(curvedPath);
  return curvedPath;
}
var intersect = findPathIntersections;
var intersectPaths = intersect;
function roundBounds(bounds) {
  return {
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  };
}
function roundPoint(point) {
  return {
    x: Math.round(point.x),
    y: Math.round(point.y)
  };
}
function asTRBL(bounds) {
  return {
    top: bounds.y,
    right: bounds.x + (bounds.width || 0),
    bottom: bounds.y + (bounds.height || 0),
    left: bounds.x
  };
}
function asBounds(trbl) {
  return {
    x: trbl.left,
    y: trbl.top,
    width: trbl.right - trbl.left,
    height: trbl.bottom - trbl.top
  };
}
function getMid(bounds) {
  return roundPoint({
    x: bounds.x + (bounds.width || 0) / 2,
    y: bounds.y + (bounds.height || 0) / 2
  });
}
function getOrientation(rect, reference, padding) {
  padding = padding || 0;
  if (!isObject$e(padding)) {
    padding = { x: padding, y: padding };
  }
  var rectOrientation = asTRBL(rect), referenceOrientation = asTRBL(reference);
  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top, right = rectOrientation.left - padding.x >= referenceOrientation.right, bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom, left = rectOrientation.right + padding.x <= referenceOrientation.left;
  var vertical = top ? "top" : bottom ? "bottom" : null, horizontal = left ? "left" : right ? "right" : null;
  if (horizontal && vertical) {
    return vertical + "-" + horizontal;
  } else {
    return horizontal || vertical || "intersect";
  }
}
function getElementLineIntersection(elementPath, linePath2, cropStart) {
  var intersections = getIntersections(elementPath, linePath2);
  if (intersections.length === 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length > 1) {
    intersections = sortBy$2(intersections, function(i) {
      var distance = Math.floor(i.t2 * 100) || 1;
      distance = 100 - distance;
      distance = (distance < 10 ? "0" : "") + distance;
      return i.segment2 + "#" + distance;
    });
    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);
  }
  return null;
}
function getIntersections(a, b) {
  return intersectPaths(a, b);
}
function filterRedundantWaypoints(waypoints) {
  waypoints = waypoints.slice();
  var idx = 0, point, previousPoint, nextPoint;
  while (waypoints[idx]) {
    point = waypoints[idx];
    previousPoint = waypoints[idx - 1];
    nextPoint = waypoints[idx + 1];
    if (pointDistance(point, nextPoint) === 0 || pointsOnLine(previousPoint, nextPoint, point)) {
      waypoints.splice(idx, 1);
    } else {
      idx++;
    }
  }
  return waypoints;
}
function round$b(number, resolution) {
  return Math.round(number * resolution) / resolution;
}
function ensurePx(number) {
  return isNumber$1(number) ? number + "px" : number;
}
function findRoot(element) {
  while (element.parent) {
    element = element.parent;
  }
  return element;
}
function createContainer(options) {
  options = assign$e({}, { width: "100%", height: "100%" }, options);
  var container = options.container || document.body;
  var parent2 = document.createElement("div");
  parent2.setAttribute("class", "djs-container");
  assign$e(parent2.style, {
    position: "relative",
    overflow: "hidden",
    width: ensurePx(options.width),
    height: ensurePx(options.height)
  });
  container.appendChild(parent2);
  return parent2;
}
function createGroup(parent2, cls, childIndex) {
  var group = create$2("g");
  classes(group).add(cls);
  var index2 = childIndex !== void 0 ? childIndex : parent2.childNodes.length - 1;
  parent2.insertBefore(group, parent2.childNodes[index2] || null);
  return group;
}
var BASE_LAYER = "base";
var HIDDEN_MARKER = "djs-element-hidden";
var PLANE_LAYER_INDEX = 0;
var UTILITY_LAYER_INDEX = 1;
var REQUIRED_MODEL_ATTRS = {
  shape: ["x", "y", "width", "height"],
  connection: ["waypoints"]
};
function Canvas(config, eventBus, graphicsFactory, elementRegistry) {
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;
  this._init(config || {});
}
Canvas.$inject = [
  "config.canvas",
  "eventBus",
  "graphicsFactory",
  "elementRegistry"
];
Canvas.prototype._init = function(config) {
  var eventBus = this._eventBus;
  var container = this._container = createContainer(config);
  var svg = this._svg = create$2("svg");
  attr(svg, { width: "100%", height: "100%" });
  append$3(container, svg);
  var viewport = this._viewport = createGroup(svg, "viewport");
  this._layers = {};
  this._planes = {};
  if (config.deferUpdate !== false) {
    this._viewboxChanged = debounce$3(bind$3(this._viewboxChanged, this), 300);
  }
  eventBus.on("diagram.init", function() {
    eventBus.fire("canvas.init", {
      svg,
      viewport
    });
  }, this);
  eventBus.on([
    "shape.added",
    "connection.added",
    "shape.removed",
    "connection.removed",
    "elements.changed",
    "plane.set"
  ], function() {
    delete this._cachedViewbox;
  }, this);
  eventBus.on("diagram.destroy", 500, this._destroy, this);
  eventBus.on("diagram.clear", 500, this._clear, this);
};
Canvas.prototype._destroy = function(emit) {
  this._eventBus.fire("canvas.destroy", {
    svg: this._svg,
    viewport: this._viewport
  });
  var parent2 = this._container.parentNode;
  if (parent2) {
    parent2.removeChild(this._container);
  }
  delete this._svg;
  delete this._container;
  delete this._layers;
  delete this._planes;
  delete this._activePlane;
  delete this._viewport;
};
Canvas.prototype._clear = function() {
  var self2 = this;
  var allElements = this._elementRegistry.getAll();
  allElements.forEach(function(element) {
    var type = getType(element);
    if (type === "root") {
      self2.setRootElementForPlane(null, self2.findPlane(element), true);
    } else {
      self2._removeElement(element, type);
    }
  });
  this._activePlane = null;
  this._planes = {};
  delete this._cachedViewbox;
};
Canvas.prototype.getDefaultLayer = function() {
  return this.getLayer(BASE_LAYER, PLANE_LAYER_INDEX);
};
Canvas.prototype.getLayer = function(name2, index2) {
  if (!name2) {
    throw new Error("must specify a name");
  }
  var layer = this._layers[name2];
  if (!layer) {
    layer = this._layers[name2] = this._createLayer(name2, index2);
  }
  if (typeof index2 !== "undefined" && layer.index !== index2) {
    throw new Error("layer <" + name2 + "> already created at index <" + index2 + ">");
  }
  return layer.group;
};
Canvas.prototype._createLayer = function(name2, index2) {
  if (typeof index2 === "undefined") {
    index2 = UTILITY_LAYER_INDEX;
  }
  var childIndex = reduce$3(this._layers, function(childIndex2, layer) {
    if (index2 >= layer.index) {
      childIndex2++;
    }
    return childIndex2;
  }, 0);
  return {
    group: createGroup(this._viewport, "layer-" + name2, childIndex),
    index: index2
  };
};
Canvas.prototype.getPlane = function(name2) {
  if (!name2) {
    throw new Error("must specify a name");
  }
  return this._planes[name2];
};
Canvas.prototype.createPlane = function(name2, rootElement) {
  if (!name2) {
    throw new Error("must specify a name");
  }
  if (this._planes[name2]) {
    throw new Error("plane " + name2 + " already exists");
  }
  if (!rootElement) {
    rootElement = {
      id: "__implicitroot" + name2,
      children: [],
      isImplicit: true
    };
  }
  var svgLayer = this.getLayer(name2, PLANE_LAYER_INDEX);
  classes(svgLayer).add(HIDDEN_MARKER);
  var plane = this._planes[name2] = {
    layer: svgLayer,
    name: name2,
    rootElement: null
  };
  this.setRootElementForPlane(rootElement, plane);
  return plane;
};
Canvas.prototype.setActivePlane = function(plane) {
  if (!plane) {
    throw new Error("must specify a plane");
  }
  if (typeof plane === "string") {
    plane = this.getPlane(plane);
  }
  if (this._activePlane) {
    classes(this._activePlane.layer).add(HIDDEN_MARKER);
  }
  this._activePlane = plane;
  classes(plane.layer).remove(HIDDEN_MARKER);
  if (plane.rootElement) {
    this._elementRegistry.updateGraphics(plane.rootElement, this._svg, true);
  }
  this._eventBus.fire("plane.set", { plane });
  return plane;
};
Canvas.prototype.getActiveLayer = function() {
  return this.getActivePlane().layer;
};
Canvas.prototype.getActivePlane = function() {
  var plane = this._activePlane;
  if (!plane) {
    plane = this.createPlane(BASE_LAYER);
    this.setActivePlane(BASE_LAYER);
  }
  return plane;
};
Canvas.prototype.findPlane = function(element) {
  if (typeof element === "string") {
    element = this._elementRegistry.get(element);
  }
  var root2 = findRoot(element);
  return find$e(this._planes, function(plane) {
    return plane.rootElement === root2;
  });
};
Canvas.prototype.getContainer = function() {
  return this._container;
};
Canvas.prototype._updateMarker = function(element, marker, add2) {
  var container;
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }
  container = this._elementRegistry._elements[element.id];
  if (!container) {
    return;
  }
  forEach$q([container.gfx, container.secondaryGfx], function(gfx) {
    if (gfx) {
      if (add2) {
        classes(gfx).add(marker);
      } else {
        classes(gfx).remove(marker);
      }
    }
  });
  this._eventBus.fire("element.marker.update", { element, gfx: container.gfx, marker, add: !!add2 });
};
Canvas.prototype.addMarker = function(element, marker) {
  this._updateMarker(element, marker, true);
};
Canvas.prototype.removeMarker = function(element, marker) {
  this._updateMarker(element, marker, false);
};
Canvas.prototype.hasMarker = function(element, marker) {
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }
  var gfx = this.getGraphics(element);
  return classes(gfx).has(marker);
};
Canvas.prototype.toggleMarker = function(element, marker) {
  if (this.hasMarker(element, marker)) {
    this.removeMarker(element, marker);
  } else {
    this.addMarker(element, marker);
  }
};
Canvas.prototype.getRootElement = function() {
  var plane = this.getActivePlane();
  return plane.rootElement;
};
Canvas.prototype.setRootElement = function(element, override) {
  var activePlane = this._activePlane;
  if (activePlane) {
    return this.setRootElementForPlane(element, activePlane, override);
  } else {
    var basePlane = this.createPlane(BASE_LAYER, element);
    this.setActivePlane(basePlane);
    return basePlane.rootElement;
  }
};
Canvas.prototype.setRootElementForPlane = function(element, plane, override) {
  if (typeof plane === "string") {
    plane = this.getPlane(plane);
  }
  if (element) {
    this._ensureValid("root", element);
  }
  var currentRoot = plane.rootElement, elementRegistry = this._elementRegistry, eventBus = this._eventBus;
  if (currentRoot) {
    if (!override) {
      throw new Error("rootElement already set, need to specify override");
    }
    eventBus.fire("root.remove", { element: currentRoot });
    eventBus.fire("root.removed", { element: currentRoot });
    elementRegistry.remove(currentRoot);
  }
  if (element) {
    var gfx = plane.layer;
    eventBus.fire("root.add", { element });
    elementRegistry.add(element, gfx);
    eventBus.fire("root.added", { element, gfx });
    if (plane === this._activePlane) {
      this._elementRegistry.updateGraphics(element, this._svg, true);
    }
  }
  plane.rootElement = element;
  return element;
};
Canvas.prototype._ensureValid = function(type, element) {
  if (!element.id) {
    throw new Error("element must have an id");
  }
  if (this._elementRegistry.get(element.id)) {
    throw new Error("element with id " + element.id + " already exists");
  }
  var requiredAttrs = REQUIRED_MODEL_ATTRS[type];
  var valid = every(requiredAttrs, function(attr2) {
    return typeof element[attr2] !== "undefined";
  });
  if (!valid) {
    throw new Error("must supply { " + requiredAttrs.join(", ") + " } with " + type);
  }
};
Canvas.prototype._setParent = function(element, parent2, parentIndex) {
  add$2(parent2.children, element, parentIndex);
  element.parent = parent2;
};
Canvas.prototype._addElement = function(type, element, parent2, parentIndex) {
  parent2 = parent2 || this.getRootElement();
  var eventBus = this._eventBus, graphicsFactory = this._graphicsFactory;
  this._ensureValid(type, element);
  eventBus.fire(type + ".add", { element, parent: parent2 });
  this._setParent(element, parent2, parentIndex);
  var gfx = graphicsFactory.create(type, element, parentIndex);
  this._elementRegistry.add(element, gfx);
  graphicsFactory.update(type, element, gfx);
  eventBus.fire(type + ".added", { element, gfx });
  return element;
};
Canvas.prototype.addShape = function(shape, parent2, parentIndex) {
  return this._addElement("shape", shape, parent2, parentIndex);
};
Canvas.prototype.addConnection = function(connection, parent2, parentIndex) {
  return this._addElement("connection", connection, parent2, parentIndex);
};
Canvas.prototype._removeElement = function(element, type) {
  var elementRegistry = this._elementRegistry, graphicsFactory = this._graphicsFactory, eventBus = this._eventBus;
  element = elementRegistry.get(element.id || element);
  if (!element) {
    return;
  }
  eventBus.fire(type + ".remove", { element });
  graphicsFactory.remove(element);
  remove$3(element.parent && element.parent.children, element);
  element.parent = null;
  eventBus.fire(type + ".removed", { element });
  elementRegistry.remove(element);
  return element;
};
Canvas.prototype.removeShape = function(shape) {
  return this._removeElement(shape, "shape");
};
Canvas.prototype.removeConnection = function(connection) {
  return this._removeElement(connection, "connection");
};
Canvas.prototype.getGraphics = function(element, secondary) {
  return this._elementRegistry.getGraphics(element, secondary);
};
Canvas.prototype._changeViewbox = function(changeFn) {
  this._eventBus.fire("canvas.viewbox.changing");
  changeFn.apply(this);
  this._cachedViewbox = null;
  this._viewboxChanged();
};
Canvas.prototype._viewboxChanged = function() {
  this._eventBus.fire("canvas.viewbox.changed", { viewbox: this.viewbox() });
};
Canvas.prototype.viewbox = function(box) {
  if (box === void 0 && this._cachedViewbox) {
    return this._cachedViewbox;
  }
  var viewport = this._viewport, innerBox, outerBox = this.getSize(), matrix, transform2, scale, x, y;
  if (!box) {
    innerBox = this._activePlane && this._activePlane.layer.getBBox() || {};
    transform2 = transform$2(viewport);
    matrix = transform2 ? transform2.matrix : createMatrix();
    scale = round$b(matrix.a, 1e3);
    x = round$b(-matrix.e || 0, 1e3);
    y = round$b(-matrix.f || 0, 1e3);
    box = this._cachedViewbox = {
      x: x ? x / scale : 0,
      y: y ? y / scale : 0,
      width: outerBox.width / scale,
      height: outerBox.height / scale,
      scale,
      inner: {
        width: innerBox.width || 0,
        height: innerBox.height || 0,
        x: innerBox.x || 0,
        y: innerBox.y || 0
      },
      outer: outerBox
    };
    return box;
  } else {
    this._changeViewbox(function() {
      scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);
      var matrix2 = this._svg.createSVGMatrix().scale(scale).translate(-box.x, -box.y);
      transform$2(viewport, matrix2);
    });
  }
  return box;
};
Canvas.prototype.scroll = function(delta2) {
  var node2 = this._viewport;
  var matrix = node2.getCTM();
  if (delta2) {
    this._changeViewbox(function() {
      delta2 = assign$e({ dx: 0, dy: 0 }, delta2 || {});
      matrix = this._svg.createSVGMatrix().translate(delta2.dx, delta2.dy).multiply(matrix);
      setCTM(node2, matrix);
    });
  }
  return { x: matrix.e, y: matrix.f };
};
Canvas.prototype.scrollToElement = function(element, padding) {
  var defaultPadding = 100;
  if (typeof element === "string") {
    element = this._elementRegistry.get(element);
  }
  var targetPlane = this.findPlane(element);
  if (targetPlane !== this._activePlane) {
    this.setActivePlane(targetPlane);
  }
  if (!padding) {
    padding = {};
  }
  if (typeof padding === "number") {
    defaultPadding = padding;
  }
  padding = {
    top: padding.top || defaultPadding,
    right: padding.right || defaultPadding,
    bottom: padding.bottom || defaultPadding,
    left: padding.left || defaultPadding
  };
  var elementBounds = getBBox(element), elementTrbl = asTRBL(elementBounds), viewboxBounds = this.viewbox(), zoom2 = this.zoom(), dx, dy;
  viewboxBounds.y += padding.top / zoom2;
  viewboxBounds.x += padding.left / zoom2;
  viewboxBounds.width -= (padding.right + padding.left) / zoom2;
  viewboxBounds.height -= (padding.bottom + padding.top) / zoom2;
  var viewboxTrbl = asTRBL(viewboxBounds);
  var canFit = elementBounds.width < viewboxBounds.width && elementBounds.height < viewboxBounds.height;
  if (!canFit) {
    dx = elementBounds.x - viewboxBounds.x;
    dy = elementBounds.y - viewboxBounds.y;
  } else {
    var dRight = Math.max(0, elementTrbl.right - viewboxTrbl.right), dLeft = Math.min(0, elementTrbl.left - viewboxTrbl.left), dBottom = Math.max(0, elementTrbl.bottom - viewboxTrbl.bottom), dTop = Math.min(0, elementTrbl.top - viewboxTrbl.top);
    dx = dRight || dLeft;
    dy = dBottom || dTop;
  }
  this.scroll({ dx: -dx * zoom2, dy: -dy * zoom2 });
};
Canvas.prototype.zoom = function(newScale, center2) {
  if (!newScale) {
    return this.viewbox(newScale).scale;
  }
  if (newScale === "fit-viewport") {
    return this._fitViewport(center2);
  }
  var outer, matrix;
  this._changeViewbox(function() {
    if (typeof center2 !== "object") {
      outer = this.viewbox().outer;
      center2 = {
        x: outer.width / 2,
        y: outer.height / 2
      };
    }
    matrix = this._setZoom(newScale, center2);
  });
  return round$b(matrix.a, 1e3);
};
function setCTM(node2, m) {
  var mstr = "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.e + "," + m.f + ")";
  node2.setAttribute("transform", mstr);
}
Canvas.prototype._fitViewport = function(center2) {
  var vbox = this.viewbox(), outer = vbox.outer, inner2 = vbox.inner, newScale, newViewbox;
  if (inner2.x >= 0 && inner2.y >= 0 && inner2.x + inner2.width <= outer.width && inner2.y + inner2.height <= outer.height && !center2) {
    newViewbox = {
      x: 0,
      y: 0,
      width: Math.max(inner2.width + inner2.x, outer.width),
      height: Math.max(inner2.height + inner2.y, outer.height)
    };
  } else {
    newScale = Math.min(1, outer.width / inner2.width, outer.height / inner2.height);
    newViewbox = {
      x: inner2.x + (center2 ? inner2.width / 2 - outer.width / newScale / 2 : 0),
      y: inner2.y + (center2 ? inner2.height / 2 - outer.height / newScale / 2 : 0),
      width: outer.width / newScale,
      height: outer.height / newScale
    };
  }
  this.viewbox(newViewbox);
  return this.viewbox(false).scale;
};
Canvas.prototype._setZoom = function(scale, center2) {
  var svg = this._svg, viewport = this._viewport;
  var matrix = svg.createSVGMatrix();
  var point = svg.createSVGPoint();
  var centerPoint, originalPoint, currentMatrix, scaleMatrix, newMatrix;
  currentMatrix = viewport.getCTM();
  var currentScale = currentMatrix.a;
  if (center2) {
    centerPoint = assign$e(point, center2);
    originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());
    scaleMatrix = matrix.translate(originalPoint.x, originalPoint.y).scale(1 / currentScale * scale).translate(-originalPoint.x, -originalPoint.y);
    newMatrix = currentMatrix.multiply(scaleMatrix);
  } else {
    newMatrix = matrix.scale(scale);
  }
  setCTM(this._viewport, newMatrix);
  return newMatrix;
};
Canvas.prototype.getSize = function() {
  return {
    width: this._container.clientWidth,
    height: this._container.clientHeight
  };
};
Canvas.prototype.getAbsoluteBBox = function(element) {
  var vbox = this.viewbox();
  var bbox;
  if (element.waypoints) {
    var gfx = this.getGraphics(element);
    bbox = gfx.getBBox();
  } else {
    bbox = element;
  }
  var x = bbox.x * vbox.scale - vbox.x * vbox.scale;
  var y = bbox.y * vbox.scale - vbox.y * vbox.scale;
  var width = bbox.width * vbox.scale;
  var height = bbox.height * vbox.scale;
  return {
    x,
    y,
    width,
    height
  };
};
Canvas.prototype.resized = function() {
  delete this._cachedViewbox;
  this._eventBus.fire("canvas.resized");
};
var ELEMENT_ID = "data-element-id";
function ElementRegistry(eventBus) {
  this._elements = {};
  this._eventBus = eventBus;
}
ElementRegistry.$inject = ["eventBus"];
ElementRegistry.prototype.add = function(element, gfx, secondaryGfx) {
  var id2 = element.id;
  this._validateId(id2);
  attr(gfx, ELEMENT_ID, id2);
  if (secondaryGfx) {
    attr(secondaryGfx, ELEMENT_ID, id2);
  }
  this._elements[id2] = { element, gfx, secondaryGfx };
};
ElementRegistry.prototype.remove = function(element) {
  var elements = this._elements, id2 = element.id || element, container = id2 && elements[id2];
  if (container) {
    attr(container.gfx, ELEMENT_ID, "");
    if (container.secondaryGfx) {
      attr(container.secondaryGfx, ELEMENT_ID, "");
    }
    delete elements[id2];
  }
};
ElementRegistry.prototype.updateId = function(element, newId) {
  this._validateId(newId);
  if (typeof element === "string") {
    element = this.get(element);
  }
  this._eventBus.fire("element.updateId", {
    element,
    newId
  });
  var gfx = this.getGraphics(element), secondaryGfx = this.getGraphics(element, true);
  this.remove(element);
  element.id = newId;
  this.add(element, gfx, secondaryGfx);
};
ElementRegistry.prototype.updateGraphics = function(filter2, gfx, secondary) {
  var id2 = filter2.id || filter2;
  var container = this._elements[id2];
  if (secondary) {
    container.secondaryGfx = gfx;
  } else {
    container.gfx = gfx;
  }
  attr(gfx, ELEMENT_ID, id2);
  return gfx;
};
ElementRegistry.prototype.get = function(filter2) {
  var id2;
  if (typeof filter2 === "string") {
    id2 = filter2;
  } else {
    id2 = filter2 && attr(filter2, ELEMENT_ID);
  }
  var container = this._elements[id2];
  return container && container.element;
};
ElementRegistry.prototype.filter = function(fn) {
  var filtered = [];
  this.forEach(function(element, gfx) {
    if (fn(element, gfx)) {
      filtered.push(element);
    }
  });
  return filtered;
};
ElementRegistry.prototype.find = function(fn) {
  var map2 = this._elements, keys2 = Object.keys(map2);
  for (var i = 0; i < keys2.length; i++) {
    var id2 = keys2[i], container = map2[id2], element = container.element, gfx = container.gfx;
    if (fn(element, gfx)) {
      return element;
    }
  }
};
ElementRegistry.prototype.getAll = function() {
  return this.filter(function(e) {
    return e;
  });
};
ElementRegistry.prototype.forEach = function(fn) {
  var map2 = this._elements;
  Object.keys(map2).forEach(function(id2) {
    var container = map2[id2], element = container.element, gfx = container.gfx;
    return fn(element, gfx);
  });
};
ElementRegistry.prototype.getGraphics = function(filter2, secondary) {
  var id2 = filter2.id || filter2;
  var container = this._elements[id2];
  return container && (secondary ? container.secondaryGfx : container.gfx);
};
ElementRegistry.prototype._validateId = function(id2) {
  if (!id2) {
    throw new Error("element must have an id");
  }
  if (this._elements[id2]) {
    throw new Error("element with id " + id2 + " already added");
  }
};
var objectRefs = { exports: {} };
var collection = {};
function extend(collection2, refs2, property2, target) {
  var inverseProperty = property2.inverse;
  Object.defineProperty(collection2, "remove", {
    value: function(element) {
      var idx = this.indexOf(element);
      if (idx !== -1) {
        this.splice(idx, 1);
        refs2.unset(element, inverseProperty, target);
      }
      return element;
    }
  });
  Object.defineProperty(collection2, "contains", {
    value: function(element) {
      return this.indexOf(element) !== -1;
    }
  });
  Object.defineProperty(collection2, "add", {
    value: function(element, idx) {
      var currentIdx = this.indexOf(element);
      if (typeof idx === "undefined") {
        if (currentIdx !== -1) {
          return;
        }
        idx = this.length;
      }
      if (currentIdx !== -1) {
        this.splice(currentIdx, 1);
      }
      this.splice(idx, 0, element);
      if (currentIdx === -1) {
        refs2.set(element, inverseProperty, target);
      }
    }
  });
  Object.defineProperty(collection2, "__refs_collection", {
    value: true
  });
  return collection2;
}
function isExtended(collection2) {
  return collection2.__refs_collection === true;
}
collection.extend = extend;
collection.isExtended = isExtended;
var Collection = collection;
function hasOwnProperty$f(e, property2) {
  return Object.prototype.hasOwnProperty.call(e, property2.name || property2);
}
function defineCollectionProperty(ref, property2, target) {
  var collection2 = Collection.extend(target[property2.name] || [], ref, property2, target);
  Object.defineProperty(target, property2.name, {
    enumerable: property2.enumerable,
    value: collection2
  });
  if (collection2.length) {
    collection2.forEach(function(o) {
      ref.set(o, property2.inverse, target);
    });
  }
}
function defineProperty$4(ref, property2, target) {
  var inverseProperty = property2.inverse;
  var _value = target[property2.name];
  Object.defineProperty(target, property2.name, {
    configurable: property2.configurable,
    enumerable: property2.enumerable,
    get: function() {
      return _value;
    },
    set: function(value) {
      if (value === _value) {
        return;
      }
      var old = _value;
      _value = null;
      if (old) {
        ref.unset(old, inverseProperty, target);
      }
      _value = value;
      ref.set(_value, inverseProperty, target);
    }
  });
}
function Refs$1(a, b) {
  if (!(this instanceof Refs$1)) {
    return new Refs$1(a, b);
  }
  a.inverse = b;
  b.inverse = a;
  this.props = {};
  this.props[a.name] = a;
  this.props[b.name] = b;
}
Refs$1.prototype.bind = function(target, property2) {
  if (typeof property2 === "string") {
    if (!this.props[property2]) {
      throw new Error("no property <" + property2 + "> in ref");
    }
    property2 = this.props[property2];
  }
  if (property2.collection) {
    defineCollectionProperty(this, property2, target);
  } else {
    defineProperty$4(this, property2, target);
  }
};
Refs$1.prototype.ensureRefsCollection = function(target, property2) {
  var collection2 = target[property2.name];
  if (!Collection.isExtended(collection2)) {
    defineCollectionProperty(this, property2, target);
  }
  return collection2;
};
Refs$1.prototype.ensureBound = function(target, property2) {
  if (!hasOwnProperty$f(target, property2)) {
    this.bind(target, property2);
  }
};
Refs$1.prototype.unset = function(target, property2, value) {
  if (target) {
    this.ensureBound(target, property2);
    if (property2.collection) {
      this.ensureRefsCollection(target, property2).remove(value);
    } else {
      target[property2.name] = void 0;
    }
  }
};
Refs$1.prototype.set = function(target, property2, value) {
  if (target) {
    this.ensureBound(target, property2);
    if (property2.collection) {
      this.ensureRefsCollection(target, property2).add(value);
    } else {
      target[property2.name] = value;
    }
  }
};
var refs = Refs$1;
objectRefs.exports = refs;
objectRefs.exports.Collection = collection;
var Refs = objectRefs.exports;
var parentRefs = new Refs({ name: "children", enumerable: true, collection: true }, { name: "parent" }), labelRefs = new Refs({ name: "labels", enumerable: true, collection: true }, { name: "labelTarget" }), attacherRefs = new Refs({ name: "attachers", collection: true }, { name: "host" }), outgoingRefs = new Refs({ name: "outgoing", collection: true }, { name: "source" }), incomingRefs = new Refs({ name: "incoming", collection: true }, { name: "target" });
function Base$1() {
  Object.defineProperty(this, "businessObject", {
    writable: true
  });
  Object.defineProperty(this, "label", {
    get: function() {
      return this.labels[0];
    },
    set: function(newLabel) {
      var label2 = this.label, labels = this.labels;
      if (!newLabel && label2) {
        labels.remove(label2);
      } else {
        labels.add(newLabel, 0);
      }
    }
  });
  parentRefs.bind(this, "parent");
  labelRefs.bind(this, "labels");
  outgoingRefs.bind(this, "outgoing");
  incomingRefs.bind(this, "incoming");
}
function Shape() {
  Base$1.call(this);
  parentRefs.bind(this, "children");
  attacherRefs.bind(this, "host");
  attacherRefs.bind(this, "attachers");
}
inherits$6(Shape, Base$1);
function Root() {
  Shape.call(this);
}
inherits$6(Root, Shape);
function Label() {
  Shape.call(this);
  labelRefs.bind(this, "labelTarget");
}
inherits$6(Label, Shape);
function Connection() {
  Base$1.call(this);
  outgoingRefs.bind(this, "source");
  incomingRefs.bind(this, "target");
}
inherits$6(Connection, Base$1);
var types$6 = {
  connection: Connection,
  shape: Shape,
  label: Label,
  root: Root
};
function create$1(type, attrs) {
  var Type = types$6[type];
  if (!Type) {
    throw new Error("unknown type: <" + type + ">");
  }
  return assign$e(new Type(), attrs);
}
function ElementFactory$1() {
  this._uid = 12;
}
ElementFactory$1.prototype.createRoot = function(attrs) {
  return this.create("root", attrs);
};
ElementFactory$1.prototype.createLabel = function(attrs) {
  return this.create("label", attrs);
};
ElementFactory$1.prototype.createShape = function(attrs) {
  return this.create("shape", attrs);
};
ElementFactory$1.prototype.createConnection = function(attrs) {
  return this.create("connection", attrs);
};
ElementFactory$1.prototype.create = function(type, attrs) {
  attrs = assign$e({}, attrs || {});
  if (!attrs.id) {
    attrs.id = type + "_" + this._uid++;
  }
  return create$1(type, attrs);
};
var FN_REF = "__fn";
var DEFAULT_PRIORITY$8 = 1e3;
var slice = Array.prototype.slice;
function EventBus() {
  this._listeners = {};
  this.on("diagram.destroy", 1, this._destroy, this);
}
EventBus.prototype.on = function(events, priority, callback, that) {
  events = isArray$n(events) ? events : [events];
  if (isFunction$6(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY$8;
  }
  if (!isNumber$1(priority)) {
    throw new Error("priority must be a number");
  }
  var actualCallback = callback;
  if (that) {
    actualCallback = bind$3(callback, that);
    actualCallback[FN_REF] = callback[FN_REF] || callback;
  }
  var self2 = this;
  events.forEach(function(e) {
    self2._addListener(e, {
      priority,
      callback: actualCallback,
      next: null
    });
  });
};
EventBus.prototype.once = function(event, priority, callback, that) {
  var self2 = this;
  if (isFunction$6(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY$8;
  }
  if (!isNumber$1(priority)) {
    throw new Error("priority must be a number");
  }
  function wrappedCallback() {
    wrappedCallback.__isTomb = true;
    var result = callback.apply(that, arguments);
    self2.off(event, wrappedCallback);
    return result;
  }
  wrappedCallback[FN_REF] = callback;
  this.on(event, priority, wrappedCallback);
};
EventBus.prototype.off = function(events, callback) {
  events = isArray$n(events) ? events : [events];
  var self2 = this;
  events.forEach(function(event) {
    self2._removeListener(event, callback);
  });
};
EventBus.prototype.createEvent = function(data) {
  var event = new InternalEvent();
  event.init(data);
  return event;
};
EventBus.prototype.fire = function(type, data) {
  var event, firstListener, returnValue, args;
  args = slice.call(arguments);
  if (typeof type === "object") {
    data = type;
    type = data.type;
  }
  if (!type) {
    throw new Error("no event type specified");
  }
  firstListener = this._listeners[type];
  if (!firstListener) {
    return;
  }
  if (data instanceof InternalEvent) {
    event = data;
  } else {
    event = this.createEvent(data);
  }
  args[0] = event;
  var originalType = event.type;
  if (type !== originalType) {
    event.type = type;
  }
  try {
    returnValue = this._invokeListeners(event, args, firstListener);
  } finally {
    if (type !== originalType) {
      event.type = originalType;
    }
  }
  if (returnValue === void 0 && event.defaultPrevented) {
    returnValue = false;
  }
  return returnValue;
};
EventBus.prototype.handleError = function(error2) {
  return this.fire("error", { error: error2 }) === false;
};
EventBus.prototype._destroy = function() {
  this._listeners = {};
};
EventBus.prototype._invokeListeners = function(event, args, listener2) {
  var returnValue;
  while (listener2) {
    if (event.cancelBubble) {
      break;
    }
    returnValue = this._invokeListener(event, args, listener2);
    listener2 = listener2.next;
  }
  return returnValue;
};
EventBus.prototype._invokeListener = function(event, args, listener2) {
  var returnValue;
  if (listener2.callback.__isTomb) {
    return returnValue;
  }
  try {
    returnValue = invokeFunction(listener2.callback, args);
    if (returnValue !== void 0) {
      event.returnValue = returnValue;
      event.stopPropagation();
    }
    if (returnValue === false) {
      event.preventDefault();
    }
  } catch (error2) {
    if (!this.handleError(error2)) {
      console.error("unhandled error in event listener", error2);
      throw error2;
    }
  }
  return returnValue;
};
EventBus.prototype._addListener = function(event, newListener) {
  var listener2 = this._getListeners(event), previousListener;
  if (!listener2) {
    this._setListeners(event, newListener);
    return;
  }
  while (listener2) {
    if (listener2.priority < newListener.priority) {
      newListener.next = listener2;
      if (previousListener) {
        previousListener.next = newListener;
      } else {
        this._setListeners(event, newListener);
      }
      return;
    }
    previousListener = listener2;
    listener2 = listener2.next;
  }
  previousListener.next = newListener;
};
EventBus.prototype._getListeners = function(name2) {
  return this._listeners[name2];
};
EventBus.prototype._setListeners = function(name2, listener2) {
  this._listeners[name2] = listener2;
};
EventBus.prototype._removeListener = function(event, callback) {
  var listener2 = this._getListeners(event), nextListener, previousListener, listenerCallback;
  if (!callback) {
    this._setListeners(event, null);
    return;
  }
  while (listener2) {
    nextListener = listener2.next;
    listenerCallback = listener2.callback;
    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
      if (previousListener) {
        previousListener.next = nextListener;
      } else {
        this._setListeners(event, nextListener);
      }
    }
    previousListener = listener2;
    listener2 = nextListener;
  }
};
function InternalEvent() {
}
InternalEvent.prototype.stopPropagation = function() {
  this.cancelBubble = true;
};
InternalEvent.prototype.preventDefault = function() {
  this.defaultPrevented = true;
};
InternalEvent.prototype.init = function(data) {
  assign$e(this, data || {});
};
function invokeFunction(fn, args) {
  return fn.apply(null, args);
}
function getVisual(gfx) {
  return gfx.childNodes[0];
}
function getChildren$1(gfx) {
  return gfx.parentNode.childNodes[1];
}
function transform$1(gfx, x, y, angle, amount) {
  var translate2 = createTransform();
  translate2.setTranslate(x, y);
  var rotate2 = createTransform();
  rotate2.setRotate(angle || 0, 0, 0);
  var scale = createTransform();
  scale.setScale(amount || 1, amount || 1);
  transform$2(gfx, [translate2, rotate2, scale]);
}
function translate$4(gfx, x, y) {
  var translate2 = createTransform();
  translate2.setTranslate(x, y);
  transform$2(gfx, translate2);
}
function rotate(gfx, angle) {
  var rotate2 = createTransform();
  rotate2.setRotate(angle, 0, 0);
  transform$2(gfx, rotate2);
}
function GraphicsFactory(eventBus, elementRegistry) {
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
}
GraphicsFactory.$inject = ["eventBus", "elementRegistry"];
GraphicsFactory.prototype._getChildrenContainer = function(element) {
  var gfx = this._elementRegistry.getGraphics(element);
  var childrenGfx;
  if (!element.parent) {
    childrenGfx = gfx;
  } else {
    childrenGfx = getChildren$1(gfx);
    if (!childrenGfx) {
      childrenGfx = create$2("g");
      classes(childrenGfx).add("djs-children");
      append$3(gfx.parentNode, childrenGfx);
    }
  }
  return childrenGfx;
};
GraphicsFactory.prototype._clear = function(gfx) {
  var visual = getVisual(gfx);
  clear$1(visual);
  return visual;
};
GraphicsFactory.prototype._createContainer = function(type, childrenGfx, parentIndex, isFrame) {
  var outerGfx = create$2("g");
  classes(outerGfx).add("djs-group");
  if (typeof parentIndex !== "undefined") {
    prependTo(outerGfx, childrenGfx, childrenGfx.childNodes[parentIndex]);
  } else {
    append$3(childrenGfx, outerGfx);
  }
  var gfx = create$2("g");
  classes(gfx).add("djs-element");
  classes(gfx).add("djs-" + type);
  if (isFrame) {
    classes(gfx).add("djs-frame");
  }
  append$3(outerGfx, gfx);
  var visual = create$2("g");
  classes(visual).add("djs-visual");
  append$3(gfx, visual);
  return gfx;
};
GraphicsFactory.prototype.create = function(type, element, parentIndex) {
  var childrenGfx = this._getChildrenContainer(element.parent);
  return this._createContainer(type, childrenGfx, parentIndex, isFrameElement$1(element));
};
GraphicsFactory.prototype.updateContainments = function(elements) {
  var self2 = this, elementRegistry = this._elementRegistry, parents;
  parents = reduce$3(elements, function(map2, e) {
    if (e.parent) {
      map2[e.parent.id] = e.parent;
    }
    return map2;
  }, {});
  forEach$q(parents, function(parent2) {
    var children = parent2.children;
    if (!children) {
      return;
    }
    var childrenGfx = self2._getChildrenContainer(parent2);
    forEach$q(children.slice().reverse(), function(child) {
      var childGfx = elementRegistry.getGraphics(child);
      prependTo(childGfx.parentNode, childrenGfx);
    });
  });
};
GraphicsFactory.prototype.drawShape = function(visual, element) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.shape", { gfx: visual, element });
};
GraphicsFactory.prototype.getShapePath = function(element) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.getShapePath", element);
};
GraphicsFactory.prototype.drawConnection = function(visual, element) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.connection", { gfx: visual, element });
};
GraphicsFactory.prototype.getConnectionPath = function(waypoints) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.getConnectionPath", waypoints);
};
GraphicsFactory.prototype.update = function(type, element, gfx) {
  if (!element.parent) {
    return;
  }
  var visual = this._clear(gfx);
  if (type === "shape") {
    this.drawShape(visual, element);
    translate$4(gfx, element.x, element.y);
  } else if (type === "connection") {
    this.drawConnection(visual, element);
  } else {
    throw new Error("unknown type: " + type);
  }
  if (element.hidden) {
    attr(gfx, "display", "none");
  } else {
    attr(gfx, "display", "block");
  }
};
GraphicsFactory.prototype.remove = function(element) {
  var gfx = this._elementRegistry.getGraphics(element);
  remove$4(gfx.parentNode);
};
function prependTo(newNode, parentNode, siblingNode) {
  var node2 = siblingNode || parentNode.firstChild;
  if (newNode === node2) {
    return;
  }
  parentNode.insertBefore(newNode, node2);
}
var CoreModule$1 = {
  __depends__: [DrawModule$1],
  __init__: ["canvas"],
  canvas: ["type", Canvas],
  elementRegistry: ["type", ElementRegistry],
  elementFactory: ["type", ElementFactory$1],
  eventBus: ["type", EventBus],
  graphicsFactory: ["type", GraphicsFactory]
};
function bootstrap(bootstrapModules) {
  var modules = [], components = [];
  function hasModule(m) {
    return modules.indexOf(m) >= 0;
  }
  function addModule(m) {
    modules.push(m);
  }
  function visit(m) {
    if (hasModule(m)) {
      return;
    }
    (m.__depends__ || []).forEach(visit);
    if (hasModule(m)) {
      return;
    }
    addModule(m);
    (m.__init__ || []).forEach(function(c) {
      components.push(c);
    });
  }
  bootstrapModules.forEach(visit);
  var injector = new Injector(modules);
  components.forEach(function(c) {
    try {
      injector[typeof c === "string" ? "get" : "invoke"](c);
    } catch (e) {
      console.error("Failed to instantiate component");
      console.error(e.stack);
      throw e;
    }
  });
  return injector;
}
function createInjector(options) {
  options = options || {};
  var configModule = {
    "config": ["value", options]
  };
  var modules = [configModule, CoreModule$1].concat(options.modules || []);
  return bootstrap(modules);
}
function Diagram(options, injector) {
  this.injector = injector = injector || createInjector(options);
  this.get = injector.get;
  this.invoke = injector.invoke;
  this.get("eventBus").fire("diagram.init");
}
Diagram.prototype.destroy = function() {
  this.get("eventBus").fire("diagram.destroy");
};
Diagram.prototype.clear = function() {
  this.get("eventBus").fire("diagram.clear");
};
function Base() {
}
Base.prototype.get = function(name2) {
  return this.$model.properties.get(this, name2);
};
Base.prototype.set = function(name2, value) {
  this.$model.properties.set(this, name2, value);
};
function Factory(model, properties2) {
  this.model = model;
  this.properties = properties2;
}
Factory.prototype.createType = function(descriptor) {
  var model = this.model;
  var props = this.properties, prototype = Object.create(Base.prototype);
  forEach$q(descriptor.properties, function(p) {
    if (!p.isMany && p.default !== void 0) {
      prototype[p.name] = p.default;
    }
  });
  props.defineModel(prototype, model);
  props.defineDescriptor(prototype, descriptor);
  var name2 = descriptor.ns.name;
  function ModdleElement(attrs) {
    props.define(this, "$type", { value: name2, enumerable: true });
    props.define(this, "$attrs", { value: {} });
    props.define(this, "$parent", { writable: true });
    forEach$q(attrs, bind$3(function(val, key) {
      this.set(key, val);
    }, this));
  }
  ModdleElement.prototype = prototype;
  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;
  props.defineModel(ModdleElement, model);
  props.defineDescriptor(ModdleElement, descriptor);
  return ModdleElement;
};
var BUILTINS = {
  String: true,
  Boolean: true,
  Integer: true,
  Real: true,
  Element: true
};
var TYPE_CONVERTERS = {
  String: function(s) {
    return s;
  },
  Boolean: function(s) {
    return s === "true";
  },
  Integer: function(s) {
    return parseInt(s, 10);
  },
  Real: function(s) {
    return parseFloat(s);
  }
};
function coerceType(type, value) {
  var converter = TYPE_CONVERTERS[type];
  if (converter) {
    return converter(value);
  } else {
    return value;
  }
}
function isBuiltIn(type) {
  return !!BUILTINS[type];
}
function isSimple(type) {
  return !!TYPE_CONVERTERS[type];
}
function parseName(name2, defaultPrefix) {
  var parts = name2.split(/:/), localName, prefix2;
  if (parts.length === 1) {
    localName = name2;
    prefix2 = defaultPrefix;
  } else if (parts.length === 2) {
    localName = parts[1];
    prefix2 = parts[0];
  } else {
    throw new Error("expected <prefix:localName> or <localName>, got " + name2);
  }
  name2 = (prefix2 ? prefix2 + ":" : "") + localName;
  return {
    name: name2,
    prefix: prefix2,
    localName
  };
}
function DescriptorBuilder(nameNs) {
  this.ns = nameNs;
  this.name = nameNs.name;
  this.allTypes = [];
  this.allTypesByName = {};
  this.properties = [];
  this.propertiesByName = {};
}
DescriptorBuilder.prototype.build = function() {
  return pick$3(this, [
    "ns",
    "name",
    "allTypes",
    "allTypesByName",
    "properties",
    "propertiesByName",
    "bodyProperty",
    "idProperty"
  ]);
};
DescriptorBuilder.prototype.addProperty = function(p, idx, validate2) {
  if (typeof idx === "boolean") {
    validate2 = idx;
    idx = void 0;
  }
  this.addNamedProperty(p, validate2 !== false);
  var properties2 = this.properties;
  if (idx !== void 0) {
    properties2.splice(idx, 0, p);
  } else {
    properties2.push(p);
  }
};
DescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {
  var oldNameNs = oldProperty.ns;
  var props = this.properties, propertiesByName = this.propertiesByName, rename = oldProperty.name !== newProperty.name;
  if (oldProperty.isId) {
    if (!newProperty.isId) {
      throw new Error("property <" + newProperty.ns.name + "> must be id property to refine <" + oldProperty.ns.name + ">");
    }
    this.setIdProperty(newProperty, false);
  }
  if (oldProperty.isBody) {
    if (!newProperty.isBody) {
      throw new Error("property <" + newProperty.ns.name + "> must be body property to refine <" + oldProperty.ns.name + ">");
    }
    this.setBodyProperty(newProperty, false);
  }
  var idx = props.indexOf(oldProperty);
  if (idx === -1) {
    throw new Error("property <" + oldNameNs.name + "> not found in property list");
  }
  props.splice(idx, 1);
  this.addProperty(newProperty, replace ? void 0 : idx, rename);
  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
};
DescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {
  var nsPrefix = p.ns.prefix;
  var parts = targetPropertyName.split("#");
  var name2 = parseName(parts[0], nsPrefix);
  var attrName = parseName(parts[1], name2.prefix).name;
  var redefinedProperty = this.propertiesByName[attrName];
  if (!redefinedProperty) {
    throw new Error("refined property <" + attrName + "> not found");
  } else {
    this.replaceProperty(redefinedProperty, p, replace);
  }
  delete p.redefines;
};
DescriptorBuilder.prototype.addNamedProperty = function(p, validate2) {
  var ns2 = p.ns, propsByName = this.propertiesByName;
  if (validate2) {
    this.assertNotDefined(p, ns2.name);
    this.assertNotDefined(p, ns2.localName);
  }
  propsByName[ns2.name] = propsByName[ns2.localName] = p;
};
DescriptorBuilder.prototype.removeNamedProperty = function(p) {
  var ns2 = p.ns, propsByName = this.propertiesByName;
  delete propsByName[ns2.name];
  delete propsByName[ns2.localName];
};
DescriptorBuilder.prototype.setBodyProperty = function(p, validate2) {
  if (validate2 && this.bodyProperty) {
    throw new Error("body property defined multiple times (<" + this.bodyProperty.ns.name + ">, <" + p.ns.name + ">)");
  }
  this.bodyProperty = p;
};
DescriptorBuilder.prototype.setIdProperty = function(p, validate2) {
  if (validate2 && this.idProperty) {
    throw new Error("id property defined multiple times (<" + this.idProperty.ns.name + ">, <" + p.ns.name + ">)");
  }
  this.idProperty = p;
};
DescriptorBuilder.prototype.assertNotDefined = function(p, name2) {
  var propertyName = p.name, definedProperty = this.propertiesByName[propertyName];
  if (definedProperty) {
    throw new Error("property <" + propertyName + "> already defined; override of <" + definedProperty.definedBy.ns.name + "#" + definedProperty.ns.name + "> by <" + p.definedBy.ns.name + "#" + p.ns.name + "> not allowed without redefines");
  }
};
DescriptorBuilder.prototype.hasProperty = function(name2) {
  return this.propertiesByName[name2];
};
DescriptorBuilder.prototype.addTrait = function(t, inherited) {
  var typesByName = this.allTypesByName, types2 = this.allTypes;
  var typeName = t.name;
  if (typeName in typesByName) {
    return;
  }
  forEach$q(t.properties, bind$3(function(p) {
    p = assign$e({}, p, {
      name: p.ns.localName,
      inherited
    });
    Object.defineProperty(p, "definedBy", {
      value: t
    });
    var replaces = p.replaces, redefines = p.redefines;
    if (replaces || redefines) {
      this.redefineProperty(p, replaces || redefines, replaces);
    } else {
      if (p.isBody) {
        this.setBodyProperty(p);
      }
      if (p.isId) {
        this.setIdProperty(p);
      }
      this.addProperty(p);
    }
  }, this));
  types2.push(t);
  typesByName[typeName] = t;
};
function Registry(packages2, properties2) {
  this.packageMap = {};
  this.typeMap = {};
  this.packages = [];
  this.properties = properties2;
  forEach$q(packages2, bind$3(this.registerPackage, this));
}
Registry.prototype.getPackage = function(uriOrPrefix) {
  return this.packageMap[uriOrPrefix];
};
Registry.prototype.getPackages = function() {
  return this.packages;
};
Registry.prototype.registerPackage = function(pkg) {
  pkg = assign$e({}, pkg);
  var pkgMap = this.packageMap;
  ensureAvailable(pkgMap, pkg, "prefix");
  ensureAvailable(pkgMap, pkg, "uri");
  forEach$q(pkg.types, bind$3(function(descriptor) {
    this.registerType(descriptor, pkg);
  }, this));
  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;
  this.packages.push(pkg);
};
Registry.prototype.registerType = function(type, pkg) {
  type = assign$e({}, type, {
    superClass: (type.superClass || []).slice(),
    extends: (type.extends || []).slice(),
    properties: (type.properties || []).slice(),
    meta: assign$e(type.meta || {})
  });
  var ns2 = parseName(type.name, pkg.prefix), name2 = ns2.name, propertiesByName = {};
  forEach$q(type.properties, bind$3(function(p) {
    var propertyNs = parseName(p.name, ns2.prefix), propertyName = propertyNs.name;
    if (!isBuiltIn(p.type)) {
      p.type = parseName(p.type, propertyNs.prefix).name;
    }
    assign$e(p, {
      ns: propertyNs,
      name: propertyName
    });
    propertiesByName[propertyName] = p;
  }, this));
  assign$e(type, {
    ns: ns2,
    name: name2,
    propertiesByName
  });
  forEach$q(type.extends, bind$3(function(extendsName) {
    var extended = this.typeMap[extendsName];
    extended.traits = extended.traits || [];
    extended.traits.push(name2);
  }, this));
  this.definePackage(type, pkg);
  this.typeMap[name2] = type;
};
Registry.prototype.mapTypes = function(nsName2, iterator, trait) {
  var type = isBuiltIn(nsName2.name) ? { name: nsName2.name } : this.typeMap[nsName2.name];
  var self2 = this;
  function traverseTrait(cls) {
    return traverseSuper(cls, true);
  }
  function traverseSuper(cls, trait2) {
    var parentNs = parseName(cls, isBuiltIn(cls) ? "" : nsName2.prefix);
    self2.mapTypes(parentNs, iterator, trait2);
  }
  if (!type) {
    throw new Error("unknown type <" + nsName2.name + ">");
  }
  forEach$q(type.superClass, trait ? traverseTrait : traverseSuper);
  iterator(type, !trait);
  forEach$q(type.traits, traverseTrait);
};
Registry.prototype.getEffectiveDescriptor = function(name2) {
  var nsName2 = parseName(name2);
  var builder = new DescriptorBuilder(nsName2);
  this.mapTypes(nsName2, function(type, inherited) {
    builder.addTrait(type, inherited);
  });
  var descriptor = builder.build();
  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);
  return descriptor;
};
Registry.prototype.definePackage = function(target, pkg) {
  this.properties.define(target, "$pkg", { value: pkg });
};
function ensureAvailable(packageMap, pkg, identifierKey) {
  var value = pkg[identifierKey];
  if (value in packageMap) {
    throw new Error("package with " + identifierKey + " <" + value + "> already defined");
  }
}
function Properties$1(model) {
  this.model = model;
}
Properties$1.prototype.set = function(target, name2, value) {
  var property2 = this.model.getPropertyDescriptor(target, name2);
  var propertyName = property2 && property2.name;
  if (isUndefined$6(value)) {
    if (property2) {
      delete target[propertyName];
    } else {
      delete target.$attrs[name2];
    }
  } else {
    if (property2) {
      if (propertyName in target) {
        target[propertyName] = value;
      } else {
        defineProperty$3(target, property2, value);
      }
    } else {
      target.$attrs[name2] = value;
    }
  }
};
Properties$1.prototype.get = function(target, name2) {
  var property2 = this.model.getPropertyDescriptor(target, name2);
  if (!property2) {
    return target.$attrs[name2];
  }
  var propertyName = property2.name;
  if (!target[propertyName] && property2.isMany) {
    defineProperty$3(target, property2, []);
  }
  return target[propertyName];
};
Properties$1.prototype.define = function(target, name2, options) {
  if (!options.writable) {
    var value = options.value;
    options = assign$e({}, options, {
      get: function() {
        return value;
      }
    });
    delete options.value;
  }
  Object.defineProperty(target, name2, options);
};
Properties$1.prototype.defineDescriptor = function(target, descriptor) {
  this.define(target, "$descriptor", { value: descriptor });
};
Properties$1.prototype.defineModel = function(target, model) {
  this.define(target, "$model", { value: model });
};
function isUndefined$6(val) {
  return typeof val === "undefined";
}
function defineProperty$3(target, property2, value) {
  Object.defineProperty(target, property2.name, {
    enumerable: !property2.isReference,
    writable: true,
    value,
    configurable: true
  });
}
function Moddle(packages2) {
  this.properties = new Properties$1(this);
  this.factory = new Factory(this, this.properties);
  this.registry = new Registry(packages2, this.properties);
  this.typeCache = {};
}
Moddle.prototype.create = function(descriptor, attrs) {
  var Type = this.getType(descriptor);
  if (!Type) {
    throw new Error("unknown type <" + descriptor + ">");
  }
  return new Type(attrs);
};
Moddle.prototype.getType = function(descriptor) {
  var cache = this.typeCache;
  var name2 = isString$3(descriptor) ? descriptor : descriptor.ns.name;
  var type = cache[name2];
  if (!type) {
    descriptor = this.registry.getEffectiveDescriptor(name2);
    type = cache[name2] = this.factory.createType(descriptor);
  }
  return type;
};
Moddle.prototype.createAny = function(name2, nsUri, properties2) {
  var nameNs = parseName(name2);
  var element = {
    $type: name2,
    $instanceOf: function(type) {
      return type === this.$type;
    }
  };
  var descriptor = {
    name: name2,
    isGeneric: true,
    ns: {
      prefix: nameNs.prefix,
      localName: nameNs.localName,
      uri: nsUri
    }
  };
  this.properties.defineDescriptor(element, descriptor);
  this.properties.defineModel(element, this);
  this.properties.define(element, "$parent", { enumerable: false, writable: true });
  this.properties.define(element, "$instanceOf", { enumerable: false, writable: true });
  forEach$q(properties2, function(a, key) {
    if (isObject$e(a) && a.value !== void 0) {
      element[a.name] = a.value;
    } else {
      element[key] = a;
    }
  });
  return element;
};
Moddle.prototype.getPackage = function(uriOrPrefix) {
  return this.registry.getPackage(uriOrPrefix);
};
Moddle.prototype.getPackages = function() {
  return this.registry.getPackages();
};
Moddle.prototype.getElementDescriptor = function(element) {
  return element.$descriptor;
};
Moddle.prototype.hasType = function(element, type) {
  if (type === void 0) {
    type = element;
    element = this;
  }
  var descriptor = element.$model.getElementDescriptor(element);
  return type in descriptor.allTypesByName;
};
Moddle.prototype.getPropertyDescriptor = function(element, property2) {
  return this.getElementDescriptor(element).propertiesByName[property2];
};
Moddle.prototype.getTypeDescriptor = function(type) {
  return this.registry.typeMap[type];
};
var fromCharCode = String.fromCharCode;
var hasOwnProperty$e = Object.prototype.hasOwnProperty;
var ENTITY_PATTERN = /&#(\d+);|&#x([0-9a-f]+);|&(\w+);/ig;
var ENTITY_MAPPING = {
  "amp": "&",
  "apos": "'",
  "gt": ">",
  "lt": "<",
  "quot": '"'
};
Object.keys(ENTITY_MAPPING).forEach(function(k) {
  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];
});
function replaceEntities(_, d, x, z) {
  if (z) {
    if (hasOwnProperty$e.call(ENTITY_MAPPING, z)) {
      return ENTITY_MAPPING[z];
    } else {
      return "&" + z + ";";
    }
  }
  if (d) {
    return fromCharCode(d);
  }
  return fromCharCode(parseInt(x, 16));
}
function decodeEntities(s) {
  if (s.length > 3 && s.indexOf("&") !== -1) {
    return s.replace(ENTITY_PATTERN, replaceEntities);
  }
  return s;
}
var XSI_URI = "http://www.w3.org/2001/XMLSchema-instance";
var XSI_PREFIX = "xsi";
var XSI_TYPE$1 = "xsi:type";
var NON_WHITESPACE_OUTSIDE_ROOT_NODE = "non-whitespace outside of root node";
function error$4(msg) {
  return new Error(msg);
}
function missingNamespaceForPrefix(prefix2) {
  return "missing namespace for prefix <" + prefix2 + ">";
}
function getter(getFn) {
  return {
    "get": getFn,
    "enumerable": true
  };
}
function cloneNsMatrix(nsMatrix) {
  var clone2 = {}, key;
  for (key in nsMatrix) {
    clone2[key] = nsMatrix[key];
  }
  return clone2;
}
function uriPrefix(prefix2) {
  return prefix2 + "$uri";
}
function buildNsMatrix(nsUriToPrefix) {
  var nsMatrix = {}, uri2, prefix2;
  for (uri2 in nsUriToPrefix) {
    prefix2 = nsUriToPrefix[uri2];
    nsMatrix[prefix2] = prefix2;
    nsMatrix[uriPrefix(prefix2)] = uri2;
  }
  return nsMatrix;
}
function noopGetContext() {
  return { "line": 0, "column": 0 };
}
function throwFunc(err) {
  throw err;
}
function Parser(options) {
  if (!this) {
    return new Parser(options);
  }
  var proxy = options && options["proxy"];
  var onText, onOpenTag, onCloseTag, onCDATA, onError = throwFunc, onWarning, onComment, onQuestion, onAttention;
  var getContext = noopGetContext;
  var maybeNS = false;
  var isNamespace = false;
  var returnError = null;
  var parseStop = false;
  var nsUriToPrefix;
  function handleError(err) {
    if (!(err instanceof Error)) {
      err = error$4(err);
    }
    returnError = err;
    onError(err, getContext);
  }
  function handleWarning(err) {
    if (!onWarning) {
      return;
    }
    if (!(err instanceof Error)) {
      err = error$4(err);
    }
    onWarning(err, getContext);
  }
  this["on"] = function(name2, cb) {
    if (typeof cb !== "function") {
      throw error$4("required args <name, cb>");
    }
    switch (name2) {
      case "openTag":
        onOpenTag = cb;
        break;
      case "text":
        onText = cb;
        break;
      case "closeTag":
        onCloseTag = cb;
        break;
      case "error":
        onError = cb;
        break;
      case "warn":
        onWarning = cb;
        break;
      case "cdata":
        onCDATA = cb;
        break;
      case "attention":
        onAttention = cb;
        break;
      case "question":
        onQuestion = cb;
        break;
      case "comment":
        onComment = cb;
        break;
      default:
        throw error$4("unsupported event: " + name2);
    }
    return this;
  };
  this["ns"] = function(nsMap) {
    if (typeof nsMap === "undefined") {
      nsMap = {};
    }
    if (typeof nsMap !== "object") {
      throw error$4("required args <nsMap={}>");
    }
    var _nsUriToPrefix = {}, k;
    for (k in nsMap) {
      _nsUriToPrefix[k] = nsMap[k];
    }
    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;
    isNamespace = true;
    nsUriToPrefix = _nsUriToPrefix;
    return this;
  };
  this["parse"] = function(xml2) {
    if (typeof xml2 !== "string") {
      throw error$4("required args <xml=string>");
    }
    returnError = null;
    parse2(xml2);
    getContext = noopGetContext;
    parseStop = false;
    return returnError;
  };
  this["stop"] = function() {
    parseStop = true;
  };
  function parse2(xml2) {
    var nsMatrixStack = isNamespace ? [] : null, nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null, _nsMatrix, nodeStack = [], anonymousNsCount = 0, tagStart = false, tagEnd = false, i = 0, j = 0, x, y, q, w, v, xmlns, elementName, _elementName, elementProxy;
    var attrsString = "", attrsStart = 0, cachedAttrs;
    function getAttrs() {
      if (cachedAttrs !== null) {
        return cachedAttrs;
      }
      var nsUri, nsUriPrefix, nsName2, defaultAlias = isNamespace && nsMatrix["xmlns"], attrList = isNamespace && maybeNS ? [] : null, i2 = attrsStart, s = attrsString, l = s.length, hasNewMatrix, newalias, value, alias, name2, attrs = {}, seenAttrs = {}, skipAttr, w2, j2;
      parseAttr:
        for (; i2 < l; i2++) {
          skipAttr = false;
          w2 = s.charCodeAt(i2);
          if (w2 === 32 || w2 < 14 && w2 > 8) {
            continue;
          }
          if (w2 < 65 || w2 > 122 || w2 > 90 && w2 < 97) {
            if (w2 !== 95 && w2 !== 58) {
              handleWarning("illegal first char attribute name");
              skipAttr = true;
            }
          }
          for (j2 = i2 + 1; j2 < l; j2++) {
            w2 = s.charCodeAt(j2);
            if (w2 > 96 && w2 < 123 || w2 > 64 && w2 < 91 || w2 > 47 && w2 < 59 || w2 === 46 || w2 === 45 || w2 === 95) {
              continue;
            }
            if (w2 === 32 || w2 < 14 && w2 > 8) {
              handleWarning("missing attribute value");
              i2 = j2;
              continue parseAttr;
            }
            if (w2 === 61) {
              break;
            }
            handleWarning("illegal attribute name char");
            skipAttr = true;
          }
          name2 = s.substring(i2, j2);
          if (name2 === "xmlns:xmlns") {
            handleWarning("illegal declaration of xmlns");
            skipAttr = true;
          }
          w2 = s.charCodeAt(j2 + 1);
          if (w2 === 34) {
            j2 = s.indexOf('"', i2 = j2 + 2);
            if (j2 === -1) {
              j2 = s.indexOf("'", i2);
              if (j2 !== -1) {
                handleWarning("attribute value quote missmatch");
                skipAttr = true;
              }
            }
          } else if (w2 === 39) {
            j2 = s.indexOf("'", i2 = j2 + 2);
            if (j2 === -1) {
              j2 = s.indexOf('"', i2);
              if (j2 !== -1) {
                handleWarning("attribute value quote missmatch");
                skipAttr = true;
              }
            }
          } else {
            handleWarning("missing attribute value quotes");
            skipAttr = true;
            for (j2 = j2 + 1; j2 < l; j2++) {
              w2 = s.charCodeAt(j2 + 1);
              if (w2 === 32 || w2 < 14 && w2 > 8) {
                break;
              }
            }
          }
          if (j2 === -1) {
            handleWarning("missing closing quotes");
            j2 = l;
            skipAttr = true;
          }
          if (!skipAttr) {
            value = s.substring(i2, j2);
          }
          i2 = j2;
          for (; j2 + 1 < l; j2++) {
            w2 = s.charCodeAt(j2 + 1);
            if (w2 === 32 || w2 < 14 && w2 > 8) {
              break;
            }
            if (i2 === j2) {
              handleWarning("illegal character after attribute end");
              skipAttr = true;
            }
          }
          i2 = j2 + 1;
          if (skipAttr) {
            continue parseAttr;
          }
          if (name2 in seenAttrs) {
            handleWarning("attribute <" + name2 + "> already defined");
            continue;
          }
          seenAttrs[name2] = true;
          if (!isNamespace) {
            attrs[name2] = value;
            continue;
          }
          if (maybeNS) {
            newalias = name2 === "xmlns" ? "xmlns" : name2.charCodeAt(0) === 120 && name2.substr(0, 6) === "xmlns:" ? name2.substr(6) : null;
            if (newalias !== null) {
              nsUri = decodeEntities(value);
              nsUriPrefix = uriPrefix(newalias);
              alias = nsUriToPrefix[nsUri];
              if (!alias) {
                if (newalias === "xmlns" || nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri) {
                  do {
                    alias = "ns" + anonymousNsCount++;
                  } while (typeof nsMatrix[alias] !== "undefined");
                } else {
                  alias = newalias;
                }
                nsUriToPrefix[nsUri] = alias;
              }
              if (nsMatrix[newalias] !== alias) {
                if (!hasNewMatrix) {
                  nsMatrix = cloneNsMatrix(nsMatrix);
                  hasNewMatrix = true;
                }
                nsMatrix[newalias] = alias;
                if (newalias === "xmlns") {
                  nsMatrix[uriPrefix(alias)] = nsUri;
                  defaultAlias = alias;
                }
                nsMatrix[nsUriPrefix] = nsUri;
              }
              attrs[name2] = value;
              continue;
            }
            attrList.push(name2, value);
            continue;
          }
          w2 = name2.indexOf(":");
          if (w2 === -1) {
            attrs[name2] = value;
            continue;
          }
          if (!(nsName2 = nsMatrix[name2.substring(0, w2)])) {
            handleWarning(missingNamespaceForPrefix(name2.substring(0, w2)));
            continue;
          }
          name2 = defaultAlias === nsName2 ? name2.substr(w2 + 1) : nsName2 + name2.substr(w2);
          if (name2 === XSI_TYPE$1) {
            w2 = value.indexOf(":");
            if (w2 !== -1) {
              nsName2 = value.substring(0, w2);
              nsName2 = nsMatrix[nsName2] || nsName2;
              value = nsName2 + value.substring(w2);
            } else {
              value = defaultAlias + ":" + value;
            }
          }
          attrs[name2] = value;
        }
      if (maybeNS) {
        for (i2 = 0, l = attrList.length; i2 < l; i2++) {
          name2 = attrList[i2++];
          value = attrList[i2];
          w2 = name2.indexOf(":");
          if (w2 !== -1) {
            if (!(nsName2 = nsMatrix[name2.substring(0, w2)])) {
              handleWarning(missingNamespaceForPrefix(name2.substring(0, w2)));
              continue;
            }
            name2 = defaultAlias === nsName2 ? name2.substr(w2 + 1) : nsName2 + name2.substr(w2);
            if (name2 === XSI_TYPE$1) {
              w2 = value.indexOf(":");
              if (w2 !== -1) {
                nsName2 = value.substring(0, w2);
                nsName2 = nsMatrix[nsName2] || nsName2;
                value = nsName2 + value.substring(w2);
              } else {
                value = defaultAlias + ":" + value;
              }
            }
          }
          attrs[name2] = value;
        }
      }
      return cachedAttrs = attrs;
    }
    function getParseContext() {
      var splitsRe = /(\r\n|\r|\n)/g;
      var line = 0;
      var column = 0;
      var startOfLine = 0;
      var endOfLine = j;
      var match2;
      var data;
      while (i >= startOfLine) {
        match2 = splitsRe.exec(xml2);
        if (!match2) {
          break;
        }
        endOfLine = match2[0].length + match2.index;
        if (endOfLine > i) {
          break;
        }
        line += 1;
        startOfLine = endOfLine;
      }
      if (i == -1) {
        column = endOfLine;
        data = xml2.substring(j);
      } else if (j === 0) {
        data = xml2.substring(j, i);
      } else {
        column = i - startOfLine;
        data = j == -1 ? xml2.substring(i) : xml2.substring(i, j + 1);
      }
      return {
        "data": data,
        "line": line,
        "column": column
      };
    }
    getContext = getParseContext;
    if (proxy) {
      elementProxy = Object.create({}, {
        "name": getter(function() {
          return elementName;
        }),
        "originalName": getter(function() {
          return _elementName;
        }),
        "attrs": getter(getAttrs),
        "ns": getter(function() {
          return nsMatrix;
        })
      });
    }
    while (j !== -1) {
      if (xml2.charCodeAt(j) === 60) {
        i = j;
      } else {
        i = xml2.indexOf("<", j);
      }
      if (i === -1) {
        if (nodeStack.length) {
          return handleError("unexpected end of file");
        }
        if (j === 0) {
          return handleError("missing start tag");
        }
        if (j < xml2.length) {
          if (xml2.substring(j).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
          }
        }
        return;
      }
      if (j !== i) {
        if (nodeStack.length) {
          if (onText) {
            onText(xml2.substring(j, i), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }
        } else {
          if (xml2.substring(j, i).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
            if (parseStop) {
              return;
            }
          }
        }
      }
      w = xml2.charCodeAt(i + 1);
      if (w === 33) {
        q = xml2.charCodeAt(i + 2);
        if (q === 91 && xml2.substr(i + 3, 6) === "CDATA[") {
          j = xml2.indexOf("]]>", i);
          if (j === -1) {
            return handleError("unclosed cdata");
          }
          if (onCDATA) {
            onCDATA(xml2.substring(i + 9, j), getContext);
            if (parseStop) {
              return;
            }
          }
          j += 3;
          continue;
        }
        if (q === 45 && xml2.charCodeAt(i + 3) === 45) {
          j = xml2.indexOf("-->", i);
          if (j === -1) {
            return handleError("unclosed comment");
          }
          if (onComment) {
            onComment(xml2.substring(i + 4, j), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }
          j += 3;
          continue;
        }
      }
      if (w === 63) {
        j = xml2.indexOf("?>", i);
        if (j === -1) {
          return handleError("unclosed question");
        }
        if (onQuestion) {
          onQuestion(xml2.substring(i, j + 2), getContext);
          if (parseStop) {
            return;
          }
        }
        j += 2;
        continue;
      }
      for (x = i + 1; ; x++) {
        v = xml2.charCodeAt(x);
        if (isNaN(v)) {
          j = -1;
          return handleError("unclosed tag");
        }
        if (v === 34) {
          q = xml2.indexOf('"', x + 1);
          x = q !== -1 ? q : x;
        } else if (v === 39) {
          q = xml2.indexOf("'", x + 1);
          x = q !== -1 ? q : x;
        } else if (v === 62) {
          j = x;
          break;
        }
      }
      if (w === 33) {
        if (onAttention) {
          onAttention(xml2.substring(i, j + 1), decodeEntities, getContext);
          if (parseStop) {
            return;
          }
        }
        j += 1;
        continue;
      }
      cachedAttrs = {};
      if (w === 47) {
        tagStart = false;
        tagEnd = true;
        if (!nodeStack.length) {
          return handleError("missing open tag");
        }
        x = elementName = nodeStack.pop();
        q = i + 2 + x.length;
        if (xml2.substring(i + 2, q) !== x) {
          return handleError("closing tag mismatch");
        }
        for (; q < j; q++) {
          w = xml2.charCodeAt(q);
          if (w === 32 || w > 8 && w < 14) {
            continue;
          }
          return handleError("close tag");
        }
      } else {
        if (xml2.charCodeAt(j - 1) === 47) {
          x = elementName = xml2.substring(i + 1, j - 1);
          tagStart = true;
          tagEnd = true;
        } else {
          x = elementName = xml2.substring(i + 1, j);
          tagStart = true;
          tagEnd = false;
        }
        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) {
          return handleError("illegal first char nodeName");
        }
        for (q = 1, y = x.length; q < y; q++) {
          w = x.charCodeAt(q);
          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {
            continue;
          }
          if (w === 32 || w < 14 && w > 8) {
            elementName = x.substring(0, q);
            cachedAttrs = null;
            break;
          }
          return handleError("invalid nodeName");
        }
        if (!tagEnd) {
          nodeStack.push(elementName);
        }
      }
      if (isNamespace) {
        _nsMatrix = nsMatrix;
        if (tagStart) {
          if (!tagEnd) {
            nsMatrixStack.push(_nsMatrix);
          }
          if (cachedAttrs === null) {
            if (maybeNS = x.indexOf("xmlns", q) !== -1) {
              attrsStart = q;
              attrsString = x;
              getAttrs();
              maybeNS = false;
            }
          }
        }
        _elementName = elementName;
        w = elementName.indexOf(":");
        if (w !== -1) {
          xmlns = nsMatrix[elementName.substring(0, w)];
          if (!xmlns) {
            return handleError("missing namespace on <" + _elementName + ">");
          }
          elementName = elementName.substr(w + 1);
        } else {
          xmlns = nsMatrix["xmlns"];
        }
        if (xmlns) {
          elementName = xmlns + ":" + elementName;
        }
      }
      if (tagStart) {
        attrsStart = q;
        attrsString = x;
        if (onOpenTag) {
          if (proxy) {
            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);
          } else {
            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);
          }
          if (parseStop) {
            return;
          }
        }
      }
      if (tagEnd) {
        if (onCloseTag) {
          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);
          if (parseStop) {
            return;
          }
        }
        if (isNamespace) {
          if (!tagStart) {
            nsMatrix = nsMatrixStack.pop();
          } else {
            nsMatrix = _nsMatrix;
          }
        }
      }
      j += 1;
    }
  }
}
function hasLowerCaseAlias(pkg) {
  return pkg.xml && pkg.xml.tagAlias === "lowerCase";
}
var DEFAULT_NS_MAP = {
  "xsi": "http://www.w3.org/2001/XMLSchema-instance",
  "xml": "http://www.w3.org/XML/1998/namespace"
};
var XSI_TYPE = "xsi:type";
function serializeFormat(element) {
  return element.xml && element.xml.serialize;
}
function serializeAsType(element) {
  return serializeFormat(element) === XSI_TYPE;
}
function serializeAsProperty(element) {
  return serializeFormat(element) === "property";
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function aliasToName(aliasNs, pkg) {
  if (!hasLowerCaseAlias(pkg)) {
    return aliasNs.name;
  }
  return aliasNs.prefix + ":" + capitalize(aliasNs.localName);
}
function prefixedToName(nameNs, pkg) {
  var name2 = nameNs.name, localName = nameNs.localName;
  var typePrefix = pkg.xml && pkg.xml.typePrefix;
  if (typePrefix && localName.indexOf(typePrefix) === 0) {
    return nameNs.prefix + ":" + localName.slice(typePrefix.length);
  } else {
    return name2;
  }
}
function normalizeXsiTypeName(name2, model) {
  var nameNs = parseName(name2);
  var pkg = model.getPackage(nameNs.prefix);
  return prefixedToName(nameNs, pkg);
}
function error$3(message2) {
  return new Error(message2);
}
function getModdleDescriptor(element) {
  return element.$descriptor;
}
function Context(options) {
  assign$e(this, options);
  this.elementsById = {};
  this.references = [];
  this.warnings = [];
  this.addReference = function(reference) {
    this.references.push(reference);
  };
  this.addElement = function(element) {
    if (!element) {
      throw error$3("expected element");
    }
    var elementsById = this.elementsById;
    var descriptor = getModdleDescriptor(element);
    var idProperty = descriptor.idProperty, id2;
    if (idProperty) {
      id2 = element.get(idProperty.name);
      if (id2) {
        if (!/^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i.test(id2)) {
          throw new Error("illegal ID <" + id2 + ">");
        }
        if (elementsById[id2]) {
          throw error$3("duplicate ID <" + id2 + ">");
        }
        elementsById[id2] = element;
      }
    }
  };
  this.addWarning = function(warning) {
    this.warnings.push(warning);
  };
}
function BaseHandler() {
}
BaseHandler.prototype.handleEnd = function() {
};
BaseHandler.prototype.handleText = function() {
};
BaseHandler.prototype.handleNode = function() {
};
function NoopHandler() {
}
NoopHandler.prototype = Object.create(BaseHandler.prototype);
NoopHandler.prototype.handleNode = function() {
  return this;
};
function BodyHandler() {
}
BodyHandler.prototype = Object.create(BaseHandler.prototype);
BodyHandler.prototype.handleText = function(text) {
  this.body = (this.body || "") + text;
};
function ReferenceHandler(property2, context) {
  this.property = property2;
  this.context = context;
}
ReferenceHandler.prototype = Object.create(BodyHandler.prototype);
ReferenceHandler.prototype.handleNode = function(node2) {
  if (this.element) {
    throw error$3("expected no sub nodes");
  } else {
    this.element = this.createReference(node2);
  }
  return this;
};
ReferenceHandler.prototype.handleEnd = function() {
  this.element.id = this.body;
};
ReferenceHandler.prototype.createReference = function(node2) {
  return {
    property: this.property.ns.name,
    id: ""
  };
};
function ValueHandler(propertyDesc, element) {
  this.element = element;
  this.propertyDesc = propertyDesc;
}
ValueHandler.prototype = Object.create(BodyHandler.prototype);
ValueHandler.prototype.handleEnd = function() {
  var value = this.body || "", element = this.element, propertyDesc = this.propertyDesc;
  value = coerceType(propertyDesc.type, value);
  if (propertyDesc.isMany) {
    element.get(propertyDesc.name).push(value);
  } else {
    element.set(propertyDesc.name, value);
  }
};
function BaseElementHandler() {
}
BaseElementHandler.prototype = Object.create(BodyHandler.prototype);
BaseElementHandler.prototype.handleNode = function(node2) {
  var parser2 = this, element = this.element;
  if (!element) {
    element = this.element = this.createElement(node2);
    this.context.addElement(element);
  } else {
    parser2 = this.handleChild(node2);
  }
  return parser2;
};
function ElementHandler(model, typeName, context) {
  this.model = model;
  this.type = model.getType(typeName);
  this.context = context;
}
ElementHandler.prototype = Object.create(BaseElementHandler.prototype);
ElementHandler.prototype.addReference = function(reference) {
  this.context.addReference(reference);
};
ElementHandler.prototype.handleText = function(text) {
  var element = this.element, descriptor = getModdleDescriptor(element), bodyProperty = descriptor.bodyProperty;
  if (!bodyProperty) {
    throw error$3("unexpected body text <" + text + ">");
  }
  BodyHandler.prototype.handleText.call(this, text);
};
ElementHandler.prototype.handleEnd = function() {
  var value = this.body, element = this.element, descriptor = getModdleDescriptor(element), bodyProperty = descriptor.bodyProperty;
  if (bodyProperty && value !== void 0) {
    value = coerceType(bodyProperty.type, value);
    element.set(bodyProperty.name, value);
  }
};
ElementHandler.prototype.createElement = function(node2) {
  var attributes = node2.attributes, Type = this.type, descriptor = getModdleDescriptor(Type), context = this.context, instance = new Type({}), model = this.model, propNameNs;
  forEach$q(attributes, function(value, name2) {
    var prop = descriptor.propertiesByName[name2], values2;
    if (prop && prop.isReference) {
      if (!prop.isMany) {
        context.addReference({
          element: instance,
          property: prop.ns.name,
          id: value
        });
      } else {
        values2 = value.split(" ");
        forEach$q(values2, function(v) {
          context.addReference({
            element: instance,
            property: prop.ns.name,
            id: v
          });
        });
      }
    } else {
      if (prop) {
        value = coerceType(prop.type, value);
      } else if (name2 !== "xmlns") {
        propNameNs = parseName(name2, descriptor.ns.prefix);
        if (model.getPackage(propNameNs.prefix)) {
          context.addWarning({
            message: "unknown attribute <" + name2 + ">",
            element: instance,
            property: name2,
            value
          });
        }
      }
      instance.set(name2, value);
    }
  });
  return instance;
};
ElementHandler.prototype.getPropertyForNode = function(node2) {
  var name2 = node2.name;
  var nameNs = parseName(name2);
  var type = this.type, model = this.model, descriptor = getModdleDescriptor(type);
  var propertyName = nameNs.name, property2 = descriptor.propertiesByName[propertyName], elementTypeName, elementType;
  if (property2 && !property2.isAttr) {
    if (serializeAsType(property2)) {
      elementTypeName = node2.attributes[XSI_TYPE];
      if (elementTypeName) {
        elementTypeName = normalizeXsiTypeName(elementTypeName, model);
        elementType = model.getType(elementTypeName);
        return assign$e({}, property2, {
          effectiveType: getModdleDescriptor(elementType).name
        });
      }
    }
    return property2;
  }
  var pkg = model.getPackage(nameNs.prefix);
  if (pkg) {
    elementTypeName = aliasToName(nameNs, pkg);
    elementType = model.getType(elementTypeName);
    property2 = find$e(descriptor.properties, function(p) {
      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);
    });
    if (property2) {
      return assign$e({}, property2, {
        effectiveType: getModdleDescriptor(elementType).name
      });
    }
  } else {
    property2 = find$e(descriptor.properties, function(p) {
      return !p.isReference && !p.isAttribute && p.type === "Element";
    });
    if (property2) {
      return property2;
    }
  }
  throw error$3("unrecognized element <" + nameNs.name + ">");
};
ElementHandler.prototype.toString = function() {
  return "ElementDescriptor[" + getModdleDescriptor(this.type).name + "]";
};
ElementHandler.prototype.valueHandler = function(propertyDesc, element) {
  return new ValueHandler(propertyDesc, element);
};
ElementHandler.prototype.referenceHandler = function(propertyDesc) {
  return new ReferenceHandler(propertyDesc, this.context);
};
ElementHandler.prototype.handler = function(type) {
  if (type === "Element") {
    return new GenericElementHandler(this.model, type, this.context);
  } else {
    return new ElementHandler(this.model, type, this.context);
  }
};
ElementHandler.prototype.handleChild = function(node2) {
  var propertyDesc, type, element, childHandler;
  propertyDesc = this.getPropertyForNode(node2);
  element = this.element;
  type = propertyDesc.effectiveType || propertyDesc.type;
  if (isSimple(type)) {
    return this.valueHandler(propertyDesc, element);
  }
  if (propertyDesc.isReference) {
    childHandler = this.referenceHandler(propertyDesc).handleNode(node2);
  } else {
    childHandler = this.handler(type).handleNode(node2);
  }
  var newElement = childHandler.element;
  if (newElement !== void 0) {
    if (propertyDesc.isMany) {
      element.get(propertyDesc.name).push(newElement);
    } else {
      element.set(propertyDesc.name, newElement);
    }
    if (propertyDesc.isReference) {
      assign$e(newElement, {
        element
      });
      this.context.addReference(newElement);
    } else {
      newElement.$parent = element;
    }
  }
  return childHandler;
};
function RootElementHandler(model, typeName, context) {
  ElementHandler.call(this, model, typeName, context);
}
RootElementHandler.prototype = Object.create(ElementHandler.prototype);
RootElementHandler.prototype.createElement = function(node2) {
  var name2 = node2.name, nameNs = parseName(name2), model = this.model, type = this.type, pkg = model.getPackage(nameNs.prefix), typeName = pkg && aliasToName(nameNs, pkg) || name2;
  if (!type.hasType(typeName)) {
    throw error$3("unexpected element <" + node2.originalName + ">");
  }
  return ElementHandler.prototype.createElement.call(this, node2);
};
function GenericElementHandler(model, typeName, context) {
  this.model = model;
  this.context = context;
}
GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);
GenericElementHandler.prototype.createElement = function(node2) {
  var name2 = node2.name, ns2 = parseName(name2), prefix2 = ns2.prefix, uri2 = node2.ns[prefix2 + "$uri"], attributes = node2.attributes;
  return this.model.createAny(name2, uri2, attributes);
};
GenericElementHandler.prototype.handleChild = function(node2) {
  var handler = new GenericElementHandler(this.model, "Element", this.context).handleNode(node2), element = this.element;
  var newElement = handler.element, children;
  if (newElement !== void 0) {
    children = element.$children = element.$children || [];
    children.push(newElement);
    newElement.$parent = element;
  }
  return handler;
};
GenericElementHandler.prototype.handleEnd = function() {
  if (this.body) {
    this.element.$body = this.body;
  }
};
function Reader(options) {
  if (options instanceof Moddle) {
    options = {
      model: options
    };
  }
  assign$e(this, { lax: false }, options);
}
Reader.prototype.fromXML = function(xml2, options, done) {
  var rootHandler = options.rootHandler;
  if (options instanceof ElementHandler) {
    rootHandler = options;
    options = {};
  } else {
    if (typeof options === "string") {
      rootHandler = this.handler(options);
      options = {};
    } else if (typeof rootHandler === "string") {
      rootHandler = this.handler(rootHandler);
    }
  }
  var model = this.model, lax = this.lax;
  var context = new Context(assign$e({}, options, { rootHandler })), parser2 = new Parser({ proxy: true }), stack = createStack();
  rootHandler.context = context;
  stack.push(rootHandler);
  function handleError(err, getContext, lax2) {
    var ctx = getContext();
    var line = ctx.line, column = ctx.column, data = ctx.data;
    if (data.charAt(0) === "<" && data.indexOf(" ") !== -1) {
      data = data.slice(0, data.indexOf(" ")) + ">";
    }
    var message2 = "unparsable content " + (data ? data + " " : "") + "detected\n	line: " + line + "\n	column: " + column + "\n	nested error: " + err.message;
    if (lax2) {
      context.addWarning({
        message: message2,
        error: err
      });
      return true;
    } else {
      throw error$3(message2);
    }
  }
  function handleWarning(err, getContext) {
    return handleError(err, getContext, true);
  }
  function resolveReferences() {
    var elementsById = context.elementsById;
    var references = context.references;
    var i, r;
    for (i = 0; r = references[i]; i++) {
      var element = r.element;
      var reference = elementsById[r.id];
      var property2 = getModdleDescriptor(element).propertiesByName[r.property];
      if (!reference) {
        context.addWarning({
          message: "unresolved reference <" + r.id + ">",
          element: r.element,
          property: r.property,
          value: r.id
        });
      }
      if (property2.isMany) {
        var collection2 = element.get(property2.name), idx = collection2.indexOf(r);
        if (idx === -1) {
          idx = collection2.length;
        }
        if (!reference) {
          collection2.splice(idx, 1);
        } else {
          collection2[idx] = reference;
        }
      } else {
        element.set(property2.name, reference);
      }
    }
  }
  function handleClose() {
    stack.pop().handleEnd();
  }
  var PREAMBLE_START_PATTERN = /^<\?xml /i;
  var ENCODING_PATTERN = / encoding="([^"]+)"/i;
  var UTF_8_PATTERN = /^utf-8$/i;
  function handleQuestion(question) {
    if (!PREAMBLE_START_PATTERN.test(question)) {
      return;
    }
    var match2 = ENCODING_PATTERN.exec(question);
    var encoding = match2 && match2[1];
    if (!encoding || UTF_8_PATTERN.test(encoding)) {
      return;
    }
    context.addWarning({
      message: "unsupported document encoding <" + encoding + ">, falling back to UTF-8"
    });
  }
  function handleOpen(node2, getContext) {
    var handler = stack.peek();
    try {
      stack.push(handler.handleNode(node2));
    } catch (err) {
      if (handleError(err, getContext, lax)) {
        stack.push(new NoopHandler());
      }
    }
  }
  function handleCData(text, getContext) {
    try {
      stack.peek().handleText(text);
    } catch (err) {
      handleWarning(err, getContext);
    }
  }
  function handleText(text, getContext) {
    if (!text.trim()) {
      return;
    }
    handleCData(text, getContext);
  }
  var uriMap = model.getPackages().reduce(function(uriMap2, p) {
    uriMap2[p.uri] = p.prefix;
    return uriMap2;
  }, {
    "http://www.w3.org/XML/1998/namespace": "xml"
  });
  parser2.ns(uriMap).on("openTag", function(obj, decodeStr, selfClosing, getContext) {
    var attrs = obj.attrs || {};
    var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {
      var value = decodeStr(attrs[key]);
      d[key] = value;
      return d;
    }, {});
    var node2 = {
      name: obj.name,
      originalName: obj.originalName,
      attributes: decodedAttrs,
      ns: obj.ns
    };
    handleOpen(node2, getContext);
  }).on("question", handleQuestion).on("closeTag", handleClose).on("cdata", handleCData).on("text", function(text, decodeEntities2, getContext) {
    handleText(decodeEntities2(text), getContext);
  }).on("error", handleError).on("warn", handleWarning);
  return new Promise(function(resolve, reject) {
    var err;
    try {
      parser2.parse(xml2);
      resolveReferences();
    } catch (e) {
      err = e;
    }
    var rootElement = rootHandler.element;
    if (!err && !rootElement) {
      err = error$3("failed to parse document as <" + rootHandler.type.$descriptor.name + ">");
    }
    var warnings = context.warnings;
    var references = context.references;
    var elementsById = context.elementsById;
    if (err) {
      err.warnings = warnings;
      return reject(err);
    } else {
      return resolve({
        rootElement,
        elementsById,
        references,
        warnings
      });
    }
  });
};
Reader.prototype.handler = function(name2) {
  return new RootElementHandler(this.model, name2);
};
function createStack() {
  var stack = [];
  Object.defineProperty(stack, "peek", {
    value: function() {
      return this[this.length - 1];
    }
  });
  return stack;
}
var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n';
var ESCAPE_ATTR_CHARS = /<|>|'|"|&|\n\r|\n/g;
var ESCAPE_CHARS = /<|>|&/g;
function Namespaces(parent2) {
  var prefixMap = {};
  var uriMap = {};
  var used = {};
  var wellknown = [];
  var custom = [];
  this.byUri = function(uri2) {
    return uriMap[uri2] || parent2 && parent2.byUri(uri2);
  };
  this.add = function(ns2, isWellknown) {
    uriMap[ns2.uri] = ns2;
    if (isWellknown) {
      wellknown.push(ns2);
    } else {
      custom.push(ns2);
    }
    this.mapPrefix(ns2.prefix, ns2.uri);
  };
  this.uriByPrefix = function(prefix2) {
    return prefixMap[prefix2 || "xmlns"];
  };
  this.mapPrefix = function(prefix2, uri2) {
    prefixMap[prefix2 || "xmlns"] = uri2;
  };
  this.getNSKey = function(ns2) {
    return ns2.prefix !== void 0 ? ns2.uri + "|" + ns2.prefix : ns2.uri;
  };
  this.logUsed = function(ns2) {
    var uri2 = ns2.uri;
    var nsKey = this.getNSKey(ns2);
    used[nsKey] = this.byUri(uri2);
    if (parent2) {
      parent2.logUsed(ns2);
    }
  };
  this.getUsed = function(ns2) {
    function isUsed(ns3) {
      var nsKey = self2.getNSKey(ns3);
      return used[nsKey];
    }
    var self2 = this;
    var allNs = [].concat(wellknown, custom);
    return allNs.filter(isUsed);
  };
}
function lower(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
}
function nameToAlias(name2, pkg) {
  if (hasLowerCaseAlias(pkg)) {
    return lower(name2);
  } else {
    return name2;
  }
}
function inherits$5(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}
function nsName(ns2) {
  if (isString$3(ns2)) {
    return ns2;
  } else {
    return (ns2.prefix ? ns2.prefix + ":" : "") + ns2.localName;
  }
}
function getNsAttrs(namespaces) {
  return namespaces.getUsed().filter(function(ns2) {
    return ns2.prefix !== "xml";
  }).map(function(ns2) {
    var name2 = "xmlns" + (ns2.prefix ? ":" + ns2.prefix : "");
    return { name: name2, value: ns2.uri };
  });
}
function getElementNs(ns2, descriptor) {
  if (descriptor.isGeneric) {
    return assign$e({ localName: descriptor.ns.localName }, ns2);
  } else {
    return assign$e({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns2);
  }
}
function getPropertyNs(ns2, descriptor) {
  return assign$e({ localName: descriptor.ns.localName }, ns2);
}
function getSerializableProperties(element) {
  var descriptor = element.$descriptor;
  return filter$a(descriptor.properties, function(p) {
    var name2 = p.name;
    if (p.isVirtual) {
      return false;
    }
    if (!has(element, name2)) {
      return false;
    }
    var value = element[name2];
    if (value === p.default) {
      return false;
    }
    if (value === null) {
      return false;
    }
    return p.isMany ? value.length : true;
  });
}
var ESCAPE_ATTR_MAP = {
  "\n": "#10",
  "\n\r": "#10",
  '"': "#34",
  "'": "#39",
  "<": "#60",
  ">": "#62",
  "&": "#38"
};
var ESCAPE_MAP = {
  "<": "lt",
  ">": "gt",
  "&": "amp"
};
function escape(str, charPattern, replaceMap) {
  str = isString$3(str) ? str : "" + str;
  return str.replace(charPattern, function(s) {
    return "&" + replaceMap[s] + ";";
  });
}
function escapeAttr(str) {
  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);
}
function escapeBody(str) {
  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);
}
function filterAttributes(props) {
  return filter$a(props, function(p) {
    return p.isAttr;
  });
}
function filterContained(props) {
  return filter$a(props, function(p) {
    return !p.isAttr;
  });
}
function ReferenceSerializer(tagName) {
  this.tagName = tagName;
}
ReferenceSerializer.prototype.build = function(element) {
  this.element = element;
  return this;
};
ReferenceSerializer.prototype.serializeTo = function(writer) {
  writer.appendIndent().append("<" + this.tagName + ">" + this.element.id + "</" + this.tagName + ">").appendNewLine();
};
function BodySerializer() {
}
BodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function(writer) {
  writer.append(this.escape ? escapeBody(this.value) : this.value);
};
BodySerializer.prototype.build = function(prop, value) {
  this.value = value;
  if (prop.type === "String" && value.search(ESCAPE_CHARS) !== -1) {
    this.escape = true;
  }
  return this;
};
function ValueSerializer(tagName) {
  this.tagName = tagName;
}
inherits$5(ValueSerializer, BodySerializer);
ValueSerializer.prototype.serializeTo = function(writer) {
  writer.appendIndent().append("<" + this.tagName + ">");
  this.serializeValue(writer);
  writer.append("</" + this.tagName + ">").appendNewLine();
};
function ElementSerializer(parent2, propertyDescriptor) {
  this.body = [];
  this.attrs = [];
  this.parent = parent2;
  this.propertyDescriptor = propertyDescriptor;
}
ElementSerializer.prototype.build = function(element) {
  this.element = element;
  var elementDescriptor = element.$descriptor, propertyDescriptor = this.propertyDescriptor;
  var otherAttrs, properties2;
  var isGeneric = elementDescriptor.isGeneric;
  if (isGeneric) {
    otherAttrs = this.parseGeneric(element);
  } else {
    otherAttrs = this.parseNsAttributes(element);
  }
  if (propertyDescriptor) {
    this.ns = this.nsPropertyTagName(propertyDescriptor);
  } else {
    this.ns = this.nsTagName(elementDescriptor);
  }
  this.tagName = this.addTagName(this.ns);
  if (!isGeneric) {
    properties2 = getSerializableProperties(element);
    this.parseAttributes(filterAttributes(properties2));
    this.parseContainments(filterContained(properties2));
  }
  this.parseGenericAttributes(element, otherAttrs);
  return this;
};
ElementSerializer.prototype.nsTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getElementNs(effectiveNs, descriptor);
};
ElementSerializer.prototype.nsPropertyTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getPropertyNs(effectiveNs, descriptor);
};
ElementSerializer.prototype.isLocalNs = function(ns2) {
  return ns2.uri === this.ns.uri;
};
ElementSerializer.prototype.nsAttributeName = function(element) {
  var ns2;
  if (isString$3(element)) {
    ns2 = parseName(element);
  } else {
    ns2 = element.ns;
  }
  if (element.inherited) {
    return { localName: ns2.localName };
  }
  var effectiveNs = this.logNamespaceUsed(ns2);
  this.getNamespaces().logUsed(effectiveNs);
  if (this.isLocalNs(effectiveNs)) {
    return { localName: ns2.localName };
  } else {
    return assign$e({ localName: ns2.localName }, effectiveNs);
  }
};
ElementSerializer.prototype.parseGeneric = function(element) {
  var self2 = this, body = this.body;
  var attributes = [];
  forEach$q(element, function(val, key) {
    var nonNsAttr;
    if (key === "$body") {
      body.push(new BodySerializer().build({ type: "String" }, val));
    } else if (key === "$children") {
      forEach$q(val, function(child) {
        body.push(new ElementSerializer(self2).build(child));
      });
    } else if (key.indexOf("$") !== 0) {
      nonNsAttr = self2.parseNsAttribute(element, key, val);
      if (nonNsAttr) {
        attributes.push({ name: key, value: val });
      }
    }
  });
  return attributes;
};
ElementSerializer.prototype.parseNsAttribute = function(element, name2, value) {
  var model = element.$model;
  var nameNs = parseName(name2);
  var ns2;
  if (nameNs.prefix === "xmlns") {
    ns2 = { prefix: nameNs.localName, uri: value };
  }
  if (!nameNs.prefix && nameNs.localName === "xmlns") {
    ns2 = { uri: value };
  }
  if (!ns2) {
    return {
      name: name2,
      value
    };
  }
  if (model && model.getPackage(value)) {
    this.logNamespace(ns2, true, true);
  } else {
    var actualNs = this.logNamespaceUsed(ns2, true);
    this.getNamespaces().logUsed(actualNs);
  }
};
ElementSerializer.prototype.parseNsAttributes = function(element, attrs) {
  var self2 = this;
  var genericAttrs = element.$attrs;
  var attributes = [];
  forEach$q(genericAttrs, function(value, name2) {
    var nonNsAttr = self2.parseNsAttribute(element, name2, value);
    if (nonNsAttr) {
      attributes.push(nonNsAttr);
    }
  });
  return attributes;
};
ElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {
  var self2 = this;
  forEach$q(attributes, function(attr2) {
    if (attr2.name === XSI_TYPE) {
      return;
    }
    try {
      self2.addAttribute(self2.nsAttributeName(attr2.name), attr2.value);
    } catch (e) {
      console.warn("missing namespace information for ", attr2.name, "=", attr2.value, "on", element, e);
    }
  });
};
ElementSerializer.prototype.parseContainments = function(properties2) {
  var self2 = this, body = this.body, element = this.element;
  forEach$q(properties2, function(p) {
    var value = element.get(p.name), isReference = p.isReference, isMany = p.isMany;
    if (!isMany) {
      value = [value];
    }
    if (p.isBody) {
      body.push(new BodySerializer().build(p, value[0]));
    } else if (isSimple(p.type)) {
      forEach$q(value, function(v) {
        body.push(new ValueSerializer(self2.addTagName(self2.nsPropertyTagName(p))).build(p, v));
      });
    } else if (isReference) {
      forEach$q(value, function(v) {
        body.push(new ReferenceSerializer(self2.addTagName(self2.nsPropertyTagName(p))).build(v));
      });
    } else {
      var asType = serializeAsType(p), asProperty = serializeAsProperty(p);
      forEach$q(value, function(v) {
        var serializer;
        if (asType) {
          serializer = new TypeSerializer(self2, p);
        } else if (asProperty) {
          serializer = new ElementSerializer(self2, p);
        } else {
          serializer = new ElementSerializer(self2);
        }
        body.push(serializer.build(v));
      });
    }
  });
};
ElementSerializer.prototype.getNamespaces = function(local) {
  var namespaces = this.namespaces, parent2 = this.parent, parentNamespaces;
  if (!namespaces) {
    parentNamespaces = parent2 && parent2.getNamespaces();
    if (local || !parentNamespaces) {
      this.namespaces = namespaces = new Namespaces(parentNamespaces);
    } else {
      namespaces = parentNamespaces;
    }
  }
  return namespaces;
};
ElementSerializer.prototype.logNamespace = function(ns2, wellknown, local) {
  var namespaces = this.getNamespaces(local);
  var nsUri = ns2.uri, nsPrefix = ns2.prefix;
  var existing = namespaces.byUri(nsUri);
  if (!existing || local) {
    namespaces.add(ns2, wellknown);
  }
  namespaces.mapPrefix(nsPrefix, nsUri);
  return ns2;
};
ElementSerializer.prototype.logNamespaceUsed = function(ns2, local) {
  var element = this.element, model = element.$model, namespaces = this.getNamespaces(local);
  var prefix2 = ns2.prefix, uri2 = ns2.uri, newPrefix, idx, wellknownUri;
  if (!prefix2 && !uri2) {
    return { localName: ns2.localName };
  }
  wellknownUri = DEFAULT_NS_MAP[prefix2] || model && (model.getPackage(prefix2) || {}).uri;
  uri2 = uri2 || wellknownUri || namespaces.uriByPrefix(prefix2);
  if (!uri2) {
    throw new Error("no namespace uri given for prefix <" + prefix2 + ">");
  }
  ns2 = namespaces.byUri(uri2);
  if (!ns2) {
    newPrefix = prefix2;
    idx = 1;
    while (namespaces.uriByPrefix(newPrefix)) {
      newPrefix = prefix2 + "_" + idx++;
    }
    ns2 = this.logNamespace({ prefix: newPrefix, uri: uri2 }, wellknownUri === uri2);
  }
  if (prefix2) {
    namespaces.mapPrefix(prefix2, uri2);
  }
  return ns2;
};
ElementSerializer.prototype.parseAttributes = function(properties2) {
  var self2 = this, element = this.element;
  forEach$q(properties2, function(p) {
    var value = element.get(p.name);
    if (p.isReference) {
      if (!p.isMany) {
        value = value.id;
      } else {
        var values2 = [];
        forEach$q(value, function(v) {
          values2.push(v.id);
        });
        value = values2.join(" ");
      }
    }
    self2.addAttribute(self2.nsAttributeName(p), value);
  });
};
ElementSerializer.prototype.addTagName = function(nsTagName) {
  var actualNs = this.logNamespaceUsed(nsTagName);
  this.getNamespaces().logUsed(actualNs);
  return nsName(nsTagName);
};
ElementSerializer.prototype.addAttribute = function(name2, value) {
  var attrs = this.attrs;
  if (isString$3(value)) {
    value = escapeAttr(value);
  }
  attrs.push({ name: name2, value });
};
ElementSerializer.prototype.serializeAttributes = function(writer) {
  var attrs = this.attrs, namespaces = this.namespaces;
  if (namespaces) {
    attrs = getNsAttrs(namespaces).concat(attrs);
  }
  forEach$q(attrs, function(a) {
    writer.append(" ").append(nsName(a.name)).append('="').append(a.value).append('"');
  });
};
ElementSerializer.prototype.serializeTo = function(writer) {
  var firstBody = this.body[0], indent = firstBody && firstBody.constructor !== BodySerializer;
  writer.appendIndent().append("<" + this.tagName);
  this.serializeAttributes(writer);
  writer.append(firstBody ? ">" : " />");
  if (firstBody) {
    if (indent) {
      writer.appendNewLine().indent();
    }
    forEach$q(this.body, function(b) {
      b.serializeTo(writer);
    });
    if (indent) {
      writer.unindent().appendIndent();
    }
    writer.append("</" + this.tagName + ">");
  }
  writer.appendNewLine();
};
function TypeSerializer(parent2, propertyDescriptor) {
  ElementSerializer.call(this, parent2, propertyDescriptor);
}
inherits$5(TypeSerializer, ElementSerializer);
TypeSerializer.prototype.parseNsAttributes = function(element) {
  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);
  var descriptor = element.$descriptor;
  if (descriptor.name === this.propertyDescriptor.type) {
    return attributes;
  }
  var typeNs = this.typeNs = this.nsTagName(descriptor);
  this.getNamespaces().logUsed(this.typeNs);
  var pkg = element.$model.getPackage(typeNs.uri), typePrefix = pkg.xml && pkg.xml.typePrefix || "";
  this.addAttribute(this.nsAttributeName(XSI_TYPE), (typeNs.prefix ? typeNs.prefix + ":" : "") + typePrefix + descriptor.ns.localName);
  return attributes;
};
TypeSerializer.prototype.isLocalNs = function(ns2) {
  return ns2.uri === (this.typeNs || this.ns).uri;
};
function SavingWriter() {
  this.value = "";
  this.write = function(str) {
    this.value += str;
  };
}
function FormatingWriter(out, format2) {
  var indent = [""];
  this.append = function(str) {
    out.write(str);
    return this;
  };
  this.appendNewLine = function() {
    if (format2) {
      out.write("\n");
    }
    return this;
  };
  this.appendIndent = function() {
    if (format2) {
      out.write(indent.join("  "));
    }
    return this;
  };
  this.indent = function() {
    indent.push("");
    return this;
  };
  this.unindent = function() {
    indent.pop();
    return this;
  };
}
function Writer(options) {
  options = assign$e({ format: false, preamble: true }, options || {});
  function toXML(tree, writer) {
    var internalWriter = writer || new SavingWriter();
    var formatingWriter = new FormatingWriter(internalWriter, options.format);
    if (options.preamble) {
      formatingWriter.append(XML_PREAMBLE);
    }
    new ElementSerializer().build(tree).serializeTo(formatingWriter);
    if (!writer) {
      return internalWriter.value;
    }
  }
  return {
    toXML
  };
}
function BpmnModdle(packages2, options) {
  Moddle.call(this, packages2, options);
}
BpmnModdle.prototype = Object.create(Moddle.prototype);
BpmnModdle.prototype.fromXML = function(xmlStr, typeName, options) {
  if (!isString$3(typeName)) {
    options = typeName;
    typeName = "bpmn:Definitions";
  }
  var reader = new Reader(assign$e({ model: this, lax: true }, options));
  var rootHandler = reader.handler(typeName);
  return reader.fromXML(xmlStr, rootHandler);
};
BpmnModdle.prototype.toXML = function(element, options) {
  var writer = new Writer(options);
  return new Promise(function(resolve, reject) {
    try {
      var result = writer.toXML(element);
      return resolve({
        xml: result
      });
    } catch (err) {
      return reject(err);
    }
  });
};
var name$1 = "BPMN20";
var uri$1 = "http://www.omg.org/spec/BPMN/20100524/MODEL";
var prefix$1 = "bpmn";
var associations$1 = [];
var types$1 = [
  {
    name: "Interface",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "operations",
        type: "Operation",
        isMany: true
      },
      {
        name: "implementationRef",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Operation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "inMessageRef",
        type: "Message",
        isReference: true
      },
      {
        name: "outMessageRef",
        type: "Message",
        isReference: true
      },
      {
        name: "errorRef",
        type: "Error",
        isMany: true,
        isReference: true
      },
      {
        name: "implementationRef",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "EndPoint",
    superClass: [
      "RootElement"
    ]
  },
  {
    name: "Auditing",
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "GlobalTask",
    superClass: [
      "CallableElement"
    ],
    properties: [
      {
        name: "resources",
        type: "ResourceRole",
        isMany: true
      }
    ]
  },
  {
    name: "Monitoring",
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Performer",
    superClass: [
      "ResourceRole"
    ]
  },
  {
    name: "Process",
    superClass: [
      "FlowElementsContainer",
      "CallableElement"
    ],
    properties: [
      {
        name: "processType",
        type: "ProcessType",
        isAttr: true
      },
      {
        name: "isClosed",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "auditing",
        type: "Auditing"
      },
      {
        name: "monitoring",
        type: "Monitoring"
      },
      {
        name: "properties",
        type: "Property",
        isMany: true
      },
      {
        name: "laneSets",
        isMany: true,
        replaces: "FlowElementsContainer#laneSets",
        type: "LaneSet"
      },
      {
        name: "flowElements",
        isMany: true,
        replaces: "FlowElementsContainer#flowElements",
        type: "FlowElement"
      },
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      },
      {
        name: "resources",
        type: "ResourceRole",
        isMany: true
      },
      {
        name: "correlationSubscriptions",
        type: "CorrelationSubscription",
        isMany: true
      },
      {
        name: "supports",
        type: "Process",
        isMany: true,
        isReference: true
      },
      {
        name: "definitionalCollaborationRef",
        type: "Collaboration",
        isAttr: true,
        isReference: true
      },
      {
        name: "isExecutable",
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "LaneSet",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "lanes",
        type: "Lane",
        isMany: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Lane",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "partitionElementRef",
        type: "BaseElement",
        isAttr: true,
        isReference: true
      },
      {
        name: "partitionElement",
        type: "BaseElement"
      },
      {
        name: "flowNodeRef",
        type: "FlowNode",
        isMany: true,
        isReference: true
      },
      {
        name: "childLaneSet",
        type: "LaneSet",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "GlobalManualTask",
    superClass: [
      "GlobalTask"
    ]
  },
  {
    name: "ManualTask",
    superClass: [
      "Task"
    ]
  },
  {
    name: "UserTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "renderings",
        type: "Rendering",
        isMany: true
      },
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Rendering",
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "HumanPerformer",
    superClass: [
      "Performer"
    ]
  },
  {
    name: "PotentialOwner",
    superClass: [
      "HumanPerformer"
    ]
  },
  {
    name: "GlobalUserTask",
    superClass: [
      "GlobalTask"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "renderings",
        type: "Rendering",
        isMany: true
      }
    ]
  },
  {
    name: "Gateway",
    isAbstract: true,
    superClass: [
      "FlowNode"
    ],
    properties: [
      {
        name: "gatewayDirection",
        type: "GatewayDirection",
        "default": "Unspecified",
        isAttr: true
      }
    ]
  },
  {
    name: "EventBasedGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "instantiate",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "eventGatewayType",
        type: "EventBasedGatewayType",
        isAttr: true,
        "default": "Exclusive"
      }
    ]
  },
  {
    name: "ComplexGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "activationCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ExclusiveGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "InclusiveGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ParallelGateway",
    superClass: [
      "Gateway"
    ]
  },
  {
    name: "RootElement",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Relationship",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "type",
        isAttr: true,
        type: "String"
      },
      {
        name: "direction",
        type: "RelationshipDirection",
        isAttr: true
      },
      {
        name: "source",
        isMany: true,
        isReference: true,
        type: "Element"
      },
      {
        name: "target",
        isMany: true,
        isReference: true,
        type: "Element"
      }
    ]
  },
  {
    name: "BaseElement",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        type: "String",
        isId: true
      },
      {
        name: "documentation",
        type: "Documentation",
        isMany: true
      },
      {
        name: "extensionDefinitions",
        type: "ExtensionDefinition",
        isMany: true,
        isReference: true
      },
      {
        name: "extensionElements",
        type: "ExtensionElements"
      }
    ]
  },
  {
    name: "Extension",
    properties: [
      {
        name: "mustUnderstand",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "definition",
        type: "ExtensionDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ExtensionDefinition",
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "extensionAttributeDefinitions",
        type: "ExtensionAttributeDefinition",
        isMany: true
      }
    ]
  },
  {
    name: "ExtensionAttributeDefinition",
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "type",
        isAttr: true,
        type: "String"
      },
      {
        name: "isReference",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "extensionDefinition",
        type: "ExtensionDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ExtensionElements",
    properties: [
      {
        name: "valueRef",
        isAttr: true,
        isReference: true,
        type: "Element"
      },
      {
        name: "values",
        type: "Element",
        isMany: true
      },
      {
        name: "extensionAttributeDefinition",
        type: "ExtensionAttributeDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Documentation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "text",
        type: "String",
        isBody: true
      },
      {
        name: "textFormat",
        "default": "text/plain",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Event",
    isAbstract: true,
    superClass: [
      "FlowNode",
      "InteractionNode"
    ],
    properties: [
      {
        name: "properties",
        type: "Property",
        isMany: true
      }
    ]
  },
  {
    name: "IntermediateCatchEvent",
    superClass: [
      "CatchEvent"
    ]
  },
  {
    name: "IntermediateThrowEvent",
    superClass: [
      "ThrowEvent"
    ]
  },
  {
    name: "EndEvent",
    superClass: [
      "ThrowEvent"
    ]
  },
  {
    name: "StartEvent",
    superClass: [
      "CatchEvent"
    ],
    properties: [
      {
        name: "isInterrupting",
        "default": true,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "ThrowEvent",
    isAbstract: true,
    superClass: [
      "Event"
    ],
    properties: [
      {
        name: "dataInputs",
        type: "DataInput",
        isMany: true
      },
      {
        name: "dataInputAssociations",
        type: "DataInputAssociation",
        isMany: true
      },
      {
        name: "inputSet",
        type: "InputSet"
      },
      {
        name: "eventDefinitions",
        type: "EventDefinition",
        isMany: true
      },
      {
        name: "eventDefinitionRef",
        type: "EventDefinition",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "CatchEvent",
    isAbstract: true,
    superClass: [
      "Event"
    ],
    properties: [
      {
        name: "parallelMultiple",
        isAttr: true,
        type: "Boolean",
        "default": false
      },
      {
        name: "dataOutputs",
        type: "DataOutput",
        isMany: true
      },
      {
        name: "dataOutputAssociations",
        type: "DataOutputAssociation",
        isMany: true
      },
      {
        name: "outputSet",
        type: "OutputSet"
      },
      {
        name: "eventDefinitions",
        type: "EventDefinition",
        isMany: true
      },
      {
        name: "eventDefinitionRef",
        type: "EventDefinition",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "BoundaryEvent",
    superClass: [
      "CatchEvent"
    ],
    properties: [
      {
        name: "cancelActivity",
        "default": true,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "attachedToRef",
        type: "Activity",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "EventDefinition",
    isAbstract: true,
    superClass: [
      "RootElement"
    ]
  },
  {
    name: "CancelEventDefinition",
    superClass: [
      "EventDefinition"
    ]
  },
  {
    name: "ErrorEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "errorRef",
        type: "Error",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "TerminateEventDefinition",
    superClass: [
      "EventDefinition"
    ]
  },
  {
    name: "EscalationEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "escalationRef",
        type: "Escalation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Escalation",
    properties: [
      {
        name: "structureRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "escalationCode",
        isAttr: true,
        type: "String"
      }
    ],
    superClass: [
      "RootElement"
    ]
  },
  {
    name: "CompensateEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "waitForCompletion",
        isAttr: true,
        type: "Boolean",
        "default": true
      },
      {
        name: "activityRef",
        type: "Activity",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "TimerEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "timeDate",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "timeCycle",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "timeDuration",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "LinkEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "target",
        type: "LinkEventDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "source",
        type: "LinkEventDefinition",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "MessageEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ConditionalEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "condition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "SignalEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "signalRef",
        type: "Signal",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Signal",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "structureRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ImplicitThrowEvent",
    superClass: [
      "ThrowEvent"
    ]
  },
  {
    name: "DataState",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ItemAwareElement",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "itemSubjectRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "dataState",
        type: "DataState"
      }
    ]
  },
  {
    name: "DataAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "sourceRef",
        type: "ItemAwareElement",
        isMany: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "ItemAwareElement",
        isReference: true
      },
      {
        name: "transformation",
        type: "FormalExpression",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "assignment",
        type: "Assignment",
        isMany: true
      }
    ]
  },
  {
    name: "DataInput",
    superClass: [
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "inputSetRef",
        type: "InputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "inputSetWithOptional",
        type: "InputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "inputSetWithWhileExecuting",
        type: "InputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "DataOutput",
    superClass: [
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "outputSetRef",
        type: "OutputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "outputSetWithOptional",
        type: "OutputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "outputSetWithWhileExecuting",
        type: "OutputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "InputSet",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "dataInputRefs",
        type: "DataInput",
        isMany: true,
        isReference: true
      },
      {
        name: "optionalInputRefs",
        type: "DataInput",
        isMany: true,
        isReference: true
      },
      {
        name: "whileExecutingInputRefs",
        type: "DataInput",
        isMany: true,
        isReference: true
      },
      {
        name: "outputSetRefs",
        type: "OutputSet",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "OutputSet",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "dataOutputRefs",
        type: "DataOutput",
        isMany: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "inputSetRefs",
        type: "InputSet",
        isMany: true,
        isReference: true
      },
      {
        name: "optionalOutputRefs",
        type: "DataOutput",
        isMany: true,
        isReference: true
      },
      {
        name: "whileExecutingOutputRefs",
        type: "DataOutput",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "Property",
    superClass: [
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "DataInputAssociation",
    superClass: [
      "DataAssociation"
    ]
  },
  {
    name: "DataOutputAssociation",
    superClass: [
      "DataAssociation"
    ]
  },
  {
    name: "InputOutputSpecification",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "dataInputs",
        type: "DataInput",
        isMany: true
      },
      {
        name: "dataOutputs",
        type: "DataOutput",
        isMany: true
      },
      {
        name: "inputSets",
        type: "InputSet",
        isMany: true
      },
      {
        name: "outputSets",
        type: "OutputSet",
        isMany: true
      }
    ]
  },
  {
    name: "DataObject",
    superClass: [
      "FlowElement",
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "InputOutputBinding",
    properties: [
      {
        name: "inputDataRef",
        type: "InputSet",
        isAttr: true,
        isReference: true
      },
      {
        name: "outputDataRef",
        type: "OutputSet",
        isAttr: true,
        isReference: true
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Assignment",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "from",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "to",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "DataStore",
    superClass: [
      "RootElement",
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "capacity",
        isAttr: true,
        type: "Integer"
      },
      {
        name: "isUnlimited",
        "default": true,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "DataStoreReference",
    superClass: [
      "ItemAwareElement",
      "FlowElement"
    ],
    properties: [
      {
        name: "dataStoreRef",
        type: "DataStore",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "DataObjectReference",
    superClass: [
      "ItemAwareElement",
      "FlowElement"
    ],
    properties: [
      {
        name: "dataObjectRef",
        type: "DataObject",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ConversationLink",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "sourceRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ConversationAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "innerConversationNodeRef",
        type: "ConversationNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "outerConversationNodeRef",
        type: "ConversationNode",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "CallConversation",
    superClass: [
      "ConversationNode"
    ],
    properties: [
      {
        name: "calledCollaborationRef",
        type: "Collaboration",
        isAttr: true,
        isReference: true
      },
      {
        name: "participantAssociations",
        type: "ParticipantAssociation",
        isMany: true
      }
    ]
  },
  {
    name: "Conversation",
    superClass: [
      "ConversationNode"
    ]
  },
  {
    name: "SubConversation",
    superClass: [
      "ConversationNode"
    ],
    properties: [
      {
        name: "conversationNodes",
        type: "ConversationNode",
        isMany: true
      }
    ]
  },
  {
    name: "ConversationNode",
    isAbstract: true,
    superClass: [
      "InteractionNode",
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      },
      {
        name: "messageFlowRefs",
        type: "MessageFlow",
        isMany: true,
        isReference: true
      },
      {
        name: "correlationKeys",
        type: "CorrelationKey",
        isMany: true
      }
    ]
  },
  {
    name: "GlobalConversation",
    superClass: [
      "Collaboration"
    ]
  },
  {
    name: "PartnerEntity",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "PartnerRole",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationProperty",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "correlationPropertyRetrievalExpression",
        type: "CorrelationPropertyRetrievalExpression",
        isMany: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "type",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Error",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "structureRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "errorCode",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "CorrelationKey",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "correlationPropertyRef",
        type: "CorrelationProperty",
        isMany: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Expression",
    superClass: [
      "BaseElement"
    ],
    isAbstract: false,
    properties: [
      {
        name: "body",
        isBody: true,
        type: "String"
      }
    ]
  },
  {
    name: "FormalExpression",
    superClass: [
      "Expression"
    ],
    properties: [
      {
        name: "language",
        isAttr: true,
        type: "String"
      },
      {
        name: "evaluatesToTypeRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Message",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "itemRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ItemDefinition",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "itemKind",
        type: "ItemKind",
        isAttr: true
      },
      {
        name: "structureRef",
        isAttr: true,
        type: "String"
      },
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "import",
        type: "Import",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "FlowElement",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "auditing",
        type: "Auditing"
      },
      {
        name: "monitoring",
        type: "Monitoring"
      },
      {
        name: "categoryValueRef",
        type: "CategoryValue",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "SequenceFlow",
    superClass: [
      "FlowElement"
    ],
    properties: [
      {
        name: "isImmediate",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "conditionExpression",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "sourceRef",
        type: "FlowNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "FlowNode",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "FlowElementsContainer",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "laneSets",
        type: "LaneSet",
        isMany: true
      },
      {
        name: "flowElements",
        type: "FlowElement",
        isMany: true
      }
    ]
  },
  {
    name: "CallableElement",
    isAbstract: true,
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "ioSpecification",
        type: "InputOutputSpecification",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "supportedInterfaceRef",
        type: "Interface",
        isMany: true,
        isReference: true
      },
      {
        name: "ioBinding",
        type: "InputOutputBinding",
        isMany: true,
        xml: {
          serialize: "property"
        }
      }
    ]
  },
  {
    name: "FlowNode",
    isAbstract: true,
    superClass: [
      "FlowElement"
    ],
    properties: [
      {
        name: "incoming",
        type: "SequenceFlow",
        isMany: true,
        isReference: true
      },
      {
        name: "outgoing",
        type: "SequenceFlow",
        isMany: true,
        isReference: true
      },
      {
        name: "lanes",
        type: "Lane",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationPropertyRetrievalExpression",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "messagePath",
        type: "FormalExpression"
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationPropertyBinding",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "dataPath",
        type: "FormalExpression"
      },
      {
        name: "correlationPropertyRef",
        type: "CorrelationProperty",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Resource",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "resourceParameters",
        type: "ResourceParameter",
        isMany: true
      }
    ]
  },
  {
    name: "ResourceParameter",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isRequired",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "type",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationSubscription",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "correlationKeyRef",
        type: "CorrelationKey",
        isAttr: true,
        isReference: true
      },
      {
        name: "correlationPropertyBinding",
        type: "CorrelationPropertyBinding",
        isMany: true
      }
    ]
  },
  {
    name: "MessageFlow",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "sourceRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "MessageFlowAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "innerMessageFlowRef",
        type: "MessageFlow",
        isAttr: true,
        isReference: true
      },
      {
        name: "outerMessageFlowRef",
        type: "MessageFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "InteractionNode",
    isAbstract: true,
    properties: [
      {
        name: "incomingConversationLinks",
        type: "ConversationLink",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "outgoingConversationLinks",
        type: "ConversationLink",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "Participant",
    superClass: [
      "InteractionNode",
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "interfaceRef",
        type: "Interface",
        isMany: true,
        isReference: true
      },
      {
        name: "participantMultiplicity",
        type: "ParticipantMultiplicity"
      },
      {
        name: "endPointRefs",
        type: "EndPoint",
        isMany: true,
        isReference: true
      },
      {
        name: "processRef",
        type: "Process",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ParticipantAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "innerParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      },
      {
        name: "outerParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ParticipantMultiplicity",
    properties: [
      {
        name: "minimum",
        "default": 0,
        isAttr: true,
        type: "Integer"
      },
      {
        name: "maximum",
        "default": 1,
        isAttr: true,
        type: "Integer"
      }
    ],
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Collaboration",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isClosed",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "participants",
        type: "Participant",
        isMany: true
      },
      {
        name: "messageFlows",
        type: "MessageFlow",
        isMany: true
      },
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      },
      {
        name: "conversations",
        type: "ConversationNode",
        isMany: true
      },
      {
        name: "conversationAssociations",
        type: "ConversationAssociation"
      },
      {
        name: "participantAssociations",
        type: "ParticipantAssociation",
        isMany: true
      },
      {
        name: "messageFlowAssociations",
        type: "MessageFlowAssociation",
        isMany: true
      },
      {
        name: "correlationKeys",
        type: "CorrelationKey",
        isMany: true
      },
      {
        name: "choreographyRef",
        type: "Choreography",
        isMany: true,
        isReference: true
      },
      {
        name: "conversationLinks",
        type: "ConversationLink",
        isMany: true
      }
    ]
  },
  {
    name: "ChoreographyActivity",
    isAbstract: true,
    superClass: [
      "FlowNode"
    ],
    properties: [
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      },
      {
        name: "initiatingParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      },
      {
        name: "correlationKeys",
        type: "CorrelationKey",
        isMany: true
      },
      {
        name: "loopType",
        type: "ChoreographyLoopType",
        "default": "None",
        isAttr: true
      }
    ]
  },
  {
    name: "CallChoreography",
    superClass: [
      "ChoreographyActivity"
    ],
    properties: [
      {
        name: "calledChoreographyRef",
        type: "Choreography",
        isAttr: true,
        isReference: true
      },
      {
        name: "participantAssociations",
        type: "ParticipantAssociation",
        isMany: true
      }
    ]
  },
  {
    name: "SubChoreography",
    superClass: [
      "ChoreographyActivity",
      "FlowElementsContainer"
    ],
    properties: [
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      }
    ]
  },
  {
    name: "ChoreographyTask",
    superClass: [
      "ChoreographyActivity"
    ],
    properties: [
      {
        name: "messageFlowRef",
        type: "MessageFlow",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "Choreography",
    superClass: [
      "Collaboration",
      "FlowElementsContainer"
    ]
  },
  {
    name: "GlobalChoreographyTask",
    superClass: [
      "Choreography"
    ],
    properties: [
      {
        name: "initiatingParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "TextAnnotation",
    superClass: [
      "Artifact"
    ],
    properties: [
      {
        name: "text",
        type: "String"
      },
      {
        name: "textFormat",
        "default": "text/plain",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Group",
    superClass: [
      "Artifact"
    ],
    properties: [
      {
        name: "categoryValueRef",
        type: "CategoryValue",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Association",
    superClass: [
      "Artifact"
    ],
    properties: [
      {
        name: "associationDirection",
        type: "AssociationDirection",
        isAttr: true
      },
      {
        name: "sourceRef",
        type: "BaseElement",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "BaseElement",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Category",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "categoryValue",
        type: "CategoryValue",
        isMany: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Artifact",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "CategoryValue",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "categorizedFlowElements",
        type: "FlowElement",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "value",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Activity",
    isAbstract: true,
    superClass: [
      "FlowNode"
    ],
    properties: [
      {
        name: "isForCompensation",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      },
      {
        name: "ioSpecification",
        type: "InputOutputSpecification",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "boundaryEventRefs",
        type: "BoundaryEvent",
        isMany: true,
        isReference: true
      },
      {
        name: "properties",
        type: "Property",
        isMany: true
      },
      {
        name: "dataInputAssociations",
        type: "DataInputAssociation",
        isMany: true
      },
      {
        name: "dataOutputAssociations",
        type: "DataOutputAssociation",
        isMany: true
      },
      {
        name: "startQuantity",
        "default": 1,
        isAttr: true,
        type: "Integer"
      },
      {
        name: "resources",
        type: "ResourceRole",
        isMany: true
      },
      {
        name: "completionQuantity",
        "default": 1,
        isAttr: true,
        type: "Integer"
      },
      {
        name: "loopCharacteristics",
        type: "LoopCharacteristics"
      }
    ]
  },
  {
    name: "ServiceTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "SubProcess",
    superClass: [
      "Activity",
      "FlowElementsContainer",
      "InteractionNode"
    ],
    properties: [
      {
        name: "triggeredByEvent",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      }
    ]
  },
  {
    name: "LoopCharacteristics",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "MultiInstanceLoopCharacteristics",
    superClass: [
      "LoopCharacteristics"
    ],
    properties: [
      {
        name: "isSequential",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "behavior",
        type: "MultiInstanceBehavior",
        "default": "All",
        isAttr: true
      },
      {
        name: "loopCardinality",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "loopDataInputRef",
        type: "ItemAwareElement",
        isReference: true
      },
      {
        name: "loopDataOutputRef",
        type: "ItemAwareElement",
        isReference: true
      },
      {
        name: "inputDataItem",
        type: "DataInput",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "outputDataItem",
        type: "DataOutput",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "complexBehaviorDefinition",
        type: "ComplexBehaviorDefinition",
        isMany: true
      },
      {
        name: "completionCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "oneBehaviorEventRef",
        type: "EventDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "noneBehaviorEventRef",
        type: "EventDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "StandardLoopCharacteristics",
    superClass: [
      "LoopCharacteristics"
    ],
    properties: [
      {
        name: "testBefore",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "loopCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "loopMaximum",
        type: "Integer",
        isAttr: true
      }
    ]
  },
  {
    name: "CallActivity",
    superClass: [
      "Activity",
      "InteractionNode"
    ],
    properties: [
      {
        name: "calledElement",
        type: "String",
        isAttr: true
      }
    ]
  },
  {
    name: "Task",
    superClass: [
      "Activity",
      "InteractionNode"
    ]
  },
  {
    name: "SendTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ReceiveTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "instantiate",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ScriptTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "scriptFormat",
        isAttr: true,
        type: "String"
      },
      {
        name: "script",
        type: "String"
      }
    ]
  },
  {
    name: "BusinessRuleTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "AdHocSubProcess",
    superClass: [
      "SubProcess"
    ],
    properties: [
      {
        name: "completionCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "ordering",
        type: "AdHocOrdering",
        isAttr: true
      },
      {
        name: "cancelRemainingInstances",
        "default": true,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "Transaction",
    superClass: [
      "SubProcess"
    ],
    properties: [
      {
        name: "protocol",
        isAttr: true,
        type: "String"
      },
      {
        name: "method",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "GlobalScriptTask",
    superClass: [
      "GlobalTask"
    ],
    properties: [
      {
        name: "scriptLanguage",
        isAttr: true,
        type: "String"
      },
      {
        name: "script",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "GlobalBusinessRuleTask",
    superClass: [
      "GlobalTask"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ComplexBehaviorDefinition",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "condition",
        type: "FormalExpression"
      },
      {
        name: "event",
        type: "ImplicitThrowEvent"
      }
    ]
  },
  {
    name: "ResourceRole",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "resourceRef",
        type: "Resource",
        isReference: true
      },
      {
        name: "resourceParameterBindings",
        type: "ResourceParameterBinding",
        isMany: true
      },
      {
        name: "resourceAssignmentExpression",
        type: "ResourceAssignmentExpression"
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ResourceParameterBinding",
    properties: [
      {
        name: "expression",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "parameterRef",
        type: "ResourceParameter",
        isAttr: true,
        isReference: true
      }
    ],
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "ResourceAssignmentExpression",
    properties: [
      {
        name: "expression",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ],
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Import",
    properties: [
      {
        name: "importType",
        isAttr: true,
        type: "String"
      },
      {
        name: "location",
        isAttr: true,
        type: "String"
      },
      {
        name: "namespace",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Definitions",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "targetNamespace",
        isAttr: true,
        type: "String"
      },
      {
        name: "expressionLanguage",
        "default": "http://www.w3.org/1999/XPath",
        isAttr: true,
        type: "String"
      },
      {
        name: "typeLanguage",
        "default": "http://www.w3.org/2001/XMLSchema",
        isAttr: true,
        type: "String"
      },
      {
        name: "imports",
        type: "Import",
        isMany: true
      },
      {
        name: "extensions",
        type: "Extension",
        isMany: true
      },
      {
        name: "rootElements",
        type: "RootElement",
        isMany: true
      },
      {
        name: "diagrams",
        isMany: true,
        type: "bpmndi:BPMNDiagram"
      },
      {
        name: "exporter",
        isAttr: true,
        type: "String"
      },
      {
        name: "relationships",
        type: "Relationship",
        isMany: true
      },
      {
        name: "exporterVersion",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
var enumerations = [
  {
    name: "ProcessType",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "Public"
      },
      {
        name: "Private"
      }
    ]
  },
  {
    name: "GatewayDirection",
    literalValues: [
      {
        name: "Unspecified"
      },
      {
        name: "Converging"
      },
      {
        name: "Diverging"
      },
      {
        name: "Mixed"
      }
    ]
  },
  {
    name: "EventBasedGatewayType",
    literalValues: [
      {
        name: "Parallel"
      },
      {
        name: "Exclusive"
      }
    ]
  },
  {
    name: "RelationshipDirection",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "Forward"
      },
      {
        name: "Backward"
      },
      {
        name: "Both"
      }
    ]
  },
  {
    name: "ItemKind",
    literalValues: [
      {
        name: "Physical"
      },
      {
        name: "Information"
      }
    ]
  },
  {
    name: "ChoreographyLoopType",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "Standard"
      },
      {
        name: "MultiInstanceSequential"
      },
      {
        name: "MultiInstanceParallel"
      }
    ]
  },
  {
    name: "AssociationDirection",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "One"
      },
      {
        name: "Both"
      }
    ]
  },
  {
    name: "MultiInstanceBehavior",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "One"
      },
      {
        name: "All"
      },
      {
        name: "Complex"
      }
    ]
  },
  {
    name: "AdHocOrdering",
    literalValues: [
      {
        name: "Parallel"
      },
      {
        name: "Sequential"
      }
    ]
  }
];
var xml$1 = {
  tagAlias: "lowerCase",
  typePrefix: "t"
};
var BpmnPackage = {
  name: name$1,
  uri: uri$1,
  prefix: prefix$1,
  associations: associations$1,
  types: types$1,
  enumerations,
  xml: xml$1
};
var name$1$1 = "BPMNDI";
var uri$1$1 = "http://www.omg.org/spec/BPMN/20100524/DI";
var prefix$1$1 = "bpmndi";
var types$1$1 = [
  {
    name: "BPMNDiagram",
    properties: [
      {
        name: "plane",
        type: "BPMNPlane",
        redefines: "di:Diagram#rootElement"
      },
      {
        name: "labelStyle",
        type: "BPMNLabelStyle",
        isMany: true
      }
    ],
    superClass: [
      "di:Diagram"
    ]
  },
  {
    name: "BPMNPlane",
    properties: [
      {
        name: "bpmnElement",
        isAttr: true,
        isReference: true,
        type: "bpmn:BaseElement",
        redefines: "di:DiagramElement#modelElement"
      }
    ],
    superClass: [
      "di:Plane"
    ]
  },
  {
    name: "BPMNShape",
    properties: [
      {
        name: "bpmnElement",
        isAttr: true,
        isReference: true,
        type: "bpmn:BaseElement",
        redefines: "di:DiagramElement#modelElement"
      },
      {
        name: "isHorizontal",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "isExpanded",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "isMarkerVisible",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "label",
        type: "BPMNLabel"
      },
      {
        name: "isMessageVisible",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "participantBandKind",
        type: "ParticipantBandKind",
        isAttr: true
      },
      {
        name: "choreographyActivityShape",
        type: "BPMNShape",
        isAttr: true,
        isReference: true
      }
    ],
    superClass: [
      "di:LabeledShape"
    ]
  },
  {
    name: "BPMNEdge",
    properties: [
      {
        name: "label",
        type: "BPMNLabel"
      },
      {
        name: "bpmnElement",
        isAttr: true,
        isReference: true,
        type: "bpmn:BaseElement",
        redefines: "di:DiagramElement#modelElement"
      },
      {
        name: "sourceElement",
        isAttr: true,
        isReference: true,
        type: "di:DiagramElement",
        redefines: "di:Edge#source"
      },
      {
        name: "targetElement",
        isAttr: true,
        isReference: true,
        type: "di:DiagramElement",
        redefines: "di:Edge#target"
      },
      {
        name: "messageVisibleKind",
        type: "MessageVisibleKind",
        isAttr: true,
        "default": "initiating"
      }
    ],
    superClass: [
      "di:LabeledEdge"
    ]
  },
  {
    name: "BPMNLabel",
    properties: [
      {
        name: "labelStyle",
        type: "BPMNLabelStyle",
        isAttr: true,
        isReference: true,
        redefines: "di:DiagramElement#style"
      }
    ],
    superClass: [
      "di:Label"
    ]
  },
  {
    name: "BPMNLabelStyle",
    properties: [
      {
        name: "font",
        type: "dc:Font"
      }
    ],
    superClass: [
      "di:Style"
    ]
  }
];
var enumerations$1 = [
  {
    name: "ParticipantBandKind",
    literalValues: [
      {
        name: "top_initiating"
      },
      {
        name: "middle_initiating"
      },
      {
        name: "bottom_initiating"
      },
      {
        name: "top_non_initiating"
      },
      {
        name: "middle_non_initiating"
      },
      {
        name: "bottom_non_initiating"
      }
    ]
  },
  {
    name: "MessageVisibleKind",
    literalValues: [
      {
        name: "initiating"
      },
      {
        name: "non_initiating"
      }
    ]
  }
];
var associations$1$1 = [];
var BpmnDiPackage = {
  name: name$1$1,
  uri: uri$1$1,
  prefix: prefix$1$1,
  types: types$1$1,
  enumerations: enumerations$1,
  associations: associations$1$1
};
var name$2 = "DC";
var uri$2 = "http://www.omg.org/spec/DD/20100524/DC";
var prefix$2 = "dc";
var types$2 = [
  {
    name: "Boolean"
  },
  {
    name: "Integer"
  },
  {
    name: "Real"
  },
  {
    name: "String"
  },
  {
    name: "Font",
    properties: [
      {
        name: "name",
        type: "String",
        isAttr: true
      },
      {
        name: "size",
        type: "Real",
        isAttr: true
      },
      {
        name: "isBold",
        type: "Boolean",
        isAttr: true
      },
      {
        name: "isItalic",
        type: "Boolean",
        isAttr: true
      },
      {
        name: "isUnderline",
        type: "Boolean",
        isAttr: true
      },
      {
        name: "isStrikeThrough",
        type: "Boolean",
        isAttr: true
      }
    ]
  },
  {
    name: "Point",
    properties: [
      {
        name: "x",
        type: "Real",
        "default": "0",
        isAttr: true
      },
      {
        name: "y",
        type: "Real",
        "default": "0",
        isAttr: true
      }
    ]
  },
  {
    name: "Bounds",
    properties: [
      {
        name: "x",
        type: "Real",
        "default": "0",
        isAttr: true
      },
      {
        name: "y",
        type: "Real",
        "default": "0",
        isAttr: true
      },
      {
        name: "width",
        type: "Real",
        isAttr: true
      },
      {
        name: "height",
        type: "Real",
        isAttr: true
      }
    ]
  }
];
var associations$2 = [];
var DcPackage = {
  name: name$2,
  uri: uri$2,
  prefix: prefix$2,
  types: types$2,
  associations: associations$2
};
var name$3 = "DI";
var uri$3 = "http://www.omg.org/spec/DD/20100524/DI";
var prefix$3 = "di";
var types$3 = [
  {
    name: "DiagramElement",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        isId: true,
        type: "String"
      },
      {
        name: "extension",
        type: "Extension"
      },
      {
        name: "owningDiagram",
        type: "Diagram",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "owningElement",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "modelElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true,
        type: "Element"
      },
      {
        name: "style",
        type: "Style",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "ownedElement",
        type: "DiagramElement",
        isReadOnly: true,
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "Node",
    isAbstract: true,
    superClass: [
      "DiagramElement"
    ]
  },
  {
    name: "Edge",
    isAbstract: true,
    superClass: [
      "DiagramElement"
    ],
    properties: [
      {
        name: "source",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "target",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "waypoint",
        isUnique: false,
        isMany: true,
        type: "dc:Point",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "Diagram",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        isId: true,
        type: "String"
      },
      {
        name: "rootElement",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "documentation",
        isAttr: true,
        type: "String"
      },
      {
        name: "resolution",
        isAttr: true,
        type: "Real"
      },
      {
        name: "ownedStyle",
        type: "Style",
        isReadOnly: true,
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "Shape",
    isAbstract: true,
    superClass: [
      "Node"
    ],
    properties: [
      {
        name: "bounds",
        type: "dc:Bounds"
      }
    ]
  },
  {
    name: "Plane",
    isAbstract: true,
    superClass: [
      "Node"
    ],
    properties: [
      {
        name: "planeElement",
        type: "DiagramElement",
        subsettedProperty: "DiagramElement-ownedElement",
        isMany: true
      }
    ]
  },
  {
    name: "LabeledEdge",
    isAbstract: true,
    superClass: [
      "Edge"
    ],
    properties: [
      {
        name: "ownedLabel",
        type: "Label",
        isReadOnly: true,
        subsettedProperty: "DiagramElement-ownedElement",
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "LabeledShape",
    isAbstract: true,
    superClass: [
      "Shape"
    ],
    properties: [
      {
        name: "ownedLabel",
        type: "Label",
        isReadOnly: true,
        subsettedProperty: "DiagramElement-ownedElement",
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "Label",
    isAbstract: true,
    superClass: [
      "Node"
    ],
    properties: [
      {
        name: "bounds",
        type: "dc:Bounds"
      }
    ]
  },
  {
    name: "Style",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        isId: true,
        type: "String"
      }
    ]
  },
  {
    name: "Extension",
    properties: [
      {
        name: "values",
        isMany: true,
        type: "Element"
      }
    ]
  }
];
var associations$3 = [];
var xml$1$1 = {
  tagAlias: "lowerCase"
};
var DiPackage = {
  name: name$3,
  uri: uri$3,
  prefix: prefix$3,
  types: types$3,
  associations: associations$3,
  xml: xml$1$1
};
var name$4 = "bpmn.io colors for BPMN";
var uri$4 = "http://bpmn.io/schema/bpmn/biocolor/1.0";
var prefix$4 = "bioc";
var types$4 = [
  {
    name: "ColoredShape",
    "extends": [
      "bpmndi:BPMNShape"
    ],
    properties: [
      {
        name: "stroke",
        isAttr: true,
        type: "String"
      },
      {
        name: "fill",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ColoredEdge",
    "extends": [
      "bpmndi:BPMNEdge"
    ],
    properties: [
      {
        name: "stroke",
        isAttr: true,
        type: "String"
      },
      {
        name: "fill",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
var enumerations$2 = [];
var associations$4 = [];
var BiocPackage = {
  name: name$4,
  uri: uri$4,
  prefix: prefix$4,
  types: types$4,
  enumerations: enumerations$2,
  associations: associations$4
};
var name$5 = "BPMN in Color";
var uri$5 = "http://www.omg.org/spec/BPMN/non-normative/color/1.0";
var prefix$5 = "color";
var types$5 = [
  {
    name: "ColoredLabel",
    "extends": [
      "bpmndi:BPMNLabel"
    ],
    properties: [
      {
        name: "color",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ColoredShape",
    "extends": [
      "bpmndi:BPMNShape"
    ],
    properties: [
      {
        name: "background-color",
        isAttr: true,
        type: "String"
      },
      {
        name: "border-color",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ColoredEdge",
    "extends": [
      "bpmndi:BPMNEdge"
    ],
    properties: [
      {
        name: "border-color",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
var enumerations$3 = [];
var associations$5 = [];
var BpmnInColorPackage = {
  name: name$5,
  uri: uri$5,
  prefix: prefix$5,
  types: types$5,
  enumerations: enumerations$3,
  associations: associations$5
};
var packages = {
  bpmn: BpmnPackage,
  bpmndi: BpmnDiPackage,
  dc: DcPackage,
  di: DiPackage,
  bioc: BiocPackage,
  color: BpmnInColorPackage
};
function simple(additionalPackages, options) {
  var pks = assign$e({}, packages, additionalPackages);
  return new BpmnModdle(pks, options);
}
function elementToString(e) {
  if (!e) {
    return "<null>";
  }
  return "<" + e.$type + (e.id ? ' id="' + e.id : "") + '" />';
}
var diRefs = new Refs({ name: "bpmnElement", enumerable: true }, { name: "di", configurable: true });
function is$P(element, type) {
  return element.$instanceOf(type);
}
function findDisplayCandidate(definitions) {
  return find$e(definitions.rootElements, function(e) {
    return is$P(e, "bpmn:Process") || is$P(e, "bpmn:Collaboration");
  });
}
function BpmnTreeWalker(handler, translate2) {
  var handledElements = {};
  var deferred = [];
  function contextual(fn, ctx) {
    return function(e) {
      fn(e, ctx);
    };
  }
  function handled(element) {
    handledElements[element.id] = element;
  }
  function isHandled(element) {
    return handledElements[element.id];
  }
  function visit(element, ctx) {
    var gfx = element.gfx;
    if (gfx) {
      throw new Error(translate2("already rendered {element}", { element: elementToString(element) }));
    }
    return handler.element(element, ctx);
  }
  function visitRoot(element, diagram) {
    return handler.root(element, diagram);
  }
  function visitIfDi(element, ctx) {
    try {
      var gfx = element.di && visit(element, ctx);
      handled(element);
      return gfx;
    } catch (e) {
      logError(e.message, { element, error: e });
      console.error(translate2("failed to import {element}", { element: elementToString(element) }));
      console.error(e);
    }
  }
  function logError(message2, context) {
    handler.error(message2, context);
  }
  function registerDi(di) {
    var bpmnElement = di.bpmnElement;
    if (bpmnElement) {
      if (bpmnElement.di) {
        logError(translate2("multiple DI elements defined for {element}", {
          element: elementToString(bpmnElement)
        }), { element: bpmnElement });
      } else {
        diRefs.bind(bpmnElement, "di");
        bpmnElement.di = di;
      }
    } else {
      logError(translate2("no bpmnElement referenced in {element}", {
        element: elementToString(di)
      }), { element: di });
    }
  }
  function handleDiagram(diagram) {
    handlePlane(diagram.plane);
  }
  function handlePlane(plane) {
    registerDi(plane);
    forEach$q(plane.planeElement, handlePlaneElement);
  }
  function handlePlaneElement(planeElement) {
    registerDi(planeElement);
  }
  function handleDefinitions(definitions, diagram) {
    var diagrams = definitions.diagrams;
    if (diagram && diagrams.indexOf(diagram) === -1) {
      throw new Error(translate2("diagram not part of bpmn:Definitions"));
    }
    if (!diagram && diagrams && diagrams.length) {
      diagram = diagrams[0];
    }
    if (!diagram) {
      throw new Error(translate2("no diagram to display"));
    }
    handleDiagram(diagram);
    var plane = diagram.plane;
    if (!plane) {
      throw new Error(translate2("no plane for {element}", { element: elementToString(diagram) }));
    }
    var rootElement = plane.bpmnElement;
    if (!rootElement) {
      rootElement = findDisplayCandidate(definitions);
      if (!rootElement) {
        throw new Error(translate2("no process or collaboration to display"));
      } else {
        logError(translate2("correcting missing bpmnElement on {plane} to {rootElement}", {
          plane: elementToString(plane),
          rootElement: elementToString(rootElement)
        }));
        plane.bpmnElement = rootElement;
        registerDi(plane);
      }
    }
    var ctx = visitRoot(rootElement, plane);
    if (is$P(rootElement, "bpmn:Process")) {
      handleProcess(rootElement, ctx);
    } else if (is$P(rootElement, "bpmn:Collaboration")) {
      handleCollaboration(rootElement);
      handleUnhandledProcesses(definitions.rootElements, ctx);
    } else {
      throw new Error(translate2("unsupported bpmnElement for {plane}: {rootElement}", {
        plane: elementToString(plane),
        rootElement: elementToString(rootElement)
      }));
    }
    handleDeferred();
  }
  function handleDeferred() {
    var fn;
    while (deferred.length) {
      fn = deferred.shift();
      fn();
    }
  }
  function handleProcess(process2, context) {
    handleFlowElementsContainer(process2, context);
    handleIoSpecification(process2.ioSpecification, context);
    handleArtifacts(process2.artifacts, context);
    handled(process2);
  }
  function handleUnhandledProcesses(rootElements, ctx) {
    var processes = filter$a(rootElements, function(e) {
      return !isHandled(e) && is$P(e, "bpmn:Process") && e.laneSets;
    });
    processes.forEach(contextual(handleProcess, ctx));
  }
  function handleMessageFlow(messageFlow, context) {
    visitIfDi(messageFlow, context);
  }
  function handleMessageFlows(messageFlows, context) {
    forEach$q(messageFlows, contextual(handleMessageFlow, context));
  }
  function handleDataAssociation(association, context) {
    visitIfDi(association, context);
  }
  function handleDataInput(dataInput, context) {
    visitIfDi(dataInput, context);
  }
  function handleDataOutput(dataOutput, context) {
    visitIfDi(dataOutput, context);
  }
  function handleArtifact(artifact, context) {
    visitIfDi(artifact, context);
  }
  function handleArtifacts(artifacts, context) {
    forEach$q(artifacts, function(e) {
      if (is$P(e, "bpmn:Association")) {
        deferred.push(function() {
          handleArtifact(e, context);
        });
      } else {
        handleArtifact(e, context);
      }
    });
  }
  function handleIoSpecification(ioSpecification, context) {
    if (!ioSpecification) {
      return;
    }
    forEach$q(ioSpecification.dataInputs, contextual(handleDataInput, context));
    forEach$q(ioSpecification.dataOutputs, contextual(handleDataOutput, context));
  }
  function handleSubProcess(subProcess, context) {
    handleFlowElementsContainer(subProcess, context);
    handleArtifacts(subProcess.artifacts, context);
  }
  function handleFlowNode(flowNode, context) {
    var childCtx = visitIfDi(flowNode, context);
    if (is$P(flowNode, "bpmn:SubProcess")) {
      handleSubProcess(flowNode, childCtx || context);
    }
    if (is$P(flowNode, "bpmn:Activity")) {
      handleIoSpecification(flowNode.ioSpecification, context);
    }
    deferred.push(function() {
      forEach$q(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));
      forEach$q(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));
    });
  }
  function handleSequenceFlow(sequenceFlow, context) {
    visitIfDi(sequenceFlow, context);
  }
  function handleDataElement(dataObject, context) {
    visitIfDi(dataObject, context);
  }
  function handleLane(lane, context) {
    deferred.push(function() {
      var newContext = visitIfDi(lane, context);
      if (lane.childLaneSet) {
        handleLaneSet(lane.childLaneSet, newContext || context);
      }
      wireFlowNodeRefs(lane);
    });
  }
  function handleLaneSet(laneSet, context) {
    forEach$q(laneSet.lanes, contextual(handleLane, context));
  }
  function handleLaneSets(laneSets, context) {
    forEach$q(laneSets, contextual(handleLaneSet, context));
  }
  function handleFlowElementsContainer(container, context) {
    handleFlowElements(container.flowElements, context);
    if (container.laneSets) {
      handleLaneSets(container.laneSets, context);
    }
  }
  function handleFlowElements(flowElements, context) {
    forEach$q(flowElements, function(e) {
      if (is$P(e, "bpmn:SequenceFlow")) {
        deferred.push(function() {
          handleSequenceFlow(e, context);
        });
      } else if (is$P(e, "bpmn:BoundaryEvent")) {
        deferred.unshift(function() {
          handleFlowNode(e, context);
        });
      } else if (is$P(e, "bpmn:FlowNode")) {
        handleFlowNode(e, context);
      } else if (is$P(e, "bpmn:DataObject"))
        ;
      else if (is$P(e, "bpmn:DataStoreReference")) {
        handleDataElement(e, context);
      } else if (is$P(e, "bpmn:DataObjectReference")) {
        handleDataElement(e, context);
      } else {
        logError(translate2("unrecognized flowElement {element} in context {context}", {
          element: elementToString(e),
          context: context ? elementToString(context.businessObject) : "null"
        }), { element: e, context });
      }
    });
  }
  function handleParticipant(participant, context) {
    var newCtx = visitIfDi(participant, context);
    var process2 = participant.processRef;
    if (process2) {
      handleProcess(process2, newCtx || context);
    }
  }
  function handleCollaboration(collaboration) {
    forEach$q(collaboration.participants, contextual(handleParticipant));
    handleArtifacts(collaboration.artifacts);
    deferred.push(function() {
      handleMessageFlows(collaboration.messageFlows);
    });
  }
  function wireFlowNodeRefs(lane) {
    forEach$q(lane.flowNodeRef, function(flowNode) {
      var lanes = flowNode.get("lanes");
      if (lanes) {
        lanes.push(lane);
      }
    });
  }
  return {
    handleDeferred,
    handleDefinitions,
    handleSubProcess,
    registerDi
  };
}
function importBpmnDiagram(diagram, definitions, bpmnDiagram) {
  var importer, eventBus, translate2;
  var error2, warnings = [];
  function render(definitions2, bpmnDiagram2) {
    var visitor2 = {
      root: function(element) {
        return importer.add(element);
      },
      element: function(element, parentShape) {
        return importer.add(element, parentShape);
      },
      error: function(message2, context) {
        warnings.push({ message: message2, context });
      }
    };
    var walker = new BpmnTreeWalker(visitor2, translate2);
    walker.handleDefinitions(definitions2, bpmnDiagram2);
  }
  return new Promise(function(resolve, reject) {
    try {
      importer = diagram.get("bpmnImporter");
      eventBus = diagram.get("eventBus");
      translate2 = diagram.get("translate");
      eventBus.fire("import.render.start", { definitions });
      render(definitions, bpmnDiagram);
      eventBus.fire("import.render.complete", {
        error: error2,
        warnings
      });
      return resolve({ warnings });
    } catch (e) {
      e.warnings = warnings;
      return reject(e);
    }
  });
}
function wrapForCompatibility(api) {
  return function() {
    if (!window.Promise) {
      throw new Error("Promises is not supported in this environment. Please polyfill Promise.");
    }
    var argLen = arguments.length;
    if (argLen >= 1 && isFunction$6(arguments[argLen - 1])) {
      var callback = arguments[argLen - 1];
      console.warn(new Error("Passing callbacks to " + api.name + " is deprecated and will be removed in a future major release. Please switch to promises: https://bpmn.io/l/moving-to-promises.html"));
      var argsWithoutCallback = Array.prototype.slice.call(arguments, 0, -1);
      api.apply(this, argsWithoutCallback).then(function(result) {
        var firstKey = Object.keys(result)[0];
        return callback(null, result[firstKey]);
      }, function(err) {
        return callback(err, err.warnings);
      });
    } else {
      return api.apply(this, arguments);
    }
  };
}
var BPMNIO_LOGO_SVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.02 5.57" width="53" height="21" style="vertical-align:middle"><path fill="currentColor" d="M1.88.92v.14c0 .41-.13.68-.4.8.33.14.46.44.46.86v.33c0 .61-.33.95-.95.95H0V0h.95c.65 0 .93.3.93.92zM.63.57v1.06h.24c.24 0 .38-.1.38-.43V.98c0-.28-.1-.4-.32-.4zm0 1.63v1.22h.36c.2 0 .32-.1.32-.39v-.35c0-.37-.12-.48-.4-.48H.63zM4.18.99v.52c0 .64-.31.98-.94.98h-.3V4h-.62V0h.92c.63 0 .94.35.94.99zM2.94.57v1.35h.3c.2 0 .3-.09.3-.37v-.6c0-.29-.1-.38-.3-.38h-.3zm2.89 2.27L6.25 0h.88v4h-.6V1.12L6.1 3.99h-.6l-.46-2.82v2.82h-.55V0h.87zM8.14 1.1V4h-.56V0h.79L9 2.4V0h.56v4h-.64zm2.49 2.29v.6h-.6v-.6zM12.12 1c0-.63.33-1 .95-1 .61 0 .95.37.95 1v2.04c0 .64-.34 1-.95 1-.62 0-.95-.37-.95-1zm.62 2.08c0 .28.13.39.33.39s.32-.1.32-.4V.98c0-.29-.12-.4-.32-.4s-.33.11-.33.4z"/><path fill="currentColor" d="M0 4.53h14.02v1.04H0zM11.08 0h.63v.62h-.63zm.63 4V1h-.63v2.98z"/></svg>';
var BPMNIO_IMG = BPMNIO_LOGO_SVG;
function css(attrs) {
  return attrs.join(";");
}
var LINK_STYLES = css([
  "color: #404040"
]);
var LIGHTBOX_STYLES = css([
  "z-index: 1001",
  "position: fixed",
  "top: 0",
  "left: 0",
  "right: 0",
  "bottom: 0"
]);
var BACKDROP_STYLES = css([
  "width: 100%",
  "height: 100%",
  "background: rgba(40,40,40,0.2)"
]);
var NOTICE_STYLES = css([
  "position: absolute",
  "left: 50%",
  "top: 40%",
  "transform: translate(-50%)",
  "width: 260px",
  "padding: 10px",
  "background: white",
  "box-shadow: 0 1px 4px rgba(0,0,0,0.3)",
  "font-family: Helvetica, Arial, sans-serif",
  "font-size: 14px",
  "display: flex",
  "line-height: 1.3"
]);
var LIGHTBOX_MARKUP = '<div class="bjs-powered-by-lightbox" style="' + LIGHTBOX_STYLES + '"><div class="backdrop" style="' + BACKDROP_STYLES + '"></div><div class="notice" style="' + NOTICE_STYLES + '"><a href="https://bpmn.io" target="_blank" rel="noopener" style="margin: 15px 20px 15px 10px; align-self: center;' + LINK_STYLES + '">' + BPMNIO_IMG + '</a><span>Web-based tooling for BPMN, DMN and CMMN diagrams powered by <a href="https://bpmn.io" target="_blank" rel="noopener">bpmn.io</a>.</span></div></div>';
var lightbox;
function open() {
  if (!lightbox) {
    lightbox = domify$h(LIGHTBOX_MARKUP);
    delegate$1.bind(lightbox, ".backdrop", "click", function(event) {
      document.body.removeChild(lightbox);
    });
  }
  document.body.appendChild(lightbox);
}
function BaseViewer(options) {
  options = assign$e({}, DEFAULT_OPTIONS$1, options);
  this._moddle = this._createModdle(options);
  this._container = this._createContainer(options);
  addProjectLogo(this._container);
  this._init(this._container, this._moddle, options);
}
inherits$6(BaseViewer, Diagram);
BaseViewer.prototype.importXML = wrapForCompatibility(function importXML(xml2, bpmnDiagram) {
  var self2 = this;
  function ParseCompleteEvent(data) {
    var event = self2.get("eventBus").createEvent(data);
    Object.defineProperty(event, "context", {
      enumerable: true,
      get: function() {
        console.warn(new Error("import.parse.complete <context> is deprecated and will be removed in future library versions"));
        return {
          warnings: data.warnings,
          references: data.references,
          elementsById: data.elementsById
        };
      }
    });
    return event;
  }
  return new Promise(function(resolve, reject) {
    xml2 = self2._emit("import.parse.start", { xml: xml2 }) || xml2;
    self2._moddle.fromXML(xml2, "bpmn:Definitions").then(function(result) {
      var definitions = result.rootElement;
      var references = result.references;
      var parseWarnings = result.warnings;
      var elementsById = result.elementsById;
      definitions = self2._emit("import.parse.complete", ParseCompleteEvent({
        error: null,
        definitions,
        elementsById,
        references,
        warnings: parseWarnings
      })) || definitions;
      self2.importDefinitions(definitions, bpmnDiagram).then(function(result2) {
        var allWarnings = [].concat(parseWarnings, result2.warnings || []);
        self2._emit("import.done", { error: null, warnings: allWarnings });
        return resolve({ warnings: allWarnings });
      }).catch(function(err) {
        var allWarnings = [].concat(parseWarnings, err.warnings || []);
        self2._emit("import.done", { error: err, warnings: allWarnings });
        return reject(addWarningsToError(err, allWarnings));
      });
    }).catch(function(err) {
      self2._emit("import.parse.complete", {
        error: err
      });
      err = checkValidationError(err);
      self2._emit("import.done", { error: err, warnings: err.warnings });
      return reject(err);
    });
  });
});
BaseViewer.prototype.importDefinitions = wrapForCompatibility(function importDefinitions(definitions, bpmnDiagram) {
  var self2 = this;
  return new Promise(function(resolve, reject) {
    self2._setDefinitions(definitions);
    self2.open(bpmnDiagram).then(function(result) {
      var warnings = result.warnings;
      return resolve({ warnings });
    }).catch(function(err) {
      return reject(err);
    });
  });
});
BaseViewer.prototype.open = wrapForCompatibility(function open2(bpmnDiagramOrId) {
  var definitions = this._definitions;
  var bpmnDiagram = bpmnDiagramOrId;
  var self2 = this;
  return new Promise(function(resolve, reject) {
    if (!definitions) {
      var err1 = new Error("no XML imported");
      return reject(addWarningsToError(err1, []));
    }
    if (typeof bpmnDiagramOrId === "string") {
      bpmnDiagram = findBPMNDiagram(definitions, bpmnDiagramOrId);
      if (!bpmnDiagram) {
        var err2 = new Error("BPMNDiagram <" + bpmnDiagramOrId + "> not found");
        return reject(addWarningsToError(err2, []));
      }
    }
    try {
      self2.clear();
    } catch (error2) {
      return reject(addWarningsToError(error2, []));
    }
    importBpmnDiagram(self2, definitions, bpmnDiagram).then(function(result) {
      var warnings = result.warnings;
      return resolve({ warnings });
    }).catch(function(err) {
      return reject(err);
    });
  });
});
BaseViewer.prototype.saveXML = wrapForCompatibility(function saveXML(options) {
  options = options || {};
  var self2 = this;
  var definitions = this._definitions;
  return new Promise(function(resolve) {
    if (!definitions) {
      return resolve({
        error: new Error("no definitions loaded")
      });
    }
    definitions = self2._emit("saveXML.start", {
      definitions
    }) || definitions;
    self2._moddle.toXML(definitions, options).then(function(result) {
      var xml2 = result.xml;
      xml2 = self2._emit("saveXML.serialized", {
        xml: xml2
      }) || xml2;
      return resolve({
        xml: xml2
      });
    });
  }).catch(function(error2) {
    return { error: error2 };
  }).then(function(result) {
    self2._emit("saveXML.done", result);
    var error2 = result.error;
    if (error2) {
      return Promise.reject(error2);
    }
    return result;
  });
});
BaseViewer.prototype.saveSVG = wrapForCompatibility(function saveSVG(options) {
  var self2 = this;
  return new Promise(function(resolve, reject) {
    self2._emit("saveSVG.start");
    var svg, err;
    try {
      var canvas = self2.get("canvas");
      var contentNode = canvas.getDefaultLayer(), defsNode = query("defs", canvas._svg);
      var contents = innerSVG(contentNode), defs = defsNode ? "<defs>" + innerSVG(defsNode) + "</defs>" : "";
      var bbox = contentNode.getBBox();
      svg = '<?xml version="1.0" encoding="utf-8"?>\n<!-- created with bpmn-js / http://bpmn.io -->\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + bbox.width + '" height="' + bbox.height + '" viewBox="' + bbox.x + " " + bbox.y + " " + bbox.width + " " + bbox.height + '" version="1.1">' + defs + contents + "</svg>";
    } catch (e) {
      err = e;
    }
    self2._emit("saveSVG.done", {
      error: err,
      svg
    });
    if (!err) {
      return resolve({ svg });
    }
    return reject(err);
  });
});
BaseViewer.prototype._setDefinitions = function(definitions) {
  this._definitions = definitions;
};
BaseViewer.prototype.getModules = function() {
  return this._modules;
};
BaseViewer.prototype.clear = function() {
  if (!this.getDefinitions()) {
    return;
  }
  this.get("elementRegistry").forEach(function(element) {
    var bo = element.businessObject;
    if (bo && bo.di) {
      delete bo.di;
    }
  });
  Diagram.prototype.clear.call(this);
};
BaseViewer.prototype.destroy = function() {
  Diagram.prototype.destroy.call(this);
  remove$5(this._container);
};
BaseViewer.prototype.on = function(event, priority, callback, target) {
  return this.get("eventBus").on(event, priority, callback, target);
};
BaseViewer.prototype.off = function(event, callback) {
  this.get("eventBus").off(event, callback);
};
BaseViewer.prototype.attachTo = function(parentNode) {
  if (!parentNode) {
    throw new Error("parentNode required");
  }
  this.detach();
  if (parentNode.get && parentNode.constructor.prototype.jquery) {
    parentNode = parentNode.get(0);
  }
  if (typeof parentNode === "string") {
    parentNode = query(parentNode);
  }
  parentNode.appendChild(this._container);
  this._emit("attach", {});
  this.get("canvas").resized();
};
BaseViewer.prototype.getDefinitions = function() {
  return this._definitions;
};
BaseViewer.prototype.detach = function() {
  var container = this._container, parentNode = container.parentNode;
  if (!parentNode) {
    return;
  }
  this._emit("detach", {});
  parentNode.removeChild(container);
};
BaseViewer.prototype._init = function(container, moddle, options) {
  var baseModules = options.modules || this.getModules(), additionalModules = options.additionalModules || [], staticModules = [
    {
      bpmnjs: ["value", this],
      moddle: ["value", moddle]
    }
  ];
  var diagramModules = [].concat(staticModules, baseModules, additionalModules);
  var diagramOptions = assign$e(omit(options, ["additionalModules"]), {
    canvas: assign$e({}, options.canvas, { container }),
    modules: diagramModules
  });
  Diagram.call(this, diagramOptions);
  if (options && options.container) {
    this.attachTo(options.container);
  }
};
BaseViewer.prototype._emit = function(type, event) {
  return this.get("eventBus").fire(type, event);
};
BaseViewer.prototype._createContainer = function(options) {
  var container = domify$h('<div class="bjs-container"></div>');
  assign$e(container.style, {
    width: ensureUnit(options.width),
    height: ensureUnit(options.height),
    position: options.position
  });
  return container;
};
BaseViewer.prototype._createModdle = function(options) {
  var moddleOptions = assign$e({}, this._moddleExtensions, options.moddleExtensions);
  return new simple(moddleOptions);
};
BaseViewer.prototype._modules = [];
function addWarningsToError(err, warningsAry) {
  err.warnings = warningsAry;
  return err;
}
function checkValidationError(err) {
  var pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/;
  var match2 = pattern.exec(err.message);
  if (match2) {
    err.message = "unparsable content <" + match2[1] + "> detected; this may indicate an invalid BPMN 2.0 diagram file" + match2[2];
  }
  return err;
}
var DEFAULT_OPTIONS$1 = {
  width: "100%",
  height: "100%",
  position: "relative"
};
function ensureUnit(val) {
  return val + (isNumber$1(val) ? "px" : "");
}
function findBPMNDiagram(definitions, diagramId) {
  if (!diagramId) {
    return null;
  }
  return find$e(definitions.diagrams, function(element) {
    return element.id === diagramId;
  }) || null;
}
function addProjectLogo(container) {
  var img = BPMNIO_IMG;
  var linkMarkup = '<a href="http://bpmn.io" target="_blank" class="bjs-powered-by" title="Powered by bpmn.io" style="position: absolute; bottom: 15px; right: 15px; z-index: 100; ' + LINK_STYLES + '">' + img + "</a>";
  var linkElement = domify$h(linkMarkup);
  container.appendChild(linkElement);
  componentEvent.bind(linkElement, "click", function(event) {
    open();
    event.preventDefault();
  });
}
function BaseModeler(options) {
  BaseViewer.call(this, options);
  this.on("import.parse.complete", function(event) {
    if (!event.error) {
      this._collectIds(event.definitions, event.elementsById);
    }
  }, this);
  this.on("diagram.destroy", function() {
    this.get("moddle").ids.clear();
  }, this);
}
inherits$6(BaseModeler, BaseViewer);
BaseModeler.prototype._createModdle = function(options) {
  var moddle = BaseViewer.prototype._createModdle.call(this, options);
  moddle.ids = new Ids$1([32, 36, 1]);
  return moddle;
};
BaseModeler.prototype._collectIds = function(definitions, elementsById) {
  var moddle = definitions.$model, ids2 = moddle.ids, id2;
  ids2.clear();
  for (id2 in elementsById) {
    ids2.claim(id2, elementsById[id2]);
  }
};
function is$O(element, type) {
  var bo = getBusinessObject$V(element);
  return bo && typeof bo.$instanceOf === "function" && bo.$instanceOf(type);
}
function isAny$b(element, types2) {
  return some$1(types2, function(t) {
    return is$O(element, t);
  });
}
function getBusinessObject$V(element) {
  return element && element.businessObject || element;
}
function getDi$1(element) {
  var bo = getBusinessObject$V(element);
  return bo && bo.di;
}
var ModelUtil$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  is: is$O,
  isAny: isAny$b,
  getBusinessObject: getBusinessObject$V,
  getDi: getDi$1
}, Symbol.toStringTag, { value: "Module" }));
function isExpanded(element) {
  if (is$O(element, "bpmn:CallActivity")) {
    return false;
  }
  if (is$O(element, "bpmn:SubProcess")) {
    return getBusinessObject$V(element).di && !!getBusinessObject$V(element).di.isExpanded;
  }
  if (is$O(element, "bpmn:Participant")) {
    return !!getBusinessObject$V(element).processRef;
  }
  return true;
}
function isInterrupting(element) {
  return element && getBusinessObject$V(element).isInterrupting !== false;
}
function isEventSubProcess$1(element) {
  return element && !!getBusinessObject$V(element).triggeredByEvent;
}
function hasEventDefinition$2(element, eventType) {
  var bo = getBusinessObject$V(element), hasEventDefinition2 = false;
  if (bo.eventDefinitions) {
    forEach$q(bo.eventDefinitions, function(event) {
      if (is$O(event, eventType)) {
        hasEventDefinition2 = true;
      }
    });
  }
  return hasEventDefinition2;
}
function hasErrorEventDefinition(element) {
  return hasEventDefinition$2(element, "bpmn:ErrorEventDefinition");
}
function hasEscalationEventDefinition(element) {
  return hasEventDefinition$2(element, "bpmn:EscalationEventDefinition");
}
function hasCompensateEventDefinition(element) {
  return hasEventDefinition$2(element, "bpmn:CompensateEventDefinition");
}
var DiUtil = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isExpanded,
  isInterrupting,
  isEventSubProcess: isEventSubProcess$1,
  hasEventDefinition: hasEventDefinition$2,
  hasErrorEventDefinition,
  hasEscalationEventDefinition,
  hasCompensateEventDefinition
}, Symbol.toStringTag, { value: "Module" }));
function getLabelAttr(semantic) {
  if (is$O(semantic, "bpmn:FlowElement") || is$O(semantic, "bpmn:Participant") || is$O(semantic, "bpmn:Lane") || is$O(semantic, "bpmn:SequenceFlow") || is$O(semantic, "bpmn:MessageFlow") || is$O(semantic, "bpmn:DataInput") || is$O(semantic, "bpmn:DataOutput")) {
    return "name";
  }
  if (is$O(semantic, "bpmn:TextAnnotation")) {
    return "text";
  }
  if (is$O(semantic, "bpmn:Group")) {
    return "categoryValueRef";
  }
}
function getCategoryValue(semantic) {
  var categoryValueRef = semantic["categoryValueRef"];
  if (!categoryValueRef) {
    return "";
  }
  return categoryValueRef.value || "";
}
function getLabel(element) {
  var semantic = element.businessObject, attr2 = getLabelAttr(semantic);
  if (attr2) {
    if (attr2 === "categoryValueRef") {
      return getCategoryValue(semantic);
    }
    return semantic[attr2] || "";
  }
}
function setLabel(element, text, isExternal) {
  var semantic = element.businessObject, attr2 = getLabelAttr(semantic);
  if (attr2) {
    if (attr2 === "categoryValueRef") {
      semantic["categoryValueRef"].value = text;
    } else {
      semantic[attr2] = text;
    }
  }
  return element;
}
function isTypedEvent(event, eventDefinitionType, filter2) {
  function matches(definition, filter3) {
    return every(filter3, function(val, key) {
      return definition[key] == val;
    });
  }
  return some$1(event.eventDefinitions, function(definition) {
    return definition.$type === eventDefinitionType && matches(event, filter2);
  });
}
function isThrowEvent(event) {
  return event.$type === "bpmn:IntermediateThrowEvent" || event.$type === "bpmn:EndEvent";
}
function isCollection(element) {
  var dataObject = element.dataObjectRef;
  return element.isCollection || dataObject && dataObject.isCollection;
}
function getDi(element) {
  return element.businessObject.di;
}
function getSemantic(element) {
  return element.businessObject;
}
function getFillColor(element, defaultColor) {
  var di = getDi(element);
  return di.get("color:background-color") || di.get("bioc:fill") || defaultColor || "white";
}
function getStrokeColor$1(element, defaultColor) {
  var di = getDi(element);
  return di.get("color:border-color") || di.get("bioc:stroke") || defaultColor || "black";
}
function getLabelColor(element, defaultColor, defaultStrokeColor) {
  var di = getDi(element), label2 = di.get("label");
  return label2 && label2.get("color:color") || defaultColor || getStrokeColor$1(element, defaultStrokeColor);
}
function getCirclePath(shape) {
  var cx = shape.x + shape.width / 2, cy = shape.y + shape.height / 2, radius = shape.width / 2;
  var circlePath2 = [
    ["M", cx, cy],
    ["m", 0, -radius],
    ["a", radius, radius, 0, 1, 1, 0, 2 * radius],
    ["a", radius, radius, 0, 1, 1, 0, -2 * radius],
    ["z"]
  ];
  return componentsToPath(circlePath2);
}
function getRoundRectPath(shape, borderRadius) {
  var x = shape.x, y = shape.y, width = shape.width, height = shape.height;
  var roundRectPath = [
    ["M", x + borderRadius, y],
    ["l", width - borderRadius * 2, 0],
    ["a", borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius],
    ["l", 0, height - borderRadius * 2],
    ["a", borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius],
    ["l", borderRadius * 2 - width, 0],
    ["a", borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius],
    ["l", 0, borderRadius * 2 - height],
    ["a", borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius],
    ["z"]
  ];
  return componentsToPath(roundRectPath);
}
function getDiamondPath(shape) {
  var width = shape.width, height = shape.height, x = shape.x, y = shape.y, halfWidth = width / 2, halfHeight = height / 2;
  var diamondPath = [
    ["M", x + halfWidth, y],
    ["l", halfWidth, halfHeight],
    ["l", -halfWidth, halfHeight],
    ["l", -halfWidth, -halfHeight],
    ["z"]
  ];
  return componentsToPath(diamondPath);
}
function getRectPath(shape) {
  var x = shape.x, y = shape.y, width = shape.width, height = shape.height;
  var rectPath = [
    ["M", x, y],
    ["l", width, 0],
    ["l", 0, height],
    ["l", -width, 0],
    ["z"]
  ];
  return componentsToPath(rectPath);
}
var RENDERER_IDS = new Ids$1();
var TASK_BORDER_RADIUS = 10;
var INNER_OUTER_DIST = 3;
var DEFAULT_FILL_OPACITY = 0.95, HIGH_FILL_OPACITY = 0.35;
var ELEMENT_LABEL_DISTANCE$1 = 10;
function BpmnRenderer(config, eventBus, styles, pathMap, canvas, textRenderer, priority) {
  BaseRenderer.call(this, eventBus, priority);
  var defaultFillColor = config && config.defaultFillColor, defaultStrokeColor = config && config.defaultStrokeColor, defaultLabelColor = config && config.defaultLabelColor;
  var rendererId = RENDERER_IDS.next();
  var markers = {};
  var computeStyle2 = styles.computeStyle;
  function addMarker(id2, options) {
    var attrs = assign$e({
      fill: "black",
      strokeWidth: 1,
      strokeLinecap: "round",
      strokeDasharray: "none"
    }, options.attrs);
    var ref = options.ref || { x: 0, y: 0 };
    var scale = options.scale || 1;
    if (attrs.strokeDasharray === "none") {
      attrs.strokeDasharray = [1e4, 1];
    }
    var marker2 = create$2("marker");
    attr(options.element, attrs);
    append$3(marker2, options.element);
    attr(marker2, {
      id: id2,
      viewBox: "0 0 20 20",
      refX: ref.x,
      refY: ref.y,
      markerWidth: 20 * scale,
      markerHeight: 20 * scale,
      orient: "auto"
    });
    var defs = query("defs", canvas._svg);
    if (!defs) {
      defs = create$2("defs");
      append$3(canvas._svg, defs);
    }
    append$3(defs, marker2);
    markers[id2] = marker2;
  }
  function colorEscape(str) {
    return str.replace(/[^0-9a-zA-z]+/g, "_");
  }
  function marker(type, fill, stroke) {
    var id2 = type + "-" + colorEscape(fill) + "-" + colorEscape(stroke) + "-" + rendererId;
    if (!markers[id2]) {
      createMarker(id2, type, fill, stroke);
    }
    return "url(#" + id2 + ")";
  }
  function createMarker(id2, type, fill, stroke) {
    if (type === "sequenceflow-end") {
      var sequenceflowEnd = create$2("path");
      attr(sequenceflowEnd, { d: "M 1 5 L 11 10 L 1 15 Z" });
      addMarker(id2, {
        element: sequenceflowEnd,
        ref: { x: 11, y: 10 },
        scale: 0.5,
        attrs: {
          fill: stroke,
          stroke
        }
      });
    }
    if (type === "messageflow-start") {
      var messageflowStart = create$2("circle");
      attr(messageflowStart, { cx: 6, cy: 6, r: 3.5 });
      addMarker(id2, {
        element: messageflowStart,
        attrs: {
          fill,
          stroke
        },
        ref: { x: 6, y: 6 }
      });
    }
    if (type === "messageflow-end") {
      var messageflowEnd = create$2("path");
      attr(messageflowEnd, { d: "m 1 5 l 0 -3 l 7 3 l -7 3 z" });
      addMarker(id2, {
        element: messageflowEnd,
        attrs: {
          fill,
          stroke,
          strokeLinecap: "butt"
        },
        ref: { x: 8.5, y: 5 }
      });
    }
    if (type === "association-start") {
      var associationStart = create$2("path");
      attr(associationStart, { d: "M 11 5 L 1 10 L 11 15" });
      addMarker(id2, {
        element: associationStart,
        attrs: {
          fill: "none",
          stroke,
          strokeWidth: 1.5
        },
        ref: { x: 1, y: 10 },
        scale: 0.5
      });
    }
    if (type === "association-end") {
      var associationEnd = create$2("path");
      attr(associationEnd, { d: "M 1 5 L 11 10 L 1 15" });
      addMarker(id2, {
        element: associationEnd,
        attrs: {
          fill: "none",
          stroke,
          strokeWidth: 1.5
        },
        ref: { x: 12, y: 10 },
        scale: 0.5
      });
    }
    if (type === "conditional-flow-marker") {
      var conditionalflowMarker = create$2("path");
      attr(conditionalflowMarker, { d: "M 0 10 L 8 6 L 16 10 L 8 14 Z" });
      addMarker(id2, {
        element: conditionalflowMarker,
        attrs: {
          fill,
          stroke
        },
        ref: { x: -1, y: 10 },
        scale: 0.5
      });
    }
    if (type === "conditional-default-flow-marker") {
      var conditionaldefaultflowMarker = create$2("path");
      attr(conditionaldefaultflowMarker, { d: "M 6 4 L 10 16" });
      addMarker(id2, {
        element: conditionaldefaultflowMarker,
        attrs: {
          stroke
        },
        ref: { x: 0, y: 10 },
        scale: 0.5
      });
    }
  }
  function drawCircle(parentGfx, width, height, offset2, attrs) {
    if (isObject$e(offset2)) {
      attrs = offset2;
      offset2 = 0;
    }
    offset2 = offset2 || 0;
    attrs = computeStyle2(attrs, {
      stroke: "black",
      strokeWidth: 2,
      fill: "white"
    });
    if (attrs.fill === "none") {
      delete attrs.fillOpacity;
    }
    var cx = width / 2, cy = height / 2;
    var circle = create$2("circle");
    attr(circle, {
      cx,
      cy,
      r: Math.round((width + height) / 4 - offset2)
    });
    attr(circle, attrs);
    append$3(parentGfx, circle);
    return circle;
  }
  function drawRect(parentGfx, width, height, r, offset2, attrs) {
    if (isObject$e(offset2)) {
      attrs = offset2;
      offset2 = 0;
    }
    offset2 = offset2 || 0;
    attrs = computeStyle2(attrs, {
      stroke: "black",
      strokeWidth: 2,
      fill: "white"
    });
    var rect = create$2("rect");
    attr(rect, {
      x: offset2,
      y: offset2,
      width: width - offset2 * 2,
      height: height - offset2 * 2,
      rx: r,
      ry: r
    });
    attr(rect, attrs);
    append$3(parentGfx, rect);
    return rect;
  }
  function drawDiamond(parentGfx, width, height, attrs) {
    var x_2 = width / 2;
    var y_2 = height / 2;
    var points = [{ x: x_2, y: 0 }, { x: width, y: y_2 }, { x: x_2, y: height }, { x: 0, y: y_2 }];
    var pointsString = points.map(function(point) {
      return point.x + "," + point.y;
    }).join(" ");
    attrs = computeStyle2(attrs, {
      stroke: "black",
      strokeWidth: 2,
      fill: "white"
    });
    var polygon = create$2("polygon");
    attr(polygon, {
      points: pointsString
    });
    attr(polygon, attrs);
    append$3(parentGfx, polygon);
    return polygon;
  }
  function drawLine(parentGfx, waypoints, attrs) {
    attrs = computeStyle2(attrs, ["no-fill"], {
      stroke: "black",
      strokeWidth: 2,
      fill: "none"
    });
    var line = createLine$1(waypoints, attrs);
    append$3(parentGfx, line);
    return line;
  }
  function drawPath(parentGfx, d, attrs) {
    attrs = computeStyle2(attrs, ["no-fill"], {
      strokeWidth: 2,
      stroke: "black"
    });
    var path = create$2("path");
    attr(path, { d });
    attr(path, attrs);
    append$3(parentGfx, path);
    return path;
  }
  function drawMarker(type, parentGfx, path, attrs) {
    return drawPath(parentGfx, path, assign$e({ "data-marker": type }, attrs));
  }
  function as(type) {
    return function(parentGfx, element) {
      return handlers[type](parentGfx, element);
    };
  }
  function renderer(type) {
    return handlers[type];
  }
  function renderEventContent(element, parentGfx) {
    var event = getSemantic(element);
    var isThrowing = isThrowEvent(event);
    if (event.eventDefinitions && event.eventDefinitions.length > 1) {
      if (event.parallelMultiple) {
        return renderer("bpmn:ParallelMultipleEventDefinition")(parentGfx, element, isThrowing);
      } else {
        return renderer("bpmn:MultipleEventDefinition")(parentGfx, element, isThrowing);
      }
    }
    if (isTypedEvent(event, "bpmn:MessageEventDefinition")) {
      return renderer("bpmn:MessageEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event, "bpmn:TimerEventDefinition")) {
      return renderer("bpmn:TimerEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event, "bpmn:ConditionalEventDefinition")) {
      return renderer("bpmn:ConditionalEventDefinition")(parentGfx, element);
    }
    if (isTypedEvent(event, "bpmn:SignalEventDefinition")) {
      return renderer("bpmn:SignalEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event, "bpmn:EscalationEventDefinition")) {
      return renderer("bpmn:EscalationEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event, "bpmn:LinkEventDefinition")) {
      return renderer("bpmn:LinkEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event, "bpmn:ErrorEventDefinition")) {
      return renderer("bpmn:ErrorEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event, "bpmn:CancelEventDefinition")) {
      return renderer("bpmn:CancelEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event, "bpmn:CompensateEventDefinition")) {
      return renderer("bpmn:CompensateEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event, "bpmn:TerminateEventDefinition")) {
      return renderer("bpmn:TerminateEventDefinition")(parentGfx, element, isThrowing);
    }
    return null;
  }
  function renderLabel(parentGfx, label2, options) {
    options = assign$e({
      size: {
        width: 100
      }
    }, options);
    var text = textRenderer.createText(label2 || "", options);
    classes(text).add("djs-label");
    append$3(parentGfx, text);
    return text;
  }
  function renderEmbeddedLabel(parentGfx, element, align) {
    var semantic = getSemantic(element);
    return renderLabel(parentGfx, semantic.name, {
      box: element,
      align,
      padding: 5,
      style: {
        fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor)
      }
    });
  }
  function renderExternalLabel(parentGfx, element) {
    var box = {
      width: 90,
      height: 30,
      x: element.width / 2 + element.x,
      y: element.height / 2 + element.y
    };
    return renderLabel(parentGfx, getLabel(element), {
      box,
      fitBox: true,
      style: assign$e({}, textRenderer.getExternalStyle(), {
        fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor)
      })
    });
  }
  function renderLaneLabel(parentGfx, text, element) {
    var textBox2 = renderLabel(parentGfx, text, {
      box: {
        height: 30,
        width: element.height
      },
      align: "center-middle",
      style: {
        fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor)
      }
    });
    var top = -1 * element.height;
    transform$1(textBox2, 0, -top, 270);
  }
  function createPathFromConnection(connection) {
    var waypoints = connection.waypoints;
    var pathData = "m  " + waypoints[0].x + "," + waypoints[0].y;
    for (var i = 1; i < waypoints.length; i++) {
      pathData += "L" + waypoints[i].x + "," + waypoints[i].y + " ";
    }
    return pathData;
  }
  var handlers = this.handlers = {
    "bpmn:Event": function(parentGfx, element, attrs) {
      if (!("fillOpacity" in attrs)) {
        attrs.fillOpacity = DEFAULT_FILL_OPACITY;
      }
      return drawCircle(parentGfx, element.width, element.height, attrs);
    },
    "bpmn:StartEvent": function(parentGfx, element) {
      var attrs = {
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      };
      var semantic = getSemantic(element);
      if (!semantic.isInterrupting) {
        attrs = {
          strokeDasharray: "6",
          strokeLinecap: "round",
          fill: getFillColor(element, defaultFillColor),
          stroke: getStrokeColor$1(element, defaultStrokeColor)
        };
      }
      var circle = renderer("bpmn:Event")(parentGfx, element, attrs);
      renderEventContent(element, parentGfx);
      return circle;
    },
    "bpmn:MessageEventDefinition": function(parentGfx, element, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_MESSAGE", {
        xScaleFactor: 0.9,
        yScaleFactor: 0.9,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.235,
          my: 0.315
        }
      });
      var fill = isThrowing ? getStrokeColor$1(element, defaultStrokeColor) : getFillColor(element, defaultFillColor);
      var stroke = isThrowing ? getFillColor(element, defaultFillColor) : getStrokeColor$1(element, defaultStrokeColor);
      var messagePath = drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke
      });
      return messagePath;
    },
    "bpmn:TimerEventDefinition": function(parentGfx, element) {
      var circle = drawCircle(parentGfx, element.width, element.height, 0.2 * element.height, {
        strokeWidth: 2,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      var pathData = pathMap.getScaledPath("EVENT_TIMER_WH", {
        xScaleFactor: 0.75,
        yScaleFactor: 0.75,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.5,
          my: 0.5
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 2,
        strokeLinecap: "square",
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      for (var i = 0; i < 12; i++) {
        var linePathData = pathMap.getScaledPath("EVENT_TIMER_LINE", {
          xScaleFactor: 0.75,
          yScaleFactor: 0.75,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.5,
            my: 0.5
          }
        });
        var width = element.width / 2;
        var height = element.height / 2;
        drawPath(parentGfx, linePathData, {
          strokeWidth: 1,
          strokeLinecap: "square",
          transform: "rotate(" + i * 30 + "," + height + "," + width + ")",
          stroke: getStrokeColor$1(element, defaultStrokeColor)
        });
      }
      return circle;
    },
    "bpmn:EscalationEventDefinition": function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_ESCALATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.5,
          my: 0.2
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor) : "none";
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor$1(event, defaultStrokeColor)
      });
    },
    "bpmn:ConditionalEventDefinition": function(parentGfx, event) {
      var pathData = pathMap.getScaledPath("EVENT_CONDITIONAL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.5,
          my: 0.222
        }
      });
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        stroke: getStrokeColor$1(event, defaultStrokeColor)
      });
    },
    "bpmn:LinkEventDefinition": function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_LINK", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.57,
          my: 0.263
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor) : "none";
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor$1(event, defaultStrokeColor)
      });
    },
    "bpmn:ErrorEventDefinition": function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_ERROR", {
        xScaleFactor: 1.1,
        yScaleFactor: 1.1,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.2,
          my: 0.722
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor) : "none";
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor$1(event, defaultStrokeColor)
      });
    },
    "bpmn:CancelEventDefinition": function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_CANCEL_45", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.638,
          my: -0.055
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor) : "none";
      var path = drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor$1(event, defaultStrokeColor)
      });
      rotate(path, 45);
      return path;
    },
    "bpmn:CompensateEventDefinition": function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_COMPENSATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.22,
          my: 0.5
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor) : "none";
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor$1(event, defaultStrokeColor)
      });
    },
    "bpmn:SignalEventDefinition": function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_SIGNAL", {
        xScaleFactor: 0.9,
        yScaleFactor: 0.9,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.5,
          my: 0.2
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor) : "none";
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor$1(event, defaultStrokeColor)
      });
    },
    "bpmn:MultipleEventDefinition": function(parentGfx, event, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_MULTIPLE", {
        xScaleFactor: 1.1,
        yScaleFactor: 1.1,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.222,
          my: 0.36
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor) : "none";
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill
      });
    },
    "bpmn:ParallelMultipleEventDefinition": function(parentGfx, event) {
      var pathData = pathMap.getScaledPath("EVENT_PARALLEL_MULTIPLE", {
        xScaleFactor: 1.2,
        yScaleFactor: 1.2,
        containerWidth: event.width,
        containerHeight: event.height,
        position: {
          mx: 0.458,
          my: 0.194
        }
      });
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getStrokeColor$1(event, defaultStrokeColor),
        stroke: getStrokeColor$1(event, defaultStrokeColor)
      });
    },
    "bpmn:EndEvent": function(parentGfx, element) {
      var circle = renderer("bpmn:Event")(parentGfx, element, {
        strokeWidth: 4,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      renderEventContent(element, parentGfx);
      return circle;
    },
    "bpmn:TerminateEventDefinition": function(parentGfx, element) {
      var circle = drawCircle(parentGfx, element.width, element.height, 8, {
        strokeWidth: 4,
        fill: getStrokeColor$1(element, defaultStrokeColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      return circle;
    },
    "bpmn:IntermediateEvent": function(parentGfx, element) {
      var outer = renderer("bpmn:Event")(parentGfx, element, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {
        strokeWidth: 1,
        fill: getFillColor(element, "none"),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      renderEventContent(element, parentGfx);
      return outer;
    },
    "bpmn:IntermediateCatchEvent": as("bpmn:IntermediateEvent"),
    "bpmn:IntermediateThrowEvent": as("bpmn:IntermediateEvent"),
    "bpmn:Activity": function(parentGfx, element, attrs) {
      attrs = attrs || {};
      if (!("fillOpacity" in attrs)) {
        attrs.fillOpacity = DEFAULT_FILL_OPACITY;
      }
      return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, attrs);
    },
    "bpmn:Task": function(parentGfx, element) {
      var attrs = {
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      };
      var rect = renderer("bpmn:Activity")(parentGfx, element, attrs);
      renderEmbeddedLabel(parentGfx, element, "center-middle");
      attachTaskMarkers(parentGfx, element);
      return rect;
    },
    "bpmn:ServiceTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathDataBG = pathMap.getScaledPath("TASK_TYPE_SERVICE", {
        abspos: {
          x: 12,
          y: 18
        }
      });
      drawPath(parentGfx, pathDataBG, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      var fillPathData = pathMap.getScaledPath("TASK_TYPE_SERVICE_FILL", {
        abspos: {
          x: 17.2,
          y: 18
        }
      });
      drawPath(parentGfx, fillPathData, {
        strokeWidth: 0,
        fill: getFillColor(element, defaultFillColor)
      });
      var pathData = pathMap.getScaledPath("TASK_TYPE_SERVICE", {
        abspos: {
          x: 17,
          y: 22
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:UserTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var x = 15;
      var y = 12;
      var pathData = pathMap.getScaledPath("TASK_TYPE_USER_1", {
        abspos: {
          x,
          y
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 0.5,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      var pathData2 = pathMap.getScaledPath("TASK_TYPE_USER_2", {
        abspos: {
          x,
          y
        }
      });
      drawPath(parentGfx, pathData2, {
        strokeWidth: 0.5,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      var pathData3 = pathMap.getScaledPath("TASK_TYPE_USER_3", {
        abspos: {
          x,
          y
        }
      });
      drawPath(parentGfx, pathData3, {
        strokeWidth: 0.5,
        fill: getStrokeColor$1(element, defaultStrokeColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:ManualTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathData = pathMap.getScaledPath("TASK_TYPE_MANUAL", {
        abspos: {
          x: 17,
          y: 15
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 0.5,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:SendTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathData = pathMap.getScaledPath("TASK_TYPE_SEND", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: 21,
        containerHeight: 14,
        position: {
          mx: 0.285,
          my: 0.357
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getStrokeColor$1(element, defaultStrokeColor),
        stroke: getFillColor(element, defaultFillColor)
      });
      return task;
    },
    "bpmn:ReceiveTask": function(parentGfx, element) {
      var semantic = getSemantic(element);
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathData;
      if (semantic.instantiate) {
        drawCircle(parentGfx, 28, 28, 20 * 0.22, { strokeWidth: 1 });
        pathData = pathMap.getScaledPath("TASK_TYPE_INSTANTIATING_SEND", {
          abspos: {
            x: 7.77,
            y: 9.52
          }
        });
      } else {
        pathData = pathMap.getScaledPath("TASK_TYPE_SEND", {
          xScaleFactor: 0.9,
          yScaleFactor: 0.9,
          containerWidth: 21,
          containerHeight: 14,
          position: {
            mx: 0.3,
            my: 0.4
          }
        });
      }
      drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:ScriptTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathData = pathMap.getScaledPath("TASK_TYPE_SCRIPT", {
        abspos: {
          x: 15,
          y: 20
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:BusinessRuleTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var headerPathData = pathMap.getScaledPath("TASK_TYPE_BUSINESS_RULE_HEADER", {
        abspos: {
          x: 8,
          y: 8
        }
      });
      var businessHeaderPath = drawPath(parentGfx, headerPathData);
      attr(businessHeaderPath, {
        strokeWidth: 1,
        fill: getFillColor(element, "#aaaaaa"),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      var headerData = pathMap.getScaledPath("TASK_TYPE_BUSINESS_RULE_MAIN", {
        abspos: {
          x: 8,
          y: 8
        }
      });
      var businessPath = drawPath(parentGfx, headerData);
      attr(businessPath, {
        strokeWidth: 1,
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:SubProcess": function(parentGfx, element, attrs) {
      attrs = assign$e({
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      }, attrs);
      var rect = renderer("bpmn:Activity")(parentGfx, element, attrs);
      var expanded = isExpanded(element);
      if (isEventSubProcess$1(element)) {
        attr(rect, {
          strokeDasharray: "1,2"
        });
      }
      renderEmbeddedLabel(parentGfx, element, expanded ? "center-top" : "center-middle");
      if (expanded) {
        attachTaskMarkers(parentGfx, element);
      } else {
        attachTaskMarkers(parentGfx, element, ["SubProcessMarker"]);
      }
      return rect;
    },
    "bpmn:AdHocSubProcess": function(parentGfx, element) {
      return renderer("bpmn:SubProcess")(parentGfx, element);
    },
    "bpmn:Transaction": function(parentGfx, element) {
      var outer = renderer("bpmn:SubProcess")(parentGfx, element);
      var innerAttrs = styles.style(["no-fill", "no-events"], {
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS - 2, INNER_OUTER_DIST, innerAttrs);
      return outer;
    },
    "bpmn:CallActivity": function(parentGfx, element) {
      return renderer("bpmn:SubProcess")(parentGfx, element, {
        strokeWidth: 5
      });
    },
    "bpmn:Participant": function(parentGfx, element) {
      var attrs = {
        fillOpacity: DEFAULT_FILL_OPACITY,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      };
      var lane = renderer("bpmn:Lane")(parentGfx, element, attrs);
      var expandedPool = isExpanded(element);
      if (expandedPool) {
        drawLine(parentGfx, [
          { x: 30, y: 0 },
          { x: 30, y: element.height }
        ], {
          stroke: getStrokeColor$1(element, defaultStrokeColor)
        });
        var text = getSemantic(element).name;
        renderLaneLabel(parentGfx, text, element);
      } else {
        var text2 = getSemantic(element).name;
        renderLabel(parentGfx, text2, {
          box: element,
          align: "center-middle",
          style: {
            fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor)
          }
        });
      }
      var participantMultiplicity = !!getSemantic(element).participantMultiplicity;
      if (participantMultiplicity) {
        renderer("ParticipantMultiplicityMarker")(parentGfx, element);
      }
      return lane;
    },
    "bpmn:Lane": function(parentGfx, element, attrs) {
      var rect = drawRect(parentGfx, element.width, element.height, 0, assign$e({
        fill: getFillColor(element, defaultFillColor),
        fillOpacity: HIGH_FILL_OPACITY,
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      }, attrs));
      var semantic = getSemantic(element);
      if (semantic.$type === "bpmn:Lane") {
        var text = semantic.name;
        renderLaneLabel(parentGfx, text, element);
      }
      return rect;
    },
    "bpmn:InclusiveGateway": function(parentGfx, element) {
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      drawCircle(parentGfx, element.width, element.height, element.height * 0.24, {
        strokeWidth: 2.5,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      return diamond;
    },
    "bpmn:ExclusiveGateway": function(parentGfx, element) {
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      var pathData = pathMap.getScaledPath("GATEWAY_EXCLUSIVE", {
        xScaleFactor: 0.4,
        yScaleFactor: 0.4,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.32,
          my: 0.3
        }
      });
      if (getDi(element).isMarkerVisible) {
        drawPath(parentGfx, pathData, {
          strokeWidth: 1,
          fill: getStrokeColor$1(element, defaultStrokeColor),
          stroke: getStrokeColor$1(element, defaultStrokeColor)
        });
      }
      return diamond;
    },
    "bpmn:ComplexGateway": function(parentGfx, element) {
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      var pathData = pathMap.getScaledPath("GATEWAY_COMPLEX", {
        xScaleFactor: 0.5,
        yScaleFactor: 0.5,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.46,
          my: 0.26
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getStrokeColor$1(element, defaultStrokeColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      return diamond;
    },
    "bpmn:ParallelGateway": function(parentGfx, element) {
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      var pathData = pathMap.getScaledPath("GATEWAY_PARALLEL", {
        xScaleFactor: 0.6,
        yScaleFactor: 0.6,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.46,
          my: 0.2
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getStrokeColor$1(element, defaultStrokeColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      return diamond;
    },
    "bpmn:EventBasedGateway": function(parentGfx, element) {
      var semantic = getSemantic(element);
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      drawCircle(parentGfx, element.width, element.height, element.height * 0.2, {
        strokeWidth: 1,
        fill: "none",
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      var type = semantic.eventGatewayType;
      var instantiate = !!semantic.instantiate;
      function drawEvent() {
        var pathData2 = pathMap.getScaledPath("GATEWAY_EVENT_BASED", {
          xScaleFactor: 0.18,
          yScaleFactor: 0.18,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.36,
            my: 0.44
          }
        });
        var attrs = {
          strokeWidth: 2,
          fill: getFillColor(element, "none"),
          stroke: getStrokeColor$1(element, defaultStrokeColor)
        };
        drawPath(parentGfx, pathData2, attrs);
      }
      if (type === "Parallel") {
        var pathData = pathMap.getScaledPath("GATEWAY_PARALLEL", {
          xScaleFactor: 0.4,
          yScaleFactor: 0.4,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.474,
            my: 0.296
          }
        });
        var parallelPath = drawPath(parentGfx, pathData);
        attr(parallelPath, {
          strokeWidth: 1,
          fill: "none"
        });
      } else if (type === "Exclusive") {
        if (!instantiate) {
          var innerCircle = drawCircle(parentGfx, element.width, element.height, element.height * 0.26);
          attr(innerCircle, {
            strokeWidth: 1,
            fill: "none",
            stroke: getStrokeColor$1(element, defaultStrokeColor)
          });
        }
        drawEvent();
      }
      return diamond;
    },
    "bpmn:Gateway": function(parentGfx, element) {
      var attrs = {
        fill: getFillColor(element, defaultFillColor),
        fillOpacity: DEFAULT_FILL_OPACITY,
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      };
      return drawDiamond(parentGfx, element.width, element.height, attrs);
    },
    "bpmn:SequenceFlow": function(parentGfx, element) {
      var pathData = createPathFromConnection(element);
      var fill = getFillColor(element, defaultFillColor), stroke = getStrokeColor$1(element, defaultStrokeColor);
      var attrs = {
        strokeLinejoin: "round",
        markerEnd: marker("sequenceflow-end", fill, stroke),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      };
      var path = drawPath(parentGfx, pathData, attrs);
      var sequenceFlow = getSemantic(element);
      var source;
      if (element.source) {
        source = element.source.businessObject;
        if (sequenceFlow.conditionExpression && source.$instanceOf("bpmn:Activity")) {
          attr(path, {
            markerStart: marker("conditional-flow-marker", fill, stroke)
          });
        }
        if (source.default && (source.$instanceOf("bpmn:Gateway") || source.$instanceOf("bpmn:Activity")) && source.default === sequenceFlow) {
          attr(path, {
            markerStart: marker("conditional-default-flow-marker", fill, stroke)
          });
        }
      }
      return path;
    },
    "bpmn:Association": function(parentGfx, element, attrs) {
      var semantic = getSemantic(element);
      var fill = getFillColor(element, defaultFillColor), stroke = getStrokeColor$1(element, defaultStrokeColor);
      attrs = assign$e({
        strokeDasharray: "0.5, 5",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      }, attrs || {});
      if (semantic.associationDirection === "One" || semantic.associationDirection === "Both") {
        attrs.markerEnd = marker("association-end", fill, stroke);
      }
      if (semantic.associationDirection === "Both") {
        attrs.markerStart = marker("association-start", fill, stroke);
      }
      return drawLine(parentGfx, element.waypoints, attrs);
    },
    "bpmn:DataInputAssociation": function(parentGfx, element) {
      var fill = getFillColor(element, defaultFillColor), stroke = getStrokeColor$1(element, defaultStrokeColor);
      return renderer("bpmn:Association")(parentGfx, element, {
        markerEnd: marker("association-end", fill, stroke)
      });
    },
    "bpmn:DataOutputAssociation": function(parentGfx, element) {
      var fill = getFillColor(element, defaultFillColor), stroke = getStrokeColor$1(element, defaultStrokeColor);
      return renderer("bpmn:Association")(parentGfx, element, {
        markerEnd: marker("association-end", fill, stroke)
      });
    },
    "bpmn:MessageFlow": function(parentGfx, element) {
      var semantic = getSemantic(element), di = getDi(element);
      var fill = getFillColor(element, defaultFillColor), stroke = getStrokeColor$1(element, defaultStrokeColor);
      var pathData = createPathFromConnection(element);
      var attrs = {
        markerEnd: marker("messageflow-end", fill, stroke),
        markerStart: marker("messageflow-start", fill, stroke),
        strokeDasharray: "10, 12",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: "1.5px",
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      };
      var path = drawPath(parentGfx, pathData, attrs);
      if (semantic.messageRef) {
        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);
        var markerPathData = pathMap.getScaledPath("MESSAGE_FLOW_MARKER", {
          abspos: {
            x: midPoint.x,
            y: midPoint.y
          }
        });
        var messageAttrs = { strokeWidth: 1 };
        if (di.messageVisibleKind === "initiating") {
          messageAttrs.fill = "white";
          messageAttrs.stroke = "black";
        } else {
          messageAttrs.fill = "#888";
          messageAttrs.stroke = "white";
        }
        var message2 = drawPath(parentGfx, markerPathData, messageAttrs);
        var labelText = semantic.messageRef.name;
        var label2 = renderLabel(parentGfx, labelText, {
          align: "center-top",
          fitBox: true,
          style: {
            fill: getStrokeColor$1(element, defaultLabelColor)
          }
        });
        var messageBounds = message2.getBBox(), labelBounds = label2.getBBox();
        var translateX = midPoint.x - labelBounds.width / 2, translateY = midPoint.y + messageBounds.height / 2 + ELEMENT_LABEL_DISTANCE$1;
        transform$1(label2, translateX, translateY, 0);
      }
      return path;
    },
    "bpmn:DataObject": function(parentGfx, element) {
      var pathData = pathMap.getScaledPath("DATA_OBJECT_PATH", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.474,
          my: 0.296
        }
      });
      var elementObject = drawPath(parentGfx, pathData, {
        fill: getFillColor(element, defaultFillColor),
        fillOpacity: DEFAULT_FILL_OPACITY,
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      var semantic = getSemantic(element);
      if (isCollection(semantic)) {
        renderDataItemCollection(parentGfx, element);
      }
      return elementObject;
    },
    "bpmn:DataObjectReference": as("bpmn:DataObject"),
    "bpmn:DataInput": function(parentGfx, element) {
      var arrowPathData = pathMap.getRawPath("DATA_ARROW");
      var elementObject = renderer("bpmn:DataObject")(parentGfx, element);
      drawPath(parentGfx, arrowPathData, { strokeWidth: 1 });
      return elementObject;
    },
    "bpmn:DataOutput": function(parentGfx, element) {
      var arrowPathData = pathMap.getRawPath("DATA_ARROW");
      var elementObject = renderer("bpmn:DataObject")(parentGfx, element);
      drawPath(parentGfx, arrowPathData, {
        strokeWidth: 1,
        fill: "black"
      });
      return elementObject;
    },
    "bpmn:DataStoreReference": function(parentGfx, element) {
      var DATA_STORE_PATH = pathMap.getScaledPath("DATA_STORE", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0.133
        }
      });
      var elementStore = drawPath(parentGfx, DATA_STORE_PATH, {
        strokeWidth: 2,
        fill: getFillColor(element, defaultFillColor),
        fillOpacity: DEFAULT_FILL_OPACITY,
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      return elementStore;
    },
    "bpmn:BoundaryEvent": function(parentGfx, element) {
      var semantic = getSemantic(element), cancel = semantic.cancelActivity;
      var attrs = {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      };
      if (!cancel) {
        attrs.strokeDasharray = "6";
        attrs.strokeLinecap = "round";
      }
      var outerAttrs = assign$e({}, attrs, {
        fillOpacity: 1
      });
      var innerAttrs = assign$e({}, attrs, {
        fill: "none"
      });
      var outer = renderer("bpmn:Event")(parentGfx, element, outerAttrs);
      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, innerAttrs);
      renderEventContent(element, parentGfx);
      return outer;
    },
    "bpmn:Group": function(parentGfx, element) {
      var group = drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {
        stroke: getStrokeColor$1(element, defaultStrokeColor),
        strokeWidth: 1,
        strokeDasharray: "8,3,1,3",
        fill: "none",
        pointerEvents: "none"
      });
      return group;
    },
    "label": function(parentGfx, element) {
      return renderExternalLabel(parentGfx, element);
    },
    "bpmn:TextAnnotation": function(parentGfx, element) {
      var style = {
        "fill": "none",
        "stroke": "none"
      };
      var textElement = drawRect(parentGfx, element.width, element.height, 0, 0, style);
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0
        }
      });
      drawPath(parentGfx, textPathData, {
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      var text = getSemantic(element).text || "";
      renderLabel(parentGfx, text, {
        box: element,
        align: "left-top",
        padding: 5,
        style: {
          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor)
        }
      });
      return textElement;
    },
    "ParticipantMultiplicityMarker": function(parentGfx, element) {
      var markerPath = pathMap.getScaledPath("MARKER_PARALLEL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: element.width / 2 / element.width,
          my: (element.height - 15) / element.height
        }
      });
      drawMarker("participant-multiplicity", parentGfx, markerPath, {
        strokeWidth: 2,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
    },
    "SubProcessMarker": function(parentGfx, element) {
      var markerRect = drawRect(parentGfx, 14, 14, 0, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
      translate$4(markerRect, element.width / 2 - 7.5, element.height - 20);
      var markerPath = pathMap.getScaledPath("MARKER_SUB_PROCESS", {
        xScaleFactor: 1.5,
        yScaleFactor: 1.5,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 - 7.5) / element.width,
          my: (element.height - 20) / element.height
        }
      });
      drawMarker("sub-process", parentGfx, markerPath, {
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
    },
    "ParallelMarker": function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath("MARKER_PARALLEL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.parallel) / element.width,
          my: (element.height - 20) / element.height
        }
      });
      drawMarker("parallel", parentGfx, markerPath, {
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
    },
    "SequentialMarker": function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath("MARKER_SEQUENTIAL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.seq) / element.width,
          my: (element.height - 19) / element.height
        }
      });
      drawMarker("sequential", parentGfx, markerPath, {
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
    },
    "CompensationMarker": function(parentGfx, element, position) {
      var markerMath = pathMap.getScaledPath("MARKER_COMPENSATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.compensation) / element.width,
          my: (element.height - 13) / element.height
        }
      });
      drawMarker("compensation", parentGfx, markerMath, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
    },
    "LoopMarker": function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath("MARKER_LOOP", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.loop) / element.width,
          my: (element.height - 7) / element.height
        }
      });
      drawMarker("loop", parentGfx, markerPath, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor),
        strokeLinecap: "round",
        strokeMiterlimit: 0.5
      });
    },
    "AdhocMarker": function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath("MARKER_ADHOC", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.adhoc) / element.width,
          my: (element.height - 15) / element.height
        }
      });
      drawMarker("adhoc", parentGfx, markerPath, {
        strokeWidth: 1,
        fill: getStrokeColor$1(element, defaultStrokeColor),
        stroke: getStrokeColor$1(element, defaultStrokeColor)
      });
    }
  };
  function attachTaskMarkers(parentGfx, element, taskMarkers) {
    var obj = getSemantic(element);
    var subprocess = taskMarkers && taskMarkers.indexOf("SubProcessMarker") !== -1;
    var position;
    if (subprocess) {
      position = {
        seq: -21,
        parallel: -22,
        compensation: -42,
        loop: -18,
        adhoc: 10
      };
    } else {
      position = {
        seq: -3,
        parallel: -6,
        compensation: -27,
        loop: 0,
        adhoc: 10
      };
    }
    forEach$q(taskMarkers, function(marker2) {
      renderer(marker2)(parentGfx, element, position);
    });
    if (obj.isForCompensation) {
      renderer("CompensationMarker")(parentGfx, element, position);
    }
    if (obj.$type === "bpmn:AdHocSubProcess") {
      renderer("AdhocMarker")(parentGfx, element, position);
    }
    var loopCharacteristics = obj.loopCharacteristics, isSequential = loopCharacteristics && loopCharacteristics.isSequential;
    if (loopCharacteristics) {
      if (isSequential === void 0) {
        renderer("LoopMarker")(parentGfx, element, position);
      }
      if (isSequential === false) {
        renderer("ParallelMarker")(parentGfx, element, position);
      }
      if (isSequential === true) {
        renderer("SequentialMarker")(parentGfx, element, position);
      }
    }
  }
  function renderDataItemCollection(parentGfx, element) {
    var yPosition = (element.height - 18) / element.height;
    var pathData = pathMap.getScaledPath("DATA_OBJECT_COLLECTION_PATH", {
      xScaleFactor: 1,
      yScaleFactor: 1,
      containerWidth: element.width,
      containerHeight: element.height,
      position: {
        mx: 0.33,
        my: yPosition
      }
    });
    drawPath(parentGfx, pathData, {
      strokeWidth: 2
    });
  }
  this._drawPath = drawPath;
}
inherits$6(BpmnRenderer, BaseRenderer);
BpmnRenderer.$inject = [
  "config.bpmnRenderer",
  "eventBus",
  "styles",
  "pathMap",
  "canvas",
  "textRenderer"
];
BpmnRenderer.prototype.canRender = function(element) {
  return is$O(element, "bpmn:BaseElement");
};
BpmnRenderer.prototype.drawShape = function(parentGfx, element) {
  var type = element.type;
  var h = this.handlers[type];
  return h(parentGfx, element);
};
BpmnRenderer.prototype.drawConnection = function(parentGfx, element) {
  var type = element.type;
  var h = this.handlers[type];
  return h(parentGfx, element);
};
BpmnRenderer.prototype.getShapePath = function(element) {
  if (is$O(element, "bpmn:Event")) {
    return getCirclePath(element);
  }
  if (is$O(element, "bpmn:Activity")) {
    return getRoundRectPath(element, TASK_BORDER_RADIUS);
  }
  if (is$O(element, "bpmn:Gateway")) {
    return getDiamondPath(element);
  }
  return getRectPath(element);
};
var DEFAULT_BOX_PADDING = 0;
var DEFAULT_LABEL_SIZE$1 = {
  width: 150,
  height: 50
};
function parseAlign(align) {
  var parts = align.split("-");
  return {
    horizontal: parts[0] || "center",
    vertical: parts[1] || "top"
  };
}
function parsePadding(padding) {
  if (isObject$e(padding)) {
    return assign$e({ top: 0, left: 0, right: 0, bottom: 0 }, padding);
  } else {
    return {
      top: padding,
      left: padding,
      right: padding,
      bottom: padding
    };
  }
}
function getTextBBox(text, fakeText) {
  fakeText.textContent = text;
  var textBBox;
  try {
    var bbox, emptyLine = text === "";
    fakeText.textContent = emptyLine ? "dummy" : text;
    textBBox = fakeText.getBBox();
    bbox = {
      width: textBBox.width + textBBox.x * 2,
      height: textBBox.height
    };
    if (emptyLine) {
      bbox.width = 0;
    }
    return bbox;
  } catch (e) {
    return { width: 0, height: 0 };
  }
}
function layoutNext(lines, maxWidth, fakeText) {
  var originalLine = lines.shift(), fitLine = originalLine;
  var textBBox;
  for (; ; ) {
    textBBox = getTextBBox(fitLine, fakeText);
    textBBox.width = fitLine ? textBBox.width : 0;
    if (fitLine === " " || fitLine === "" || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {
      return fit(lines, fitLine, originalLine, textBBox);
    }
    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);
  }
}
function fit(lines, fitLine, originalLine, textBBox) {
  if (fitLine.length < originalLine.length) {
    var remainder = originalLine.slice(fitLine.length).trim();
    lines.unshift(remainder);
  }
  return {
    width: textBBox.width,
    height: textBBox.height,
    text: fitLine
  };
}
var SOFT_BREAK = "\xAD";
function semanticShorten(line, maxLength) {
  var parts = line.split(/(\s|-|\u00AD)/g), part, shortenedParts = [], length2 = 0;
  if (parts.length > 1) {
    while (part = parts.shift()) {
      if (part.length + length2 < maxLength) {
        shortenedParts.push(part);
        length2 += part.length;
      } else {
        if (part === "-" || part === SOFT_BREAK) {
          shortenedParts.pop();
        }
        break;
      }
    }
  }
  var last2 = shortenedParts[shortenedParts.length - 1];
  if (last2 && last2 === SOFT_BREAK) {
    shortenedParts[shortenedParts.length - 1] = "-";
  }
  return shortenedParts.join("");
}
function shortenLine(line, width, maxWidth) {
  var length2 = Math.max(line.length * (maxWidth / width), 1);
  var shortenedLine = semanticShorten(line, length2);
  if (!shortenedLine) {
    shortenedLine = line.slice(0, Math.max(Math.round(length2 - 1), 1));
  }
  return shortenedLine;
}
function getHelperSvg() {
  var helperSvg = document.getElementById("helper-svg");
  if (!helperSvg) {
    helperSvg = create$2("svg");
    attr(helperSvg, {
      id: "helper-svg",
      width: 0,
      height: 0,
      style: "visibility: hidden; position: fixed"
    });
    document.body.appendChild(helperSvg);
  }
  return helperSvg;
}
function Text(config) {
  this._config = assign$e({}, {
    size: DEFAULT_LABEL_SIZE$1,
    padding: DEFAULT_BOX_PADDING,
    style: {},
    align: "center-top"
  }, config || {});
}
Text.prototype.createText = function(text, options) {
  return this.layoutText(text, options).element;
};
Text.prototype.getDimensions = function(text, options) {
  return this.layoutText(text, options).dimensions;
};
Text.prototype.layoutText = function(text, options) {
  var box = assign$e({}, this._config.size, options.box), style = assign$e({}, this._config.style, options.style), align = parseAlign(options.align || this._config.align), padding = parsePadding(options.padding !== void 0 ? options.padding : this._config.padding), fitBox = options.fitBox || false;
  var lineHeight = getLineHeight(style);
  var lines = text.split(/\u00AD?\r?\n/), layouted = [];
  var maxWidth = box.width - padding.left - padding.right;
  var helperText = create$2("text");
  attr(helperText, { x: 0, y: 0 });
  attr(helperText, style);
  var helperSvg = getHelperSvg();
  append$3(helperSvg, helperText);
  while (lines.length) {
    layouted.push(layoutNext(lines, maxWidth, helperText));
  }
  if (align.vertical === "middle") {
    padding.top = padding.bottom = 0;
  }
  var totalHeight = reduce$3(layouted, function(sum, line, idx) {
    return sum + (lineHeight || line.height);
  }, 0) + padding.top + padding.bottom;
  var maxLineWidth = reduce$3(layouted, function(sum, line, idx) {
    return line.width > sum ? line.width : sum;
  }, 0);
  var y = padding.top;
  if (align.vertical === "middle") {
    y += (box.height - totalHeight) / 2;
  }
  y -= (lineHeight || layouted[0].height) / 4;
  var textElement = create$2("text");
  attr(textElement, style);
  forEach$q(layouted, function(line) {
    var x;
    y += lineHeight || line.height;
    switch (align.horizontal) {
      case "left":
        x = padding.left;
        break;
      case "right":
        x = (fitBox ? maxLineWidth : maxWidth) - padding.right - line.width;
        break;
      default:
        x = Math.max(((fitBox ? maxLineWidth : maxWidth) - line.width) / 2 + padding.left, 0);
    }
    var tspan = create$2("tspan");
    attr(tspan, { x, y });
    tspan.textContent = line.text;
    append$3(textElement, tspan);
  });
  remove$4(helperText);
  var dimensions = {
    width: maxLineWidth,
    height: totalHeight
  };
  return {
    dimensions,
    element: textElement
  };
};
function getLineHeight(style) {
  if ("fontSize" in style && "lineHeight" in style) {
    return style.lineHeight * parseInt(style.fontSize, 10);
  }
}
var DEFAULT_FONT_SIZE = 12;
var LINE_HEIGHT_RATIO = 1.2;
var MIN_TEXT_ANNOTATION_HEIGHT = 30;
function TextRenderer(config) {
  var defaultStyle = assign$e({
    fontFamily: "Arial, sans-serif",
    fontSize: DEFAULT_FONT_SIZE,
    fontWeight: "normal",
    lineHeight: LINE_HEIGHT_RATIO
  }, config && config.defaultStyle || {});
  var fontSize = parseInt(defaultStyle.fontSize, 10) - 1;
  var externalStyle = assign$e({}, defaultStyle, {
    fontSize
  }, config && config.externalStyle || {});
  var textUtil = new Text({
    style: defaultStyle
  });
  this.getExternalLabelBounds = function(bounds, text) {
    var layoutedDimensions = textUtil.getDimensions(text, {
      box: {
        width: 90,
        height: 30,
        x: bounds.width / 2 + bounds.x,
        y: bounds.height / 2 + bounds.y
      },
      style: externalStyle
    });
    return {
      x: Math.round(bounds.x + bounds.width / 2 - layoutedDimensions.width / 2),
      y: Math.round(bounds.y),
      width: Math.ceil(layoutedDimensions.width),
      height: Math.ceil(layoutedDimensions.height)
    };
  };
  this.getTextAnnotationBounds = function(bounds, text) {
    var layoutedDimensions = textUtil.getDimensions(text, {
      box: bounds,
      style: defaultStyle,
      align: "left-top",
      padding: 5
    });
    return {
      x: bounds.x,
      y: bounds.y,
      width: bounds.width,
      height: Math.max(MIN_TEXT_ANNOTATION_HEIGHT, Math.round(layoutedDimensions.height))
    };
  };
  this.createText = function(text, options) {
    return textUtil.createText(text, options || {});
  };
  this.getDefaultStyle = function() {
    return defaultStyle;
  };
  this.getExternalStyle = function() {
    return externalStyle;
  };
}
TextRenderer.$inject = [
  "config.textRenderer"
];
function PathMap() {
  this.pathMap = {
    "EVENT_MESSAGE": {
      d: "m {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}",
      height: 36,
      width: 36,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    "EVENT_SIGNAL": {
      d: "M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z",
      height: 36,
      width: 36,
      heightElements: [18],
      widthElements: [10, 20]
    },
    "EVENT_ESCALATION": {
      d: "M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z",
      height: 36,
      width: 36,
      heightElements: [20, 7],
      widthElements: [8]
    },
    "EVENT_CONDITIONAL": {
      d: "M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z M {e.x2},{e.y3} l {e.x0},0 M {e.x2},{e.y4} l {e.x0},0 M {e.x2},{e.y5} l {e.x0},0 M {e.x2},{e.y6} l {e.x0},0 M {e.x2},{e.y7} l {e.x0},0 M {e.x2},{e.y8} l {e.x0},0 ",
      height: 36,
      width: 36,
      heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],
      widthElements: [10.5, 14.5, 12.5]
    },
    "EVENT_LINK": {
      d: "m {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z",
      height: 36,
      width: 36,
      heightElements: [4.4375, 6.75, 7.8125],
      widthElements: [9.84375, 13.5]
    },
    "EVENT_ERROR": {
      d: "m {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z",
      height: 36,
      width: 36,
      heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],
      widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]
    },
    "EVENT_CANCEL_45": {
      d: "m {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z",
      height: 36,
      width: 36,
      heightElements: [4.75, 8.5],
      widthElements: [4.75, 8.5]
    },
    "EVENT_COMPENSATION": {
      d: "m {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z",
      height: 36,
      width: 36,
      heightElements: [6.5, 13, 0.4, 6.1],
      widthElements: [9, 9.3, 8.7]
    },
    "EVENT_TIMER_WH": {
      d: "M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ",
      height: 36,
      width: 36,
      heightElements: [10, 2],
      widthElements: [3, 7]
    },
    "EVENT_TIMER_LINE": {
      d: "M {mx},{my} m {e.x0},{e.y0} l -{e.x1},{e.y1} ",
      height: 36,
      width: 36,
      heightElements: [10, 3],
      widthElements: [0, 0]
    },
    "EVENT_MULTIPLE": {
      d: "m {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z",
      height: 36,
      width: 36,
      heightElements: [6.28099, 12.56199],
      widthElements: [3.1405, 9.42149, 12.56198]
    },
    "EVENT_PARALLEL_MULTIPLE": {
      d: "m {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} -{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z",
      height: 36,
      width: 36,
      heightElements: [2.56228, 7.68683],
      widthElements: [2.56228, 7.68683]
    },
    "GATEWAY_EXCLUSIVE": {
      d: "m {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} {e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} {e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z",
      height: 17.5,
      width: 17.5,
      heightElements: [8.5, 6.5312, -6.5312, -8.5],
      widthElements: [6.5, -6.5, 3, -3, 5, -5]
    },
    "GATEWAY_PARALLEL": {
      d: "m {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z",
      height: 30,
      width: 30,
      heightElements: [5, 12.5],
      widthElements: [5, 12.5]
    },
    "GATEWAY_EVENT_BASED": {
      d: "m {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z",
      height: 11,
      width: 11,
      heightElements: [-6, 6, 12, -12],
      widthElements: [9, -3, -12]
    },
    "GATEWAY_COMPLEX": {
      d: "m {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} {e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} {e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} -{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z",
      height: 17.125,
      width: 17.125,
      heightElements: [4.875, 3.4375, 2.125, 3],
      widthElements: [3.4375, 2.125, 4.875, 3]
    },
    "DATA_OBJECT_PATH": {
      d: "m 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0",
      height: 61,
      width: 51,
      heightElements: [10, 50, 60],
      widthElements: [10, 40, 50, 60]
    },
    "DATA_OBJECT_COLLECTION_PATH": {
      d: "m{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "DATA_ARROW": {
      d: "m 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z",
      height: 61,
      width: 51,
      heightElements: [],
      widthElements: []
    },
    "DATA_STORE": {
      d: "m  {mx},{my} l  0,{e.y2} c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 l  0,-{e.y2} c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 m  -{e.x2},{e.y0}c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0m  -{e.x2},{e.y0}c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0",
      height: 61,
      width: 61,
      heightElements: [7, 10, 45],
      widthElements: [2, 58, 60]
    },
    "TEXT_ANNOTATION": {
      d: "m {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0",
      height: 30,
      width: 10,
      heightElements: [30],
      widthElements: [10]
    },
    "MARKER_SUB_PROCESS": {
      d: "m{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "MARKER_PARALLEL": {
      d: "m{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "MARKER_SEQUENTIAL": {
      d: "m{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "MARKER_COMPENSATION": {
      d: "m {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z",
      height: 10,
      width: 21,
      heightElements: [],
      widthElements: []
    },
    "MARKER_LOOP": {
      d: "m {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 -6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902",
      height: 13.9,
      width: 13.7,
      heightElements: [],
      widthElements: []
    },
    "MARKER_ADHOC": {
      d: "m {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 -3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 -2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z",
      height: 4,
      width: 15,
      heightElements: [],
      widthElements: []
    },
    "TASK_TYPE_SEND": {
      d: "m {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}",
      height: 14,
      width: 21,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    "TASK_TYPE_SCRIPT": {
      d: "m {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z m -7,-12 l 5,0 m -4.5,3 l 4.5,0 m -3,3 l 5,0m -4,3 l 5,0",
      height: 15,
      width: 12.6,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    "TASK_TYPE_USER_1": {
      d: "m {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 -4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 zm -8,6 l 0,5.5 m 11,0 l 0,-5"
    },
    "TASK_TYPE_USER_2": {
      d: "m {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 -2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 "
    },
    "TASK_TYPE_USER_3": {
      d: "m {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 -4.20799998,3.36699999 -4.20699998,4.34799999 z"
    },
    "TASK_TYPE_MANUAL": {
      d: "m {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 -0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 -1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 -10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 -0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 -1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 -0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 -5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z"
    },
    "TASK_TYPE_INSTANTIATING_SEND": {
      d: "m {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6"
    },
    "TASK_TYPE_SERVICE": {
      d: "m {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 -1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 -0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 -1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 -0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z m 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z"
    },
    "TASK_TYPE_SERVICE_FILL": {
      d: "m {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z"
    },
    "TASK_TYPE_BUSINESS_RULE_HEADER": {
      d: "m {mx},{my} 0,4 20,0 0,-4 z"
    },
    "TASK_TYPE_BUSINESS_RULE_MAIN": {
      d: "m {mx},{my} 0,12 20,0 0,-12 zm 0,8 l 20,0 m -13,-4 l 0,8"
    },
    "MESSAGE_FLOW_MARKER": {
      d: "m {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6"
    }
  };
  this.getRawPath = function getRawPath(pathId) {
    return this.pathMap[pathId].d;
  };
  this.getScaledPath = function getScaledPath(pathId, param) {
    var rawPath = this.pathMap[pathId];
    var mx, my;
    if (param.abspos) {
      mx = param.abspos.x;
      my = param.abspos.y;
    } else {
      mx = param.containerWidth * param.position.mx;
      my = param.containerHeight * param.position.my;
    }
    var coordinates = {};
    if (param.position) {
      var heightRatio = param.containerHeight / rawPath.height * param.yScaleFactor;
      var widthRatio = param.containerWidth / rawPath.width * param.xScaleFactor;
      for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {
        coordinates["y" + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;
      }
      for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {
        coordinates["x" + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;
      }
    }
    var path = format(rawPath.d, {
      mx,
      my,
      e: coordinates
    });
    return path;
  };
}
var tokenRegex = /\{([^{}]+)\}/g, objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g;
function replacer(all2, key, obj) {
  var res = obj;
  key.replace(objNotationRegex, function(all3, name2, quote, quotedName, isFunc) {
    name2 = name2 || quotedName;
    if (res) {
      if (name2 in res) {
        res = res[name2];
      }
      typeof res == "function" && isFunc && (res = res());
    }
  });
  res = (res == null || res == obj ? all2 : res) + "";
  return res;
}
function format(str, obj) {
  return String(str).replace(tokenRegex, function(all2, key) {
    return replacer(all2, key, obj);
  });
}
var DrawModule = {
  __init__: ["bpmnRenderer"],
  bpmnRenderer: ["type", BpmnRenderer],
  textRenderer: ["type", TextRenderer],
  pathMap: ["type", PathMap]
};
function translate$3(template2, replacements) {
  replacements = replacements || {};
  return template2.replace(/{([^}]+)}/g, function(_, key) {
    return replacements[key] || "{" + key + "}";
  });
}
var translate$2 = {
  translate: ["value", translate$3]
};
var DEFAULT_LABEL_SIZE = {
  width: 90,
  height: 20
};
var FLOW_LABEL_INDENT = 15;
function isLabelExternal(semantic) {
  return is$O(semantic, "bpmn:Event") || is$O(semantic, "bpmn:Gateway") || is$O(semantic, "bpmn:DataStoreReference") || is$O(semantic, "bpmn:DataObjectReference") || is$O(semantic, "bpmn:DataInput") || is$O(semantic, "bpmn:DataOutput") || is$O(semantic, "bpmn:SequenceFlow") || is$O(semantic, "bpmn:MessageFlow") || is$O(semantic, "bpmn:Group");
}
function hasExternalLabel(element) {
  return isLabel$6(element.label);
}
function getFlowLabelPosition(waypoints) {
  var mid2 = waypoints.length / 2 - 1;
  var first = waypoints[Math.floor(mid2)];
  var second = waypoints[Math.ceil(mid2 + 0.01)];
  var position = getWaypointsMid(waypoints);
  var angle = Math.atan((second.y - first.y) / (second.x - first.x));
  var x = position.x, y = position.y;
  if (Math.abs(angle) < Math.PI / 2) {
    y -= FLOW_LABEL_INDENT;
  } else {
    x += FLOW_LABEL_INDENT;
  }
  return { x, y };
}
function getWaypointsMid(waypoints) {
  var mid2 = waypoints.length / 2 - 1;
  var first = waypoints[Math.floor(mid2)];
  var second = waypoints[Math.ceil(mid2 + 0.01)];
  return {
    x: first.x + (second.x - first.x) / 2,
    y: first.y + (second.y - first.y) / 2
  };
}
function getExternalLabelMid(element) {
  if (element.waypoints) {
    return getFlowLabelPosition(element.waypoints);
  } else if (is$O(element, "bpmn:Group")) {
    return {
      x: element.x + element.width / 2,
      y: element.y + DEFAULT_LABEL_SIZE.height / 2
    };
  } else {
    return {
      x: element.x + element.width / 2,
      y: element.y + element.height + DEFAULT_LABEL_SIZE.height / 2
    };
  }
}
function getExternalLabelBounds(semantic, element) {
  var mid2, size2, bounds, di = semantic.di, label2 = di.label;
  if (label2 && label2.bounds) {
    bounds = label2.bounds;
    size2 = {
      width: Math.max(DEFAULT_LABEL_SIZE.width, bounds.width),
      height: bounds.height
    };
    mid2 = {
      x: bounds.x + bounds.width / 2,
      y: bounds.y + bounds.height / 2
    };
  } else {
    mid2 = getExternalLabelMid(element);
    size2 = DEFAULT_LABEL_SIZE;
  }
  return assign$e({
    x: mid2.x - size2.width / 2,
    y: mid2.y - size2.height / 2
  }, size2);
}
function isLabel$6(element) {
  return element && !!element.labelTarget;
}
function elementData(semantic, attrs) {
  return assign$e({
    id: semantic.id,
    type: semantic.$type,
    businessObject: semantic
  }, attrs);
}
function getWaypoints(bo, source, target) {
  var waypoints = bo.di.waypoint;
  if (!waypoints || waypoints.length < 2) {
    return [getMid(source), getMid(target)];
  }
  return waypoints.map(function(p) {
    return { x: p.x, y: p.y };
  });
}
function notYetDrawn(translate2, semantic, refSemantic, property2) {
  return new Error(translate2("element {element} referenced by {referenced}#{property} not yet drawn", {
    element: elementToString(refSemantic),
    referenced: elementToString(semantic),
    property: property2
  }));
}
function BpmnImporter(eventBus, canvas, elementFactory, elementRegistry, translate2, textRenderer) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementFactory = elementFactory;
  this._elementRegistry = elementRegistry;
  this._translate = translate2;
  this._textRenderer = textRenderer;
}
BpmnImporter.$inject = [
  "eventBus",
  "canvas",
  "elementFactory",
  "elementRegistry",
  "translate",
  "textRenderer"
];
BpmnImporter.prototype.add = function(semantic, parentElement) {
  var di = semantic.di, element, translate2 = this._translate, hidden;
  var parentIndex;
  if (is$O(di, "bpmndi:BPMNPlane")) {
    element = this._elementFactory.createRoot(elementData(semantic));
    this._canvas.setRootElement(element);
  } else if (is$O(di, "bpmndi:BPMNShape")) {
    var collapsed = !isExpanded(semantic), isFrame = isFrameElement(semantic);
    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);
    var bounds = semantic.di.bounds;
    element = this._elementFactory.createShape(elementData(semantic, {
      collapsed,
      hidden,
      x: Math.round(bounds.x),
      y: Math.round(bounds.y),
      width: Math.round(bounds.width),
      height: Math.round(bounds.height),
      isFrame
    }));
    if (is$O(semantic, "bpmn:BoundaryEvent")) {
      this._attachBoundary(semantic, element);
    }
    if (is$O(semantic, "bpmn:Lane")) {
      parentIndex = 0;
    }
    if (is$O(semantic, "bpmn:DataStoreReference")) {
      if (!isPointInsideBBox$1(parentElement, getMid(bounds))) {
        parentElement = this._canvas.getRootElement();
      }
    }
    this._canvas.addShape(element, parentElement, parentIndex);
  } else if (is$O(di, "bpmndi:BPMNEdge")) {
    var source = this._getSource(semantic), target = this._getTarget(semantic);
    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);
    element = this._elementFactory.createConnection(elementData(semantic, {
      hidden,
      source,
      target,
      waypoints: getWaypoints(semantic, source, target)
    }));
    if (is$O(semantic, "bpmn:DataAssociation")) {
      parentElement = null;
    }
    if (is$O(semantic, "bpmn:SequenceFlow")) {
      parentIndex = 0;
    }
    this._canvas.addConnection(element, parentElement, parentIndex);
  } else {
    throw new Error(translate2("unknown di {di} for element {semantic}", {
      di: elementToString(di),
      semantic: elementToString(semantic)
    }));
  }
  if (isLabelExternal(semantic) && getLabel(element)) {
    this.addLabel(semantic, element);
  }
  this._eventBus.fire("bpmnElement.added", { element });
  return element;
};
BpmnImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {
  var translate2 = this._translate;
  var hostSemantic = boundarySemantic.attachedToRef;
  if (!hostSemantic) {
    throw new Error(translate2("missing {semantic}#attachedToRef", {
      semantic: elementToString(boundarySemantic)
    }));
  }
  var host = this._elementRegistry.get(hostSemantic.id), attachers = host && host.attachers;
  if (!host) {
    throw notYetDrawn(translate2, boundarySemantic, hostSemantic, "attachedToRef");
  }
  boundaryElement.host = host;
  if (!attachers) {
    host.attachers = attachers = [];
  }
  if (attachers.indexOf(boundaryElement) === -1) {
    attachers.push(boundaryElement);
  }
};
BpmnImporter.prototype.addLabel = function(semantic, element) {
  var bounds, text, label2;
  bounds = getExternalLabelBounds(semantic, element);
  text = getLabel(element);
  if (text) {
    bounds = this._textRenderer.getExternalLabelBounds(bounds, text);
  }
  label2 = this._elementFactory.createLabel(elementData(semantic, {
    id: semantic.id + "_label",
    labelTarget: element,
    type: "label",
    hidden: element.hidden || !getLabel(element),
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  }));
  return this._canvas.addShape(label2, element.parent);
};
BpmnImporter.prototype._getEnd = function(semantic, side) {
  var element, refSemantic, type = semantic.$type, translate2 = this._translate;
  refSemantic = semantic[side + "Ref"];
  if (side === "source" && type === "bpmn:DataInputAssociation") {
    refSemantic = refSemantic && refSemantic[0];
  }
  if (side === "source" && type === "bpmn:DataOutputAssociation" || side === "target" && type === "bpmn:DataInputAssociation") {
    refSemantic = semantic.$parent;
  }
  element = refSemantic && this._getElement(refSemantic);
  if (element) {
    return element;
  }
  if (refSemantic) {
    throw notYetDrawn(translate2, semantic, refSemantic, side + "Ref");
  } else {
    throw new Error(translate2("{semantic}#{side} Ref not specified", {
      semantic: elementToString(semantic),
      side
    }));
  }
};
BpmnImporter.prototype._getSource = function(semantic) {
  return this._getEnd(semantic, "source");
};
BpmnImporter.prototype._getTarget = function(semantic) {
  return this._getEnd(semantic, "target");
};
BpmnImporter.prototype._getElement = function(semantic) {
  return this._elementRegistry.get(semantic.id);
};
function isPointInsideBBox$1(bbox, point) {
  var x = point.x, y = point.y;
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
}
function isFrameElement(semantic) {
  return is$O(semantic, "bpmn:Group");
}
var ImportModule = {
  __depends__: [
    translate$2
  ],
  bpmnImporter: ["type", BpmnImporter]
};
var CoreModule = {
  __depends__: [
    DrawModule,
    ImportModule
  ]
};
function __stopPropagation(event) {
  if (!event || typeof event.stopPropagation !== "function") {
    return;
  }
  event.stopPropagation();
}
function getOriginal$2(event) {
  return event.originalEvent || event.srcEvent;
}
function stopPropagation$1(event, immediate) {
  __stopPropagation(event);
  __stopPropagation(getOriginal$2(event));
}
function toPoint(event) {
  if (event.pointers && event.pointers.length) {
    event = event.pointers[0];
  }
  if (event.touches && event.touches.length) {
    event = event.touches[0];
  }
  return event ? {
    x: event.clientX,
    y: event.clientY
  } : null;
}
function isMac() {
  return /mac/i.test(navigator.platform);
}
function isButton$1(event, button) {
  return (getOriginal$2(event) || event).button === button;
}
function isPrimaryButton$1(event) {
  return isButton$1(event, 0);
}
function isAuxiliaryButton$1(event) {
  return isButton$1(event, 1);
}
function hasPrimaryModifier(event) {
  var originalEvent = getOriginal$2(event) || event;
  if (!isPrimaryButton$1(event)) {
    return false;
  }
  if (isMac()) {
    return originalEvent.metaKey;
  } else {
    return originalEvent.ctrlKey;
  }
}
function hasSecondaryModifier(event) {
  var originalEvent = getOriginal$2(event) || event;
  return isPrimaryButton$1(event) && originalEvent.shiftKey;
}
function allowAll$1(event) {
  return true;
}
function allowPrimaryAndAuxiliary$1(event) {
  return isPrimaryButton$1(event) || isAuxiliaryButton$1(event);
}
var LOW_PRIORITY$o = 500;
function InteractionEvents$1(eventBus, elementRegistry, styles) {
  var self2 = this;
  function fire(type, event, element) {
    if (isIgnored(type, event)) {
      return;
    }
    var target, gfx, returnValue;
    if (!element) {
      target = event.delegateTarget || event.target;
      if (target) {
        gfx = target;
        element = elementRegistry.get(gfx);
      }
    } else {
      gfx = elementRegistry.getGraphics(element);
    }
    if (!gfx || !element) {
      return;
    }
    returnValue = eventBus.fire(type, {
      element,
      gfx,
      originalEvent: event
    });
    if (returnValue === false) {
      event.stopPropagation();
      event.preventDefault();
    }
  }
  var handlers = {};
  function mouseHandler(localEventName) {
    return handlers[localEventName];
  }
  function isIgnored(localEventName, event) {
    var filter2 = ignoredFilters[localEventName] || isPrimaryButton$1;
    return !filter2(event);
  }
  var bindings = {
    click: "element.click",
    contextmenu: "element.contextmenu",
    dblclick: "element.dblclick",
    mousedown: "element.mousedown",
    mousemove: "element.mousemove",
    mouseover: "element.hover",
    mouseout: "element.out",
    mouseup: "element.mouseup"
  };
  var ignoredFilters = {
    "element.contextmenu": allowAll$1,
    "element.mousedown": allowPrimaryAndAuxiliary$1,
    "element.mouseup": allowPrimaryAndAuxiliary$1,
    "element.click": allowPrimaryAndAuxiliary$1,
    "element.dblclick": allowPrimaryAndAuxiliary$1
  };
  function triggerMouseEvent(eventName, event, targetElement) {
    var localEventName = bindings[eventName];
    if (!localEventName) {
      throw new Error("unmapped DOM event name <" + eventName + ">");
    }
    return fire(localEventName, event, targetElement);
  }
  var ELEMENT_SELECTOR2 = "svg, .djs-element";
  function registerEvent(node2, event, localEvent, ignoredFilter) {
    var handler = handlers[localEvent] = function(event2) {
      fire(localEvent, event2);
    };
    if (ignoredFilter) {
      ignoredFilters[localEvent] = ignoredFilter;
    }
    handler.$delegate = delegate$1.bind(node2, ELEMENT_SELECTOR2, event, handler);
  }
  function unregisterEvent(node2, event, localEvent) {
    var handler = mouseHandler(localEvent);
    if (!handler) {
      return;
    }
    delegate$1.unbind(node2, event, handler.$delegate);
  }
  function registerEvents(svg) {
    forEach$q(bindings, function(val, key) {
      registerEvent(svg, key, val);
    });
  }
  function unregisterEvents(svg) {
    forEach$q(bindings, function(val, key) {
      unregisterEvent(svg, key, val);
    });
  }
  eventBus.on("canvas.destroy", function(event) {
    unregisterEvents(event.svg);
  });
  eventBus.on("canvas.init", function(event) {
    registerEvents(event.svg);
  });
  eventBus.on(["shape.added", "connection.added"], function(event) {
    var element = event.element, gfx = event.gfx;
    eventBus.fire("interactionEvents.createHit", { element, gfx });
  });
  eventBus.on([
    "shape.changed",
    "connection.changed"
  ], LOW_PRIORITY$o, function(event) {
    var element = event.element, gfx = event.gfx;
    eventBus.fire("interactionEvents.updateHit", { element, gfx });
  });
  eventBus.on("interactionEvents.createHit", LOW_PRIORITY$o, function(event) {
    var element = event.element, gfx = event.gfx;
    self2.createDefaultHit(element, gfx);
  });
  eventBus.on("interactionEvents.updateHit", function(event) {
    var element = event.element, gfx = event.gfx;
    self2.updateDefaultHit(element, gfx);
  });
  var STROKE_HIT_STYLE = createHitStyle("djs-hit djs-hit-stroke");
  var CLICK_STROKE_HIT_STYLE = createHitStyle("djs-hit djs-hit-click-stroke");
  var ALL_HIT_STYLE = createHitStyle("djs-hit djs-hit-all");
  var HIT_TYPES = {
    "all": ALL_HIT_STYLE,
    "click-stroke": CLICK_STROKE_HIT_STYLE,
    "stroke": STROKE_HIT_STYLE
  };
  function createHitStyle(classNames, attrs) {
    attrs = assign$e({
      stroke: "white",
      strokeWidth: 15
    }, attrs || {});
    return styles.cls(classNames, ["no-fill", "no-border"], attrs);
  }
  function applyStyle2(hit, type) {
    var attrs = HIT_TYPES[type];
    if (!attrs) {
      throw new Error("invalid hit type <" + type + ">");
    }
    attr(hit, attrs);
    return hit;
  }
  function appendHit(gfx, hit) {
    append$3(gfx, hit);
  }
  this.removeHits = function(gfx) {
    var hits = all(".djs-hit", gfx);
    forEach$q(hits, remove$4);
  };
  this.createDefaultHit = function(element, gfx) {
    var waypoints = element.waypoints, isFrame = element.isFrame, boxType;
    if (waypoints) {
      return this.createWaypointsHit(gfx, waypoints);
    } else {
      boxType = isFrame ? "stroke" : "all";
      return this.createBoxHit(gfx, boxType, {
        width: element.width,
        height: element.height
      });
    }
  };
  this.createWaypointsHit = function(gfx, waypoints) {
    var hit = createLine$1(waypoints);
    applyStyle2(hit, "stroke");
    appendHit(gfx, hit);
    return hit;
  };
  this.createBoxHit = function(gfx, type, attrs) {
    attrs = assign$e({
      x: 0,
      y: 0
    }, attrs);
    var hit = create$2("rect");
    applyStyle2(hit, type);
    attr(hit, attrs);
    appendHit(gfx, hit);
    return hit;
  };
  this.updateDefaultHit = function(element, gfx) {
    var hit = query(".djs-hit", gfx);
    if (!hit) {
      return;
    }
    if (element.waypoints) {
      updateLine$1(hit, element.waypoints);
    } else {
      attr(hit, {
        width: element.width,
        height: element.height
      });
    }
    return hit;
  };
  this.fire = fire;
  this.triggerMouseEvent = triggerMouseEvent;
  this.mouseHandler = mouseHandler;
  this.registerEvent = registerEvent;
  this.unregisterEvent = unregisterEvent;
}
InteractionEvents$1.$inject = [
  "eventBus",
  "elementRegistry",
  "styles"
];
var InteractionEventsModule$2 = {
  __init__: ["interactionEvents"],
  interactionEvents: ["type", InteractionEvents$1]
};
var LOW_PRIORITY$n = 500;
function Outline(eventBus, styles, elementRegistry) {
  this.offset = 6;
  var OUTLINE_STYLE = styles.cls("djs-outline", ["no-fill"]);
  var self2 = this;
  function createOutline(gfx, bounds) {
    var outline = create$2("rect");
    attr(outline, assign$e({
      x: 10,
      y: 10,
      width: 100,
      height: 100
    }, OUTLINE_STYLE));
    append$3(gfx, outline);
    return outline;
  }
  eventBus.on(["shape.added", "shape.changed"], LOW_PRIORITY$n, function(event) {
    var element = event.element, gfx = event.gfx;
    var outline = query(".djs-outline", gfx);
    if (!outline) {
      outline = createOutline(gfx);
    }
    self2.updateShapeOutline(outline, element);
  });
  eventBus.on(["connection.added", "connection.changed"], function(event) {
    var element = event.element, gfx = event.gfx;
    var outline = query(".djs-outline", gfx);
    if (!outline) {
      outline = createOutline(gfx);
    }
    self2.updateConnectionOutline(outline, element);
  });
}
Outline.prototype.updateShapeOutline = function(outline, element) {
  attr(outline, {
    x: -this.offset,
    y: -this.offset,
    width: element.width + this.offset * 2,
    height: element.height + this.offset * 2
  });
};
Outline.prototype.updateConnectionOutline = function(outline, connection) {
  var bbox = getBBox(connection);
  attr(outline, {
    x: bbox.x - this.offset,
    y: bbox.y - this.offset,
    width: bbox.width + this.offset * 2,
    height: bbox.height + this.offset * 2
  });
};
Outline.$inject = ["eventBus", "styles", "elementRegistry"];
var OutlineModule = {
  __init__: ["outline"],
  outline: ["type", Outline]
};
function Selection(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._selectedElements = [];
  var self2 = this;
  eventBus.on(["shape.remove", "connection.remove"], function(e) {
    var element = e.element;
    self2.deselect(element);
  });
  eventBus.on(["diagram.clear", "plane.set"], function(e) {
    self2.select(null);
  });
}
Selection.$inject = ["eventBus", "canvas"];
Selection.prototype.deselect = function(element) {
  var selectedElements = this._selectedElements;
  var idx = selectedElements.indexOf(element);
  if (idx !== -1) {
    var oldSelection = selectedElements.slice();
    selectedElements.splice(idx, 1);
    this._eventBus.fire("selection.changed", { oldSelection, newSelection: selectedElements });
  }
};
Selection.prototype.get = function() {
  return this._selectedElements;
};
Selection.prototype.isSelected = function(element) {
  return this._selectedElements.indexOf(element) !== -1;
};
Selection.prototype.select = function(elements, add2) {
  var selectedElements = this._selectedElements, oldSelection = selectedElements.slice();
  if (!isArray$n(elements)) {
    elements = elements ? [elements] : [];
  }
  var canvas = this._canvas;
  elements = elements.filter(function(element) {
    var plane = canvas.findPlane(element);
    return plane === canvas.getActivePlane();
  });
  if (add2) {
    forEach$q(elements, function(element) {
      if (selectedElements.indexOf(element) !== -1) {
        return;
      } else {
        selectedElements.push(element);
      }
    });
  } else {
    this._selectedElements = selectedElements = elements.slice();
  }
  this._eventBus.fire("selection.changed", { oldSelection, newSelection: selectedElements });
};
var MARKER_HOVER = "hover", MARKER_SELECTED = "selected";
function SelectionVisuals(events, canvas, selection, styles) {
  this._multiSelectionBox = null;
  function addMarker(e, cls) {
    canvas.addMarker(e, cls);
  }
  function removeMarker(e, cls) {
    canvas.removeMarker(e, cls);
  }
  events.on("element.hover", function(event) {
    addMarker(event.element, MARKER_HOVER);
  });
  events.on("element.out", function(event) {
    removeMarker(event.element, MARKER_HOVER);
  });
  events.on("selection.changed", function(event) {
    function deselect(s) {
      removeMarker(s, MARKER_SELECTED);
    }
    function select(s) {
      addMarker(s, MARKER_SELECTED);
    }
    var oldSelection = event.oldSelection, newSelection = event.newSelection;
    forEach$q(oldSelection, function(e) {
      if (newSelection.indexOf(e) === -1) {
        deselect(e);
      }
    });
    forEach$q(newSelection, function(e) {
      if (oldSelection.indexOf(e) === -1) {
        select(e);
      }
    });
  });
}
SelectionVisuals.$inject = [
  "eventBus",
  "canvas",
  "selection",
  "styles"
];
function SelectionBehavior(eventBus, selection, canvas, elementRegistry) {
  eventBus.on("create.end", 500, function(event) {
    var context = event.context, canExecute = context.canExecute, elements = context.elements, hints = context.hints || {}, autoSelect = hints.autoSelect;
    if (canExecute) {
      if (autoSelect === false) {
        return;
      }
      if (isArray$n(autoSelect)) {
        selection.select(autoSelect);
      } else {
        selection.select(elements.filter(isShown));
      }
    }
  });
  eventBus.on("connect.end", 500, function(event) {
    var context = event.context, canExecute = context.canExecute, hover = context.hover;
    if (canExecute && hover) {
      selection.select(hover);
    }
  });
  eventBus.on("shape.move.end", 500, function(event) {
    var previousSelection = event.previousSelection || [];
    var shape = elementRegistry.get(event.context.shape.id);
    var isSelected = find$e(previousSelection, function(selectedShape) {
      return shape.id === selectedShape.id;
    });
    if (!isSelected) {
      selection.select(shape);
    }
  });
  eventBus.on("element.click", function(event) {
    if (!isPrimaryButton$1(event)) {
      return;
    }
    var element = event.element;
    if (element === canvas.getRootElement()) {
      element = null;
    }
    var isSelected = selection.isSelected(element), isMultiSelect = selection.get().length > 1;
    var add2 = hasPrimaryModifier(event) || hasSecondaryModifier(event);
    if (isSelected && isMultiSelect) {
      if (add2) {
        return selection.deselect(element);
      } else {
        return selection.select(element);
      }
    } else if (!isSelected) {
      selection.select(element, add2);
    } else {
      selection.deselect(element);
    }
  });
}
SelectionBehavior.$inject = [
  "eventBus",
  "selection",
  "canvas",
  "elementRegistry"
];
function isShown(element) {
  return !element.hidden;
}
var SelectionModule = {
  __init__: ["selectionVisuals", "selectionBehavior"],
  __depends__: [
    InteractionEventsModule$2,
    OutlineModule
  ],
  selection: ["type", Selection],
  selectionVisuals: ["type", SelectionVisuals],
  selectionBehavior: ["type", SelectionBehavior]
};
function IdGenerator(prefix2) {
  this._counter = 0;
  this._prefix = (prefix2 ? prefix2 + "-" : "") + Math.floor(Math.random() * 1e9) + "-";
}
IdGenerator.prototype.next = function() {
  return this._prefix + ++this._counter;
};
var ids$1 = new IdGenerator("ov");
var LOW_PRIORITY$m = 500;
function Overlays(config, eventBus, canvas, elementRegistry) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementRegistry = elementRegistry;
  this._ids = ids$1;
  this._overlayDefaults = assign$e({
    show: null,
    scale: true
  }, config && config.defaults);
  this._overlays = {};
  this._overlayContainers = [];
  this._overlayRoot = createRoot$1(canvas.getContainer());
  this._init();
}
Overlays.$inject = [
  "config.overlays",
  "eventBus",
  "canvas",
  "elementRegistry"
];
Overlays.prototype.get = function(search) {
  if (isString$3(search)) {
    search = { id: search };
  }
  if (isString$3(search.element)) {
    search.element = this._elementRegistry.get(search.element);
  }
  if (search.element) {
    var container = this._getOverlayContainer(search.element, true);
    if (container) {
      return search.type ? filter$a(container.overlays, matchPattern$1({ type: search.type })) : container.overlays.slice();
    } else {
      return [];
    }
  } else if (search.type) {
    return filter$a(this._overlays, matchPattern$1({ type: search.type }));
  } else {
    return search.id ? this._overlays[search.id] : null;
  }
};
Overlays.prototype.add = function(element, type, overlay) {
  if (isObject$e(type)) {
    overlay = type;
    type = null;
  }
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }
  if (!overlay.position) {
    throw new Error("must specifiy overlay position");
  }
  if (!overlay.html) {
    throw new Error("must specifiy overlay html");
  }
  if (!element) {
    throw new Error("invalid element specified");
  }
  var id2 = this._ids.next();
  overlay = assign$e({}, this._overlayDefaults, overlay, {
    id: id2,
    type,
    element,
    html: overlay.html
  });
  this._addOverlay(overlay);
  return id2;
};
Overlays.prototype.remove = function(filter2) {
  var overlays = this.get(filter2) || [];
  if (!isArray$n(overlays)) {
    overlays = [overlays];
  }
  var self2 = this;
  forEach$q(overlays, function(overlay) {
    var container = self2._getOverlayContainer(overlay.element, true);
    if (overlay) {
      remove$5(overlay.html);
      remove$5(overlay.htmlContainer);
      delete overlay.htmlContainer;
      delete overlay.element;
      delete self2._overlays[overlay.id];
    }
    if (container) {
      var idx = container.overlays.indexOf(overlay);
      if (idx !== -1) {
        container.overlays.splice(idx, 1);
      }
    }
  });
};
Overlays.prototype.show = function() {
  setVisible$1(this._overlayRoot);
};
Overlays.prototype.hide = function() {
  setVisible$1(this._overlayRoot, false);
};
Overlays.prototype.clear = function() {
  this._overlays = {};
  this._overlayContainers = [];
  clear$1(this._overlayRoot);
};
Overlays.prototype._updateOverlayContainer = function(container) {
  var element = container.element, html = container.html;
  var x = element.x, y = element.y;
  if (element.waypoints) {
    var bbox = getBBox(element);
    x = bbox.x;
    y = bbox.y;
  }
  setPosition$2(html, x, y);
  attr$1(container.html, "data-container-id", element.id);
};
Overlays.prototype._updateOverlay = function(overlay) {
  var position = overlay.position, htmlContainer = overlay.htmlContainer, element = overlay.element;
  var left = position.left, top = position.top;
  if (position.right !== void 0) {
    var width;
    if (element.waypoints) {
      width = getBBox(element).width;
    } else {
      width = element.width;
    }
    left = position.right * -1 + width;
  }
  if (position.bottom !== void 0) {
    var height;
    if (element.waypoints) {
      height = getBBox(element).height;
    } else {
      height = element.height;
    }
    top = position.bottom * -1 + height;
  }
  setPosition$2(htmlContainer, left || 0, top || 0);
};
Overlays.prototype._createOverlayContainer = function(element) {
  var html = domify$h('<div class="djs-overlays" style="position: absolute" />');
  this._overlayRoot.appendChild(html);
  var container = {
    html,
    element,
    overlays: []
  };
  this._updateOverlayContainer(container);
  this._overlayContainers.push(container);
  return container;
};
Overlays.prototype._updateRoot = function(viewbox) {
  var scale = viewbox.scale || 1;
  var matrix = "matrix(" + [
    scale,
    0,
    0,
    scale,
    -1 * viewbox.x * scale,
    -1 * viewbox.y * scale
  ].join(",") + ")";
  setTransform$1(this._overlayRoot, matrix);
};
Overlays.prototype._getOverlayContainer = function(element, raw) {
  var container = find$e(this._overlayContainers, function(c) {
    return c.element === element;
  });
  if (!container && !raw) {
    return this._createOverlayContainer(element);
  }
  return container;
};
Overlays.prototype._addOverlay = function(overlay) {
  var id2 = overlay.id, element = overlay.element, html = overlay.html, htmlContainer, overlayContainer;
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }
  if (isString$3(html)) {
    html = domify$h(html);
  }
  overlayContainer = this._getOverlayContainer(element);
  htmlContainer = domify$h('<div class="djs-overlay" data-overlay-id="' + id2 + '" style="position: absolute">');
  htmlContainer.appendChild(html);
  if (overlay.type) {
    classes$1(htmlContainer).add("djs-overlay-" + overlay.type);
  }
  var plane = this._canvas.findPlane(element);
  var activePlane = this._canvas.getActivePlane();
  overlay.plane = plane;
  if (plane !== activePlane) {
    setVisible$1(htmlContainer, false);
  }
  overlay.htmlContainer = htmlContainer;
  overlayContainer.overlays.push(overlay);
  overlayContainer.html.appendChild(htmlContainer);
  this._overlays[id2] = overlay;
  this._updateOverlay(overlay);
  this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
};
Overlays.prototype._updateOverlayVisibilty = function(overlay, viewbox) {
  var show = overlay.show, plane = overlay.plane, minZoom = show && show.minZoom, maxZoom = show && show.maxZoom, htmlContainer = overlay.htmlContainer, activePlane = this._canvas.getActivePlane(), visible = true;
  if (plane !== activePlane) {
    visible = false;
  } else if (show) {
    if (isDefined(minZoom) && minZoom > viewbox.scale || isDefined(maxZoom) && maxZoom < viewbox.scale) {
      visible = false;
    }
  }
  setVisible$1(htmlContainer, visible);
  this._updateOverlayScale(overlay, viewbox);
};
Overlays.prototype._updateOverlayScale = function(overlay, viewbox) {
  var shouldScale = overlay.scale, minScale, maxScale, htmlContainer = overlay.htmlContainer;
  var scale, transform2 = "";
  if (shouldScale !== true) {
    if (shouldScale === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = shouldScale.min;
      maxScale = shouldScale.max;
    }
    if (isDefined(minScale) && viewbox.scale < minScale) {
      scale = (1 / viewbox.scale || 1) * minScale;
    }
    if (isDefined(maxScale) && viewbox.scale > maxScale) {
      scale = (1 / viewbox.scale || 1) * maxScale;
    }
  }
  if (isDefined(scale)) {
    transform2 = "scale(" + scale + "," + scale + ")";
  }
  setTransform$1(htmlContainer, transform2);
};
Overlays.prototype._updateOverlaysVisibilty = function(viewbox) {
  var self2 = this;
  forEach$q(this._overlays, function(overlay) {
    self2._updateOverlayVisibilty(overlay, viewbox);
  });
};
Overlays.prototype._init = function() {
  var eventBus = this._eventBus;
  var self2 = this;
  function updateViewbox(viewbox) {
    self2._updateRoot(viewbox);
    self2._updateOverlaysVisibilty(viewbox);
    self2.show();
  }
  eventBus.on("canvas.viewbox.changing", function(event) {
    self2.hide();
  });
  eventBus.on("canvas.viewbox.changed", function(event) {
    updateViewbox(event.viewbox);
  });
  eventBus.on(["shape.remove", "connection.remove"], function(e) {
    var element = e.element;
    var overlays = self2.get({ element });
    forEach$q(overlays, function(o) {
      self2.remove(o.id);
    });
    var container = self2._getOverlayContainer(element);
    if (container) {
      remove$5(container.html);
      var i = self2._overlayContainers.indexOf(container);
      if (i !== -1) {
        self2._overlayContainers.splice(i, 1);
      }
    }
  });
  eventBus.on("element.changed", LOW_PRIORITY$m, function(e) {
    var element = e.element;
    var container = self2._getOverlayContainer(element, true);
    if (container) {
      forEach$q(container.overlays, function(overlay) {
        self2._updateOverlay(overlay);
      });
      self2._updateOverlayContainer(container);
    }
  });
  eventBus.on("element.marker.update", function(e) {
    var container = self2._getOverlayContainer(e.element, true);
    if (container) {
      classes$1(container.html)[e.add ? "add" : "remove"](e.marker);
    }
  });
  eventBus.on("plane.set", function(e) {
    forEach$q(self2._overlays, function(el) {
      setVisible$1(el.htmlContainer, el.plane === e.plane);
    });
  });
  eventBus.on("diagram.clear", this.clear, this);
};
function createRoot$1(parentNode) {
  var root2 = domify$h('<div class="djs-overlay-container" style="position: absolute; width: 0; height: 0;" />');
  parentNode.insertBefore(root2, parentNode.firstChild);
  return root2;
}
function setPosition$2(el, x, y) {
  assign$e(el.style, { left: x + "px", top: y + "px" });
}
function setVisible$1(el, visible) {
  el.style.display = visible === false ? "none" : "";
}
function setTransform$1(el, transform2) {
  el.style["transform-origin"] = "top left";
  ["", "-ms-", "-webkit-"].forEach(function(prefix2) {
    el.style[prefix2 + "transform"] = transform2;
  });
}
var OverlaysModule = {
  __init__: ["overlays"],
  overlays: ["type", Overlays]
};
function Viewer(options) {
  BaseViewer.call(this, options);
}
inherits$6(Viewer, BaseViewer);
Viewer.prototype._modules = [
  CoreModule,
  translate$2,
  SelectionModule,
  OverlaysModule
];
Viewer.prototype._moddleExtensions = {};
function hasModifier(event) {
  return event.ctrlKey || event.metaKey || event.shiftKey || event.altKey;
}
function isCmd(event) {
  if (event.altKey) {
    return false;
  }
  return event.ctrlKey || event.metaKey;
}
function isKey$4(keys2, event) {
  keys2 = isArray$n(keys2) ? keys2 : [keys2];
  return keys2.indexOf(event.key) !== -1 || keys2.indexOf(event.keyCode) !== -1;
}
function isShift(event) {
  return event.shiftKey;
}
var KEYDOWN_EVENT = "keyboard.keydown", KEYUP_EVENT = "keyboard.keyup";
var HANDLE_MODIFIER_ATTRIBUTE = "input-handle-modified-keys";
var DEFAULT_PRIORITY$7 = 1e3;
function Keyboard(config, eventBus) {
  var self2 = this;
  this._config = config || {};
  this._eventBus = eventBus;
  this._keydownHandler = this._keydownHandler.bind(this);
  this._keyupHandler = this._keyupHandler.bind(this);
  eventBus.on("diagram.destroy", function() {
    self2._fire("destroy");
    self2.unbind();
  });
  eventBus.on("diagram.init", function() {
    self2._fire("init");
  });
  eventBus.on("attach", function() {
    if (config && config.bindTo) {
      self2.bind(config.bindTo);
    }
  });
  eventBus.on("detach", function() {
    self2.unbind();
  });
}
Keyboard.$inject = [
  "config.keyboard",
  "eventBus"
];
Keyboard.prototype._keydownHandler = function(event) {
  this._keyHandler(event, KEYDOWN_EVENT);
};
Keyboard.prototype._keyupHandler = function(event) {
  this._keyHandler(event, KEYUP_EVENT);
};
Keyboard.prototype._keyHandler = function(event, type) {
  var eventBusResult;
  if (this._isEventIgnored(event)) {
    return;
  }
  var context = {
    keyEvent: event
  };
  eventBusResult = this._eventBus.fire(type || KEYDOWN_EVENT, context);
  if (eventBusResult) {
    event.preventDefault();
  }
};
Keyboard.prototype._isEventIgnored = function(event) {
  return isInput(event.target) && this._isModifiedKeyIgnored(event);
};
Keyboard.prototype._isModifiedKeyIgnored = function(event) {
  if (!isCmd(event)) {
    return true;
  }
  var allowedModifiers = this._getAllowedModifiers(event.target);
  return !allowedModifiers.includes(event.key);
};
Keyboard.prototype._getAllowedModifiers = function(element) {
  var modifierContainer = closest(element, "[" + HANDLE_MODIFIER_ATTRIBUTE + "]", true);
  if (!modifierContainer || this._node && !this._node.contains(modifierContainer)) {
    return [];
  }
  return modifierContainer.getAttribute(HANDLE_MODIFIER_ATTRIBUTE).split(",");
};
Keyboard.prototype.bind = function(node2) {
  this.unbind();
  this._node = node2;
  componentEvent.bind(node2, "keydown", this._keydownHandler, true);
  componentEvent.bind(node2, "keyup", this._keyupHandler, true);
  this._fire("bind");
};
Keyboard.prototype.getBinding = function() {
  return this._node;
};
Keyboard.prototype.unbind = function() {
  var node2 = this._node;
  if (node2) {
    this._fire("unbind");
    componentEvent.unbind(node2, "keydown", this._keydownHandler, true);
    componentEvent.unbind(node2, "keyup", this._keyupHandler, true);
  }
  this._node = null;
};
Keyboard.prototype._fire = function(event) {
  this._eventBus.fire("keyboard." + event, { node: this._node });
};
Keyboard.prototype.addListener = function(priority, listener2, type) {
  if (isFunction$6(priority)) {
    type = listener2;
    listener2 = priority;
    priority = DEFAULT_PRIORITY$7;
  }
  this._eventBus.on(type || KEYDOWN_EVENT, priority, listener2);
};
Keyboard.prototype.removeListener = function(listener2, type) {
  this._eventBus.off(type || KEYDOWN_EVENT, listener2);
};
Keyboard.prototype.hasModifier = hasModifier;
Keyboard.prototype.isCmd = isCmd;
Keyboard.prototype.isShift = isShift;
Keyboard.prototype.isKey = isKey$4;
function isInput(target) {
  return target && (matchesSelector(target, "input, textarea") || target.contentEditable === "true");
}
var LOW_PRIORITY$l = 500;
var KEYCODE_C = 67;
var KEYCODE_V = 86;
var KEYCODE_Y = 89;
var KEYCODE_Z = 90;
var KEYS_COPY = ["c", "C", KEYCODE_C];
var KEYS_PASTE = ["v", "V", KEYCODE_V];
var KEYS_REDO = ["y", "Y", KEYCODE_Y];
var KEYS_UNDO = ["z", "Z", KEYCODE_Z];
function KeyboardBindings(eventBus, keyboard) {
  var self2 = this;
  eventBus.on("editorActions.init", LOW_PRIORITY$l, function(event) {
    var editorActions = event.editorActions;
    self2.registerBindings(keyboard, editorActions);
  });
}
KeyboardBindings.$inject = [
  "eventBus",
  "keyboard"
];
KeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {
  function addListener(action, fn) {
    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn);
    }
  }
  addListener("undo", function(context) {
    var event = context.keyEvent;
    if (isCmd(event) && !isShift(event) && isKey$4(KEYS_UNDO, event)) {
      editorActions.trigger("undo");
      return true;
    }
  });
  addListener("redo", function(context) {
    var event = context.keyEvent;
    if (isCmd(event) && (isKey$4(KEYS_REDO, event) || isKey$4(KEYS_UNDO, event) && isShift(event))) {
      editorActions.trigger("redo");
      return true;
    }
  });
  addListener("copy", function(context) {
    var event = context.keyEvent;
    if (isCmd(event) && isKey$4(KEYS_COPY, event)) {
      editorActions.trigger("copy");
      return true;
    }
  });
  addListener("paste", function(context) {
    var event = context.keyEvent;
    if (isCmd(event) && isKey$4(KEYS_PASTE, event)) {
      editorActions.trigger("paste");
      return true;
    }
  });
  addListener("stepZoom", function(context) {
    var event = context.keyEvent;
    if (isKey$4(["+", "Add", "="], event) && isCmd(event)) {
      editorActions.trigger("stepZoom", { value: 1 });
      return true;
    }
  });
  addListener("stepZoom", function(context) {
    var event = context.keyEvent;
    if (isKey$4(["-", "Subtract"], event) && isCmd(event)) {
      editorActions.trigger("stepZoom", { value: -1 });
      return true;
    }
  });
  addListener("zoom", function(context) {
    var event = context.keyEvent;
    if (isKey$4("0", event) && isCmd(event)) {
      editorActions.trigger("zoom", { value: 1 });
      return true;
    }
  });
  addListener("removeSelection", function(context) {
    var event = context.keyEvent;
    if (isKey$4(["Backspace", "Delete", "Del"], event)) {
      editorActions.trigger("removeSelection");
      return true;
    }
  });
};
var KeyboardModule$1 = {
  __init__: ["keyboard", "keyboardBindings"],
  keyboard: ["type", Keyboard],
  keyboardBindings: ["type", KeyboardBindings]
};
var DEFAULT_CONFIG$1 = {
  moveSpeed: 50,
  moveSpeedAccelerated: 200
};
function KeyboardMove(config, keyboard, canvas) {
  var self2 = this;
  this._config = assign$e({}, DEFAULT_CONFIG$1, config || {});
  keyboard.addListener(arrowsListener);
  function arrowsListener(context) {
    var event = context.keyEvent, config2 = self2._config;
    if (!keyboard.isCmd(event)) {
      return;
    }
    if (keyboard.isKey([
      "ArrowLeft",
      "Left",
      "ArrowUp",
      "Up",
      "ArrowDown",
      "Down",
      "ArrowRight",
      "Right"
    ], event)) {
      var speed = keyboard.isShift(event) ? config2.moveSpeedAccelerated : config2.moveSpeed;
      var direction;
      switch (event.key) {
        case "ArrowLeft":
        case "Left":
          direction = "left";
          break;
        case "ArrowUp":
        case "Up":
          direction = "up";
          break;
        case "ArrowRight":
        case "Right":
          direction = "right";
          break;
        case "ArrowDown":
        case "Down":
          direction = "down";
          break;
      }
      self2.moveCanvas({
        speed,
        direction
      });
      return true;
    }
  }
  this.moveCanvas = function(opts) {
    var dx = 0, dy = 0, speed = opts.speed;
    var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);
    switch (opts.direction) {
      case "left":
        dx = actualSpeed;
        break;
      case "up":
        dy = actualSpeed;
        break;
      case "right":
        dx = -actualSpeed;
        break;
      case "down":
        dy = -actualSpeed;
        break;
    }
    canvas.scroll({
      dx,
      dy
    });
  };
}
KeyboardMove.$inject = [
  "config.keyboardMove",
  "keyboard",
  "canvas"
];
var KeyboardMoveModule = {
  __depends__: [
    KeyboardModule$1
  ],
  __init__: ["keyboardMove"],
  keyboardMove: ["type", KeyboardMove]
};
var CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;
function set(mode) {
  var classes2 = classes$1(document.body);
  classes2.removeMatching(CURSOR_CLS_PATTERN);
  if (mode) {
    classes2.add("djs-cursor-" + mode);
  }
}
function unset() {
  set(null);
}
var TRAP_PRIORITY = 5e3;
function install(eventBus, eventName) {
  eventName = eventName || "element.click";
  function trap() {
    return false;
  }
  eventBus.once(eventName, TRAP_PRIORITY, trap);
  return function() {
    eventBus.off(eventName, trap);
  };
}
function center(bounds) {
  return {
    x: bounds.x + bounds.width / 2,
    y: bounds.y + bounds.height / 2
  };
}
function delta(a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}
var THRESHOLD$1 = 15;
function MoveCanvas(eventBus, canvas) {
  var context;
  eventBus.on("element.mousedown", 500, function(e) {
    return handleStart(e.originalEvent);
  });
  function handleMove(event) {
    var start = context.start, button = context.button, position = toPoint(event), delta$1 = delta(position, start);
    if (!context.dragging && length(delta$1) > THRESHOLD$1) {
      context.dragging = true;
      if (button === 0) {
        install(eventBus);
      }
      set("grab");
    }
    if (context.dragging) {
      var lastPosition = context.last || context.start;
      delta$1 = delta(position, lastPosition);
      canvas.scroll({
        dx: delta$1.x,
        dy: delta$1.y
      });
      context.last = position;
    }
    event.preventDefault();
  }
  function handleEnd(event) {
    componentEvent.unbind(document, "mousemove", handleMove);
    componentEvent.unbind(document, "mouseup", handleEnd);
    context = null;
    unset();
  }
  function handleStart(event) {
    if (closest(event.target, ".djs-draggable")) {
      return;
    }
    var button = event.button;
    if (button >= 2 || event.ctrlKey || event.shiftKey || event.altKey) {
      return;
    }
    context = {
      button,
      start: toPoint(event)
    };
    componentEvent.bind(document, "mousemove", handleMove);
    componentEvent.bind(document, "mouseup", handleEnd);
    return true;
  }
  this.isActive = function() {
    return !!context;
  };
}
MoveCanvas.$inject = [
  "eventBus",
  "canvas"
];
function length(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}
var MoveCanvasModule = {
  __init__: ["moveCanvas"],
  moveCanvas: ["type", MoveCanvas]
};
function log10(x) {
  return Math.log(x) / Math.log(10);
}
function getStepSize(range2, steps) {
  var minLinearRange = log10(range2.min), maxLinearRange = log10(range2.max);
  var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);
  return absoluteLinearRange / steps;
}
function cap(range2, scale) {
  return Math.max(range2.min, Math.min(range2.max, scale));
}
var sign = Math.sign || function(n) {
  return n >= 0 ? 1 : -1;
};
var RANGE = { min: 0.2, max: 4 }, NUM_STEPS = 10;
var DELTA_THRESHOLD = 0.1;
var DEFAULT_SCALE = 0.75;
function ZoomScroll(config, eventBus, canvas) {
  config = config || {};
  this._enabled = false;
  this._canvas = canvas;
  this._container = canvas._container;
  this._handleWheel = bind$3(this._handleWheel, this);
  this._totalDelta = 0;
  this._scale = config.scale || DEFAULT_SCALE;
  var self2 = this;
  eventBus.on("canvas.init", function(e) {
    self2._init(config.enabled !== false);
  });
}
ZoomScroll.$inject = [
  "config.zoomScroll",
  "eventBus",
  "canvas"
];
ZoomScroll.prototype.scroll = function scroll(delta2) {
  this._canvas.scroll(delta2);
};
ZoomScroll.prototype.reset = function reset() {
  this._canvas.zoom("fit-viewport");
};
ZoomScroll.prototype.zoom = function zoom(delta2, position) {
  var stepSize = getStepSize(RANGE, NUM_STEPS * 2);
  this._totalDelta += delta2;
  if (Math.abs(this._totalDelta) > DELTA_THRESHOLD) {
    this._zoom(delta2, position, stepSize);
    this._totalDelta = 0;
  }
};
ZoomScroll.prototype._handleWheel = function handleWheel(event) {
  if (closest(event.target, ".djs-scrollable", true)) {
    return;
  }
  var element = this._container;
  event.preventDefault();
  var isZoom = event.ctrlKey;
  var isHorizontalScroll = event.shiftKey;
  var factor = -1 * this._scale, delta2;
  if (isZoom) {
    factor *= event.deltaMode === 0 ? 0.02 : 0.32;
  } else {
    factor *= event.deltaMode === 0 ? 1 : 16;
  }
  if (isZoom) {
    var elementRect = element.getBoundingClientRect();
    var offset2 = {
      x: event.clientX - elementRect.left,
      y: event.clientY - elementRect.top
    };
    delta2 = Math.sqrt(Math.pow(event.deltaY, 2) + Math.pow(event.deltaX, 2)) * sign(event.deltaY) * factor;
    this.zoom(delta2, offset2);
  } else {
    if (isHorizontalScroll) {
      delta2 = {
        dx: factor * event.deltaY,
        dy: 0
      };
    } else {
      delta2 = {
        dx: factor * event.deltaX,
        dy: factor * event.deltaY
      };
    }
    this.scroll(delta2);
  }
};
ZoomScroll.prototype.stepZoom = function stepZoom(delta2, position) {
  var stepSize = getStepSize(RANGE, NUM_STEPS);
  this._zoom(delta2, position, stepSize);
};
ZoomScroll.prototype._zoom = function(delta2, position, stepSize) {
  var canvas = this._canvas;
  var direction = delta2 > 0 ? 1 : -1;
  var currentLinearZoomLevel = log10(canvas.zoom());
  var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;
  newLinearZoomLevel += stepSize * direction;
  var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);
  canvas.zoom(cap(RANGE, newLogZoomLevel), position);
};
ZoomScroll.prototype.toggle = function toggle(newEnabled) {
  var element = this._container;
  var handleWheel2 = this._handleWheel;
  var oldEnabled = this._enabled;
  if (typeof newEnabled === "undefined") {
    newEnabled = !oldEnabled;
  }
  if (oldEnabled !== newEnabled) {
    componentEvent[newEnabled ? "bind" : "unbind"](element, "wheel", handleWheel2, false);
  }
  this._enabled = newEnabled;
  return newEnabled;
};
ZoomScroll.prototype._init = function(newEnabled) {
  this.toggle(newEnabled);
};
var ZoomScrollModule = {
  __init__: ["zoomScroll"],
  zoomScroll: ["type", ZoomScroll]
};
function NavigatedViewer(options) {
  Viewer.call(this, options);
}
inherits$6(NavigatedViewer, Viewer);
NavigatedViewer.prototype._navigationModules = [
  KeyboardMoveModule,
  MoveCanvasModule,
  ZoomScrollModule
];
NavigatedViewer.prototype._modules = [].concat(Viewer.prototype._modules, NavigatedViewer.prototype._navigationModules);
var hammer = { exports: {} };
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(module) {
  (function(window2, document2, exportName, undefined$1) {
    var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
    var TEST_ELEMENT = document2.createElement("div");
    var TYPE_FUNCTION = "function";
    var round2 = Math.round;
    var abs2 = Math.abs;
    var now2 = Date.now;
    function setTimeoutContext(fn, timeout, context) {
      return setTimeout(bindFn(fn, context), timeout);
    }
    function invokeArrayArg(arg, fn, context) {
      if (Array.isArray(arg)) {
        each2(arg, context[fn], context);
        return true;
      }
      return false;
    }
    function each2(obj, iterator, context) {
      var i;
      if (!obj) {
        return;
      }
      if (obj.forEach) {
        obj.forEach(iterator, context);
      } else if (obj.length !== undefined$1) {
        i = 0;
        while (i < obj.length) {
          iterator.call(context, obj[i], i, obj);
          i++;
        }
      } else {
        for (i in obj) {
          obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
      }
    }
    function deprecate(method, name2, message2) {
      var deprecationMessage = "DEPRECATED METHOD: " + name2 + "\n" + message2 + " AT \n";
      return function() {
        var e = new Error("get-stack-trace");
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
        var log2 = window2.console && (window2.console.warn || window2.console.log);
        if (log2) {
          log2.call(window2.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
      };
    }
    var assign2;
    if (typeof Object.assign !== "function") {
      assign2 = function assign3(target) {
        if (target === undefined$1 || target === null) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        var output = Object(target);
        for (var index2 = 1; index2 < arguments.length; index2++) {
          var source = arguments[index2];
          if (source !== undefined$1 && source !== null) {
            for (var nextKey in source) {
              if (source.hasOwnProperty(nextKey)) {
                output[nextKey] = source[nextKey];
              }
            }
          }
        }
        return output;
      };
    } else {
      assign2 = Object.assign;
    }
    var extend2 = deprecate(function extend3(dest, src, merge3) {
      var keys2 = Object.keys(src);
      var i = 0;
      while (i < keys2.length) {
        if (!merge3 || merge3 && dest[keys2[i]] === undefined$1) {
          dest[keys2[i]] = src[keys2[i]];
        }
        i++;
      }
      return dest;
    }, "extend", "Use `assign`.");
    var merge2 = deprecate(function merge3(dest, src) {
      return extend2(dest, src, true);
    }, "merge", "Use `assign`.");
    function inherit(child, base2, properties2) {
      var baseP = base2.prototype, childP;
      childP = child.prototype = Object.create(baseP);
      childP.constructor = child;
      childP._super = baseP;
      if (properties2) {
        assign2(childP, properties2);
      }
    }
    function bindFn(fn, context) {
      return function boundFn() {
        return fn.apply(context, arguments);
      };
    }
    function boolOrFn(val, args) {
      if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined$1 : undefined$1, args);
      }
      return val;
    }
    function ifUndefined(val1, val2) {
      return val1 === undefined$1 ? val2 : val1;
    }
    function addEventListeners(target, types2, handler) {
      each2(splitStr(types2), function(type) {
        target.addEventListener(type, handler, false);
      });
    }
    function removeEventListeners2(target, types2, handler) {
      each2(splitStr(types2), function(type) {
        target.removeEventListener(type, handler, false);
      });
    }
    function hasParent(node2, parent2) {
      while (node2) {
        if (node2 == parent2) {
          return true;
        }
        node2 = node2.parentNode;
      }
      return false;
    }
    function inStr(str, find2) {
      return str.indexOf(find2) > -1;
    }
    function splitStr(str) {
      return str.trim().split(/\s+/g);
    }
    function inArray(src, find2, findByKey) {
      if (src.indexOf && !findByKey) {
        return src.indexOf(find2);
      } else {
        var i = 0;
        while (i < src.length) {
          if (findByKey && src[i][findByKey] == find2 || !findByKey && src[i] === find2) {
            return i;
          }
          i++;
        }
        return -1;
      }
    }
    function toArray2(obj) {
      return Array.prototype.slice.call(obj, 0);
    }
    function uniqueArray(src, key, sort) {
      var results = [];
      var values2 = [];
      var i = 0;
      while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values2, val) < 0) {
          results.push(src[i]);
        }
        values2[i] = val;
        i++;
      }
      if (sort) {
        if (!key) {
          results = results.sort();
        } else {
          results = results.sort(function sortUniqueArray(a, b) {
            return a[key] > b[key];
          });
        }
      }
      return results;
    }
    function prefixed(obj, property2) {
      var prefix2, prop;
      var camelProp = property2[0].toUpperCase() + property2.slice(1);
      var i = 0;
      while (i < VENDOR_PREFIXES.length) {
        prefix2 = VENDOR_PREFIXES[i];
        prop = prefix2 ? prefix2 + camelProp : property2;
        if (prop in obj) {
          return prop;
        }
        i++;
      }
      return undefined$1;
    }
    var _uniqueId = 1;
    function uniqueId() {
      return _uniqueId++;
    }
    function getWindowForElement(element) {
      var doc = element.ownerDocument || element;
      return doc.defaultView || doc.parentWindow || window2;
    }
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH = "ontouchstart" in window2;
    var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined$1;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
    var INPUT_TYPE_TOUCH = "touch";
    var INPUT_TYPE_PEN = "pen";
    var INPUT_TYPE_MOUSE = "mouse";
    var INPUT_TYPE_KINECT = "kinect";
    var COMPUTE_INTERVAL = 25;
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;
    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;
    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    var PROPS_XY = ["x", "y"];
    var PROPS_CLIENT_XY = ["clientX", "clientY"];
    function Input(manager, callback) {
      var self2 = this;
      this.manager = manager;
      this.callback = callback;
      this.element = manager.element;
      this.target = manager.options.inputTarget;
      this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
          self2.handler(ev);
        }
      };
      this.init();
    }
    Input.prototype = {
      handler: function() {
      },
      init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      },
      destroy: function() {
        this.evEl && removeEventListeners2(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners2(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners2(getWindowForElement(this.element), this.evWin, this.domHandler);
      }
    };
    function createInputInstance(manager) {
      var Type;
      var inputClass = manager.options.inputClass;
      if (inputClass) {
        Type = inputClass;
      } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
      } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
      } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
      } else {
        Type = TouchMouseInput;
      }
      return new Type(manager, inputHandler);
    }
    function inputHandler(manager, eventType, input) {
      var pointersLen = input.pointers.length;
      var changedPointersLen = input.changedPointers.length;
      var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
      var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
      input.isFirst = !!isFirst;
      input.isFinal = !!isFinal;
      if (isFirst) {
        manager.session = {};
      }
      input.eventType = eventType;
      computeInputData(manager, input);
      manager.emit("hammer.input", input);
      manager.recognize(input);
      manager.session.prevInput = input;
    }
    function computeInputData(manager, input) {
      var session = manager.session;
      var pointers = input.pointers;
      var pointersLength = pointers.length;
      if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
      }
      if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
      } else if (pointersLength === 1) {
        session.firstMultiple = false;
      }
      var firstInput = session.firstInput;
      var firstMultiple = session.firstMultiple;
      var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
      var center2 = input.center = getCenter(pointers);
      input.timeStamp = now2();
      input.deltaTime = input.timeStamp - firstInput.timeStamp;
      input.angle = getAngle2(offsetCenter, center2);
      input.distance = getDistance2(offsetCenter, center2);
      computeDeltaXY(session, input);
      input.offsetDirection = getDirection2(input.deltaX, input.deltaY);
      var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
      input.overallVelocityX = overallVelocity.x;
      input.overallVelocityY = overallVelocity.y;
      input.overallVelocity = abs2(overallVelocity.x) > abs2(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
      input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
      input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
      input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
      computeIntervalInputData(session, input);
      var target = manager.element;
      if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
      }
      input.target = target;
    }
    function computeDeltaXY(session, input) {
      var center2 = input.center;
      var offset2 = session.offsetDelta || {};
      var prevDelta = session.prevDelta || {};
      var prevInput = session.prevInput || {};
      if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
          x: prevInput.deltaX || 0,
          y: prevInput.deltaY || 0
        };
        offset2 = session.offsetDelta = {
          x: center2.x,
          y: center2.y
        };
      }
      input.deltaX = prevDelta.x + (center2.x - offset2.x);
      input.deltaY = prevDelta.y + (center2.y - offset2.y);
    }
    function computeIntervalInputData(session, input) {
      var last2 = session.lastInterval || input, deltaTime = input.timeStamp - last2.timeStamp, velocity, velocityX, velocityY, direction;
      if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last2.velocity === undefined$1)) {
        var deltaX = input.deltaX - last2.deltaX;
        var deltaY = input.deltaY - last2.deltaY;
        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = abs2(v.x) > abs2(v.y) ? v.x : v.y;
        direction = getDirection2(deltaX, deltaY);
        session.lastInterval = input;
      } else {
        velocity = last2.velocity;
        velocityX = last2.velocityX;
        velocityY = last2.velocityY;
        direction = last2.direction;
      }
      input.velocity = velocity;
      input.velocityX = velocityX;
      input.velocityY = velocityY;
      input.direction = direction;
    }
    function simpleCloneInputData(input) {
      var pointers = [];
      var i = 0;
      while (i < input.pointers.length) {
        pointers[i] = {
          clientX: round2(input.pointers[i].clientX),
          clientY: round2(input.pointers[i].clientY)
        };
        i++;
      }
      return {
        timeStamp: now2(),
        pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
      };
    }
    function getCenter(pointers) {
      var pointersLength = pointers.length;
      if (pointersLength === 1) {
        return {
          x: round2(pointers[0].clientX),
          y: round2(pointers[0].clientY)
        };
      }
      var x = 0, y = 0, i = 0;
      while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
      }
      return {
        x: round2(x / pointersLength),
        y: round2(y / pointersLength)
      };
    }
    function getVelocity(deltaTime, x, y) {
      return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
      };
    }
    function getDirection2(x, y) {
      if (x === y) {
        return DIRECTION_NONE;
      }
      if (abs2(x) >= abs2(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    function getDistance2(p1, p2, props) {
      if (!props) {
        props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
      return Math.sqrt(x * x + y * y);
    }
    function getAngle2(p1, p2, props) {
      if (!props) {
        props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
      return Math.atan2(y, x) * 180 / Math.PI;
    }
    function getRotation(start, end) {
      return getAngle2(end[1], end[0], PROPS_CLIENT_XY) + getAngle2(start[1], start[0], PROPS_CLIENT_XY);
    }
    function getScale(start, end) {
      return getDistance2(end[0], end[1], PROPS_CLIENT_XY) / getDistance2(start[0], start[1], PROPS_CLIENT_XY);
    }
    var MOUSE_INPUT_MAP = {
      mousedown: INPUT_START,
      mousemove: INPUT_MOVE,
      mouseup: INPUT_END
    };
    var MOUSE_ELEMENT_EVENTS = "mousedown";
    var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
    function MouseInput() {
      this.evEl = MOUSE_ELEMENT_EVENTS;
      this.evWin = MOUSE_WINDOW_EVENTS;
      this.pressed = false;
      Input.apply(this, arguments);
    }
    inherit(MouseInput, Input, {
      handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];
        if (eventType & INPUT_START && ev.button === 0) {
          this.pressed = true;
        }
        if (eventType & INPUT_MOVE && ev.which !== 1) {
          eventType = INPUT_END;
        }
        if (!this.pressed) {
          return;
        }
        if (eventType & INPUT_END) {
          this.pressed = false;
        }
        this.callback(this.manager, eventType, {
          pointers: [ev],
          changedPointers: [ev],
          pointerType: INPUT_TYPE_MOUSE,
          srcEvent: ev
        });
      }
    });
    var POINTER_INPUT_MAP = {
      pointerdown: INPUT_START,
      pointermove: INPUT_MOVE,
      pointerup: INPUT_END,
      pointercancel: INPUT_CANCEL,
      pointerout: INPUT_CANCEL
    };
    var IE10_POINTER_TYPE_ENUM = {
      2: INPUT_TYPE_TOUCH,
      3: INPUT_TYPE_PEN,
      4: INPUT_TYPE_MOUSE,
      5: INPUT_TYPE_KINECT
    };
    var POINTER_ELEMENT_EVENTS = "pointerdown";
    var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
    if (window2.MSPointerEvent && !window2.PointerEvent) {
      POINTER_ELEMENT_EVENTS = "MSPointerDown";
      POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
    }
    function PointerEventInput() {
      this.evEl = POINTER_ELEMENT_EVENTS;
      this.evWin = POINTER_WINDOW_EVENTS;
      Input.apply(this, arguments);
      this.store = this.manager.session.pointerEvents = [];
    }
    inherit(PointerEventInput, Input, {
      handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;
        var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
        var isTouch = pointerType == INPUT_TYPE_TOUCH;
        var storeIndex = inArray(store, ev.pointerId, "pointerId");
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
          if (storeIndex < 0) {
            store.push(ev);
            storeIndex = store.length - 1;
          }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          removePointer = true;
        }
        if (storeIndex < 0) {
          return;
        }
        store[storeIndex] = ev;
        this.callback(this.manager, eventType, {
          pointers: store,
          changedPointers: [ev],
          pointerType,
          srcEvent: ev
        });
        if (removePointer) {
          store.splice(storeIndex, 1);
        }
      }
    });
    var SINGLE_TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
    };
    var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
    var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
    function SingleTouchInput() {
      this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
      this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
      this.started = false;
      Input.apply(this, arguments);
    }
    inherit(SingleTouchInput, Input, {
      handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
        if (type === INPUT_START) {
          this.started = true;
        }
        if (!this.started) {
          return;
        }
        var touches = normalizeSingleTouches.call(this, ev, type);
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
          this.started = false;
        }
        this.callback(this.manager, type, {
          pointers: touches[0],
          changedPointers: touches[1],
          pointerType: INPUT_TYPE_TOUCH,
          srcEvent: ev
        });
      }
    });
    function normalizeSingleTouches(ev, type) {
      var all2 = toArray2(ev.touches);
      var changed = toArray2(ev.changedTouches);
      if (type & (INPUT_END | INPUT_CANCEL)) {
        all2 = uniqueArray(all2.concat(changed), "identifier", true);
      }
      return [all2, changed];
    }
    var TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
    function TouchInput() {
      this.evTarget = TOUCH_TARGET_EVENTS;
      this.targetIds = {};
      Input.apply(this, arguments);
    }
    inherit(TouchInput, Input, {
      handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
          return;
        }
        this.callback(this.manager, type, {
          pointers: touches[0],
          changedPointers: touches[1],
          pointerType: INPUT_TYPE_TOUCH,
          srcEvent: ev
        });
      }
    });
    function getTouches(ev, type) {
      var allTouches = toArray2(ev.touches);
      var targetIds = this.targetIds;
      if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
      }
      var i, targetTouches, changedTouches = toArray2(ev.changedTouches), changedTargetTouches = [], target = this.target;
      targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
      });
      if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
          targetIds[targetTouches[i].identifier] = true;
          i++;
        }
      }
      i = 0;
      while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
          changedTargetTouches.push(changedTouches[i]);
        }
        if (type & (INPUT_END | INPUT_CANCEL)) {
          delete targetIds[changedTouches[i].identifier];
        }
        i++;
      }
      if (!changedTargetTouches.length) {
        return;
      }
      return [
        uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
        changedTargetTouches
      ];
    }
    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DISTANCE = 25;
    function TouchMouseInput() {
      Input.apply(this, arguments);
      var handler = bindFn(this.handler, this);
      this.touch = new TouchInput(this.manager, handler);
      this.mouse = new MouseInput(this.manager, handler);
      this.primaryTouch = null;
      this.lastTouches = [];
    }
    inherit(TouchMouseInput, Input, {
      handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
          return;
        }
        if (isTouch) {
          recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
          return;
        }
        this.callback(manager, inputEvent, inputData);
      },
      destroy: function destroy2() {
        this.touch.destroy();
        this.mouse.destroy();
      }
    });
    function recordTouches(eventType, eventData) {
      if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
      }
    }
    function setLastTouch(eventData) {
      var touch = eventData.changedPointers[0];
      if (touch.identifier === this.primaryTouch) {
        var lastTouch = { x: touch.clientX, y: touch.clientY };
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
          var i = lts.indexOf(lastTouch);
          if (i > -1) {
            lts.splice(i, 1);
          }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
      }
    }
    function isSyntheticEvent(eventData) {
      var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
      for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
          return true;
        }
      }
      return false;
    }
    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined$1;
    var TOUCH_ACTION_COMPUTE = "compute";
    var TOUCH_ACTION_AUTO = "auto";
    var TOUCH_ACTION_MANIPULATION = "manipulation";
    var TOUCH_ACTION_NONE = "none";
    var TOUCH_ACTION_PAN_X = "pan-x";
    var TOUCH_ACTION_PAN_Y = "pan-y";
    var TOUCH_ACTION_MAP = getTouchActionProps();
    function TouchAction(manager, value) {
      this.manager = manager;
      this.set(value);
    }
    TouchAction.prototype = {
      set: function(value) {
        if (value == TOUCH_ACTION_COMPUTE) {
          value = this.compute();
        }
        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
          this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
      },
      update: function() {
        this.set(this.manager.options.touchAction);
      },
      compute: function() {
        var actions = [];
        each2(this.manager.recognizers, function(recognizer) {
          if (boolOrFn(recognizer.options.enable, [recognizer])) {
            actions = actions.concat(recognizer.getTouchAction());
          }
        });
        return cleanTouchActions(actions.join(" "));
      },
      preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;
        if (this.manager.session.prevented) {
          srcEvent.preventDefault();
          return;
        }
        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
        if (hasNone) {
          var isTapPointer = input.pointers.length === 1;
          var isTapMovement = input.distance < 2;
          var isTapTouchTime = input.deltaTime < 250;
          if (isTapPointer && isTapMovement && isTapTouchTime) {
            return;
          }
        }
        if (hasPanX && hasPanY) {
          return;
        }
        if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
          return this.preventSrc(srcEvent);
        }
      },
      preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
      }
    };
    function cleanTouchActions(actions) {
      if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
      }
      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
      if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
      }
      if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
      }
      if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
      }
      return TOUCH_ACTION_AUTO;
    }
    function getTouchActionProps() {
      if (!NATIVE_TOUCH_ACTION) {
        return false;
      }
      var touchMap = {};
      var cssSupports = window2.CSS && window2.CSS.supports;
      ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
        touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
      });
      return touchMap;
    }
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;
    function Recognizer(options) {
      this.options = assign2({}, this.defaults, options || {});
      this.id = uniqueId();
      this.manager = null;
      this.options.enable = ifUndefined(this.options.enable, true);
      this.state = STATE_POSSIBLE;
      this.simultaneous = {};
      this.requireFail = [];
    }
    Recognizer.prototype = {
      defaults: {},
      set: function(options) {
        assign2(this.options, options);
        this.manager && this.manager.touchAction.update();
        return this;
      },
      recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
          return this;
        }
        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
          simultaneous[otherRecognizer.id] = otherRecognizer;
          otherRecognizer.recognizeWith(this);
        }
        return this;
      },
      dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
          return this;
        }
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
      },
      requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
          return this;
        }
        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
          requireFail.push(otherRecognizer);
          otherRecognizer.requireFailure(this);
        }
        return this;
      },
      dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
          return this;
        }
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index2 = inArray(this.requireFail, otherRecognizer);
        if (index2 > -1) {
          this.requireFail.splice(index2, 1);
        }
        return this;
      },
      hasRequireFailures: function() {
        return this.requireFail.length > 0;
      },
      canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
      },
      emit: function(input) {
        var self2 = this;
        var state = this.state;
        function emit(event) {
          self2.manager.emit(event, input);
        }
        if (state < STATE_ENDED) {
          emit(self2.options.event + stateStr(state));
        }
        emit(self2.options.event);
        if (input.additionalEvent) {
          emit(input.additionalEvent);
        }
        if (state >= STATE_ENDED) {
          emit(self2.options.event + stateStr(state));
        }
      },
      tryEmit: function(input) {
        if (this.canEmit()) {
          return this.emit(input);
        }
        this.state = STATE_FAILED;
      },
      canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
          if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
            return false;
          }
          i++;
        }
        return true;
      },
      recognize: function(inputData) {
        var inputDataClone = assign2({}, inputData);
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
          this.reset();
          this.state = STATE_FAILED;
          return;
        }
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
          this.state = STATE_POSSIBLE;
        }
        this.state = this.process(inputDataClone);
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
          this.tryEmit(inputDataClone);
        }
      },
      process: function(inputData) {
      },
      getTouchAction: function() {
      },
      reset: function() {
      }
    };
    function stateStr(state) {
      if (state & STATE_CANCELLED) {
        return "cancel";
      } else if (state & STATE_ENDED) {
        return "end";
      } else if (state & STATE_CHANGED) {
        return "move";
      } else if (state & STATE_BEGAN) {
        return "start";
      }
      return "";
    }
    function directionStr(direction) {
      if (direction == DIRECTION_DOWN) {
        return "down";
      } else if (direction == DIRECTION_UP) {
        return "up";
      } else if (direction == DIRECTION_LEFT) {
        return "left";
      } else if (direction == DIRECTION_RIGHT) {
        return "right";
      }
      return "";
    }
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
      var manager = recognizer.manager;
      if (manager) {
        return manager.get(otherRecognizer);
      }
      return otherRecognizer;
    }
    function AttrRecognizer() {
      Recognizer.apply(this, arguments);
    }
    inherit(AttrRecognizer, Recognizer, {
      defaults: {
        pointers: 1
      },
      attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
      },
      process: function(input) {
        var state = this.state;
        var eventType = input.eventType;
        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
          return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
          if (eventType & INPUT_END) {
            return state | STATE_ENDED;
          } else if (!(state & STATE_BEGAN)) {
            return STATE_BEGAN;
          }
          return state | STATE_CHANGED;
        }
        return STATE_FAILED;
      }
    });
    function PanRecognizer() {
      AttrRecognizer.apply(this, arguments);
      this.pX = null;
      this.pY = null;
    }
    inherit(PanRecognizer, AttrRecognizer, {
      defaults: {
        event: "pan",
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
      },
      getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
          actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
          actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
      },
      directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;
        if (!(direction & options.direction)) {
          if (options.direction & DIRECTION_HORIZONTAL) {
            direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
            hasMoved = x != this.pX;
            distance = Math.abs(input.deltaX);
          } else {
            direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
            hasMoved = y != this.pY;
            distance = Math.abs(input.deltaY);
          }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
      },
      attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
      },
      emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;
        var direction = directionStr(input.direction);
        if (direction) {
          input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
      }
    });
    function PinchRecognizer() {
      AttrRecognizer.apply(this, arguments);
    }
    inherit(PinchRecognizer, AttrRecognizer, {
      defaults: {
        event: "pinch",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
      },
      attrTest: function(input) {
        return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
      },
      emit: function(input) {
        if (input.scale !== 1) {
          var inOut = input.scale < 1 ? "in" : "out";
          input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
      }
    });
    function PressRecognizer() {
      Recognizer.apply(this, arguments);
      this._timer = null;
      this._input = null;
    }
    inherit(PressRecognizer, Recognizer, {
      defaults: {
        event: "press",
        pointers: 1,
        time: 251,
        threshold: 9
      },
      getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
      },
      process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;
        this._input = input;
        if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
          this.reset();
        } else if (input.eventType & INPUT_START) {
          this.reset();
          this._timer = setTimeoutContext(function() {
            this.state = STATE_RECOGNIZED;
            this.tryEmit();
          }, options.time, this);
        } else if (input.eventType & INPUT_END) {
          return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
          return;
        }
        if (input && input.eventType & INPUT_END) {
          this.manager.emit(this.options.event + "up", input);
        } else {
          this._input.timeStamp = now2();
          this.manager.emit(this.options.event, this._input);
        }
      }
    });
    function RotateRecognizer() {
      AttrRecognizer.apply(this, arguments);
    }
    inherit(RotateRecognizer, AttrRecognizer, {
      defaults: {
        event: "rotate",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
      },
      attrTest: function(input) {
        return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
      }
    });
    function SwipeRecognizer() {
      AttrRecognizer.apply(this, arguments);
    }
    inherit(SwipeRecognizer, AttrRecognizer, {
      defaults: {
        event: "swipe",
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
      },
      getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
      },
      attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;
        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
          velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
          velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
          velocity = input.overallVelocityY;
        }
        return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs2(velocity) > this.options.velocity && input.eventType & INPUT_END;
      },
      emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
          this.manager.emit(this.options.event + direction, input);
        }
        this.manager.emit(this.options.event, input);
      }
    });
    function TapRecognizer() {
      Recognizer.apply(this, arguments);
      this.pTime = false;
      this.pCenter = false;
      this._timer = null;
      this._input = null;
      this.count = 0;
    }
    inherit(TapRecognizer, Recognizer, {
      defaults: {
        event: "tap",
        pointers: 1,
        taps: 1,
        interval: 300,
        time: 250,
        threshold: 9,
        posThreshold: 10
      },
      getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
      },
      process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;
        this.reset();
        if (input.eventType & INPUT_START && this.count === 0) {
          return this.failTimeout();
        }
        if (validMovement && validTouchTime && validPointers) {
          if (input.eventType != INPUT_END) {
            return this.failTimeout();
          }
          var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
          var validMultiTap = !this.pCenter || getDistance2(this.pCenter, input.center) < options.posThreshold;
          this.pTime = input.timeStamp;
          this.pCenter = input.center;
          if (!validMultiTap || !validInterval) {
            this.count = 1;
          } else {
            this.count += 1;
          }
          this._input = input;
          var tapCount = this.count % options.taps;
          if (tapCount === 0) {
            if (!this.hasRequireFailures()) {
              return STATE_RECOGNIZED;
            } else {
              this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
              }, options.interval, this);
              return STATE_BEGAN;
            }
          }
        }
        return STATE_FAILED;
      },
      failTimeout: function() {
        this._timer = setTimeoutContext(function() {
          this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function() {
        if (this.state == STATE_RECOGNIZED) {
          this._input.tapCount = this.count;
          this.manager.emit(this.options.event, this._input);
        }
      }
    });
    function Hammer2(element, options) {
      options = options || {};
      options.recognizers = ifUndefined(options.recognizers, Hammer2.defaults.preset);
      return new Manager(element, options);
    }
    Hammer2.VERSION = "2.0.7";
    Hammer2.defaults = {
      domEvents: false,
      touchAction: TOUCH_ACTION_COMPUTE,
      enable: true,
      inputTarget: null,
      inputClass: null,
      preset: [
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ["rotate"]],
        [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
        [TapRecognizer],
        [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
        [PressRecognizer]
      ],
      cssProps: {
        userSelect: "none",
        touchSelect: "none",
        touchCallout: "none",
        contentZooming: "none",
        userDrag: "none",
        tapHighlightColor: "rgba(0,0,0,0)"
      }
    };
    var STOP = 1;
    var FORCED_STOP = 2;
    function Manager(element, options) {
      this.options = assign2({}, Hammer2.defaults, options || {});
      this.options.inputTarget = this.options.inputTarget || element;
      this.handlers = {};
      this.session = {};
      this.recognizers = [];
      this.oldCssProps = {};
      this.element = element;
      this.input = createInputInstance(this);
      this.touchAction = new TouchAction(this, this.options.touchAction);
      toggleCssProps(this, true);
      each2(this.options.recognizers, function(item) {
        var recognizer = this.add(new item[0](item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
      }, this);
    }
    Manager.prototype = {
      set: function(options) {
        assign2(this.options, options);
        if (options.touchAction) {
          this.touchAction.update();
        }
        if (options.inputTarget) {
          this.input.destroy();
          this.input.target = options.inputTarget;
          this.input.init();
        }
        return this;
      },
      stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
      },
      recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
          return;
        }
        this.touchAction.preventDefaults(inputData);
        var recognizer;
        var recognizers = this.recognizers;
        var curRecognizer = session.curRecognizer;
        if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
          curRecognizer = session.curRecognizer = null;
        }
        var i = 0;
        while (i < recognizers.length) {
          recognizer = recognizers[i];
          if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
            recognizer.recognize(inputData);
          } else {
            recognizer.reset();
          }
          if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
            curRecognizer = session.curRecognizer = recognizer;
          }
          i++;
        }
      },
      get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
          return recognizer;
        }
        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
          if (recognizers[i].options.event == recognizer) {
            return recognizers[i];
          }
        }
        return null;
      },
      add: function(recognizer) {
        if (invokeArrayArg(recognizer, "add", this)) {
          return this;
        }
        var existing = this.get(recognizer.options.event);
        if (existing) {
          this.remove(existing);
        }
        this.recognizers.push(recognizer);
        recognizer.manager = this;
        this.touchAction.update();
        return recognizer;
      },
      remove: function(recognizer) {
        if (invokeArrayArg(recognizer, "remove", this)) {
          return this;
        }
        recognizer = this.get(recognizer);
        if (recognizer) {
          var recognizers = this.recognizers;
          var index2 = inArray(recognizers, recognizer);
          if (index2 !== -1) {
            recognizers.splice(index2, 1);
            this.touchAction.update();
          }
        }
        return this;
      },
      on: function(events, handler) {
        if (events === undefined$1) {
          return;
        }
        if (handler === undefined$1) {
          return;
        }
        var handlers = this.handlers;
        each2(splitStr(events), function(event) {
          handlers[event] = handlers[event] || [];
          handlers[event].push(handler);
        });
        return this;
      },
      off: function(events, handler) {
        if (events === undefined$1) {
          return;
        }
        var handlers = this.handlers;
        each2(splitStr(events), function(event) {
          if (!handler) {
            delete handlers[event];
          } else {
            handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
          }
        });
        return this;
      },
      emit: function(event, data) {
        if (this.options.domEvents) {
          triggerDomEvent(event, data);
        }
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
          return;
        }
        data.type = event;
        data.preventDefault = function() {
          data.srcEvent.preventDefault();
        };
        var i = 0;
        while (i < handlers.length) {
          handlers[i](data);
          i++;
        }
      },
      destroy: function() {
        this.element && toggleCssProps(this, false);
        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
      }
    };
    function toggleCssProps(manager, add2) {
      var element = manager.element;
      if (!element.style) {
        return;
      }
      var prop;
      each2(manager.options.cssProps, function(value, name2) {
        prop = prefixed(element.style, name2);
        if (add2) {
          manager.oldCssProps[prop] = element.style[prop];
          element.style[prop] = value;
        } else {
          element.style[prop] = manager.oldCssProps[prop] || "";
        }
      });
      if (!add2) {
        manager.oldCssProps = {};
      }
    }
    function triggerDomEvent(event, data) {
      var gestureEvent = document2.createEvent("Event");
      gestureEvent.initEvent(event, true, true);
      gestureEvent.gesture = data;
      data.target.dispatchEvent(gestureEvent);
    }
    assign2(Hammer2, {
      INPUT_START,
      INPUT_MOVE,
      INPUT_END,
      INPUT_CANCEL,
      STATE_POSSIBLE,
      STATE_BEGAN,
      STATE_CHANGED,
      STATE_ENDED,
      STATE_RECOGNIZED,
      STATE_CANCELLED,
      STATE_FAILED,
      DIRECTION_NONE,
      DIRECTION_LEFT,
      DIRECTION_RIGHT,
      DIRECTION_UP,
      DIRECTION_DOWN,
      DIRECTION_HORIZONTAL,
      DIRECTION_VERTICAL,
      DIRECTION_ALL,
      Manager,
      Input,
      TouchAction,
      TouchInput,
      MouseInput,
      PointerEventInput,
      TouchMouseInput,
      SingleTouchInput,
      Recognizer,
      AttrRecognizer,
      Tap: TapRecognizer,
      Pan: PanRecognizer,
      Swipe: SwipeRecognizer,
      Pinch: PinchRecognizer,
      Rotate: RotateRecognizer,
      Press: PressRecognizer,
      on: addEventListeners,
      off: removeEventListeners2,
      each: each2,
      merge: merge2,
      extend: extend2,
      assign: assign2,
      inherit,
      bindFn,
      prefixed
    });
    var freeGlobal2 = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
    freeGlobal2.Hammer = Hammer2;
    if (typeof undefined$1 === "function" && undefined$1.amd) {
      undefined$1(function() {
        return Hammer2;
      });
    } else if (module.exports) {
      module.exports = Hammer2;
    } else {
      window2[exportName] = Hammer2;
    }
  })(window, document, "Hammer");
})(hammer);
var Hammer = hammer.exports;
var MIN_ZOOM = 0.2, MAX_ZOOM = 4;
var mouseEvents = [
  "mousedown",
  "mouseup",
  "mouseover",
  "mouseout",
  "click",
  "dblclick"
];
function get$4(service, injector) {
  return injector.get(service, false);
}
function stopEvent(event) {
  event.preventDefault();
  if (typeof event.stopPropagation === "function") {
    event.stopPropagation();
  } else if (event.srcEvent && typeof event.srcEvent.stopPropagation === "function") {
    event.srcEvent.stopPropagation();
  }
  if (typeof event.stopImmediatePropagation === "function") {
    event.stopImmediatePropagation();
  }
}
function createTouchRecognizer(node2) {
  function stopMouse(event) {
    forEach$q(mouseEvents, function(e) {
      componentEvent.bind(node2, e, stopEvent, true);
    });
  }
  function allowMouse(event) {
    setTimeout(function() {
      forEach$q(mouseEvents, function(e) {
        componentEvent.unbind(node2, e, stopEvent, true);
      });
    }, 500);
  }
  componentEvent.bind(node2, "touchstart", stopMouse, true);
  componentEvent.bind(node2, "touchend", allowMouse, true);
  componentEvent.bind(node2, "touchcancel", allowMouse, true);
  var recognizer = new Hammer.Manager(node2, {
    inputClass: Hammer.TouchInput,
    recognizers: [],
    domEvents: true
  });
  var tap = new Hammer.Tap();
  var pan = new Hammer.Pan({ threshold: 10 });
  var press = new Hammer.Press();
  var pinch = new Hammer.Pinch();
  var doubleTap = new Hammer.Tap({ event: "doubletap", taps: 2 });
  pinch.requireFailure(pan);
  pinch.requireFailure(press);
  recognizer.add([pan, press, pinch, doubleTap, tap]);
  recognizer.reset = function(force) {
    var recognizers = this.recognizers, session = this.session;
    if (session.stopped) {
      return;
    }
    recognizer.stop(force);
    setTimeout(function() {
      var i, r;
      for (i = 0; r = recognizers[i]; i++) {
        r.reset();
        r.state = 8;
      }
      session.curRecognizer = null;
    }, 0);
  };
  recognizer.on("hammer.input", function(event) {
    if (event.srcEvent.defaultPrevented) {
      recognizer.reset(true);
    }
  });
  return recognizer;
}
function TouchInteractionEvents(injector, canvas, eventBus, elementRegistry, interactionEvents) {
  var dragging = get$4("dragging", injector), move = get$4("move", injector), contextPad = get$4("contextPad", injector), palette = get$4("palette", injector);
  var recognizer;
  function handler(type, buttonType) {
    return function(event) {
      var gfx = getGfx2(event.target), element = gfx && elementRegistry.get(gfx);
      if (buttonType) {
        event.srcEvent.button = buttonType;
      }
      return interactionEvents.fire(type, event, element);
    };
  }
  function getGfx2(target) {
    var node2 = closest(target, "svg, .djs-element", true);
    return node2;
  }
  function initEvents(svg) {
    recognizer = createTouchRecognizer(svg);
    function startGrabCanvas(event) {
      var lx = 0, ly = 0;
      function update2(e) {
        var dx = e.deltaX - lx, dy = e.deltaY - ly;
        canvas.scroll({ dx, dy });
        lx = e.deltaX;
        ly = e.deltaY;
      }
      function end(e) {
        recognizer.off("panmove", update2);
        recognizer.off("panend", end);
        recognizer.off("pancancel", end);
      }
      recognizer.on("panmove", update2);
      recognizer.on("panend", end);
      recognizer.on("pancancel", end);
    }
    function startGrab(event) {
      var gfx = getGfx2(event.target), element = gfx && elementRegistry.get(gfx);
      if (move && canvas.getRootElement() !== element) {
        return move.start(event, element, true);
      } else {
        startGrabCanvas();
      }
    }
    function startZoom(e) {
      var zoom2 = canvas.zoom(), mid2 = e.center;
      function update2(e2) {
        var ratio = 1 - (1 - e2.scale) / 1.5, newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, ratio * zoom2));
        canvas.zoom(newZoom, mid2);
        stopEvent(e2);
      }
      function end(e2) {
        recognizer.off("pinchmove", update2);
        recognizer.off("pinchend", end);
        recognizer.off("pinchcancel", end);
        recognizer.reset(true);
      }
      recognizer.on("pinchmove", update2);
      recognizer.on("pinchend", end);
      recognizer.on("pinchcancel", end);
    }
    recognizer.on("tap", handler("element.click"));
    recognizer.on("doubletap", handler("element.dblclick", 1));
    recognizer.on("panstart", startGrab);
    recognizer.on("press", startGrab);
    recognizer.on("pinchstart", startZoom);
  }
  if (dragging) {
    eventBus.on("drag.move", function(event) {
      var originalEvent = event.originalEvent;
      if (!originalEvent || originalEvent instanceof MouseEvent) {
        return;
      }
      var position = toPoint(originalEvent);
      var node2 = document.elementFromPoint(position.x, position.y), gfx = getGfx2(node2), element = gfx && elementRegistry.get(gfx);
      if (element !== event.hover) {
        if (event.hover) {
          dragging.out(event);
        }
        if (element) {
          dragging.hover({ element, gfx });
          event.hover = element;
          event.hoverGfx = gfx;
        }
      }
    });
  }
  if (contextPad) {
    eventBus.on("contextPad.create", function(event) {
      var node2 = event.pad.html;
      var padRecognizer = createTouchRecognizer(node2);
      padRecognizer.on("panstart", function(event2) {
        contextPad.trigger("dragstart", event2, true);
      });
      padRecognizer.on("press", function(event2) {
        contextPad.trigger("dragstart", event2, true);
      });
      padRecognizer.on("tap", function(event2) {
        contextPad.trigger("click", event2);
      });
    });
  }
  if (palette) {
    eventBus.on("palette.create", function(event) {
      var node2 = event.container;
      var padRecognizer = createTouchRecognizer(node2);
      padRecognizer.on("panstart", function(event2) {
        palette.trigger("dragstart", event2, true);
      });
      padRecognizer.on("press", function(event2) {
        palette.trigger("dragstart", event2, true);
      });
      padRecognizer.on("tap", function(event2) {
        palette.trigger("click", event2);
      });
    });
  }
  eventBus.on("canvas.init", function(event) {
    initEvents(event.svg);
  });
}
TouchInteractionEvents.$inject = [
  "injector",
  "canvas",
  "eventBus",
  "elementRegistry",
  "interactionEvents",
  "touchFix"
];
function TouchFix(canvas, eventBus) {
  var self2 = this;
  eventBus.on("canvas.init", function(e) {
    self2.addBBoxMarker(e.svg);
  });
}
TouchFix.$inject = ["canvas", "eventBus"];
TouchFix.prototype.addBBoxMarker = function(svg) {
  var markerStyle = {
    fill: "none",
    class: "outer-bound-marker"
  };
  var rect1 = create$2("rect");
  attr(rect1, {
    x: -1e4,
    y: 1e4,
    width: 10,
    height: 10
  });
  attr(rect1, markerStyle);
  append$3(svg, rect1);
  var rect2 = create$2("rect");
  attr(rect2, {
    x: 1e4,
    y: 1e4,
    width: 10,
    height: 10
  });
  attr(rect2, markerStyle);
  append$3(svg, rect2);
};
var TouchModule$1 = {
  __depends__: [InteractionEventsModule$2],
  __init__: ["touchInteractionEvents"],
  touchInteractionEvents: ["type", TouchInteractionEvents],
  touchFix: ["type", TouchFix]
};
var TouchModule = {
  __depends__: [
    TouchModule$1
  ]
};
function last$2(arr) {
  return arr && arr[arr.length - 1];
}
function sortTopOrMiddle(element) {
  return element.y;
}
function sortLeftOrCenter(element) {
  return element.x;
}
var ALIGNMENT_SORTING = {
  left: sortLeftOrCenter,
  center: sortLeftOrCenter,
  right: function(element) {
    return element.x + element.width;
  },
  top: sortTopOrMiddle,
  middle: sortTopOrMiddle,
  bottom: function(element) {
    return element.y + element.height;
  }
};
function AlignElements$1(modeling) {
  this._modeling = modeling;
}
AlignElements$1.$inject = ["modeling"];
AlignElements$1.prototype._getOrientationDetails = function(type) {
  var vertical = ["top", "bottom", "middle"], axis = "x", dimension = "width";
  if (vertical.indexOf(type) !== -1) {
    axis = "y";
    dimension = "height";
  }
  return {
    axis,
    dimension
  };
};
AlignElements$1.prototype._isType = function(type, types2) {
  return types2.indexOf(type) !== -1;
};
AlignElements$1.prototype._alignmentPosition = function(type, sortedElements) {
  var orientation = this._getOrientationDetails(type), axis = orientation.axis, dimension = orientation.dimension, alignment = {}, centers = {}, hasSharedCenters = false, centeredElements, firstElement, lastElement;
  function getMiddleOrTop(first, last2) {
    return Math.round((first[axis] + last2[axis] + last2[dimension]) / 2);
  }
  if (this._isType(type, ["left", "top"])) {
    alignment[type] = sortedElements[0][axis];
  } else if (this._isType(type, ["right", "bottom"])) {
    lastElement = last$2(sortedElements);
    alignment[type] = lastElement[axis] + lastElement[dimension];
  } else if (this._isType(type, ["center", "middle"])) {
    forEach$q(sortedElements, function(element) {
      var center2 = element[axis] + Math.round(element[dimension] / 2);
      if (centers[center2]) {
        centers[center2].elements.push(element);
      } else {
        centers[center2] = {
          elements: [element],
          center: center2
        };
      }
    });
    centeredElements = sortBy$2(centers, function(center2) {
      if (center2.elements.length > 1) {
        hasSharedCenters = true;
      }
      return center2.elements.length;
    });
    if (hasSharedCenters) {
      alignment[type] = last$2(centeredElements).center;
      return alignment;
    }
    firstElement = sortedElements[0];
    sortedElements = sortBy$2(sortedElements, function(element) {
      return element[axis] + element[dimension];
    });
    lastElement = last$2(sortedElements);
    alignment[type] = getMiddleOrTop(firstElement, lastElement);
  }
  return alignment;
};
AlignElements$1.prototype.trigger = function(elements, type) {
  var modeling = this._modeling;
  var filteredElements = filter$a(elements, function(element) {
    return !(element.waypoints || element.host || element.labelTarget);
  });
  if (filteredElements.length < 2) {
    return;
  }
  var sortFn = ALIGNMENT_SORTING[type];
  var sortedElements = sortBy$2(filteredElements, sortFn);
  var alignment = this._alignmentPosition(type, sortedElements);
  modeling.alignElements(sortedElements, alignment);
};
var AlignElementsModule = {
  __init__: ["alignElements"],
  alignElements: ["type", AlignElements$1]
};
var PLACEMENT_DETECTION_PAD = 10;
var DEFAULT_DISTANCE = 50;
var DEFAULT_MAX_DISTANCE = 250;
function findFreePosition(source, element, position, getNextPosition) {
  var connectedAtPosition;
  while (connectedAtPosition = getConnectedAtPosition(source, position, element)) {
    position = getNextPosition(element, position, connectedAtPosition);
  }
  return position;
}
function generateGetNextPosition(nextPositionDirection) {
  return function(element, previousPosition, connectedAtPosition) {
    var nextPosition = {
      x: previousPosition.x,
      y: previousPosition.y
    };
    ["x", "y"].forEach(function(axis) {
      var nextPositionDirectionForAxis = nextPositionDirection[axis];
      if (!nextPositionDirectionForAxis) {
        return;
      }
      var dimension = axis === "x" ? "width" : "height";
      var margin = nextPositionDirectionForAxis.margin, minDistance = nextPositionDirectionForAxis.minDistance;
      if (margin < 0) {
        nextPosition[axis] = Math.min(connectedAtPosition[axis] + margin - element[dimension] / 2, previousPosition[axis] - minDistance + margin);
      } else {
        nextPosition[axis] = Math.max(connectedAtPosition[axis] + connectedAtPosition[dimension] + margin + element[dimension] / 2, previousPosition[axis] + minDistance + margin);
      }
    });
    return nextPosition;
  };
}
function getConnectedAtPosition(source, position, element) {
  var bounds = {
    x: position.x - element.width / 2,
    y: position.y - element.height / 2,
    width: element.width,
    height: element.height
  };
  var closure = getAutoPlaceClosure(source);
  return find$e(closure, function(target) {
    if (target === element) {
      return false;
    }
    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);
    return orientation === "intersect";
  });
}
function getConnectedDistance(source, hints) {
  if (!hints) {
    hints = {};
  }
  function getDefaultWeight(connection) {
    return connection.source === source ? 1 : -1;
  }
  var defaultDistance = hints.defaultDistance || DEFAULT_DISTANCE, direction = hints.direction || "e", filter2 = hints.filter, getWeight = hints.getWeight || getDefaultWeight, maxDistance = hints.maxDistance || DEFAULT_MAX_DISTANCE, reference = hints.reference || "start";
  if (!filter2) {
    filter2 = noneFilter;
  }
  function getDistance2(a, b) {
    if (direction === "n") {
      if (reference === "start") {
        return asTRBL(a).top - asTRBL(b).bottom;
      } else if (reference === "center") {
        return asTRBL(a).top - getMid(b).y;
      } else {
        return asTRBL(a).top - asTRBL(b).top;
      }
    } else if (direction === "w") {
      if (reference === "start") {
        return asTRBL(a).left - asTRBL(b).right;
      } else if (reference === "center") {
        return asTRBL(a).left - getMid(b).x;
      } else {
        return asTRBL(a).left - asTRBL(b).left;
      }
    } else if (direction === "s") {
      if (reference === "start") {
        return asTRBL(b).top - asTRBL(a).bottom;
      } else if (reference === "center") {
        return getMid(b).y - asTRBL(a).bottom;
      } else {
        return asTRBL(b).bottom - asTRBL(a).bottom;
      }
    } else {
      if (reference === "start") {
        return asTRBL(b).left - asTRBL(a).right;
      } else if (reference === "center") {
        return getMid(b).x - asTRBL(a).right;
      } else {
        return asTRBL(b).right - asTRBL(a).right;
      }
    }
  }
  var sourcesDistances = source.incoming.filter(filter2).map(function(connection) {
    var weight = getWeight(connection);
    var distance = weight < 0 ? getDistance2(connection.source, source) : getDistance2(source, connection.source);
    return {
      id: connection.source.id,
      distance,
      weight
    };
  });
  var targetsDistances = source.outgoing.filter(filter2).map(function(connection) {
    var weight = getWeight(connection);
    var distance = weight > 0 ? getDistance2(source, connection.target) : getDistance2(connection.target, source);
    return {
      id: connection.target.id,
      distance,
      weight
    };
  });
  var distances = sourcesDistances.concat(targetsDistances).reduce(function(accumulator, currentValue) {
    accumulator[currentValue.id + "__weight_" + currentValue.weight] = currentValue;
    return accumulator;
  }, {});
  var distancesGrouped = reduce$3(distances, function(accumulator, currentValue) {
    var distance = currentValue.distance, weight = currentValue.weight;
    if (distance < 0 || distance > maxDistance) {
      return accumulator;
    }
    if (!accumulator[String(distance)]) {
      accumulator[String(distance)] = 0;
    }
    accumulator[String(distance)] += 1 * weight;
    if (!accumulator.distance || accumulator[accumulator.distance] < accumulator[String(distance)]) {
      accumulator.distance = distance;
    }
    return accumulator;
  }, {});
  return distancesGrouped.distance || defaultDistance;
}
function getAutoPlaceClosure(source) {
  var allConnected = getConnected(source);
  if (source.host) {
    allConnected = allConnected.concat(getConnected(source.host));
  }
  if (source.attachers) {
    allConnected = allConnected.concat(source.attachers.reduce(function(shapes, attacher) {
      return shapes.concat(getConnected(attacher));
    }, []));
  }
  return allConnected;
}
function getConnected(element) {
  return getTargets(element).concat(getSources(element));
}
function getSources(shape) {
  return shape.incoming.map(function(connection) {
    return connection.source;
  });
}
function getTargets(shape) {
  return shape.outgoing.map(function(connection) {
    return connection.target;
  });
}
function noneFilter() {
  return true;
}
var LOW_PRIORITY$k = 100;
function AutoPlace$1(eventBus, modeling, canvas) {
  eventBus.on("autoPlace", LOW_PRIORITY$k, function(context) {
    var shape = context.shape, source = context.source;
    return getNewShapePosition$1(source, shape);
  });
  eventBus.on("autoPlace.end", function(event) {
    canvas.scrollToElement(event.shape);
  });
  this.append = function(source, shape, hints) {
    eventBus.fire("autoPlace.start", {
      source,
      shape
    });
    var position = eventBus.fire("autoPlace", {
      source,
      shape
    });
    var newShape = modeling.appendShape(source, shape, position, source.parent, hints);
    eventBus.fire("autoPlace.end", {
      source,
      shape: newShape
    });
    return newShape;
  };
}
AutoPlace$1.$inject = [
  "eventBus",
  "modeling",
  "canvas"
];
function getNewShapePosition$1(source, element, hints) {
  if (!hints) {
    hints = {};
  }
  var distance = hints.defaultDistance || DEFAULT_DISTANCE;
  var sourceMid = getMid(source), sourceTrbl = asTRBL(source);
  return {
    x: sourceTrbl.right + distance + element.width / 2,
    y: sourceMid.y
  };
}
function AutoPlaceSelectionBehavior(eventBus, selection) {
  eventBus.on("autoPlace.end", 500, function(e) {
    selection.select(e.shape);
  });
}
AutoPlaceSelectionBehavior.$inject = [
  "eventBus",
  "selection"
];
var AutoPlaceModule$1 = {
  __init__: ["autoPlaceSelectionBehavior"],
  autoPlace: ["type", AutoPlace$1],
  autoPlaceSelectionBehavior: ["type", AutoPlaceSelectionBehavior]
};
function getParent$1(element, anyType) {
  if (typeof anyType === "string") {
    anyType = [anyType];
  }
  while (element = element.parent) {
    if (isAny$b(element, anyType)) {
      return element;
    }
  }
  return null;
}
var ModelingUtil = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getParent: getParent$1,
  is: is$O,
  isAny: isAny$b
}, Symbol.toStringTag, { value: "Module" }));
function getNewShapePosition(source, element) {
  if (is$O(element, "bpmn:TextAnnotation")) {
    return getTextAnnotationPosition(source, element);
  }
  if (isAny$b(element, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"])) {
    return getDataElementPosition(source, element);
  }
  if (is$O(element, "bpmn:FlowNode")) {
    return getFlowNodePosition(source, element);
  }
}
function getFlowNodePosition(source, element) {
  var sourceTrbl = asTRBL(source);
  var sourceMid = getMid(source);
  var horizontalDistance = getConnectedDistance(source, {
    filter: function(connection) {
      return is$O(connection, "bpmn:SequenceFlow");
    }
  });
  var margin = 30, minDistance = 80, orientation = "left";
  if (is$O(source, "bpmn:BoundaryEvent")) {
    orientation = getOrientation(source, source.host, -25);
    if (orientation.indexOf("top") !== -1) {
      margin *= -1;
    }
  }
  var position = {
    x: sourceTrbl.right + horizontalDistance + element.width / 2,
    y: sourceMid.y + getVerticalDistance(orientation, minDistance)
  };
  var nextPositionDirection = {
    y: {
      margin,
      minDistance
    }
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}
function getVerticalDistance(orientation, minDistance) {
  if (orientation.indexOf("top") != -1) {
    return -1 * minDistance;
  } else if (orientation.indexOf("bottom") != -1) {
    return minDistance;
  } else {
    return 0;
  }
}
function getTextAnnotationPosition(source, element) {
  var sourceTrbl = asTRBL(source);
  var position = {
    x: sourceTrbl.right + element.width / 2,
    y: sourceTrbl.top - 50 - element.height / 2
  };
  var nextPositionDirection = {
    y: {
      margin: -30,
      minDistance: 20
    }
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}
function getDataElementPosition(source, element) {
  var sourceTrbl = asTRBL(source);
  var position = {
    x: sourceTrbl.right - 10 + element.width / 2,
    y: sourceTrbl.bottom + 40 + element.width / 2
  };
  var nextPositionDirection = {
    x: {
      margin: 30,
      minDistance: 30
    }
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}
function AutoPlace(eventBus) {
  eventBus.on("autoPlace", function(context) {
    var shape = context.shape, source = context.source;
    return getNewShapePosition(source, shape);
  });
}
AutoPlace.$inject = ["eventBus"];
var AutoPlaceModule = {
  __depends__: [AutoPlaceModule$1],
  __init__: ["bpmnAutoPlace"],
  bpmnAutoPlace: ["type", AutoPlace]
};
var DEFAULT_PRIORITY$6 = 1e3;
function CommandInterceptor$5(eventBus) {
  this._eventBus = eventBus;
}
CommandInterceptor$5.$inject = ["eventBus"];
function unwrapEvent$1(fn, that) {
  return function(event) {
    return fn.call(that || null, event.context, event.command, event);
  };
}
CommandInterceptor$5.prototype.on = function(events, hook, priority, handlerFn, unwrap, that) {
  if (isFunction$6(hook) || isNumber$1(hook)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = hook;
    hook = null;
  }
  if (isFunction$6(priority)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = DEFAULT_PRIORITY$6;
  }
  if (isObject$e(unwrap)) {
    that = unwrap;
    unwrap = false;
  }
  if (!isFunction$6(handlerFn)) {
    throw new Error("handlerFn must be a function");
  }
  if (!isArray$n(events)) {
    events = [events];
  }
  var eventBus = this._eventBus;
  forEach$q(events, function(event) {
    var fullEvent = ["commandStack", event, hook].filter(function(e) {
      return e;
    }).join(".");
    eventBus.on(fullEvent, priority, unwrap ? unwrapEvent$1(handlerFn, that) : handlerFn, that);
  });
};
var hooks$1 = [
  "canExecute",
  "preExecute",
  "preExecuted",
  "execute",
  "executed",
  "postExecute",
  "postExecuted",
  "revert",
  "reverted"
];
forEach$q(hooks$1, function(hook) {
  CommandInterceptor$5.prototype[hook] = function(events, priority, handlerFn, unwrap, that) {
    if (isFunction$6(events) || isNumber$1(events)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = events;
      events = null;
    }
    this.on(events, hook, priority, handlerFn, unwrap, that);
  };
});
function AutoResize(eventBus, elementRegistry, modeling, rules) {
  CommandInterceptor$5.call(this, eventBus);
  this._elementRegistry = elementRegistry;
  this._modeling = modeling;
  this._rules = rules;
  var self2 = this;
  this.postExecuted(["shape.create"], function(event) {
    var context = event.context, hints = context.hints || {}, shape = context.shape, parent2 = context.parent || context.newParent;
    if (hints.autoResize === false) {
      return;
    }
    self2._expand([shape], parent2);
  });
  this.postExecuted(["elements.move"], function(event) {
    var context = event.context, elements = flatten$a(values$2(context.closure.topLevel)), hints = context.hints;
    var autoResize = hints ? hints.autoResize : true;
    if (autoResize === false) {
      return;
    }
    var expandings = groupBy$1(elements, function(element) {
      return element.parent.id;
    });
    forEach$q(expandings, function(elements2, parentId) {
      if (isArray$n(autoResize)) {
        elements2 = elements2.filter(function(element) {
          return find$e(autoResize, matchPattern$1({ id: element.id }));
        });
      }
      self2._expand(elements2, parentId);
    });
  });
  this.postExecuted(["shape.toggleCollapse"], function(event) {
    var context = event.context, hints = context.hints, shape = context.shape;
    if (hints && hints.autoResize === false) {
      return;
    }
    if (shape.collapsed) {
      return;
    }
    self2._expand(shape.children || [], shape);
  });
  this.postExecuted(["shape.resize"], function(event) {
    var context = event.context, hints = context.hints, shape = context.shape, parent2 = shape.parent;
    if (hints && hints.autoResize === false) {
      return;
    }
    if (parent2) {
      self2._expand([shape], parent2);
    }
  });
}
AutoResize.$inject = [
  "eventBus",
  "elementRegistry",
  "modeling",
  "rules"
];
inherits$6(AutoResize, CommandInterceptor$5);
AutoResize.prototype._getOptimalBounds = function(elements, target) {
  var offset2 = this.getOffset(target), padding = this.getPadding(target);
  var elementsTrbl = asTRBL(getBBox(elements)), targetTrbl = asTRBL(target);
  var newTrbl = {};
  if (elementsTrbl.top - targetTrbl.top < padding.top) {
    newTrbl.top = elementsTrbl.top - offset2.top;
  }
  if (elementsTrbl.left - targetTrbl.left < padding.left) {
    newTrbl.left = elementsTrbl.left - offset2.left;
  }
  if (targetTrbl.right - elementsTrbl.right < padding.right) {
    newTrbl.right = elementsTrbl.right + offset2.right;
  }
  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {
    newTrbl.bottom = elementsTrbl.bottom + offset2.bottom;
  }
  return asBounds(assign$e({}, targetTrbl, newTrbl));
};
AutoResize.prototype._expand = function(elements, target) {
  if (typeof target === "string") {
    target = this._elementRegistry.get(target);
  }
  var allowed = this._rules.allowed("element.autoResize", {
    elements,
    target
  });
  if (!allowed) {
    return;
  }
  var newBounds = this._getOptimalBounds(elements, target);
  if (!boundsChanged$1(newBounds, target)) {
    return;
  }
  var resizeDirections = getResizeDirections(pick$3(target, ["x", "y", "width", "height"]), newBounds);
  this.resize(target, newBounds, {
    autoResize: resizeDirections
  });
  var parent2 = target.parent;
  if (parent2) {
    this._expand([target], parent2);
  }
};
AutoResize.prototype.getOffset = function(shape) {
  return { top: 60, bottom: 60, left: 100, right: 100 };
};
AutoResize.prototype.getPadding = function(shape) {
  return { top: 2, bottom: 2, left: 15, right: 15 };
};
AutoResize.prototype.resize = function(shape, newBounds, hints) {
  this._modeling.resizeShape(shape, newBounds, null, hints);
};
function boundsChanged$1(newBounds, oldBounds) {
  return newBounds.x !== oldBounds.x || newBounds.y !== oldBounds.y || newBounds.width !== oldBounds.width || newBounds.height !== oldBounds.height;
}
function getResizeDirections(oldBounds, newBounds) {
  var directions2 = "";
  oldBounds = asTRBL(oldBounds);
  newBounds = asTRBL(newBounds);
  if (oldBounds.top > newBounds.top) {
    directions2 = directions2.concat("n");
  }
  if (oldBounds.right < newBounds.right) {
    directions2 = directions2.concat("w");
  }
  if (oldBounds.bottom < newBounds.bottom) {
    directions2 = directions2.concat("s");
  }
  if (oldBounds.left > newBounds.left) {
    directions2 = directions2.concat("e");
  }
  return directions2;
}
function BpmnAutoResize(injector) {
  injector.invoke(AutoResize, this);
}
BpmnAutoResize.$inject = [
  "injector"
];
inherits$6(BpmnAutoResize, AutoResize);
BpmnAutoResize.prototype.resize = function(target, newBounds, hints) {
  if (is$O(target, "bpmn:Participant")) {
    this._modeling.resizeLane(target, newBounds, null, hints);
  } else {
    this._modeling.resizeShape(target, newBounds, null, hints);
  }
};
function RuleProvider(eventBus) {
  CommandInterceptor$5.call(this, eventBus);
  this.init();
}
RuleProvider.$inject = ["eventBus"];
inherits$6(RuleProvider, CommandInterceptor$5);
RuleProvider.prototype.addRule = function(actions, priority, fn) {
  var self2 = this;
  if (typeof actions === "string") {
    actions = [actions];
  }
  actions.forEach(function(action) {
    self2.canExecute(action, priority, function(context, action2, event) {
      return fn(context);
    }, true);
  });
};
RuleProvider.prototype.init = function() {
};
function AutoResizeProvider(eventBus) {
  RuleProvider.call(this, eventBus);
  var self2 = this;
  this.addRule("element.autoResize", function(context) {
    return self2.canResize(context.elements, context.target);
  });
}
AutoResizeProvider.$inject = ["eventBus"];
inherits$6(AutoResizeProvider, RuleProvider);
AutoResizeProvider.prototype.canResize = function(elements, target) {
  return false;
};
function BpmnAutoResizeProvider(eventBus, modeling) {
  AutoResizeProvider.call(this, eventBus);
  this._modeling = modeling;
}
inherits$6(BpmnAutoResizeProvider, AutoResizeProvider);
BpmnAutoResizeProvider.$inject = [
  "eventBus",
  "modeling"
];
BpmnAutoResizeProvider.prototype.canResize = function(elements, target) {
  if (!is$O(target, "bpmn:Participant") && !is$O(target, "bpmn:Lane") && !is$O(target, "bpmn:SubProcess")) {
    return false;
  }
  var canResize2 = true;
  forEach$q(elements, function(element) {
    if (is$O(element, "bpmn:Lane") || element.labelTarget) {
      canResize2 = false;
      return;
    }
  });
  return canResize2;
};
var AutoResizeModule = {
  __init__: [
    "bpmnAutoResize",
    "bpmnAutoResizeProvider"
  ],
  bpmnAutoResize: ["type", BpmnAutoResize],
  bpmnAutoResizeProvider: ["type", BpmnAutoResizeProvider]
};
var HIGH_PRIORITY$j = 1500;
function HoverFix(elementRegistry, eventBus, injector) {
  var self2 = this;
  var dragging = injector.get("dragging", false);
  function ensureHover(event) {
    if (event.hover) {
      return;
    }
    var originalEvent = event.originalEvent;
    var gfx = self2._findTargetGfx(originalEvent);
    var element = gfx && elementRegistry.get(gfx);
    if (gfx && element) {
      event.stopPropagation();
      dragging.hover({ element, gfx });
      dragging.move(originalEvent);
    }
  }
  if (dragging) {
    eventBus.on("drag.start", function(event) {
      eventBus.once("drag.move", HIGH_PRIORITY$j, function(event2) {
        ensureHover(event2);
      });
    });
  }
  (function() {
    var hoverGfx;
    var hover;
    eventBus.on("element.hover", function(event) {
      hoverGfx = event.gfx;
      hover = event.element;
    });
    eventBus.on("element.hover", HIGH_PRIORITY$j, function(event) {
      if (hover) {
        eventBus.fire("element.out", {
          element: hover,
          gfx: hoverGfx
        });
      }
    });
    eventBus.on("element.out", function() {
      hoverGfx = null;
      hover = null;
    });
  })();
  this._findTargetGfx = function(event) {
    var position, target;
    if (!(event instanceof MouseEvent)) {
      return;
    }
    position = toPoint(event);
    target = document.elementFromPoint(position.x, position.y);
    return getGfx(target);
  };
}
HoverFix.$inject = [
  "elementRegistry",
  "eventBus",
  "injector"
];
function getGfx(target) {
  return closest(target, "svg, .djs-element", true);
}
var HoverFixModule = {
  __init__: [
    "hoverFix"
  ],
  hoverFix: ["type", HoverFix]
};
var round$a = Math.round;
var DRAG_ACTIVE_CLS = "djs-drag-active";
function preventDefault$1(event) {
  event.preventDefault();
}
function isTouchEvent(event) {
  return typeof TouchEvent !== "undefined" && event instanceof TouchEvent;
}
function getLength(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}
function Dragging(eventBus, canvas, selection, elementRegistry) {
  var defaultOptions = {
    threshold: 5,
    trapClick: true
  };
  var context;
  function toLocalPoint(globalPosition) {
    var viewbox = canvas.viewbox();
    var clientRect = canvas._container.getBoundingClientRect();
    return {
      x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,
      y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale
    };
  }
  function fire(type, dragContext) {
    dragContext = dragContext || context;
    var event = eventBus.createEvent(assign$e({}, dragContext.payload, dragContext.data, { isTouch: dragContext.isTouch }));
    if (eventBus.fire("drag." + type, event) === false) {
      return false;
    }
    return eventBus.fire(dragContext.prefix + "." + type, event);
  }
  function restoreSelection(previousSelection) {
    var existingSelection = previousSelection.filter(function(element) {
      return elementRegistry.get(element.id);
    });
    existingSelection.length && selection.select(existingSelection);
  }
  function move(event, activate) {
    var payload = context.payload, displacement = context.displacement;
    var globalStart = context.globalStart, globalCurrent = toPoint(event), globalDelta = delta(globalCurrent, globalStart);
    var localStart = context.localStart, localCurrent = toLocalPoint(globalCurrent), localDelta = delta(localCurrent, localStart);
    if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {
      assign$e(payload, {
        x: round$a(localStart.x + displacement.x),
        y: round$a(localStart.y + displacement.y),
        dx: 0,
        dy: 0
      }, { originalEvent: event });
      if (fire("start") === false) {
        return cancel();
      }
      context.active = true;
      if (!context.keepSelection) {
        payload.previousSelection = selection.get();
        selection.select(null);
      }
      if (context.cursor) {
        set(context.cursor);
      }
      canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
    }
    stopPropagation$1(event);
    if (context.active) {
      assign$e(payload, {
        x: round$a(localCurrent.x + displacement.x),
        y: round$a(localCurrent.y + displacement.y),
        dx: round$a(localDelta.x),
        dy: round$a(localDelta.y)
      }, { originalEvent: event });
      fire("move");
    }
  }
  function end(event) {
    var previousContext, returnValue = true;
    if (context.active) {
      if (event) {
        context.payload.originalEvent = event;
        stopPropagation$1(event);
      }
      returnValue = fire("end");
    }
    if (returnValue === false) {
      fire("rejected");
    }
    previousContext = cleanup(returnValue !== true);
    fire("ended", previousContext);
  }
  function checkCancel(event) {
    if (event.which === 27) {
      preventDefault$1(event);
      cancel();
    }
  }
  function trapClickAndEnd(event) {
    var untrap;
    if (context.active) {
      untrap = install(eventBus);
      setTimeout(untrap, 400);
      preventDefault$1(event);
    }
    end(event);
  }
  function trapTouch(event) {
    move(event);
  }
  function hover(event) {
    var payload = context.payload;
    payload.hoverGfx = event.gfx;
    payload.hover = event.element;
    fire("hover");
  }
  function out(event) {
    fire("out");
    var payload = context.payload;
    payload.hoverGfx = null;
    payload.hover = null;
  }
  function cancel(restore) {
    var previousContext;
    if (!context) {
      return;
    }
    var wasActive = context.active;
    if (wasActive) {
      fire("cancel");
    }
    previousContext = cleanup(restore);
    if (wasActive) {
      fire("canceled", previousContext);
    }
  }
  function cleanup(restore) {
    var previousContext, endDrag;
    fire("cleanup");
    unset();
    if (context.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }
    componentEvent.unbind(document, "mousemove", move);
    componentEvent.unbind(document, "dragstart", preventDefault$1);
    componentEvent.unbind(document, "selectstart", preventDefault$1);
    componentEvent.unbind(document, "mousedown", endDrag, true);
    componentEvent.unbind(document, "mouseup", endDrag, true);
    componentEvent.unbind(document, "keyup", checkCancel);
    componentEvent.unbind(document, "touchstart", trapTouch, true);
    componentEvent.unbind(document, "touchcancel", cancel, true);
    componentEvent.unbind(document, "touchmove", move, true);
    componentEvent.unbind(document, "touchend", end, true);
    eventBus.off("element.hover", hover);
    eventBus.off("element.out", out);
    canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
    var previousSelection = context.payload.previousSelection;
    if (restore !== false && previousSelection && !selection.get().length) {
      restoreSelection(previousSelection);
    }
    previousContext = context;
    context = null;
    return previousContext;
  }
  function init2(event, relativeTo, prefix2, options) {
    if (context) {
      cancel(false);
    }
    if (typeof relativeTo === "string") {
      options = prefix2;
      prefix2 = relativeTo;
      relativeTo = null;
    }
    options = assign$e({}, defaultOptions, options || {});
    var data = options.data || {}, originalEvent, globalStart, localStart, endDrag, isTouch;
    if (options.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }
    if (event) {
      originalEvent = getOriginal$2(event) || event;
      globalStart = toPoint(event);
      stopPropagation$1(event);
      if (originalEvent.type === "dragstart") {
        preventDefault$1(originalEvent);
      }
    } else {
      originalEvent = null;
      globalStart = { x: 0, y: 0 };
    }
    localStart = toLocalPoint(globalStart);
    if (!relativeTo) {
      relativeTo = localStart;
    }
    isTouch = isTouchEvent(originalEvent);
    context = assign$e({
      prefix: prefix2,
      data,
      payload: {},
      globalStart,
      displacement: delta(relativeTo, localStart),
      localStart,
      isTouch
    }, options);
    if (!options.manual) {
      if (isTouch) {
        componentEvent.bind(document, "touchstart", trapTouch, true);
        componentEvent.bind(document, "touchcancel", cancel, true);
        componentEvent.bind(document, "touchmove", move, true);
        componentEvent.bind(document, "touchend", end, true);
      } else {
        componentEvent.bind(document, "mousemove", move);
        componentEvent.bind(document, "dragstart", preventDefault$1);
        componentEvent.bind(document, "selectstart", preventDefault$1);
        componentEvent.bind(document, "mousedown", endDrag, true);
        componentEvent.bind(document, "mouseup", endDrag, true);
      }
      componentEvent.bind(document, "keyup", checkCancel);
      eventBus.on("element.hover", hover);
      eventBus.on("element.out", out);
    }
    fire("init");
    if (options.autoActivate) {
      move(event, true);
    }
  }
  eventBus.on("diagram.destroy", cancel);
  this.init = init2;
  this.move = move;
  this.hover = hover;
  this.out = out;
  this.end = end;
  this.cancel = cancel;
  this.context = function() {
    return context;
  };
  this.setOptions = function(options) {
    assign$e(defaultOptions, options);
  };
}
Dragging.$inject = [
  "eventBus",
  "canvas",
  "selection",
  "elementRegistry"
];
var DraggingModule = {
  __depends__: [
    HoverFixModule,
    SelectionModule
  ],
  dragging: ["type", Dragging]
};
function AutoScroll(config, eventBus, canvas) {
  this._canvas = canvas;
  this._opts = assign$e({
    scrollThresholdIn: [20, 20, 20, 20],
    scrollThresholdOut: [0, 0, 0, 0],
    scrollRepeatTimeout: 15,
    scrollStep: 10
  }, config);
  var self2 = this;
  eventBus.on("drag.move", function(e) {
    var point = self2._toBorderPoint(e);
    self2.startScroll(point);
  });
  eventBus.on(["drag.cleanup"], function() {
    self2.stopScroll();
  });
}
AutoScroll.$inject = [
  "config.autoScroll",
  "eventBus",
  "canvas"
];
AutoScroll.prototype.startScroll = function(point) {
  var canvas = this._canvas;
  var opts = this._opts;
  var self2 = this;
  var clientRect = canvas.getContainer().getBoundingClientRect();
  var diff2 = [
    point.x,
    point.y,
    clientRect.width - point.x,
    clientRect.height - point.y
  ];
  this.stopScroll();
  var dx = 0, dy = 0;
  for (var i = 0; i < 4; i++) {
    if (between(diff2[i], opts.scrollThresholdOut[i], opts.scrollThresholdIn[i])) {
      if (i === 0) {
        dx = opts.scrollStep;
      } else if (i == 1) {
        dy = opts.scrollStep;
      } else if (i == 2) {
        dx = -opts.scrollStep;
      } else if (i == 3) {
        dy = -opts.scrollStep;
      }
    }
  }
  if (dx !== 0 || dy !== 0) {
    canvas.scroll({ dx, dy });
    this._scrolling = setTimeout(function() {
      self2.startScroll(point);
    }, opts.scrollRepeatTimeout);
  }
};
function between(val, start, end) {
  if (start < val && val < end) {
    return true;
  }
  return false;
}
AutoScroll.prototype.stopScroll = function() {
  clearTimeout(this._scrolling);
};
AutoScroll.prototype.setOptions = function(options) {
  this._opts = assign$e({}, this._opts, options);
};
AutoScroll.prototype._toBorderPoint = function(event) {
  var clientRect = this._canvas._container.getBoundingClientRect();
  var globalPosition = toPoint(event.originalEvent);
  return {
    x: globalPosition.x - clientRect.left,
    y: globalPosition.y - clientRect.top
  };
};
var AutoScrollModule = {
  __depends__: [
    DraggingModule
  ],
  __init__: ["autoScroll"],
  autoScroll: ["type", AutoScroll]
};
function Rules(injector) {
  this._commandStack = injector.get("commandStack", false);
}
Rules.$inject = ["injector"];
Rules.prototype.allowed = function(action, context) {
  var allowed = true;
  var commandStack = this._commandStack;
  if (commandStack) {
    allowed = commandStack.canExecute(action, context);
  }
  return allowed === void 0 ? true : allowed;
};
var RulesModule$1 = {
  __init__: ["rules"],
  rules: ["type", Rules]
};
var round$9 = Math.round, max$6 = Math.max;
function circlePath(center2, r) {
  var x = center2.x, y = center2.y;
  return [
    ["M", x, y],
    ["m", 0, -r],
    ["a", r, r, 0, 1, 1, 0, 2 * r],
    ["a", r, r, 0, 1, 1, 0, -2 * r],
    ["z"]
  ];
}
function linePath(points) {
  var segments = [];
  points.forEach(function(p, idx) {
    segments.push([idx === 0 ? "M" : "L", p.x, p.y]);
  });
  return segments;
}
var INTERSECTION_THRESHOLD$1 = 10;
function getBendpointIntersection(waypoints, reference) {
  var i, w;
  for (i = 0; w = waypoints[i]; i++) {
    if (pointDistance(w, reference) <= INTERSECTION_THRESHOLD$1) {
      return {
        point: waypoints[i],
        bendpoint: true,
        index: i
      };
    }
  }
  return null;
}
function getPathIntersection(waypoints, reference) {
  var intersections = intersectPaths(circlePath(reference, INTERSECTION_THRESHOLD$1), linePath(waypoints));
  var a = intersections[0], b = intersections[intersections.length - 1], idx;
  if (!a) {
    return null;
  }
  if (a !== b) {
    if (a.segment2 !== b.segment2) {
      idx = max$6(a.segment2, b.segment2) - 1;
      return {
        point: waypoints[idx],
        bendpoint: true,
        index: idx
      };
    }
    return {
      point: {
        x: round$9(a.x + b.x) / 2,
        y: round$9(a.y + b.y) / 2
      },
      index: a.segment2
    };
  }
  return {
    point: {
      x: round$9(a.x),
      y: round$9(a.y)
    },
    index: a.segment2
  };
}
function getApproxIntersection(waypoints, reference) {
  return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);
}
var BENDPOINT_CLS = "djs-bendpoint";
var SEGMENT_DRAGGER_CLS = "djs-segment-dragger";
function toCanvasCoordinates(canvas, event) {
  var position = toPoint(event), clientRect = canvas._container.getBoundingClientRect(), offset2;
  offset2 = {
    x: clientRect.left,
    y: clientRect.top
  };
  var viewbox = canvas.viewbox();
  return {
    x: viewbox.x + (position.x - offset2.x) / viewbox.scale,
    y: viewbox.y + (position.y - offset2.y) / viewbox.scale
  };
}
function getConnectionIntersection(canvas, waypoints, event) {
  var localPosition = toCanvasCoordinates(canvas, event), intersection2 = getApproxIntersection(waypoints, localPosition);
  return intersection2;
}
function addBendpoint(parentGfx, cls) {
  var groupGfx = create$2("g");
  classes(groupGfx).add(BENDPOINT_CLS);
  append$3(parentGfx, groupGfx);
  var visual = create$2("circle");
  attr(visual, {
    cx: 0,
    cy: 0,
    r: 4
  });
  classes(visual).add("djs-visual");
  append$3(groupGfx, visual);
  var hit = create$2("circle");
  attr(hit, {
    cx: 0,
    cy: 0,
    r: 10
  });
  classes(hit).add("djs-hit");
  append$3(groupGfx, hit);
  if (cls) {
    classes(groupGfx).add(cls);
  }
  return groupGfx;
}
function createParallelDragger(parentGfx, segmentStart, segmentEnd, alignment) {
  var draggerGfx = create$2("g");
  append$3(parentGfx, draggerGfx);
  var width = 14, height = 3, padding = 11, hitWidth = calculateHitWidth(segmentStart, segmentEnd, alignment), hitHeight = height + padding;
  var visual = create$2("rect");
  attr(visual, {
    x: -width / 2,
    y: -height / 2,
    width,
    height
  });
  classes(visual).add("djs-visual");
  append$3(draggerGfx, visual);
  var hit = create$2("rect");
  attr(hit, {
    x: -hitWidth / 2,
    y: -hitHeight / 2,
    width: hitWidth,
    height: hitHeight
  });
  classes(hit).add("djs-hit");
  append$3(draggerGfx, hit);
  rotate(draggerGfx, alignment === "v" ? 90 : 0);
  return draggerGfx;
}
function addSegmentDragger(parentGfx, segmentStart, segmentEnd) {
  var groupGfx = create$2("g"), mid2 = getMidPoint(segmentStart, segmentEnd), alignment = pointsAligned(segmentStart, segmentEnd);
  append$3(parentGfx, groupGfx);
  createParallelDragger(groupGfx, segmentStart, segmentEnd, alignment);
  classes(groupGfx).add(SEGMENT_DRAGGER_CLS);
  classes(groupGfx).add(alignment === "h" ? "horizontal" : "vertical");
  translate$4(groupGfx, mid2.x, mid2.y);
  return groupGfx;
}
function calculateSegmentMoveRegion(segmentLength) {
  return Math.abs(Math.round(segmentLength * 2 / 3));
}
function calculateHitWidth(segmentStart, segmentEnd, alignment) {
  var segmentLengthXAxis = segmentEnd.x - segmentStart.x, segmentLengthYAxis = segmentEnd.y - segmentStart.y;
  return alignment === "h" ? calculateSegmentMoveRegion(segmentLengthXAxis) : calculateSegmentMoveRegion(segmentLengthYAxis);
}
var css_escape = { exports: {} };
/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
(function(module, exports) {
  (function(root2, factory2) {
    {
      module.exports = factory2(root2);
    }
  })(typeof commonjsGlobal != "undefined" ? commonjsGlobal : commonjsGlobal, function(root2) {
    if (root2.CSS && root2.CSS.escape) {
      return root2.CSS.escape;
    }
    var cssEscape2 = function(value) {
      if (arguments.length == 0) {
        throw new TypeError("`CSS.escape` requires an argument.");
      }
      var string = String(value);
      var length2 = string.length;
      var index2 = -1;
      var codeUnit;
      var result = "";
      var firstCodeUnit = string.charCodeAt(0);
      while (++index2 < length2) {
        codeUnit = string.charCodeAt(index2);
        if (codeUnit == 0) {
          result += "\uFFFD";
          continue;
        }
        if (codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || index2 == 0 && codeUnit >= 48 && codeUnit <= 57 || index2 == 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit == 45) {
          result += "\\" + codeUnit.toString(16) + " ";
          continue;
        }
        if (index2 == 0 && length2 == 1 && codeUnit == 45) {
          result += "\\" + string.charAt(index2);
          continue;
        }
        if (codeUnit >= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
          result += string.charAt(index2);
          continue;
        }
        result += "\\" + string.charAt(index2);
      }
      return result;
    };
    if (!root2.CSS) {
      root2.CSS = {};
    }
    root2.CSS.escape = cssEscape2;
    return cssEscape2;
  });
})(css_escape);
var cssEscape = css_escape.exports;
var HTML_ESCAPE_MAP$1 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function escapeHTML$n(str) {
  str = "" + str;
  return str && str.replace(/[&<>"']/g, function(match2) {
    return HTML_ESCAPE_MAP$1[match2];
  });
}
function Bendpoints(eventBus, canvas, interactionEvents, bendpointMove, connectionSegmentMove) {
  function isIntersectionMiddle(intersection2, waypoints, treshold) {
    var idx = intersection2.index, p = intersection2.point, p0, p1, mid2, aligned, xDelta, yDelta;
    if (idx <= 0 || intersection2.bendpoint) {
      return false;
    }
    p0 = waypoints[idx - 1];
    p1 = waypoints[idx];
    mid2 = getMidPoint(p0, p1), aligned = pointsAligned(p0, p1);
    xDelta = Math.abs(p.x - mid2.x);
    yDelta = Math.abs(p.y - mid2.y);
    return aligned && xDelta <= treshold && yDelta <= treshold;
  }
  function calculateIntersectionThreshold(connection, intersection2) {
    var waypoints = connection.waypoints, relevantSegment, alignment, segmentLength, threshold;
    if (intersection2.index <= 0 || intersection2.bendpoint) {
      return null;
    }
    relevantSegment = {
      start: waypoints[intersection2.index - 1],
      end: waypoints[intersection2.index]
    };
    alignment = pointsAligned(relevantSegment.start, relevantSegment.end);
    if (!alignment) {
      return null;
    }
    if (alignment === "h") {
      segmentLength = relevantSegment.end.x - relevantSegment.start.x;
    } else {
      segmentLength = relevantSegment.end.y - relevantSegment.start.y;
    }
    threshold = calculateSegmentMoveRegion(segmentLength) / 2;
    return threshold;
  }
  function activateBendpointMove(event, connection) {
    var waypoints = connection.waypoints, intersection2 = getConnectionIntersection(canvas, waypoints, event), threshold;
    if (!intersection2) {
      return;
    }
    threshold = calculateIntersectionThreshold(connection, intersection2);
    if (isIntersectionMiddle(intersection2, waypoints, threshold)) {
      connectionSegmentMove.start(event, connection, intersection2.index);
    } else {
      bendpointMove.start(event, connection, intersection2.index, !intersection2.bendpoint);
    }
    return true;
  }
  function bindInteractionEvents(node2, eventName, element) {
    componentEvent.bind(node2, eventName, function(event) {
      interactionEvents.triggerMouseEvent(eventName, event, element);
      event.stopPropagation();
    });
  }
  function getBendpointsContainer(element, create2) {
    var layer = canvas.getLayer("overlays"), gfx = query('.djs-bendpoints[data-element-id="' + cssEscape(element.id) + '"]', layer);
    if (!gfx && create2) {
      gfx = create$2("g");
      attr(gfx, { "data-element-id": element.id });
      classes(gfx).add("djs-bendpoints");
      append$3(layer, gfx);
      bindInteractionEvents(gfx, "mousedown", element);
      bindInteractionEvents(gfx, "click", element);
      bindInteractionEvents(gfx, "dblclick", element);
    }
    return gfx;
  }
  function getSegmentDragger(idx, parentGfx) {
    return query('.djs-segment-dragger[data-segment-idx="' + idx + '"]', parentGfx);
  }
  function createBendpoints(gfx, connection) {
    connection.waypoints.forEach(function(p, idx) {
      var bendpoint = addBendpoint(gfx);
      append$3(gfx, bendpoint);
      translate$4(bendpoint, p.x, p.y);
    });
    addBendpoint(gfx, "floating");
  }
  function createSegmentDraggers(gfx, connection) {
    var waypoints = connection.waypoints;
    var segmentStart, segmentEnd, segmentDraggerGfx;
    for (var i = 1; i < waypoints.length; i++) {
      segmentStart = waypoints[i - 1];
      segmentEnd = waypoints[i];
      if (pointsAligned(segmentStart, segmentEnd)) {
        segmentDraggerGfx = addSegmentDragger(gfx, segmentStart, segmentEnd);
        attr(segmentDraggerGfx, { "data-segment-idx": i });
        bindInteractionEvents(segmentDraggerGfx, "mousemove", connection);
      }
    }
  }
  function clearBendpoints(gfx) {
    forEach$q(all("." + BENDPOINT_CLS, gfx), function(node2) {
      remove$4(node2);
    });
  }
  function clearSegmentDraggers(gfx) {
    forEach$q(all("." + SEGMENT_DRAGGER_CLS, gfx), function(node2) {
      remove$4(node2);
    });
  }
  function addHandles(connection) {
    var gfx = getBendpointsContainer(connection);
    if (!gfx) {
      gfx = getBendpointsContainer(connection, true);
      createBendpoints(gfx, connection);
      createSegmentDraggers(gfx, connection);
    }
    return gfx;
  }
  function updateHandles(connection) {
    var gfx = getBendpointsContainer(connection);
    if (gfx) {
      clearSegmentDraggers(gfx);
      clearBendpoints(gfx);
      createSegmentDraggers(gfx, connection);
      createBendpoints(gfx, connection);
    }
  }
  function updateFloatingBendpointPosition(parentGfx, intersection2) {
    var floating = query(".floating", parentGfx), point = intersection2.point;
    if (!floating) {
      return;
    }
    translate$4(floating, point.x, point.y);
  }
  function updateSegmentDraggerPosition(parentGfx, intersection2, waypoints) {
    var draggerGfx = getSegmentDragger(intersection2.index, parentGfx), segmentStart = waypoints[intersection2.index - 1], segmentEnd = waypoints[intersection2.index], point = intersection2.point, mid2 = getMidPoint(segmentStart, segmentEnd), alignment = pointsAligned(segmentStart, segmentEnd), draggerVisual, relativePosition;
    if (!draggerGfx) {
      return;
    }
    draggerVisual = getDraggerVisual(draggerGfx);
    relativePosition = {
      x: point.x - mid2.x,
      y: point.y - mid2.y
    };
    if (alignment === "v") {
      relativePosition = {
        x: relativePosition.y,
        y: relativePosition.x
      };
    }
    translate$4(draggerVisual, relativePosition.x, relativePosition.y);
  }
  eventBus.on("connection.changed", function(event) {
    updateHandles(event.element);
  });
  eventBus.on("connection.remove", function(event) {
    var gfx = getBendpointsContainer(event.element);
    if (gfx) {
      remove$4(gfx);
    }
  });
  eventBus.on("element.marker.update", function(event) {
    var element = event.element, bendpointsGfx;
    if (!element.waypoints) {
      return;
    }
    bendpointsGfx = addHandles(element);
    if (event.add) {
      classes(bendpointsGfx).add(event.marker);
    } else {
      classes(bendpointsGfx).remove(event.marker);
    }
  });
  eventBus.on("element.mousemove", function(event) {
    var element = event.element, waypoints = element.waypoints, bendpointsGfx, intersection2;
    if (waypoints) {
      bendpointsGfx = getBendpointsContainer(element, true);
      intersection2 = getConnectionIntersection(canvas, waypoints, event.originalEvent);
      if (!intersection2) {
        return;
      }
      updateFloatingBendpointPosition(bendpointsGfx, intersection2);
      if (!intersection2.bendpoint) {
        updateSegmentDraggerPosition(bendpointsGfx, intersection2, waypoints);
      }
    }
  });
  eventBus.on("element.mousedown", function(event) {
    if (!isPrimaryButton$1(event)) {
      return;
    }
    var originalEvent = event.originalEvent, element = event.element;
    if (!element.waypoints) {
      return;
    }
    return activateBendpointMove(originalEvent, element);
  });
  eventBus.on("selection.changed", function(event) {
    var newSelection = event.newSelection, primary = newSelection[0];
    if (primary && primary.waypoints) {
      addHandles(primary);
    }
  });
  eventBus.on("element.hover", function(event) {
    var element = event.element;
    if (element.waypoints) {
      addHandles(element);
      interactionEvents.registerEvent(event.gfx, "mousemove", "element.mousemove");
    }
  });
  eventBus.on("element.out", function(event) {
    interactionEvents.unregisterEvent(event.gfx, "mousemove", "element.mousemove");
  });
  eventBus.on("element.updateId", function(context) {
    var element = context.element, newId = context.newId;
    if (element.waypoints) {
      var bendpointContainer = getBendpointsContainer(element);
      if (bendpointContainer) {
        attr(bendpointContainer, { "data-element-id": newId });
      }
    }
  });
  this.addHandles = addHandles;
  this.updateHandles = updateHandles;
  this.getBendpointsContainer = getBendpointsContainer;
  this.getSegmentDragger = getSegmentDragger;
}
Bendpoints.$inject = [
  "eventBus",
  "canvas",
  "interactionEvents",
  "bendpointMove",
  "connectionSegmentMove"
];
function getDraggerVisual(draggerGfx) {
  return query(".djs-visual", draggerGfx);
}
var round$8 = Math.round;
var RECONNECT_START$1 = "reconnectStart", RECONNECT_END$1 = "reconnectEnd", UPDATE_WAYPOINTS$1 = "updateWaypoints";
function BendpointMove(injector, eventBus, canvas, dragging, rules, modeling) {
  this._injector = injector;
  this.start = function(event, connection, bendpointIndex, insert) {
    var gfx = canvas.getGraphics(connection), source = connection.source, target = connection.target, waypoints = connection.waypoints, type;
    if (!insert && bendpointIndex === 0) {
      type = RECONNECT_START$1;
    } else if (!insert && bendpointIndex === waypoints.length - 1) {
      type = RECONNECT_END$1;
    } else {
      type = UPDATE_WAYPOINTS$1;
    }
    var command = type === UPDATE_WAYPOINTS$1 ? "connection.updateWaypoints" : "connection.reconnect";
    var allowed = rules.allowed(command, {
      connection,
      source,
      target
    });
    if (allowed === false) {
      allowed = rules.allowed(command, {
        connection,
        source: target,
        target: source
      });
    }
    if (allowed === false) {
      return;
    }
    dragging.init(event, "bendpoint.move", {
      data: {
        connection,
        connectionGfx: gfx,
        context: {
          allowed,
          bendpointIndex,
          connection,
          source,
          target,
          insert,
          type
        }
      }
    });
  };
  eventBus.on("bendpoint.move.hover", function(event) {
    var context = event.context, connection = context.connection, source = connection.source, target = connection.target, hover = event.hover, type = context.type;
    context.hover = hover;
    var allowed;
    if (!hover) {
      return;
    }
    var command = type === UPDATE_WAYPOINTS$1 ? "connection.updateWaypoints" : "connection.reconnect";
    allowed = context.allowed = rules.allowed(command, {
      connection,
      source: type === RECONNECT_START$1 ? hover : source,
      target: type === RECONNECT_END$1 ? hover : target
    });
    if (allowed) {
      context.source = type === RECONNECT_START$1 ? hover : source;
      context.target = type === RECONNECT_END$1 ? hover : target;
      return;
    }
    if (allowed === false) {
      allowed = context.allowed = rules.allowed(command, {
        connection,
        source: type === RECONNECT_END$1 ? hover : target,
        target: type === RECONNECT_START$1 ? hover : source
      });
    }
    if (allowed) {
      context.source = type === RECONNECT_END$1 ? hover : target;
      context.target = type === RECONNECT_START$1 ? hover : source;
    }
  });
  eventBus.on(["bendpoint.move.out", "bendpoint.move.cleanup"], function(event) {
    var context = event.context, type = context.type;
    context.hover = null;
    context.source = null;
    context.target = null;
    if (type !== UPDATE_WAYPOINTS$1) {
      context.allowed = false;
    }
  });
  eventBus.on("bendpoint.move.end", function(event) {
    var context = event.context, allowed = context.allowed, bendpointIndex = context.bendpointIndex, connection = context.connection, insert = context.insert, newWaypoints = connection.waypoints.slice(), source = context.source, target = context.target, type = context.type, hints = context.hints || {};
    var docking = {
      x: round$8(event.x),
      y: round$8(event.y)
    };
    if (!allowed) {
      return false;
    }
    if (type === UPDATE_WAYPOINTS$1) {
      if (insert) {
        newWaypoints.splice(bendpointIndex, 0, docking);
      } else {
        newWaypoints[bendpointIndex] = docking;
      }
      hints.bendpointMove = {
        insert,
        bendpointIndex
      };
      newWaypoints = this.cropWaypoints(connection, newWaypoints);
      modeling.updateWaypoints(connection, filterRedundantWaypoints(newWaypoints), hints);
    } else {
      if (type === RECONNECT_START$1) {
        hints.docking = "source";
        if (isReverse$2(context)) {
          hints.docking = "target";
          hints.newWaypoints = newWaypoints.reverse();
        }
      } else if (type === RECONNECT_END$1) {
        hints.docking = "target";
        if (isReverse$2(context)) {
          hints.docking = "source";
          hints.newWaypoints = newWaypoints.reverse();
        }
      }
      modeling.reconnect(connection, source, target, docking, hints);
    }
  }, this);
}
BendpointMove.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "dragging",
  "rules",
  "modeling"
];
BendpointMove.prototype.cropWaypoints = function(connection, newWaypoints) {
  var connectionDocking = this._injector.get("connectionDocking", false);
  if (!connectionDocking) {
    return newWaypoints;
  }
  var waypoints = connection.waypoints;
  connection.waypoints = newWaypoints;
  connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
  newWaypoints = connection.waypoints;
  connection.waypoints = waypoints;
  return newWaypoints;
};
function isReverse$2(context) {
  var hover = context.hover, source = context.source, target = context.target, type = context.type;
  if (type === RECONNECT_START$1) {
    return hover && target && hover === target && source !== target;
  }
  if (type === RECONNECT_END$1) {
    return hover && source && hover === source && source !== target;
  }
}
var RECONNECT_START = "reconnectStart", RECONNECT_END = "reconnectEnd", UPDATE_WAYPOINTS = "updateWaypoints";
var MARKER_OK$4 = "connect-ok", MARKER_NOT_OK$4 = "connect-not-ok", MARKER_CONNECT_HOVER$1 = "connect-hover", MARKER_CONNECT_UPDATING$1 = "djs-updating", MARKER_ELEMENT_HIDDEN = "djs-element-hidden";
var HIGH_PRIORITY$i = 1100;
function BendpointMovePreview(bendpointMove, injector, eventBus, canvas) {
  this._injector = injector;
  var connectionPreview = injector.get("connectionPreview", false);
  eventBus.on("bendpoint.move.start", function(event) {
    var context = event.context, bendpointIndex = context.bendpointIndex, connection = context.connection, insert = context.insert, waypoints = connection.waypoints, newWaypoints = waypoints.slice();
    context.waypoints = waypoints;
    if (insert) {
      newWaypoints.splice(bendpointIndex, 0, { x: event.x, y: event.y });
    }
    connection.waypoints = newWaypoints;
    var draggerGfx = context.draggerGfx = addBendpoint(canvas.getLayer("overlays"));
    classes(draggerGfx).add("djs-dragging");
    canvas.addMarker(connection, MARKER_ELEMENT_HIDDEN);
    canvas.addMarker(connection, MARKER_CONNECT_UPDATING$1);
  });
  eventBus.on("bendpoint.move.hover", function(event) {
    var context = event.context, allowed = context.allowed, hover = context.hover, type = context.type;
    if (hover) {
      canvas.addMarker(hover, MARKER_CONNECT_HOVER$1);
      if (type === UPDATE_WAYPOINTS) {
        return;
      }
      if (allowed) {
        canvas.removeMarker(hover, MARKER_NOT_OK$4);
        canvas.addMarker(hover, MARKER_OK$4);
      } else if (allowed === false) {
        canvas.removeMarker(hover, MARKER_OK$4);
        canvas.addMarker(hover, MARKER_NOT_OK$4);
      }
    }
  });
  eventBus.on([
    "bendpoint.move.out",
    "bendpoint.move.cleanup"
  ], HIGH_PRIORITY$i, function(event) {
    var context = event.context, hover = context.hover, target = context.target;
    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER$1);
      canvas.removeMarker(hover, target ? MARKER_OK$4 : MARKER_NOT_OK$4);
    }
  });
  eventBus.on("bendpoint.move.move", function(event) {
    var context = event.context, allowed = context.allowed, bendpointIndex = context.bendpointIndex, draggerGfx = context.draggerGfx, hover = context.hover, type = context.type, connection = context.connection, source = connection.source, target = connection.target, newWaypoints = connection.waypoints.slice(), bendpoint = { x: event.x, y: event.y }, hints = context.hints || {}, drawPreviewHints = {};
    if (connectionPreview) {
      if (hints.connectionStart) {
        drawPreviewHints.connectionStart = hints.connectionStart;
      }
      if (hints.connectionEnd) {
        drawPreviewHints.connectionEnd = hints.connectionEnd;
      }
      if (type === RECONNECT_START) {
        if (isReverse$2(context)) {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
          drawPreviewHints.source = target;
          drawPreviewHints.target = hover || source;
          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
          drawPreviewHints.source = hover || source;
          drawPreviewHints.target = target;
        }
      } else if (type === RECONNECT_END) {
        if (isReverse$2(context)) {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
          drawPreviewHints.source = hover || target;
          drawPreviewHints.target = source;
          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
          drawPreviewHints.source = source;
          drawPreviewHints.target = hover || target;
        }
      } else {
        drawPreviewHints.noCropping = true;
        drawPreviewHints.noLayout = true;
        newWaypoints[bendpointIndex] = bendpoint;
      }
      if (type === UPDATE_WAYPOINTS) {
        newWaypoints = bendpointMove.cropWaypoints(connection, newWaypoints);
      }
      drawPreviewHints.waypoints = newWaypoints;
      connectionPreview.drawPreview(context, allowed, drawPreviewHints);
    }
    translate$4(draggerGfx, event.x, event.y);
  }, this);
  eventBus.on([
    "bendpoint.move.end",
    "bendpoint.move.cancel"
  ], HIGH_PRIORITY$i, function(event) {
    var context = event.context, connection = context.connection, draggerGfx = context.draggerGfx, hover = context.hover, target = context.target, waypoints = context.waypoints;
    connection.waypoints = waypoints;
    remove$4(draggerGfx);
    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING$1);
    canvas.removeMarker(connection, MARKER_ELEMENT_HIDDEN);
    if (hover) {
      canvas.removeMarker(hover, MARKER_OK$4);
      canvas.removeMarker(hover, target ? MARKER_OK$4 : MARKER_NOT_OK$4);
    }
    if (connectionPreview) {
      connectionPreview.cleanUp(context);
    }
  });
}
BendpointMovePreview.$inject = [
  "bendpointMove",
  "injector",
  "eventBus",
  "canvas"
];
var MARKER_CONNECT_HOVER = "connect-hover", MARKER_CONNECT_UPDATING = "djs-updating";
function axisAdd(point, axis, delta2) {
  return axisSet(point, axis, point[axis] + delta2);
}
function axisSet(point, axis, value) {
  return {
    x: axis === "x" ? value : point.x,
    y: axis === "y" ? value : point.y
  };
}
function axisFenced(position, segmentStart, segmentEnd, axis) {
  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]), minValue = Math.min(segmentStart[axis], segmentEnd[axis]);
  var padding = 20;
  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);
  return axisSet(segmentStart, axis, fencedValue);
}
function flipAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getDocking$2(point, referenceElement, moveAxis) {
  var referenceMid, inverseAxis;
  if (point.original) {
    return point.original;
  } else {
    referenceMid = getMid(referenceElement);
    inverseAxis = flipAxis(moveAxis);
    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);
  }
}
function ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, modeling) {
  var connectionDocking = injector.get("connectionDocking", false);
  this.start = function(event, connection, idx) {
    var context, gfx = canvas.getGraphics(connection), segmentStartIndex = idx - 1, segmentEndIndex = idx, waypoints = connection.waypoints, segmentStart = waypoints[segmentStartIndex], segmentEnd = waypoints[segmentEndIndex], intersection2 = getConnectionIntersection(canvas, waypoints, event), direction, axis, dragPosition;
    direction = pointsAligned(segmentStart, segmentEnd);
    if (!direction) {
      return;
    }
    axis = direction === "v" ? "x" : "y";
    if (segmentStartIndex === 0) {
      segmentStart = getDocking$2(segmentStart, connection.source, axis);
    }
    if (segmentEndIndex === waypoints.length - 1) {
      segmentEnd = getDocking$2(segmentEnd, connection.target, axis);
    }
    if (intersection2) {
      dragPosition = intersection2.point;
    } else {
      dragPosition = {
        x: (segmentStart.x + segmentEnd.x) / 2,
        y: (segmentStart.y + segmentEnd.y) / 2
      };
    }
    context = {
      connection,
      segmentStartIndex,
      segmentEndIndex,
      segmentStart,
      segmentEnd,
      axis,
      dragPosition
    };
    dragging.init(event, dragPosition, "connectionSegment.move", {
      cursor: axis === "x" ? "resize-ew" : "resize-ns",
      data: {
        connection,
        connectionGfx: gfx,
        context
      }
    });
  };
  function cropConnection(connection, newWaypoints) {
    if (!connectionDocking) {
      return newWaypoints;
    }
    var oldWaypoints = connection.waypoints, croppedWaypoints;
    connection.waypoints = newWaypoints;
    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);
    connection.waypoints = oldWaypoints;
    return croppedWaypoints;
  }
  function redrawConnection(data) {
    graphicsFactory.update("connection", data.connection, data.connectionGfx);
  }
  function updateDragger(context, segmentOffset, event) {
    var newWaypoints = context.newWaypoints, segmentStartIndex = context.segmentStartIndex + segmentOffset, segmentStart = newWaypoints[segmentStartIndex], segmentEndIndex = context.segmentEndIndex + segmentOffset, segmentEnd = newWaypoints[segmentEndIndex], axis = flipAxis(context.axis);
    var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);
    translate$4(context.draggerGfx, draggerPosition.x, draggerPosition.y);
  }
  function filterRedundantWaypoints2(waypoints, segmentStartIndex) {
    var segmentOffset = 0;
    var filteredWaypoints = waypoints.filter(function(r, idx) {
      if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {
        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;
        return false;
      }
      return true;
    });
    return {
      waypoints: filteredWaypoints,
      segmentOffset
    };
  }
  eventBus.on("connectionSegment.move.start", function(event) {
    var context = event.context, connection = event.connection, layer = canvas.getLayer("overlays");
    context.originalWaypoints = connection.waypoints.slice();
    context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);
    classes(context.draggerGfx).add("djs-dragging");
    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
  });
  eventBus.on("connectionSegment.move.move", function(event) {
    var context = event.context, connection = context.connection, segmentStartIndex = context.segmentStartIndex, segmentEndIndex = context.segmentEndIndex, segmentStart = context.segmentStart, segmentEnd = context.segmentEnd, axis = context.axis;
    var newWaypoints = context.originalWaypoints.slice(), newSegmentStart = axisAdd(segmentStart, axis, event["d" + axis]), newSegmentEnd = axisAdd(segmentEnd, axis, event["d" + axis]);
    var waypointCount = newWaypoints.length, segmentOffset = 0;
    newWaypoints[segmentStartIndex] = newSegmentStart;
    newWaypoints[segmentEndIndex] = newSegmentEnd;
    var sourceToSegmentOrientation, targetToSegmentOrientation;
    if (segmentStartIndex < 2) {
      sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart);
      if (segmentStartIndex === 1) {
        if (sourceToSegmentOrientation === "intersect") {
          newWaypoints.shift();
          newWaypoints[0] = newSegmentStart;
          segmentOffset--;
        }
      } else {
        if (sourceToSegmentOrientation !== "intersect") {
          newWaypoints.unshift(segmentStart);
          segmentOffset++;
        }
      }
    }
    if (segmentEndIndex > waypointCount - 3) {
      targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd);
      if (segmentEndIndex === waypointCount - 2) {
        if (targetToSegmentOrientation === "intersect") {
          newWaypoints.pop();
          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;
        }
      } else {
        if (targetToSegmentOrientation !== "intersect") {
          newWaypoints.push(segmentEnd);
        }
      }
    }
    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);
    updateDragger(context, segmentOffset, event);
    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;
    redrawConnection(event);
  });
  eventBus.on("connectionSegment.move.hover", function(event) {
    event.context.hover = event.hover;
    canvas.addMarker(event.hover, MARKER_CONNECT_HOVER);
  });
  eventBus.on([
    "connectionSegment.move.out",
    "connectionSegment.move.cleanup"
  ], function(event) {
    var hover = event.context.hover;
    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
    }
  });
  eventBus.on("connectionSegment.move.cleanup", function(event) {
    var context = event.context, connection = context.connection;
    if (context.draggerGfx) {
      remove$4(context.draggerGfx);
    }
    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);
  });
  eventBus.on([
    "connectionSegment.move.cancel",
    "connectionSegment.move.end"
  ], function(event) {
    var context = event.context, connection = context.connection;
    connection.waypoints = context.originalWaypoints;
    redrawConnection(event);
  });
  eventBus.on("connectionSegment.move.end", function(event) {
    var context = event.context, connection = context.connection, newWaypoints = context.newWaypoints, newSegmentStartIndex = context.newSegmentStartIndex;
    newWaypoints = newWaypoints.map(function(p) {
      return {
        original: p.original,
        x: Math.round(p.x),
        y: Math.round(p.y)
      };
    });
    var filtered = filterRedundantWaypoints2(newWaypoints, newSegmentStartIndex);
    var filteredWaypoints = filtered.waypoints, croppedWaypoints = cropConnection(connection, filteredWaypoints), segmentOffset = filtered.segmentOffset;
    var hints = {
      segmentMove: {
        segmentStartIndex: context.segmentStartIndex,
        newSegmentStartIndex: newSegmentStartIndex + segmentOffset
      }
    };
    modeling.updateWaypoints(connection, croppedWaypoints, hints);
  });
}
ConnectionSegmentMove.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "dragging",
  "graphicsFactory",
  "modeling"
];
var abs$6 = Math.abs, round$7 = Math.round;
function snapTo(value, values2, tolerance) {
  tolerance = tolerance === void 0 ? 10 : tolerance;
  var idx, snapValue;
  for (idx = 0; idx < values2.length; idx++) {
    snapValue = values2[idx];
    if (abs$6(snapValue - value) <= tolerance) {
      return snapValue;
    }
  }
}
function topLeft(bounds) {
  return {
    x: bounds.x,
    y: bounds.y
  };
}
function bottomRight(bounds) {
  return {
    x: bounds.x + bounds.width,
    y: bounds.y + bounds.height
  };
}
function mid$2(bounds, defaultValue) {
  if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {
    return defaultValue;
  }
  return {
    x: round$7(bounds.x + bounds.width / 2),
    y: round$7(bounds.y + bounds.height / 2)
  };
}
function isSnapped(event, axis) {
  var snapped = event.snapped;
  if (!snapped) {
    return false;
  }
  if (typeof axis === "string") {
    return snapped[axis];
  }
  return snapped.x && snapped.y;
}
function setSnapped(event, axis, value) {
  if (typeof axis !== "string") {
    throw new Error("axis must be in [x, y]");
  }
  if (typeof value !== "number" && value !== false) {
    throw new Error("value must be Number or false");
  }
  var delta2, previousValue = event[axis];
  var snapped = event.snapped = event.snapped || {};
  if (value === false) {
    snapped[axis] = false;
  } else {
    snapped[axis] = true;
    delta2 = value - previousValue;
    event[axis] += delta2;
    event["d" + axis] += delta2;
  }
  return previousValue;
}
function getChildren(parent2) {
  return parent2.children || [];
}
var abs$5 = Math.abs, round$6 = Math.round;
var TOLERANCE = 10;
function BendpointSnapping(eventBus) {
  function snapTo2(values2, value) {
    if (isArray$n(values2)) {
      var i = values2.length;
      while (i--)
        if (abs$5(values2[i] - value) <= TOLERANCE) {
          return values2[i];
        }
    } else {
      values2 = +values2;
      var rem = value % values2;
      if (rem < TOLERANCE) {
        return value - rem;
      }
      if (rem > values2 - TOLERANCE) {
        return value - rem + values2;
      }
    }
    return value;
  }
  function mid2(element) {
    if (element.width) {
      return {
        x: round$6(element.width / 2 + element.x),
        y: round$6(element.height / 2 + element.y)
      };
    }
  }
  function getConnectionSegmentSnaps(context) {
    var snapPoints = context.snapPoints, connection = context.connection, waypoints = connection.waypoints, segmentStart = context.segmentStart, segmentStartIndex = context.segmentStartIndex, segmentEnd = context.segmentEnd, segmentEndIndex = context.segmentEndIndex, axis = context.axis;
    if (snapPoints) {
      return snapPoints;
    }
    var referenceWaypoints = [
      waypoints[segmentStartIndex - 1],
      segmentStart,
      segmentEnd,
      waypoints[segmentEndIndex + 1]
    ];
    if (segmentStartIndex < 2) {
      referenceWaypoints.unshift(mid2(connection.source));
    }
    if (segmentEndIndex > waypoints.length - 3) {
      referenceWaypoints.unshift(mid2(connection.target));
    }
    context.snapPoints = snapPoints = { horizontal: [], vertical: [] };
    forEach$q(referenceWaypoints, function(p) {
      if (p) {
        p = p.original || p;
        if (axis === "y") {
          snapPoints.horizontal.push(p.y);
        }
        if (axis === "x") {
          snapPoints.vertical.push(p.x);
        }
      }
    });
    return snapPoints;
  }
  eventBus.on("connectionSegment.move.move", 1500, function(event) {
    var context = event.context, snapPoints = getConnectionSegmentSnaps(context), x = event.x, y = event.y, sx, sy;
    if (!snapPoints) {
      return;
    }
    sx = snapTo2(snapPoints.vertical, x);
    sy = snapTo2(snapPoints.horizontal, y);
    var cx = x - sx, cy = y - sy;
    assign$e(event, {
      dx: event.dx - cx,
      dy: event.dy - cy,
      x: sx,
      y: sy
    });
    if (cx || snapPoints.vertical.indexOf(x) !== -1) {
      setSnapped(event, "x", sx);
    }
    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {
      setSnapped(event, "y", sy);
    }
  });
  function getBendpointSnaps(context) {
    var snapPoints = context.snapPoints, waypoints = context.connection.waypoints, bendpointIndex = context.bendpointIndex;
    if (snapPoints) {
      return snapPoints;
    }
    var referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];
    context.snapPoints = snapPoints = { horizontal: [], vertical: [] };
    forEach$q(referenceWaypoints, function(p) {
      if (p) {
        p = p.original || p;
        snapPoints.horizontal.push(p.y);
        snapPoints.vertical.push(p.x);
      }
    });
    return snapPoints;
  }
  eventBus.on(["bendpoint.move.move", "bendpoint.move.end"], 1500, function(event) {
    var context = event.context, snapPoints = getBendpointSnaps(context), hover = context.hover, hoverMid = hover && mid2(hover), x = event.x, y = event.y, sx, sy;
    if (!snapPoints) {
      return;
    }
    sx = snapTo2(hoverMid ? snapPoints.vertical.concat([hoverMid.x]) : snapPoints.vertical, x);
    sy = snapTo2(hoverMid ? snapPoints.horizontal.concat([hoverMid.y]) : snapPoints.horizontal, y);
    var cx = x - sx, cy = y - sy;
    assign$e(event, {
      dx: event.dx - cx,
      dy: event.dy - cy,
      x: event.x - cx,
      y: event.y - cy
    });
    if (cx || snapPoints.vertical.indexOf(x) !== -1) {
      setSnapped(event, "x", sx);
    }
    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {
      setSnapped(event, "y", sy);
    }
  });
}
BendpointSnapping.$inject = ["eventBus"];
var BendpointsModule = {
  __depends__: [
    DraggingModule,
    RulesModule$1
  ],
  __init__: ["bendpoints", "bendpointSnapping", "bendpointMovePreview"],
  bendpoints: ["type", Bendpoints],
  bendpointMove: ["type", BendpointMove],
  bendpointMovePreview: ["type", BendpointMovePreview],
  connectionSegmentMove: ["type", ConnectionSegmentMove],
  bendpointSnapping: ["type", BendpointSnapping]
};
function Connect(eventBus, dragging, modeling, rules) {
  function canConnect2(source, target) {
    return rules.allowed("connection.create", {
      source,
      target
    });
  }
  function canConnectReverse(source, target) {
    return canConnect2(target, source);
  }
  eventBus.on("connect.hover", function(event) {
    var context = event.context, start = context.start, hover = event.hover, canExecute;
    context.hover = hover;
    canExecute = context.canExecute = canConnect2(start, hover);
    if (isNil(canExecute)) {
      return;
    }
    if (canExecute !== false) {
      context.source = start;
      context.target = hover;
      return;
    }
    canExecute = context.canExecute = canConnectReverse(start, hover);
    if (isNil(canExecute)) {
      return;
    }
    if (canExecute !== false) {
      context.source = hover;
      context.target = start;
    }
  });
  eventBus.on(["connect.out", "connect.cleanup"], function(event) {
    var context = event.context;
    context.hover = null;
    context.source = null;
    context.target = null;
    context.canExecute = false;
  });
  eventBus.on("connect.end", function(event) {
    var context = event.context, canExecute = context.canExecute, connectionStart = context.connectionStart, connectionEnd = {
      x: event.x,
      y: event.y
    }, source = context.source, target = context.target;
    if (!canExecute) {
      return false;
    }
    var attrs = null, hints = {
      connectionStart: isReverse$1(context) ? connectionEnd : connectionStart,
      connectionEnd: isReverse$1(context) ? connectionStart : connectionEnd
    };
    if (isObject$e(canExecute)) {
      attrs = canExecute;
    }
    modeling.connect(source, target, attrs, hints);
  });
  this.start = function(event, start, connectionStart, autoActivate) {
    if (!isObject$e(connectionStart)) {
      autoActivate = connectionStart;
      connectionStart = getMid(start);
    }
    dragging.init(event, "connect", {
      autoActivate,
      data: {
        shape: start,
        context: {
          start,
          connectionStart
        }
      }
    });
  };
}
Connect.$inject = [
  "eventBus",
  "dragging",
  "modeling",
  "rules"
];
function isReverse$1(context) {
  var hover = context.hover, source = context.source, target = context.target;
  return hover && source && hover === source && source !== target;
}
var HIGH_PRIORITY$h = 1100, LOW_PRIORITY$j = 900;
var MARKER_OK$3 = "connect-ok", MARKER_NOT_OK$3 = "connect-not-ok";
function ConnectPreview(injector, eventBus, canvas) {
  var connectionPreview = injector.get("connectionPreview", false);
  connectionPreview && eventBus.on("connect.move", function(event) {
    var context = event.context, canConnect2 = context.canExecute, hover = context.hover, source = context.source, start = context.start, startPosition = context.startPosition, target = context.target, connectionStart = context.connectionStart || startPosition, connectionEnd = context.connectionEnd || {
      x: event.x,
      y: event.y
    }, previewStart = connectionStart, previewEnd = connectionEnd;
    if (isReverse$1(context)) {
      previewStart = connectionEnd;
      previewEnd = connectionStart;
    }
    connectionPreview.drawPreview(context, canConnect2, {
      source: source || start,
      target: target || hover,
      connectionStart: previewStart,
      connectionEnd: previewEnd
    });
  });
  eventBus.on("connect.hover", LOW_PRIORITY$j, function(event) {
    var context = event.context, hover = event.hover, canExecute = context.canExecute;
    if (canExecute === null) {
      return;
    }
    canvas.addMarker(hover, canExecute ? MARKER_OK$3 : MARKER_NOT_OK$3);
  });
  eventBus.on([
    "connect.out",
    "connect.cleanup"
  ], HIGH_PRIORITY$h, function(event) {
    var hover = event.hover;
    if (hover) {
      canvas.removeMarker(hover, MARKER_OK$3);
      canvas.removeMarker(hover, MARKER_NOT_OK$3);
    }
  });
  connectionPreview && eventBus.on("connect.cleanup", function(event) {
    connectionPreview.cleanUp(event.context);
  });
}
ConnectPreview.$inject = [
  "injector",
  "eventBus",
  "canvas"
];
var ConnectModule = {
  __depends__: [
    SelectionModule,
    RulesModule$1,
    DraggingModule
  ],
  __init__: [
    "connectPreview"
  ],
  connect: ["type", Connect],
  connectPreview: ["type", ConnectPreview]
};
var MARKER_CONNECTION_PREVIEW = "djs-connection-preview";
function ConnectionPreview(injector, canvas, graphicsFactory, elementFactory) {
  this._canvas = canvas;
  this._graphicsFactory = graphicsFactory;
  this._elementFactory = elementFactory;
  this._connectionDocking = injector.get("connectionDocking", false);
  this._layouter = injector.get("layouter", false);
}
ConnectionPreview.$inject = [
  "injector",
  "canvas",
  "graphicsFactory",
  "elementFactory"
];
ConnectionPreview.prototype.drawPreview = function(context, canConnect2, hints) {
  hints = hints || {};
  var connectionPreviewGfx = context.connectionPreviewGfx, getConnection = context.getConnection, source = hints.source, target = hints.target, waypoints = hints.waypoints, connectionStart = hints.connectionStart, connectionEnd = hints.connectionEnd, noLayout = hints.noLayout, noCropping = hints.noCropping, noNoop = hints.noNoop, connection;
  var self2 = this;
  if (!connectionPreviewGfx) {
    connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();
  }
  clear(connectionPreviewGfx);
  if (!getConnection) {
    getConnection = context.getConnection = cacheReturnValues(function(canConnect3, source2, target2) {
      return self2.getConnection(canConnect3, source2, target2);
    });
  }
  if (canConnect2) {
    connection = getConnection(canConnect2, source, target);
  }
  if (!connection) {
    !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);
    return;
  }
  connection.waypoints = waypoints || [];
  if (this._layouter && !noLayout) {
    connection.waypoints = this._layouter.layoutConnection(connection, {
      source,
      target,
      connectionStart,
      connectionEnd,
      waypoints: hints.waypoints || connection.waypoints
    });
  }
  if (!connection.waypoints || !connection.waypoints.length) {
    connection.waypoints = [
      source ? getMid(source) : connectionStart,
      target ? getMid(target) : connectionEnd
    ];
  }
  if (this._connectionDocking && (source || target) && !noCropping) {
    connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);
  }
  this._graphicsFactory.drawConnection(connectionPreviewGfx, connection);
};
ConnectionPreview.prototype.drawNoopPreview = function(connectionPreviewGfx, hints) {
  var source = hints.source, target = hints.target, start = hints.connectionStart || getMid(source), end = hints.connectionEnd || getMid(target);
  var waypoints = this.cropWaypoints(start, end, source, target);
  var connection = this.createNoopConnection(waypoints[0], waypoints[1]);
  append$3(connectionPreviewGfx, connection);
};
ConnectionPreview.prototype.cropWaypoints = function(start, end, source, target) {
  var graphicsFactory = this._graphicsFactory, sourcePath = source && graphicsFactory.getShapePath(source), targetPath = target && graphicsFactory.getShapePath(target), connectionPath = graphicsFactory.getConnectionPath({ waypoints: [start, end] });
  start = source && getElementLineIntersection(sourcePath, connectionPath, true) || start;
  end = target && getElementLineIntersection(targetPath, connectionPath, false) || end;
  return [start, end];
};
ConnectionPreview.prototype.cleanUp = function(context) {
  if (context && context.connectionPreviewGfx) {
    remove$4(context.connectionPreviewGfx);
  }
};
ConnectionPreview.prototype.getConnection = function(canConnect2) {
  var attrs = ensureConnectionAttrs(canConnect2);
  return this._elementFactory.createConnection(attrs);
};
ConnectionPreview.prototype.createConnectionPreviewGfx = function() {
  var gfx = create$2("g");
  attr(gfx, {
    pointerEvents: "none"
  });
  classes(gfx).add(MARKER_CONNECTION_PREVIEW);
  append$3(this._canvas.getActiveLayer(), gfx);
  return gfx;
};
ConnectionPreview.prototype.createNoopConnection = function(start, end) {
  var connection = create$2("polyline");
  attr(connection, {
    "stroke": "#333",
    "strokeDasharray": [1],
    "strokeWidth": 2,
    "pointer-events": "none"
  });
  attr(connection, { "points": [start.x, start.y, end.x, end.y] });
  return connection;
};
function cacheReturnValues(fn) {
  var returnValues = {};
  return function(firstArgument) {
    var key = JSON.stringify(firstArgument);
    var returnValue = returnValues[key];
    if (!returnValue) {
      returnValue = returnValues[key] = fn.apply(null, arguments);
    }
    return returnValue;
  };
}
function ensureConnectionAttrs(canConnect2) {
  if (isObject$e(canConnect2)) {
    return canConnect2;
  } else {
    return {};
  }
}
var ConnectionPreviewModule = {
  __init__: ["connectionPreview"],
  connectionPreview: ["type", ConnectionPreview]
};
function getOriginal$1(event) {
  return event.originalEvent || event.srcEvent;
}
function isButton(event, button) {
  return (getOriginal$1(event) || event).button === button;
}
function isPrimaryButton(event) {
  return isButton(event, 0);
}
function isAuxiliaryButton(event) {
  return isButton(event, 1);
}
function toSVGPoints(points) {
  var result = "";
  for (var i = 0, p; p = points[i]; i++) {
    result += p.x + "," + p.y + " ";
  }
  return result;
}
function createLine(points, attrs) {
  var line = create$2("polyline");
  attr(line, { points: toSVGPoints(points) });
  if (attrs) {
    attr(line, attrs);
  }
  return line;
}
function updateLine(gfx, points) {
  attr(gfx, { points: toSVGPoints(points) });
  return gfx;
}
function allowAll(event) {
  return true;
}
function allowPrimaryAndAuxiliary(event) {
  return isPrimaryButton(event) || isAuxiliaryButton(event);
}
var LOW_PRIORITY$i = 500;
function InteractionEvents(eventBus, elementRegistry, styles) {
  var self2 = this;
  function fire(type, event, element) {
    if (isIgnored(type, event)) {
      return;
    }
    var target, gfx, returnValue;
    if (!element) {
      target = event.delegateTarget || event.target;
      if (target) {
        gfx = target;
        element = elementRegistry.get(gfx);
      }
    } else {
      gfx = elementRegistry.getGraphics(element);
    }
    if (!gfx || !element) {
      return;
    }
    returnValue = eventBus.fire(type, {
      element,
      gfx,
      originalEvent: event
    });
    if (returnValue === false) {
      event.stopPropagation();
      event.preventDefault();
    }
  }
  var handlers = {};
  function mouseHandler(localEventName) {
    return handlers[localEventName];
  }
  function isIgnored(localEventName, event) {
    var filter2 = ignoredFilters[localEventName] || isPrimaryButton;
    return !filter2(event);
  }
  var bindings = {
    click: "element.click",
    contextmenu: "element.contextmenu",
    dblclick: "element.dblclick",
    mousedown: "element.mousedown",
    mousemove: "element.mousemove",
    mouseover: "element.hover",
    mouseout: "element.out",
    mouseup: "element.mouseup"
  };
  var ignoredFilters = {
    "element.contextmenu": allowAll,
    "element.mousedown": allowPrimaryAndAuxiliary,
    "element.mouseup": allowPrimaryAndAuxiliary,
    "element.click": allowPrimaryAndAuxiliary,
    "element.dblclick": allowPrimaryAndAuxiliary
  };
  function triggerMouseEvent(eventName, event, targetElement) {
    var localEventName = bindings[eventName];
    if (!localEventName) {
      throw new Error("unmapped DOM event name <" + eventName + ">");
    }
    return fire(localEventName, event, targetElement);
  }
  var ELEMENT_SELECTOR2 = "svg, .djs-element";
  function registerEvent(node2, event, localEvent, ignoredFilter) {
    var handler = handlers[localEvent] = function(event2) {
      fire(localEvent, event2);
    };
    if (ignoredFilter) {
      ignoredFilters[localEvent] = ignoredFilter;
    }
    handler.$delegate = delegate$1.bind(node2, ELEMENT_SELECTOR2, event, handler);
  }
  function unregisterEvent(node2, event, localEvent) {
    var handler = mouseHandler(localEvent);
    if (!handler) {
      return;
    }
    delegate$1.unbind(node2, event, handler.$delegate);
  }
  function registerEvents(svg) {
    forEach$q(bindings, function(val, key) {
      registerEvent(svg, key, val);
    });
  }
  function unregisterEvents(svg) {
    forEach$q(bindings, function(val, key) {
      unregisterEvent(svg, key, val);
    });
  }
  eventBus.on("canvas.destroy", function(event) {
    unregisterEvents(event.svg);
  });
  eventBus.on("canvas.init", function(event) {
    registerEvents(event.svg);
  });
  eventBus.on(["shape.added", "connection.added"], function(event) {
    var element = event.element, gfx = event.gfx;
    eventBus.fire("interactionEvents.createHit", { element, gfx });
  });
  eventBus.on([
    "shape.changed",
    "connection.changed"
  ], LOW_PRIORITY$i, function(event) {
    var element = event.element, gfx = event.gfx;
    eventBus.fire("interactionEvents.updateHit", { element, gfx });
  });
  eventBus.on("interactionEvents.createHit", LOW_PRIORITY$i, function(event) {
    var element = event.element, gfx = event.gfx;
    self2.createDefaultHit(element, gfx);
  });
  eventBus.on("interactionEvents.updateHit", function(event) {
    var element = event.element, gfx = event.gfx;
    self2.updateDefaultHit(element, gfx);
  });
  var STROKE_HIT_STYLE = createHitStyle("djs-hit djs-hit-stroke");
  var CLICK_STROKE_HIT_STYLE = createHitStyle("djs-hit djs-hit-click-stroke");
  var ALL_HIT_STYLE = createHitStyle("djs-hit djs-hit-all");
  var HIT_TYPES = {
    "all": ALL_HIT_STYLE,
    "click-stroke": CLICK_STROKE_HIT_STYLE,
    "stroke": STROKE_HIT_STYLE
  };
  function createHitStyle(classNames, attrs) {
    attrs = assign$e({
      stroke: "white",
      strokeWidth: 15
    }, attrs || {});
    return styles.cls(classNames, ["no-fill", "no-border"], attrs);
  }
  function applyStyle2(hit, type) {
    var attrs = HIT_TYPES[type];
    if (!attrs) {
      throw new Error("invalid hit type <" + type + ">");
    }
    attr(hit, attrs);
    return hit;
  }
  function appendHit(gfx, hit) {
    append$3(gfx, hit);
  }
  this.removeHits = function(gfx) {
    var hits = all(".djs-hit", gfx);
    forEach$q(hits, remove$4);
  };
  this.createDefaultHit = function(element, gfx) {
    var waypoints = element.waypoints, isFrame = element.isFrame, boxType;
    if (waypoints) {
      return this.createWaypointsHit(gfx, waypoints);
    } else {
      boxType = isFrame ? "stroke" : "all";
      return this.createBoxHit(gfx, boxType, {
        width: element.width,
        height: element.height
      });
    }
  };
  this.createWaypointsHit = function(gfx, waypoints) {
    var hit = createLine(waypoints);
    applyStyle2(hit, "stroke");
    appendHit(gfx, hit);
    return hit;
  };
  this.createBoxHit = function(gfx, type, attrs) {
    attrs = assign$e({
      x: 0,
      y: 0
    }, attrs);
    var hit = create$2("rect");
    applyStyle2(hit, type);
    attr(hit, attrs);
    appendHit(gfx, hit);
    return hit;
  };
  this.updateDefaultHit = function(element, gfx) {
    var hit = query(".djs-hit", gfx);
    if (!hit) {
      return;
    }
    if (element.waypoints) {
      updateLine(hit, element.waypoints);
    } else {
      attr(hit, {
        width: element.width,
        height: element.height
      });
    }
    return hit;
  };
  this.fire = fire;
  this.triggerMouseEvent = triggerMouseEvent;
  this.mouseHandler = mouseHandler;
  this.registerEvent = registerEvent;
  this.unregisterEvent = unregisterEvent;
}
InteractionEvents.$inject = [
  "eventBus",
  "elementRegistry",
  "styles"
];
var InteractionEventsModule$1 = {
  __init__: ["interactionEvents"],
  interactionEvents: ["type", InteractionEvents]
};
var min$3 = Math.min, max$5 = Math.max;
function preventDefault(e) {
  e.preventDefault();
}
function stopPropagation(e) {
  e.stopPropagation();
}
function isTextNode(node2) {
  return node2.nodeType === Node.TEXT_NODE;
}
function toArray(nodeList) {
  return [].slice.call(nodeList);
}
function TextBox(options) {
  this.container = options.container;
  this.parent = domify$h('<div class="djs-direct-editing-parent"><div class="djs-direct-editing-content" contenteditable="true"></div></div>');
  this.content = query("[contenteditable]", this.parent);
  this.keyHandler = options.keyHandler || function() {
  };
  this.resizeHandler = options.resizeHandler || function() {
  };
  this.autoResize = bind$3(this.autoResize, this);
  this.handlePaste = bind$3(this.handlePaste, this);
}
TextBox.prototype.create = function(bounds, style, value, options) {
  var self2 = this;
  var parent2 = this.parent, content = this.content, container = this.container;
  options = this.options = options || {};
  style = this.style = style || {};
  var parentStyle = pick$3(style, [
    "width",
    "height",
    "maxWidth",
    "maxHeight",
    "minWidth",
    "minHeight",
    "left",
    "top",
    "backgroundColor",
    "position",
    "overflow",
    "border",
    "wordWrap",
    "textAlign",
    "outline",
    "transform"
  ]);
  assign$e(parent2.style, {
    width: bounds.width + "px",
    height: bounds.height + "px",
    maxWidth: bounds.maxWidth + "px",
    maxHeight: bounds.maxHeight + "px",
    minWidth: bounds.minWidth + "px",
    minHeight: bounds.minHeight + "px",
    left: bounds.x + "px",
    top: bounds.y + "px",
    backgroundColor: "#ffffff",
    position: "absolute",
    overflow: "visible",
    border: "1px solid #ccc",
    boxSizing: "border-box",
    wordWrap: "normal",
    textAlign: "center",
    outline: "none"
  }, parentStyle);
  var contentStyle = pick$3(style, [
    "fontFamily",
    "fontSize",
    "fontWeight",
    "lineHeight",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft"
  ]);
  assign$e(content.style, {
    boxSizing: "border-box",
    width: "100%",
    outline: "none",
    wordWrap: "break-word"
  }, contentStyle);
  if (options.centerVertically) {
    assign$e(content.style, {
      position: "absolute",
      top: "50%",
      transform: "translate(0, -50%)"
    }, contentStyle);
  }
  content.innerText = value;
  componentEvent.bind(content, "keydown", this.keyHandler);
  componentEvent.bind(content, "mousedown", stopPropagation);
  componentEvent.bind(content, "paste", self2.handlePaste);
  if (options.autoResize) {
    componentEvent.bind(content, "input", this.autoResize);
  }
  if (options.resizable) {
    this.resizable(style);
  }
  container.appendChild(parent2);
  this.setSelection(content.lastChild, content.lastChild && content.lastChild.length);
  return parent2;
};
TextBox.prototype.handlePaste = function(e) {
  var options = this.options, style = this.style;
  e.preventDefault();
  var text;
  if (e.clipboardData) {
    text = e.clipboardData.getData("text/plain");
  } else {
    text = window.clipboardData.getData("Text");
  }
  this.insertText(text);
  if (options.autoResize) {
    var hasResized = this.autoResize(style);
    if (hasResized) {
      this.resizeHandler(hasResized);
    }
  }
};
TextBox.prototype.insertText = function(text) {
  text = normalizeEndOfLineSequences$1(text);
  var success = document.execCommand("insertText", false, text);
  if (success) {
    return;
  }
  this._insertTextIE(text);
};
TextBox.prototype._insertTextIE = function(text) {
  var range2 = this.getSelection(), startContainer = range2.startContainer, endContainer = range2.endContainer, startOffset = range2.startOffset, endOffset = range2.endOffset, commonAncestorContainer = range2.commonAncestorContainer;
  var childNodesArray = toArray(commonAncestorContainer.childNodes);
  var container, offset2;
  if (isTextNode(commonAncestorContainer)) {
    var containerTextContent = startContainer.textContent;
    startContainer.textContent = containerTextContent.substring(0, startOffset) + text + containerTextContent.substring(endOffset);
    container = startContainer;
    offset2 = startOffset + text.length;
  } else if (startContainer === this.content && endContainer === this.content) {
    var textNode = document.createTextNode(text);
    this.content.insertBefore(textNode, childNodesArray[startOffset]);
    container = textNode;
    offset2 = textNode.textContent.length;
  } else {
    var startContainerChildIndex = childNodesArray.indexOf(startContainer), endContainerChildIndex = childNodesArray.indexOf(endContainer);
    childNodesArray.forEach(function(childNode, index2) {
      if (index2 === startContainerChildIndex) {
        childNode.textContent = startContainer.textContent.substring(0, startOffset) + text + endContainer.textContent.substring(endOffset);
      } else if (index2 > startContainerChildIndex && index2 <= endContainerChildIndex) {
        remove$5(childNode);
      }
    });
    container = startContainer;
    offset2 = startOffset + text.length;
  }
  if (container && offset2 !== void 0) {
    setTimeout(function() {
      self.setSelection(container, offset2);
    });
  }
};
TextBox.prototype.autoResize = function() {
  var parent2 = this.parent, content = this.content;
  var fontSize = parseInt(this.style.fontSize) || 12;
  if (content.scrollHeight > parent2.offsetHeight || content.scrollHeight < parent2.offsetHeight - fontSize) {
    var bounds = parent2.getBoundingClientRect();
    var height = content.scrollHeight;
    parent2.style.height = height + "px";
    this.resizeHandler({
      width: bounds.width,
      height: bounds.height,
      dx: 0,
      dy: height - bounds.height
    });
  }
};
TextBox.prototype.resizable = function() {
  var self2 = this;
  var parent2 = this.parent, resizeHandle = this.resizeHandle;
  var minWidth = parseInt(this.style.minWidth) || 0, minHeight = parseInt(this.style.minHeight) || 0, maxWidth = parseInt(this.style.maxWidth) || Infinity, maxHeight = parseInt(this.style.maxHeight) || Infinity;
  if (!resizeHandle) {
    resizeHandle = this.resizeHandle = domify$h('<div class="djs-direct-editing-resize-handle"></div>');
    var startX, startY, startWidth, startHeight;
    var onMouseDown = function(e) {
      preventDefault(e);
      stopPropagation(e);
      startX = e.clientX;
      startY = e.clientY;
      var bounds = parent2.getBoundingClientRect();
      startWidth = bounds.width;
      startHeight = bounds.height;
      componentEvent.bind(document, "mousemove", onMouseMove);
      componentEvent.bind(document, "mouseup", onMouseUp);
    };
    var onMouseMove = function(e) {
      preventDefault(e);
      stopPropagation(e);
      var newWidth = min$3(max$5(startWidth + e.clientX - startX, minWidth), maxWidth);
      var newHeight = min$3(max$5(startHeight + e.clientY - startY, minHeight), maxHeight);
      parent2.style.width = newWidth + "px";
      parent2.style.height = newHeight + "px";
      self2.resizeHandler({
        width: startWidth,
        height: startHeight,
        dx: e.clientX - startX,
        dy: e.clientY - startY
      });
    };
    var onMouseUp = function(e) {
      preventDefault(e);
      stopPropagation(e);
      componentEvent.unbind(document, "mousemove", onMouseMove, false);
      componentEvent.unbind(document, "mouseup", onMouseUp, false);
    };
    componentEvent.bind(resizeHandle, "mousedown", onMouseDown);
  }
  assign$e(resizeHandle.style, {
    position: "absolute",
    bottom: "0px",
    right: "0px",
    cursor: "nwse-resize",
    width: "0",
    height: "0",
    borderTop: (parseInt(this.style.fontSize) / 4 || 3) + "px solid transparent",
    borderRight: (parseInt(this.style.fontSize) / 4 || 3) + "px solid #ccc",
    borderBottom: (parseInt(this.style.fontSize) / 4 || 3) + "px solid #ccc",
    borderLeft: (parseInt(this.style.fontSize) / 4 || 3) + "px solid transparent"
  });
  parent2.appendChild(resizeHandle);
};
TextBox.prototype.destroy = function() {
  var parent2 = this.parent, content = this.content, resizeHandle = this.resizeHandle;
  content.innerText = "";
  parent2.removeAttribute("style");
  content.removeAttribute("style");
  componentEvent.unbind(content, "keydown", this.keyHandler);
  componentEvent.unbind(content, "mousedown", stopPropagation);
  componentEvent.unbind(content, "input", this.autoResize);
  componentEvent.unbind(content, "paste", this.handlePaste);
  if (resizeHandle) {
    resizeHandle.removeAttribute("style");
    remove$5(resizeHandle);
  }
  remove$5(parent2);
};
TextBox.prototype.getValue = function() {
  return this.content.innerText.trim();
};
TextBox.prototype.getSelection = function() {
  var selection = window.getSelection(), range2 = selection.getRangeAt(0);
  return range2;
};
TextBox.prototype.setSelection = function(container, offset2) {
  var range2 = document.createRange();
  if (container === null) {
    range2.selectNodeContents(this.content);
  } else {
    range2.setStart(container, offset2);
    range2.setEnd(container, offset2);
  }
  var selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range2);
};
function normalizeEndOfLineSequences$1(string) {
  return string.replace(/\r\n|\r|\n/g, "\n");
}
function DirectEditing(eventBus, canvas) {
  this._eventBus = eventBus;
  this._providers = [];
  this._textbox = new TextBox({
    container: canvas.getContainer(),
    keyHandler: bind$3(this._handleKey, this),
    resizeHandler: bind$3(this._handleResize, this)
  });
}
DirectEditing.$inject = ["eventBus", "canvas"];
DirectEditing.prototype.registerProvider = function(provider) {
  this._providers.push(provider);
};
DirectEditing.prototype.isActive = function() {
  return !!this._active;
};
DirectEditing.prototype.cancel = function() {
  if (!this._active) {
    return;
  }
  this._fire("cancel");
  this.close();
};
DirectEditing.prototype._fire = function(event, context) {
  this._eventBus.fire("directEditing." + event, context || { active: this._active });
};
DirectEditing.prototype.close = function() {
  this._textbox.destroy();
  this._fire("deactivate");
  this._active = null;
  this.resizable = void 0;
};
DirectEditing.prototype.complete = function() {
  var active = this._active;
  if (!active) {
    return;
  }
  var containerBounds, previousBounds = active.context.bounds, newBounds = this.$textbox.getBoundingClientRect(), newText = this.getValue(), previousText = active.context.text;
  if (newText !== previousText || newBounds.height !== previousBounds.height || newBounds.width !== previousBounds.width) {
    containerBounds = this._textbox.container.getBoundingClientRect();
    active.provider.update(active.element, newText, active.context.text, {
      x: newBounds.left - containerBounds.left,
      y: newBounds.top - containerBounds.top,
      width: newBounds.width,
      height: newBounds.height
    });
  }
  this._fire("complete");
  this.close();
};
DirectEditing.prototype.getValue = function() {
  return this._textbox.getValue();
};
DirectEditing.prototype._handleKey = function(e) {
  e.stopPropagation();
  var key = e.keyCode || e.charCode;
  if (key === 27) {
    e.preventDefault();
    return this.cancel();
  }
  if (key === 13 && !e.shiftKey) {
    e.preventDefault();
    return this.complete();
  }
};
DirectEditing.prototype._handleResize = function(event) {
  this._fire("resize", event);
};
DirectEditing.prototype.activate = function(element) {
  if (this.isActive()) {
    this.cancel();
  }
  var context;
  var provider = find$e(this._providers, function(p) {
    return (context = p.activate(element)) ? p : null;
  });
  if (context) {
    this.$textbox = this._textbox.create(context.bounds, context.style, context.text, context.options);
    this._active = {
      element,
      context,
      provider
    };
    if (context.options && context.options.resizable) {
      this.resizable = true;
    }
    this._fire("activate");
  }
  return !!context;
};
var DirectEditingModule = {
  __depends__: [
    InteractionEventsModule$1
  ],
  __init__: ["directEditing"],
  directEditing: ["type", DirectEditing]
};
var entrySelector = ".entry";
var DEFAULT_PRIORITY$5 = 1e3;
function ContextPad(config, eventBus, overlays) {
  this._eventBus = eventBus;
  this._overlays = overlays;
  var scale = isDefined(config && config.scale) ? config.scale : {
    min: 1,
    max: 1.5
  };
  this._overlaysConfig = {
    position: {
      right: -9,
      top: -6
    },
    scale
  };
  this._current = null;
  this._init();
}
ContextPad.$inject = [
  "config.contextPad",
  "eventBus",
  "overlays"
];
ContextPad.prototype._init = function() {
  var eventBus = this._eventBus;
  var self2 = this;
  eventBus.on("selection.changed", function(e) {
    var selection = e.newSelection;
    if (selection.length === 1) {
      self2.open(selection[0]);
    } else {
      self2.close();
    }
  });
  eventBus.on("elements.delete", function(event) {
    var elements = event.elements;
    forEach$q(elements, function(e) {
      if (self2.isOpen(e)) {
        self2.close();
      }
    });
  });
  eventBus.on("element.changed", function(event) {
    var element = event.element, current = self2._current;
    if (current && current.element === element) {
      self2.open(element, true);
    }
  });
};
ContextPad.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY$5;
  }
  this._eventBus.on("contextPad.getProviders", priority, function(event) {
    event.providers.push(provider);
  });
};
ContextPad.prototype.getEntries = function(element) {
  var providers = this._getProviders();
  var entries = {};
  forEach$q(providers, function(provider) {
    var entriesOrUpdater = provider.getContextPadEntries(element);
    if (isFunction$6(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      forEach$q(entriesOrUpdater, function(entry, id2) {
        entries[id2] = entry;
      });
    }
  });
  return entries;
};
ContextPad.prototype.trigger = function(action, event, autoActivate) {
  var element = this._current.element, entries = this._current.entries, entry, handler, originalEvent, button = event.delegateTarget || event.target;
  if (!button) {
    return event.preventDefault();
  }
  entry = entries[attr$1(button, "data-action")];
  handler = entry.action;
  originalEvent = event.originalEvent || event;
  if (isFunction$6(handler)) {
    if (action === "click") {
      return handler(originalEvent, element, autoActivate);
    }
  } else {
    if (handler[action]) {
      return handler[action](originalEvent, element, autoActivate);
    }
  }
  event.preventDefault();
};
ContextPad.prototype.open = function(element, force) {
  if (!force && this.isOpen(element)) {
    return;
  }
  this.close();
  this._updateAndOpen(element);
};
ContextPad.prototype._getProviders = function() {
  var event = this._eventBus.createEvent({
    type: "contextPad.getProviders",
    providers: []
  });
  this._eventBus.fire(event);
  return event.providers;
};
ContextPad.prototype._updateAndOpen = function(element) {
  var entries = this.getEntries(element), pad = this.getPad(element), html = pad.html;
  forEach$q(entries, function(entry, id2) {
    var grouping = entry.group || "default", control = domify$h(entry.html || '<div class="entry" draggable="true"></div>'), container;
    attr$1(control, "data-action", id2);
    container = query("[data-group=" + grouping + "]", html);
    if (!container) {
      container = domify$h('<div class="group" data-group="' + grouping + '"></div>');
      html.appendChild(container);
    }
    container.appendChild(control);
    if (entry.className) {
      addClasses$1(control, entry.className);
    }
    if (entry.title) {
      attr$1(control, "title", entry.title);
    }
    if (entry.imageUrl) {
      control.appendChild(domify$h('<img src="' + entry.imageUrl + '">'));
    }
  });
  classes$1(html).add("open");
  this._current = {
    element,
    pad,
    entries
  };
  this._eventBus.fire("contextPad.open", { current: this._current });
};
ContextPad.prototype.getPad = function(element) {
  if (this.isOpen()) {
    return this._current.pad;
  }
  var self2 = this;
  var overlays = this._overlays;
  var html = domify$h('<div class="djs-context-pad"></div>');
  var overlaysConfig = assign$e({
    html
  }, this._overlaysConfig);
  delegate$1.bind(html, entrySelector, "click", function(event) {
    self2.trigger("click", event);
  });
  delegate$1.bind(html, entrySelector, "dragstart", function(event) {
    self2.trigger("dragstart", event);
  });
  componentEvent.bind(html, "mousedown", function(event) {
    event.stopPropagation();
  });
  this._overlayId = overlays.add(element, "context-pad", overlaysConfig);
  var pad = overlays.get(this._overlayId);
  this._eventBus.fire("contextPad.create", { element, pad });
  return pad;
};
ContextPad.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }
  this._overlays.remove(this._overlayId);
  this._overlayId = null;
  this._eventBus.fire("contextPad.close", { current: this._current });
  this._current = null;
};
ContextPad.prototype.isOpen = function(element) {
  return !!this._current && (!element ? true : this._current.element === element);
};
function addClasses$1(element, classNames) {
  var classes2 = classes$1(element);
  var actualClassNames = isArray$n(classNames) ? classNames : classNames.split(/\s+/g);
  actualClassNames.forEach(function(cls) {
    classes2.add(cls);
  });
}
var ContextPadModule$1 = {
  __depends__: [
    InteractionEventsModule$2,
    OverlaysModule
  ],
  contextPad: ["type", ContextPad]
};
var MARKER_TYPES = [
  "marker-start",
  "marker-mid",
  "marker-end"
];
var NODES_CAN_HAVE_MARKER = [
  "circle",
  "ellipse",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect"
];
function PreviewSupport(elementRegistry, eventBus, canvas, styles) {
  this._elementRegistry = elementRegistry;
  this._canvas = canvas;
  this._styles = styles;
  this._clonedMarkers = {};
  var self2 = this;
  eventBus.on("drag.cleanup", function() {
    forEach$q(self2._clonedMarkers, function(clonedMarker) {
      remove$4(clonedMarker);
    });
    self2._clonedMarkers = {};
  });
}
PreviewSupport.$inject = [
  "elementRegistry",
  "eventBus",
  "canvas",
  "styles"
];
PreviewSupport.prototype.getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};
PreviewSupport.prototype.addDragger = function(element, group, gfx) {
  gfx = gfx || this.getGfx(element);
  var dragger = clone$1(gfx);
  var bbox = gfx.getBoundingClientRect();
  this._cloneMarkers(getVisual(dragger));
  attr(dragger, this._styles.cls("djs-dragger", [], {
    x: bbox.top,
    y: bbox.left
  }));
  append$3(group, dragger);
  return dragger;
};
PreviewSupport.prototype.addFrame = function(shape, group) {
  var frame = create$2("rect", {
    class: "djs-resize-overlay",
    width: shape.width,
    height: shape.height,
    x: shape.x,
    y: shape.y
  });
  append$3(group, frame);
  return frame;
};
PreviewSupport.prototype._cloneMarkers = function(gfx) {
  var self2 = this;
  if (gfx.childNodes) {
    for (var i = 0; i < gfx.childNodes.length; i++) {
      self2._cloneMarkers(gfx.childNodes[i]);
    }
  }
  if (!canHaveMarker(gfx)) {
    return;
  }
  MARKER_TYPES.forEach(function(markerType) {
    if (attr(gfx, markerType)) {
      var marker = getMarker(gfx, markerType, self2._canvas.getContainer());
      self2._cloneMarker(gfx, marker, markerType);
    }
  });
};
PreviewSupport.prototype._cloneMarker = function(gfx, marker, markerType) {
  var markerId = marker.id;
  var clonedMarker = this._clonedMarkers[markerId];
  if (!clonedMarker) {
    clonedMarker = clone$1(marker);
    var clonedMarkerId = markerId + "-clone";
    clonedMarker.id = clonedMarkerId;
    classes(clonedMarker).add("djs-dragger").add("djs-dragger-marker");
    this._clonedMarkers[markerId] = clonedMarker;
    var defs = query("defs", this._canvas._svg);
    if (!defs) {
      defs = create$2("defs");
      append$3(this._canvas._svg, defs);
    }
    append$3(defs, clonedMarker);
  }
  var reference = idToReference(this._clonedMarkers[markerId].id);
  attr(gfx, markerType, reference);
};
function getMarker(node2, markerType, parentNode) {
  var id2 = referenceToId(attr(node2, markerType));
  return query("marker#" + id2, parentNode || document);
}
function referenceToId(reference) {
  return reference.match(/url\(['"]?#([^'"]*)['"]?\)/)[1];
}
function idToReference(id2) {
  return "url(#" + id2 + ")";
}
function canHaveMarker(node2) {
  return NODES_CAN_HAVE_MARKER.indexOf(node2.nodeName) !== -1;
}
var PreviewSupportModule = {
  __init__: ["previewSupport"],
  previewSupport: ["type", PreviewSupport]
};
var MARKER_OK$2 = "drop-ok", MARKER_NOT_OK$2 = "drop-not-ok", MARKER_ATTACH$2 = "attach-ok", MARKER_NEW_PARENT$1 = "new-parent";
var PREFIX = "create";
var HIGH_PRIORITY$g = 2e3;
function Create(canvas, dragging, eventBus, modeling, rules) {
  function canCreate2(elements, target, position, source, hints) {
    if (!target) {
      return false;
    }
    elements = filter$a(elements, function(element) {
      var labelTarget = element.labelTarget;
      return !element.parent && !(isLabel$5(element) && elements.indexOf(labelTarget) !== -1);
    });
    var shape = find$e(elements, function(element) {
      return !isConnection$b(element);
    });
    var attach = false, connect = false, create2 = false;
    if (isSingleShape(elements)) {
      attach = rules.allowed("shape.attach", {
        position,
        shape,
        target
      });
    }
    if (!attach) {
      if (isSingleShape(elements)) {
        create2 = rules.allowed("shape.create", {
          position,
          shape,
          source,
          target
        });
      } else {
        create2 = rules.allowed("elements.create", {
          elements,
          position,
          target
        });
      }
    }
    var connectionTarget = hints.connectionTarget;
    if (create2 || attach) {
      if (shape && source) {
        connect = rules.allowed("connection.create", {
          source: connectionTarget === source ? shape : source,
          target: connectionTarget === source ? source : shape,
          hints: {
            targetParent: target,
            targetAttach: attach
          }
        });
      }
      return {
        attach,
        connect
      };
    }
    if (create2 === null || attach === null) {
      return null;
    }
    return false;
  }
  function setMarker(element, marker) {
    [MARKER_ATTACH$2, MARKER_OK$2, MARKER_NOT_OK$2, MARKER_NEW_PARENT$1].forEach(function(m) {
      if (m === marker) {
        canvas.addMarker(element, m);
      } else {
        canvas.removeMarker(element, m);
      }
    });
  }
  eventBus.on(["create.move", "create.hover"], function(event) {
    var context = event.context, elements = context.elements, hover = event.hover, source = context.source, hints = context.hints || {};
    if (!hover) {
      context.canExecute = false;
      context.target = null;
      return;
    }
    ensureConstraints$2(event);
    var position = {
      x: event.x,
      y: event.y
    };
    var canExecute = context.canExecute = hover && canCreate2(elements, hover, position, source, hints);
    if (hover && canExecute !== null) {
      context.target = hover;
      if (canExecute && canExecute.attach) {
        setMarker(hover, MARKER_ATTACH$2);
      } else {
        setMarker(hover, canExecute ? MARKER_NEW_PARENT$1 : MARKER_NOT_OK$2);
      }
    }
  });
  eventBus.on(["create.end", "create.out", "create.cleanup"], function(event) {
    var hover = event.hover;
    if (hover) {
      setMarker(hover, null);
    }
  });
  eventBus.on("create.end", function(event) {
    var context = event.context, source = context.source, shape = context.shape, elements = context.elements, target = context.target, canExecute = context.canExecute, attach = canExecute && canExecute.attach, connect = canExecute && canExecute.connect, hints = context.hints || {};
    if (canExecute === false || !target) {
      return false;
    }
    ensureConstraints$2(event);
    var position = {
      x: event.x,
      y: event.y
    };
    if (connect) {
      shape = modeling.appendShape(source, shape, position, target, {
        attach,
        connection: connect === true ? {} : connect,
        connectionTarget: hints.connectionTarget
      });
    } else {
      elements = modeling.createElements(elements, position, target, assign$e({}, hints, {
        attach
      }));
      shape = find$e(elements, function(element) {
        return !isConnection$b(element);
      });
    }
    assign$e(context, {
      elements,
      shape
    });
    assign$e(event, {
      elements,
      shape
    });
  });
  function cancel() {
    var context = dragging.context();
    if (context && context.prefix === PREFIX) {
      dragging.cancel();
    }
  }
  eventBus.on("create.init", function() {
    eventBus.on("elements.changed", cancel);
    eventBus.once(["create.cancel", "create.end"], HIGH_PRIORITY$g, function() {
      eventBus.off("elements.changed", cancel);
    });
  });
  this.start = function(event, elements, context) {
    if (!isArray$n(elements)) {
      elements = [elements];
    }
    var shape = find$e(elements, function(element) {
      return !isConnection$b(element);
    });
    if (!shape) {
      return;
    }
    context = assign$e({
      elements,
      hints: {},
      shape
    }, context || {});
    forEach$q(elements, function(element) {
      if (!isNumber$1(element.x)) {
        element.x = 0;
      }
      if (!isNumber$1(element.y)) {
        element.y = 0;
      }
    });
    var bbox = getBBox(elements);
    forEach$q(elements, function(element) {
      if (isConnection$b(element)) {
        element.waypoints = map$7(element.waypoints, function(waypoint) {
          return {
            x: waypoint.x - bbox.x - bbox.width / 2,
            y: waypoint.y - bbox.y - bbox.height / 2
          };
        });
      }
      assign$e(element, {
        x: element.x - bbox.x - bbox.width / 2,
        y: element.y - bbox.y - bbox.height / 2
      });
    });
    dragging.init(event, PREFIX, {
      cursor: "grabbing",
      autoActivate: true,
      data: {
        shape,
        elements,
        context
      }
    });
  };
}
Create.$inject = [
  "canvas",
  "dragging",
  "eventBus",
  "modeling",
  "rules"
];
function ensureConstraints$2(event) {
  var context = event.context, createConstraints = context.createConstraints;
  if (!createConstraints) {
    return;
  }
  if (createConstraints.left) {
    event.x = Math.max(event.x, createConstraints.left);
  }
  if (createConstraints.right) {
    event.x = Math.min(event.x, createConstraints.right);
  }
  if (createConstraints.top) {
    event.y = Math.max(event.y, createConstraints.top);
  }
  if (createConstraints.bottom) {
    event.y = Math.min(event.y, createConstraints.bottom);
  }
}
function isConnection$b(element) {
  return !!element.waypoints;
}
function isSingleShape(elements) {
  return elements && elements.length === 1 && !isConnection$b(elements[0]);
}
function isLabel$5(element) {
  return !!element.labelTarget;
}
var LOW_PRIORITY$h = 750;
function CreatePreview(canvas, eventBus, graphicsFactory, previewSupport, styles) {
  function createDragGroup(elements) {
    var dragGroup = create$2("g");
    attr(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
    var childrenGfx = create$2("g");
    elements.forEach(function(element) {
      var gfx;
      if (element.hidden) {
        return;
      }
      if (element.waypoints) {
        gfx = graphicsFactory._createContainer("connection", childrenGfx);
        graphicsFactory.drawConnection(getVisual(gfx), element);
      } else {
        gfx = graphicsFactory._createContainer("shape", childrenGfx);
        graphicsFactory.drawShape(getVisual(gfx), element);
        translate$4(gfx, element.x, element.y);
      }
      previewSupport.addDragger(element, dragGroup, gfx);
    });
    return dragGroup;
  }
  eventBus.on("create.move", LOW_PRIORITY$h, function(event) {
    var hover = event.hover, context = event.context, elements = context.elements, dragGroup = context.dragGroup;
    if (!dragGroup) {
      dragGroup = context.dragGroup = createDragGroup(elements);
    }
    var activeLayer;
    if (hover) {
      if (!dragGroup.parentNode) {
        activeLayer = canvas.getActiveLayer();
        append$3(activeLayer, dragGroup);
      }
      translate$4(dragGroup, event.x, event.y);
    } else {
      remove$4(dragGroup);
    }
  });
  eventBus.on("create.cleanup", function(event) {
    var context = event.context, dragGroup = context.dragGroup;
    if (dragGroup) {
      remove$4(dragGroup);
    }
  });
}
CreatePreview.$inject = [
  "canvas",
  "eventBus",
  "graphicsFactory",
  "previewSupport",
  "styles"
];
var CreateModule = {
  __depends__: [
    DraggingModule,
    PreviewSupportModule,
    RulesModule$1,
    SelectionModule
  ],
  __init__: [
    "create",
    "createPreview"
  ],
  create: ["type", Create],
  createPreview: ["type", CreatePreview]
};
var DATA_REF = "data-id";
var CLOSE_EVENTS = [
  "contextPad.close",
  "canvas.viewbox.changing",
  "commandStack.changed"
];
var DEFAULT_PRIORITY$4 = 1e3;
function PopupMenu(config, eventBus, canvas) {
  var scale = isDefined(config && config.scale) ? config.scale : {
    min: 1,
    max: 1.5
  };
  this._config = {
    scale
  };
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._providers = {};
  this._current = {};
}
PopupMenu.$inject = [
  "config.popupMenu",
  "eventBus",
  "canvas"
];
PopupMenu.prototype.registerProvider = function(id2, priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY$4;
  }
  this._eventBus.on("popupMenu.getProviders." + id2, priority, function(event) {
    event.providers.push(provider);
  });
};
PopupMenu.prototype.isEmpty = function(element, providerId) {
  if (!element) {
    throw new Error("element parameter is missing");
  }
  if (!providerId) {
    throw new Error("providerId parameter is missing");
  }
  var providers = this._getProviders(providerId);
  if (!providers) {
    return true;
  }
  var entries = this._getEntries(element, providers), headerEntries = this._getHeaderEntries(element, providers);
  var hasEntries = size(entries) > 0, hasHeaderEntries = headerEntries && size(headerEntries) > 0;
  return !hasEntries && !hasHeaderEntries;
};
PopupMenu.prototype.open = function(element, id2, position) {
  var providers = this._getProviders(id2);
  if (!element) {
    throw new Error("Element is missing");
  }
  if (!providers || !providers.length) {
    throw new Error("No registered providers for: " + id2);
  }
  if (!position) {
    throw new Error("the position argument is missing");
  }
  if (this.isOpen()) {
    this.close();
  }
  this._emit("open");
  var current = this._current = {
    className: id2,
    element,
    position
  };
  var entries = this._getEntries(element, providers), headerEntries = this._getHeaderEntries(element, providers);
  current.entries = assign$e({}, entries, headerEntries);
  current.container = this._createContainer();
  if (size(headerEntries)) {
    current.container.appendChild(this._createEntries(headerEntries, "djs-popup-header"));
  }
  if (size(entries)) {
    current.container.appendChild(this._createEntries(entries, "djs-popup-body"));
  }
  var canvas = this._canvas, parent2 = canvas.getContainer();
  this._attachContainer(current.container, parent2, position.cursor);
  this._bindAutoClose();
};
PopupMenu.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }
  this._emit("close");
  this._unbindAutoClose();
  remove$5(this._current.container);
  this._current.container = null;
};
PopupMenu.prototype.isOpen = function() {
  return !!this._current.container;
};
PopupMenu.prototype.trigger = function(event) {
  event.preventDefault();
  var element = event.delegateTarget || event.target, entryId = attr$1(element, DATA_REF);
  var entry = this._getEntry(entryId);
  if (entry.action) {
    return entry.action.call(null, event, entry);
  }
};
PopupMenu.prototype._getProviders = function(id2) {
  var event = this._eventBus.createEvent({
    type: "popupMenu.getProviders." + id2,
    providers: []
  });
  this._eventBus.fire(event);
  return event.providers;
};
PopupMenu.prototype._getEntries = function(element, providers) {
  var entries = {};
  forEach$q(providers, function(provider) {
    if (!provider.getPopupMenuEntries) {
      forEach$q(provider.getEntries(element), function(entry) {
        var id2 = entry.id;
        if (!id2) {
          throw new Error("every entry must have the id property set");
        }
        entries[id2] = omit(entry, ["id"]);
      });
      return;
    }
    var entriesOrUpdater = provider.getPopupMenuEntries(element);
    if (isFunction$6(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      forEach$q(entriesOrUpdater, function(entry, id2) {
        entries[id2] = entry;
      });
    }
  });
  return entries;
};
PopupMenu.prototype._getHeaderEntries = function(element, providers) {
  var entries = {};
  forEach$q(providers, function(provider) {
    if (!provider.getPopupMenuHeaderEntries) {
      if (!provider.getHeaderEntries) {
        return;
      }
      forEach$q(provider.getHeaderEntries(element), function(entry) {
        var id2 = entry.id;
        if (!id2) {
          throw new Error("every entry must have the id property set");
        }
        entries[id2] = omit(entry, ["id"]);
      });
      return;
    }
    var entriesOrUpdater = provider.getPopupMenuHeaderEntries(element);
    if (isFunction$6(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      forEach$q(entriesOrUpdater, function(entry, id2) {
        entries[id2] = entry;
      });
    }
  });
  return entries;
};
PopupMenu.prototype._getEntry = function(entryId) {
  var entry = this._current.entries[entryId];
  if (!entry) {
    throw new Error("entry not found");
  }
  return entry;
};
PopupMenu.prototype._emit = function(eventName) {
  this._eventBus.fire("popupMenu." + eventName);
};
PopupMenu.prototype._createContainer = function() {
  var container = domify$h('<div class="djs-popup">'), position = this._current.position, className = this._current.className;
  assign$e(container.style, {
    position: "absolute",
    left: position.x + "px",
    top: position.y + "px",
    visibility: "hidden"
  });
  classes$1(container).add(className);
  return container;
};
PopupMenu.prototype._attachContainer = function(container, parent2, cursor) {
  var self2 = this;
  delegate$1.bind(container, ".entry", "click", function(event) {
    self2.trigger(event);
  });
  this._updateScale(container);
  parent2.appendChild(container);
  if (cursor) {
    this._assureIsInbounds(container, cursor);
  }
};
PopupMenu.prototype._updateScale = function(container) {
  var zoom2 = this._canvas.zoom();
  var scaleConfig = this._config.scale, minScale, maxScale, scale = zoom2;
  if (scaleConfig !== true) {
    if (scaleConfig === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = scaleConfig.min;
      maxScale = scaleConfig.max;
    }
    if (isDefined(minScale) && zoom2 < minScale) {
      scale = minScale;
    }
    if (isDefined(maxScale) && zoom2 > maxScale) {
      scale = maxScale;
    }
  }
  setTransform(container, "scale(" + scale + ")");
};
PopupMenu.prototype._assureIsInbounds = function(container, cursor) {
  var canvas = this._canvas, clientRect = canvas._container.getBoundingClientRect();
  var containerX = container.offsetLeft, containerY = container.offsetTop, containerWidth = container.scrollWidth, containerHeight = container.scrollHeight, overAxis = {}, left, top;
  var cursorPosition = {
    x: cursor.x - clientRect.left,
    y: cursor.y - clientRect.top
  };
  if (containerX + containerWidth > clientRect.width) {
    overAxis.x = true;
  }
  if (containerY + containerHeight > clientRect.height) {
    overAxis.y = true;
  }
  if (overAxis.x && overAxis.y) {
    left = cursorPosition.x - containerWidth + "px";
    top = cursorPosition.y - containerHeight + "px";
  } else if (overAxis.x) {
    left = cursorPosition.x - containerWidth + "px";
    top = cursorPosition.y + "px";
  } else if (overAxis.y && cursorPosition.y < containerHeight) {
    left = cursorPosition.x + "px";
    top = 10 + "px";
  } else if (overAxis.y) {
    left = cursorPosition.x + "px";
    top = cursorPosition.y - containerHeight + "px";
  }
  assign$e(container.style, { left, top }, { visibility: "visible", "z-index": 1e3 });
};
PopupMenu.prototype._createEntries = function(entries, className) {
  var entriesContainer = domify$h("<div>"), self2 = this;
  classes$1(entriesContainer).add(className);
  forEach$q(entries, function(entry, id2) {
    var entryContainer = self2._createEntry(entry, id2);
    entriesContainer.appendChild(entryContainer);
  });
  return entriesContainer;
};
PopupMenu.prototype._createEntry = function(entry, id2) {
  var entryContainer = domify$h("<div>"), entryClasses = classes$1(entryContainer);
  entryClasses.add("entry");
  if (entry.className) {
    entry.className.split(" ").forEach(function(className) {
      entryClasses.add(className);
    });
  }
  attr$1(entryContainer, DATA_REF, id2);
  if (entry.label) {
    var label2 = domify$h("<span>");
    label2.textContent = entry.label;
    entryContainer.appendChild(label2);
  }
  if (entry.imageUrl) {
    entryContainer.appendChild(domify$h('<img src="' + entry.imageUrl + '" />'));
  }
  if (entry.active === true) {
    entryClasses.add("active");
  }
  if (entry.disabled === true) {
    entryClasses.add("disabled");
  }
  if (entry.title) {
    entryContainer.title = entry.title;
  }
  return entryContainer;
};
PopupMenu.prototype._bindAutoClose = function() {
  this._eventBus.once(CLOSE_EVENTS, this.close, this);
};
PopupMenu.prototype._unbindAutoClose = function() {
  this._eventBus.off(CLOSE_EVENTS, this.close, this);
};
function setTransform(element, transform2) {
  element.style["transform-origin"] = "top left";
  ["", "-ms-", "-webkit-"].forEach(function(prefix2) {
    element.style[prefix2 + "transform"] = transform2;
  });
}
var PopupMenuModule$1 = {
  __init__: ["popupMenu"],
  popupMenu: ["type", PopupMenu]
};
function Clipboard() {
}
Clipboard.prototype.get = function() {
  return this._data;
};
Clipboard.prototype.set = function(data) {
  this._data = data;
};
Clipboard.prototype.clear = function() {
  var data = this._data;
  delete this._data;
  return data;
};
Clipboard.prototype.isEmpty = function() {
  return !this._data;
};
var ClipboardModule = {
  clipboard: ["type", Clipboard]
};
function Mouse(eventBus) {
  var self2 = this;
  this._lastMoveEvent = null;
  function setLastMoveEvent(mousemoveEvent) {
    self2._lastMoveEvent = mousemoveEvent;
  }
  eventBus.on("canvas.init", function(context) {
    var svg = self2._svg = context.svg;
    svg.addEventListener("mousemove", setLastMoveEvent);
  });
  eventBus.on("canvas.destroy", function() {
    self2._lastMouseEvent = null;
    self2._svg.removeEventListener("mousemove", setLastMoveEvent);
  });
}
Mouse.$inject = ["eventBus"];
Mouse.prototype.getLastMoveEvent = function() {
  return this._lastMoveEvent || createMoveEvent(0, 0);
};
function createMoveEvent(x, y) {
  var event = document.createEvent("MouseEvent");
  var screenX = x, screenY = y, clientX = x, clientY = y;
  if (event.initMouseEvent) {
    event.initMouseEvent("mousemove", true, true, window, 0, screenX, screenY, clientX, clientY, false, false, false, false, 0, null);
  }
  return event;
}
var MouseModule = {
  __init__: ["mouse"],
  mouse: ["type", Mouse]
};
function CopyPaste(canvas, create2, clipboard, elementFactory, eventBus, modeling, mouse, rules) {
  this._canvas = canvas;
  this._create = create2;
  this._clipboard = clipboard;
  this._elementFactory = elementFactory;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._mouse = mouse;
  this._rules = rules;
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element, elements = context.elements;
    descriptor.priority = 1;
    descriptor.id = element.id;
    var parentCopied = find$e(elements, function(e) {
      return e === element.parent;
    });
    if (parentCopied) {
      descriptor.parent = element.parent.id;
    }
    if (isAttacher$1(element)) {
      descriptor.priority = 2;
      descriptor.host = element.host.id;
    }
    if (isConnection$a(element)) {
      descriptor.priority = 3;
      descriptor.source = element.source.id;
      descriptor.target = element.target.id;
      descriptor.waypoints = copyWaypoints$1(element);
    }
    if (isLabel$4(element)) {
      descriptor.priority = 4;
      descriptor.labelTarget = element.labelTarget.id;
    }
    forEach$q(["x", "y", "width", "height"], function(property2) {
      if (isNumber$1(element[property2])) {
        descriptor[property2] = element[property2];
      }
    });
    descriptor.hidden = element.hidden;
    descriptor.collapsed = element.collapsed;
  });
  eventBus.on("copyPaste.pasteElements", function(context) {
    var hints = context.hints;
    assign$e(hints, {
      createElementsBehavior: false
    });
  });
}
CopyPaste.$inject = [
  "canvas",
  "create",
  "clipboard",
  "elementFactory",
  "eventBus",
  "modeling",
  "mouse",
  "rules"
];
CopyPaste.prototype.copy = function(elements) {
  var allowed, tree;
  if (!isArray$n(elements)) {
    elements = elements ? [elements] : [];
  }
  allowed = this._eventBus.fire("copyPaste.canCopyElements", {
    elements
  });
  if (allowed === false) {
    tree = {};
  } else {
    tree = this.createTree(isArray$n(allowed) ? allowed : elements);
  }
  this._clipboard.set(tree);
  this._eventBus.fire("copyPaste.elementsCopied", {
    elements,
    tree
  });
  return tree;
};
CopyPaste.prototype.paste = function(context) {
  var tree = this._clipboard.get();
  if (this._clipboard.isEmpty()) {
    return;
  }
  var hints = context && context.hints || {};
  this._eventBus.fire("copyPaste.pasteElements", {
    hints
  });
  var elements = this._createElements(tree);
  if (context && context.element && context.point) {
    return this._paste(elements, context.element, context.point, hints);
  }
  this._create.start(this._mouse.getLastMoveEvent(), elements, {
    hints: hints || {}
  });
};
CopyPaste.prototype._paste = function(elements, target, position, hints) {
  forEach$q(elements, function(element) {
    if (!isNumber$1(element.x)) {
      element.x = 0;
    }
    if (!isNumber$1(element.y)) {
      element.y = 0;
    }
  });
  var bbox = getBBox(elements);
  forEach$q(elements, function(element) {
    if (isConnection$a(element)) {
      element.waypoints = map$7(element.waypoints, function(waypoint) {
        return {
          x: waypoint.x - bbox.x - bbox.width / 2,
          y: waypoint.y - bbox.y - bbox.height / 2
        };
      });
    }
    assign$e(element, {
      x: element.x - bbox.x - bbox.width / 2,
      y: element.y - bbox.y - bbox.height / 2
    });
  });
  return this._modeling.createElements(elements, position, target, assign$e({}, hints));
};
CopyPaste.prototype._createElements = function(tree) {
  var self2 = this;
  var eventBus = this._eventBus;
  var cache = {};
  var elements = [];
  forEach$q(tree, function(branch, depth) {
    branch = sortBy$2(branch, "priority");
    forEach$q(branch, function(descriptor) {
      var attrs = assign$e({}, omit(descriptor, ["priority"]));
      if (cache[descriptor.parent]) {
        attrs.parent = cache[descriptor.parent];
      } else {
        delete attrs.parent;
      }
      eventBus.fire("copyPaste.pasteElement", {
        cache,
        descriptor: attrs
      });
      var element;
      if (isConnection$a(attrs)) {
        attrs.source = cache[descriptor.source];
        attrs.target = cache[descriptor.target];
        element = cache[descriptor.id] = self2.createConnection(attrs);
        elements.push(element);
        return;
      }
      if (isLabel$4(attrs)) {
        attrs.labelTarget = cache[attrs.labelTarget];
        element = cache[descriptor.id] = self2.createLabel(attrs);
        elements.push(element);
        return;
      }
      if (attrs.host) {
        attrs.host = cache[attrs.host];
      }
      element = cache[descriptor.id] = self2.createShape(attrs);
      elements.push(element);
    });
  });
  return elements;
};
CopyPaste.prototype.createConnection = function(attrs) {
  var connection = this._elementFactory.createConnection(omit(attrs, ["id"]));
  return connection;
};
CopyPaste.prototype.createLabel = function(attrs) {
  var label2 = this._elementFactory.createLabel(omit(attrs, ["id"]));
  return label2;
};
CopyPaste.prototype.createShape = function(attrs) {
  var shape = this._elementFactory.createShape(omit(attrs, ["id"]));
  return shape;
};
CopyPaste.prototype.hasRelations = function(element, elements) {
  var labelTarget, source, target;
  if (isConnection$a(element)) {
    source = find$e(elements, matchPattern$1({ id: element.source.id }));
    target = find$e(elements, matchPattern$1({ id: element.target.id }));
    if (!source || !target) {
      return false;
    }
  }
  if (isLabel$4(element)) {
    labelTarget = find$e(elements, matchPattern$1({ id: element.labelTarget.id }));
    if (!labelTarget) {
      return false;
    }
  }
  return true;
};
CopyPaste.prototype.createTree = function(elements) {
  var rules = this._rules, self2 = this;
  var tree = {}, elementsData = [];
  var parents = getParents$2(elements);
  function canCopy2(element, elements2) {
    return rules.allowed("element.copy", {
      element,
      elements: elements2
    });
  }
  function addElementData(element, depth) {
    var foundElementData = find$e(elementsData, function(elementsData2) {
      return element === elementsData2.element;
    });
    if (!foundElementData) {
      elementsData.push({
        element,
        depth
      });
      return;
    }
    if (foundElementData.depth < depth) {
      elementsData = removeElementData(foundElementData, elementsData);
      elementsData.push({
        element: foundElementData.element,
        depth
      });
    }
  }
  function removeElementData(elementData2, elementsData2) {
    var index2 = elementsData2.indexOf(elementData2);
    if (index2 !== -1) {
      elementsData2.splice(index2, 1);
    }
    return elementsData2;
  }
  eachElement$1(parents, function(element, _index, depth) {
    if (isLabel$4(element)) {
      return;
    }
    forEach$q(element.labels, function(label2) {
      addElementData(label2, depth);
    });
    function addRelatedElements(elements2) {
      elements2 && elements2.length && forEach$q(elements2, function(element2) {
        forEach$q(element2.labels, function(label2) {
          addElementData(label2, depth);
        });
        addElementData(element2, depth);
      });
    }
    forEach$q([element.attachers, element.incoming, element.outgoing], addRelatedElements);
    addElementData(element, depth);
    return element.children;
  });
  elements = map$7(elementsData, function(elementData2) {
    return elementData2.element;
  });
  elementsData = map$7(elementsData, function(elementData2) {
    elementData2.descriptor = {};
    self2._eventBus.fire("copyPaste.copyElement", {
      descriptor: elementData2.descriptor,
      element: elementData2.element,
      elements
    });
    return elementData2;
  });
  elementsData = sortBy$2(elementsData, function(elementData2) {
    return elementData2.descriptor.priority;
  });
  elements = map$7(elementsData, function(elementData2) {
    return elementData2.element;
  });
  forEach$q(elementsData, function(elementData2) {
    var depth = elementData2.depth;
    if (!self2.hasRelations(elementData2.element, elements)) {
      removeElement(elementData2.element, elements);
      return;
    }
    if (!canCopy2(elementData2.element, elements)) {
      removeElement(elementData2.element, elements);
      return;
    }
    if (!tree[depth]) {
      tree[depth] = [];
    }
    tree[depth].push(elementData2.descriptor);
  });
  return tree;
};
function isAttacher$1(element) {
  return !!element.host;
}
function isConnection$a(element) {
  return !!element.waypoints;
}
function isLabel$4(element) {
  return !!element.labelTarget;
}
function copyWaypoints$1(element) {
  return map$7(element.waypoints, function(waypoint) {
    waypoint = copyWaypoint$1(waypoint);
    if (waypoint.original) {
      waypoint.original = copyWaypoint$1(waypoint.original);
    }
    return waypoint;
  });
}
function copyWaypoint$1(waypoint) {
  return assign$e({}, waypoint);
}
function removeElement(element, elements) {
  var index2 = elements.indexOf(element);
  if (index2 === -1) {
    return elements;
  }
  return elements.splice(index2, 1);
}
var CopyPasteModule$1 = {
  __depends__: [
    ClipboardModule,
    CreateModule,
    MouseModule,
    RulesModule$1
  ],
  __init__: ["copyPaste"],
  copyPaste: ["type", CopyPaste]
};
function copyProperties$1(source, target, properties2) {
  if (!isArray$n(properties2)) {
    properties2 = [properties2];
  }
  forEach$q(properties2, function(property2) {
    if (!isUndefined$7(source[property2])) {
      target[property2] = source[property2];
    }
  });
}
function removeProperties(element, properties2) {
  if (!isArray$n(properties2)) {
    properties2 = [properties2];
  }
  forEach$q(properties2, function(property2) {
    if (element[property2]) {
      delete element[property2];
    }
  });
}
var LOW_PRIORITY$g = 750;
function BpmnCopyPaste(bpmnFactory, eventBus, moddleCopy) {
  eventBus.on("copyPaste.copyElement", LOW_PRIORITY$g, function(context) {
    var descriptor = context.descriptor, element = context.element;
    var businessObject = descriptor.oldBusinessObject = getBusinessObject$V(element);
    descriptor.type = element.type;
    copyProperties$1(businessObject, descriptor, "name");
    descriptor.di = {};
    copyProperties$1(businessObject.di, descriptor.di, [
      "fill",
      "stroke",
      "background-color",
      "border-color",
      "color"
    ]);
    copyProperties$1(businessObject.di, descriptor, "isExpanded");
    if (isLabel$3(descriptor)) {
      return descriptor;
    }
    if (businessObject.default) {
      descriptor.default = businessObject.default.id;
    }
  });
  eventBus.on("moddleCopy.canCopyProperty", function(context) {
    var parent2 = context.parent, property2 = context.property, propertyName = context.propertyName, bpmnProcess;
    if (propertyName === "processRef" && is$O(parent2, "bpmn:Participant") && is$O(property2, "bpmn:Process")) {
      bpmnProcess = bpmnFactory.create("bpmn:Process");
      return moddleCopy.copyElement(property2, bpmnProcess);
    }
  });
  var references;
  function resolveReferences(descriptor, cache) {
    var businessObject = getBusinessObject$V(descriptor);
    if (descriptor.default) {
      references[descriptor.default] = {
        element: businessObject,
        property: "default"
      };
    }
    if (descriptor.host) {
      getBusinessObject$V(descriptor).attachedToRef = getBusinessObject$V(cache[descriptor.host]);
    }
    references = omit(references, reduce$3(references, function(array, reference, key) {
      var element = reference.element, property2 = reference.property;
      if (key === descriptor.id) {
        element[property2] = businessObject;
        array.push(descriptor.id);
      }
      return array;
    }, []));
  }
  eventBus.on("copyPaste.pasteElements", function() {
    references = {};
  });
  eventBus.on("copyPaste.pasteElement", function(context) {
    var cache = context.cache, descriptor = context.descriptor, oldBusinessObject = descriptor.oldBusinessObject, newBusinessObject;
    if (isLabel$3(descriptor)) {
      descriptor.businessObject = getBusinessObject$V(cache[descriptor.labelTarget]);
      return;
    }
    newBusinessObject = bpmnFactory.create(oldBusinessObject.$type);
    descriptor.businessObject = moddleCopy.copyElement(oldBusinessObject, newBusinessObject);
    resolveReferences(descriptor, cache);
    copyProperties$1(descriptor, newBusinessObject, [
      "isExpanded",
      "name"
    ]);
    removeProperties(descriptor, "oldBusinessObject");
  });
}
BpmnCopyPaste.$inject = [
  "bpmnFactory",
  "eventBus",
  "moddleCopy"
];
function isLabel$3(element) {
  return !!element.labelTarget;
}
var DISALLOWED_PROPERTIES = [
  "artifacts",
  "dataInputAssociations",
  "dataOutputAssociations",
  "default",
  "flowElements",
  "lanes",
  "incoming",
  "outgoing"
];
function ModdleCopy(eventBus, bpmnFactory, moddle) {
  this._bpmnFactory = bpmnFactory;
  this._eventBus = eventBus;
  this._moddle = moddle;
  eventBus.on("moddleCopy.canCopyProperties", function(context) {
    var propertyNames = context.propertyNames;
    if (!propertyNames || !propertyNames.length) {
      return;
    }
    return sortBy$2(propertyNames, function(propertyName) {
      return propertyName === "extensionElements";
    });
  });
  eventBus.on("moddleCopy.canCopyProperty", function(context) {
    var parent2 = context.parent, parentDescriptor = isObject$e(parent2) && parent2.$descriptor, propertyName = context.propertyName;
    if (propertyName && DISALLOWED_PROPERTIES.indexOf(propertyName) !== -1) {
      return false;
    }
    if (propertyName && parentDescriptor && !find$e(parentDescriptor.properties, matchPattern$1({ name: propertyName }))) {
      return false;
    }
  });
  eventBus.on("moddleCopy.canSetCopiedProperty", function(context) {
    var property2 = context.property;
    if (is$N(property2, "bpmn:ExtensionElements") && (!property2.values || !property2.values.length)) {
      return false;
    }
  });
}
ModdleCopy.$inject = [
  "eventBus",
  "bpmnFactory",
  "moddle"
];
ModdleCopy.prototype.copyElement = function(sourceElement, targetElement, propertyNames) {
  var self2 = this;
  if (propertyNames && !isArray$n(propertyNames)) {
    propertyNames = [propertyNames];
  }
  propertyNames = propertyNames || getPropertyNames(sourceElement.$descriptor);
  var canCopyProperties = this._eventBus.fire("moddleCopy.canCopyProperties", {
    propertyNames,
    sourceElement,
    targetElement
  });
  if (canCopyProperties === false) {
    return targetElement;
  }
  if (isArray$n(canCopyProperties)) {
    propertyNames = canCopyProperties;
  }
  forEach$q(propertyNames, function(propertyName) {
    var sourceProperty;
    if (has(sourceElement, propertyName)) {
      sourceProperty = sourceElement.get(propertyName);
    }
    var copiedProperty = self2.copyProperty(sourceProperty, targetElement, propertyName);
    var canSetProperty = self2._eventBus.fire("moddleCopy.canSetCopiedProperty", {
      parent: targetElement,
      property: copiedProperty,
      propertyName
    });
    if (canSetProperty === false) {
      return;
    }
    if (isDefined(copiedProperty)) {
      targetElement.set(propertyName, copiedProperty);
    }
  });
  return targetElement;
};
ModdleCopy.prototype.copyProperty = function(property2, parent2, propertyName) {
  var self2 = this;
  var copiedProperty = this._eventBus.fire("moddleCopy.canCopyProperty", {
    parent: parent2,
    property: property2,
    propertyName
  });
  if (copiedProperty === false) {
    return;
  }
  if (copiedProperty) {
    if (isObject$e(copiedProperty) && copiedProperty.$type && !copiedProperty.$parent) {
      copiedProperty.$parent = parent2;
    }
    return copiedProperty;
  }
  var propertyDescriptor = this._moddle.getPropertyDescriptor(parent2, propertyName);
  if (propertyDescriptor.isReference) {
    return;
  }
  if (propertyDescriptor.isId) {
    return this._copyId(property2, parent2);
  }
  if (isArray$n(property2)) {
    return reduce$3(property2, function(childProperties, childProperty) {
      copiedProperty = self2.copyProperty(childProperty, parent2, propertyName);
      if (copiedProperty) {
        copiedProperty.$parent = parent2;
        return childProperties.concat(copiedProperty);
      }
      return childProperties;
    }, []);
  }
  if (isObject$e(property2) && property2.$type) {
    if (this._moddle.getElementDescriptor(property2).isGeneric) {
      return;
    }
    copiedProperty = self2._bpmnFactory.create(property2.$type);
    copiedProperty.$parent = parent2;
    copiedProperty = self2.copyElement(property2, copiedProperty);
    return copiedProperty;
  }
  return property2;
};
ModdleCopy.prototype._copyId = function(id2, element) {
  if (this._moddle.ids.assigned(id2)) {
    return;
  } else {
    this._moddle.ids.claim(id2, element);
    return id2;
  }
};
function getPropertyNames(descriptor, keepDefaultProperties) {
  return reduce$3(descriptor.properties, function(properties2, property2) {
    if (keepDefaultProperties && property2.default) {
      return properties2;
    }
    return properties2.concat(property2.name);
  }, []);
}
function is$N(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
var CopyPasteModule = {
  __depends__: [
    CopyPasteModule$1
  ],
  __init__: ["bpmnCopyPaste", "moddleCopy"],
  bpmnCopyPaste: ["type", BpmnCopyPaste],
  moddleCopy: ["type", ModdleCopy]
};
var round$5 = Math.round;
function Replace(modeling) {
  this._modeling = modeling;
}
Replace.$inject = ["modeling"];
Replace.prototype.replaceElement = function(oldElement, newElementData, options) {
  if (oldElement.waypoints) {
    return null;
  }
  var modeling = this._modeling;
  var width = newElementData.width || oldElement.width, height = newElementData.height || oldElement.height, x = newElementData.x || oldElement.x, y = newElementData.y || oldElement.y, centerX = round$5(x + width / 2), centerY = round$5(y + height / 2);
  return modeling.replaceShape(oldElement, assign$e({}, newElementData, {
    x: centerX,
    y: centerY,
    width,
    height
  }), options);
};
var ReplaceModule$1 = {
  __init__: ["replace"],
  replace: ["type", Replace]
};
function copyProperties(source, target, properties2) {
  if (!isArray$n(properties2)) {
    properties2 = [properties2];
  }
  forEach$q(properties2, function(property2) {
    if (!isUndefined$7(source[property2])) {
      target[property2] = source[property2];
    }
  });
}
var CUSTOM_PROPERTIES = [
  "cancelActivity",
  "instantiate",
  "eventGatewayType",
  "triggeredByEvent",
  "isInterrupting"
];
function toggeling(element, target) {
  var oldCollapsed = element && has(element, "collapsed") ? element.collapsed : !isExpanded(element);
  var targetCollapsed;
  if (target && (has(target, "collapsed") || has(target, "isExpanded"))) {
    targetCollapsed = has(target, "collapsed") ? target.collapsed : !target.isExpanded;
  } else {
    targetCollapsed = oldCollapsed;
  }
  if (oldCollapsed !== targetCollapsed) {
    element.collapsed = oldCollapsed;
    return true;
  }
  return false;
}
function BpmnReplace(bpmnFactory, elementFactory, moddleCopy, modeling, replace, rules, selection) {
  function replaceElement(element, target, hints) {
    hints = hints || {};
    var type = target.type, oldBusinessObject = element.businessObject;
    if (isSubProcess(oldBusinessObject)) {
      if (type === "bpmn:SubProcess") {
        if (toggeling(element, target)) {
          modeling.toggleCollapse(element);
          return element;
        }
      }
    }
    var newBusinessObject = bpmnFactory.create(type);
    var newElement = {
      type,
      businessObject: newBusinessObject
    };
    var elementProps = getPropertyNames(oldBusinessObject.$descriptor), newElementProps = getPropertyNames(newBusinessObject.$descriptor, true), copyProps = intersection(elementProps, newElementProps);
    assign$e(newBusinessObject, pick$3(target, CUSTOM_PROPERTIES));
    var properties2 = filter$a(copyProps, function(propertyName) {
      if (propertyName === "eventDefinitions") {
        return hasEventDefinition$1(element, target.eventDefinitionType);
      }
      if (propertyName === "loopCharacteristics") {
        return !isEventSubProcess$1(newBusinessObject);
      }
      if (has(newBusinessObject, propertyName)) {
        return false;
      }
      if (propertyName === "processRef" && target.isExpanded === false) {
        return false;
      }
      if (propertyName === "triggeredByEvent") {
        return false;
      }
      return true;
    });
    newBusinessObject = moddleCopy.copyElement(oldBusinessObject, newBusinessObject, properties2);
    if (target.eventDefinitionType) {
      if (!hasEventDefinition$1(newBusinessObject, target.eventDefinitionType)) {
        newElement.eventDefinitionType = target.eventDefinitionType;
        newElement.eventDefinitionAttrs = target.eventDefinitionAttrs;
      }
    }
    if (is$O(oldBusinessObject, "bpmn:Activity")) {
      if (isSubProcess(oldBusinessObject)) {
        newElement.isExpanded = isExpanded(oldBusinessObject);
      } else if (target && has(target, "isExpanded")) {
        newElement.isExpanded = target.isExpanded;
      }
      if (isExpanded(oldBusinessObject) && !is$O(oldBusinessObject, "bpmn:Task") && newElement.isExpanded) {
        newElement.width = element.width;
        newElement.height = element.height;
      }
    }
    if (isSubProcess(oldBusinessObject) && !isSubProcess(newBusinessObject)) {
      hints.moveChildren = false;
    }
    if (is$O(oldBusinessObject, "bpmn:Participant")) {
      if (target.isExpanded === true) {
        newBusinessObject.processRef = bpmnFactory.create("bpmn:Process");
      } else {
        hints.moveChildren = false;
      }
      newElement.width = element.width;
      newElement.height = elementFactory._getDefaultSize(newBusinessObject).height;
    }
    if (!rules.allowed("shape.resize", { shape: newBusinessObject })) {
      newElement.height = elementFactory._getDefaultSize(newBusinessObject).height;
      newElement.width = elementFactory._getDefaultSize(newBusinessObject).width;
    }
    newBusinessObject.name = oldBusinessObject.name;
    if (isAny$b(oldBusinessObject, [
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway",
      "bpmn:Activity"
    ]) && isAny$b(newBusinessObject, [
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway",
      "bpmn:Activity"
    ])) {
      newBusinessObject.default = oldBusinessObject.default;
    }
    if (target.host && !is$O(oldBusinessObject, "bpmn:BoundaryEvent") && is$O(newBusinessObject, "bpmn:BoundaryEvent")) {
      newElement.host = target.host;
    }
    if (newElement.type === "bpmn:DataStoreReference" || newElement.type === "bpmn:DataObjectReference") {
      newElement.x = element.x + (element.width - newElement.width) / 2;
    }
    newElement.di = {};
    copyProperties(oldBusinessObject.di, newElement.di, [
      "fill",
      "stroke",
      "background-color",
      "border-color",
      "color"
    ]);
    newElement = replace.replaceElement(element, newElement, hints);
    if (hints.select !== false) {
      selection.select(newElement);
    }
    return newElement;
  }
  this.replaceElement = replaceElement;
}
BpmnReplace.$inject = [
  "bpmnFactory",
  "elementFactory",
  "moddleCopy",
  "modeling",
  "replace",
  "rules",
  "selection"
];
function isSubProcess(bo) {
  return is$O(bo, "bpmn:SubProcess");
}
function hasEventDefinition$1(element, type) {
  var bo = getBusinessObject$V(element);
  return type && bo.get("eventDefinitions").some(function(definition) {
    return is$O(definition, type);
  });
}
function intersection(a1, a2) {
  return a1.filter(function(el) {
    return a2.indexOf(el) !== -1;
  });
}
var ReplaceModule = {
  __depends__: [
    CopyPasteModule,
    ReplaceModule$1,
    SelectionModule
  ],
  bpmnReplace: ["type", BpmnReplace]
};
function isDifferentType(element) {
  return function(entry) {
    var target = entry.target;
    var businessObject = getBusinessObject$V(element), eventDefinition = businessObject.eventDefinitions && businessObject.eventDefinitions[0];
    var isTypeEqual = businessObject.$type === target.type;
    var isEventDefinitionEqual = (eventDefinition && eventDefinition.$type) === target.eventDefinitionType;
    var isTriggeredByEventEqual = businessObject.triggeredByEvent === target.triggeredByEvent;
    var isExpandedEqual = target.isExpanded === void 0 || target.isExpanded === isExpanded(businessObject);
    return !isTypeEqual || !isEventDefinitionEqual || !isTriggeredByEventEqual || !isExpandedEqual;
  };
}
var START_EVENT = [
  {
    label: "Start Event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate Throw Event",
    actionName: "replace-with-none-intermediate-throwing",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End Event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message Start Event",
    actionName: "replace-with-message-start",
    className: "bpmn-icon-start-event-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer Start Event",
    actionName: "replace-with-timer-start",
    className: "bpmn-icon-start-event-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Conditional Start Event",
    actionName: "replace-with-conditional-start",
    className: "bpmn-icon-start-event-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Signal Start Event",
    actionName: "replace-with-signal-start",
    className: "bpmn-icon-start-event-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
];
var START_EVENT_SUB_PROCESS = [
  {
    label: "Start Event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate Throw Event",
    actionName: "replace-with-none-intermediate-throwing",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End Event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  }
];
var INTERMEDIATE_EVENT = [
  {
    label: "Start Event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate Throw Event",
    actionName: "replace-with-none-intermediate-throw",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End Event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message Intermediate Catch Event",
    actionName: "replace-with-message-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Message Intermediate Throw Event",
    actionName: "replace-with-message-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-message",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer Intermediate Catch Event",
    actionName: "replace-with-timer-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Escalation Intermediate Throw Event",
    actionName: "replace-with-escalation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-escalation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Conditional Intermediate Catch Event",
    actionName: "replace-with-conditional-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Link Intermediate Catch Event",
    actionName: "replace-with-link-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-link",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Link Intermediate Throw Event",
    actionName: "replace-with-link-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-link",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Compensation Intermediate Throw Event",
    actionName: "replace-with-compensation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-compensation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal Intermediate Catch Event",
    actionName: "replace-with-signal-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Signal Intermediate Throw Event",
    actionName: "replace-with-signal-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-signal",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
];
var END_EVENT = [
  {
    label: "Start Event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate Throw Event",
    actionName: "replace-with-none-intermediate-throw",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End Event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message End Event",
    actionName: "replace-with-message-end",
    className: "bpmn-icon-end-event-message",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Escalation End Event",
    actionName: "replace-with-escalation-end",
    className: "bpmn-icon-end-event-escalation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Error End Event",
    actionName: "replace-with-error-end",
    className: "bpmn-icon-end-event-error",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition"
    }
  },
  {
    label: "Cancel End Event",
    actionName: "replace-with-cancel-end",
    className: "bpmn-icon-end-event-cancel",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition"
    }
  },
  {
    label: "Compensation End Event",
    actionName: "replace-with-compensation-end",
    className: "bpmn-icon-end-event-compensation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal End Event",
    actionName: "replace-with-signal-end",
    className: "bpmn-icon-end-event-signal",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Terminate End Event",
    actionName: "replace-with-terminate-end",
    className: "bpmn-icon-end-event-terminate",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:TerminateEventDefinition"
    }
  }
];
var GATEWAY = [
  {
    label: "Exclusive Gateway",
    actionName: "replace-with-exclusive-gateway",
    className: "bpmn-icon-gateway-xor",
    target: {
      type: "bpmn:ExclusiveGateway"
    }
  },
  {
    label: "Parallel Gateway",
    actionName: "replace-with-parallel-gateway",
    className: "bpmn-icon-gateway-parallel",
    target: {
      type: "bpmn:ParallelGateway"
    }
  },
  {
    label: "Inclusive Gateway",
    actionName: "replace-with-inclusive-gateway",
    className: "bpmn-icon-gateway-or",
    target: {
      type: "bpmn:InclusiveGateway"
    }
  },
  {
    label: "Complex Gateway",
    actionName: "replace-with-complex-gateway",
    className: "bpmn-icon-gateway-complex",
    target: {
      type: "bpmn:ComplexGateway"
    }
  },
  {
    label: "Event based Gateway",
    actionName: "replace-with-event-based-gateway",
    className: "bpmn-icon-gateway-eventbased",
    target: {
      type: "bpmn:EventBasedGateway",
      instantiate: false,
      eventGatewayType: "Exclusive"
    }
  }
];
var SUBPROCESS_EXPANDED = [
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Event Sub Process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  },
  {
    label: "Sub Process (collapsed)",
    actionName: "replace-with-collapsed-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: false
    }
  }
];
var TRANSACTION = [
  {
    label: "Sub Process",
    actionName: "replace-with-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Event Sub Process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  }
];
var EVENT_SUB_PROCESS = [
  {
    label: "Sub Process",
    actionName: "replace-with-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  }
];
var TASK = [
  {
    label: "Task",
    actionName: "replace-with-task",
    className: "bpmn-icon-task",
    target: {
      type: "bpmn:Task"
    }
  },
  {
    label: "Send Task",
    actionName: "replace-with-send-task",
    className: "bpmn-icon-send",
    target: {
      type: "bpmn:SendTask"
    }
  },
  {
    label: "Receive Task",
    actionName: "replace-with-receive-task",
    className: "bpmn-icon-receive",
    target: {
      type: "bpmn:ReceiveTask"
    }
  },
  {
    label: "User Task",
    actionName: "replace-with-user-task",
    className: "bpmn-icon-user",
    target: {
      type: "bpmn:UserTask"
    }
  },
  {
    label: "Manual Task",
    actionName: "replace-with-manual-task",
    className: "bpmn-icon-manual",
    target: {
      type: "bpmn:ManualTask"
    }
  },
  {
    label: "Business Rule Task",
    actionName: "replace-with-rule-task",
    className: "bpmn-icon-business-rule",
    target: {
      type: "bpmn:BusinessRuleTask"
    }
  },
  {
    label: "Service Task",
    actionName: "replace-with-service-task",
    className: "bpmn-icon-service",
    target: {
      type: "bpmn:ServiceTask"
    }
  },
  {
    label: "Script Task",
    actionName: "replace-with-script-task",
    className: "bpmn-icon-script",
    target: {
      type: "bpmn:ScriptTask"
    }
  },
  {
    label: "Call Activity",
    actionName: "replace-with-call-activity",
    className: "bpmn-icon-call-activity",
    target: {
      type: "bpmn:CallActivity"
    }
  },
  {
    label: "Sub Process (collapsed)",
    actionName: "replace-with-collapsed-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: false
    }
  },
  {
    label: "Sub Process (expanded)",
    actionName: "replace-with-expanded-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  }
];
var DATA_OBJECT_REFERENCE = [
  {
    label: "Data Store Reference",
    actionName: "replace-with-data-store-reference",
    className: "bpmn-icon-data-store",
    target: {
      type: "bpmn:DataStoreReference"
    }
  }
];
var DATA_STORE_REFERENCE = [
  {
    label: "Data Object Reference",
    actionName: "replace-with-data-object-reference",
    className: "bpmn-icon-data-object",
    target: {
      type: "bpmn:DataObjectReference"
    }
  }
];
var BOUNDARY_EVENT = [
  {
    label: "Message Boundary Event",
    actionName: "replace-with-message-boundary",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer Boundary Event",
    actionName: "replace-with-timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Escalation Boundary Event",
    actionName: "replace-with-escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Conditional Boundary Event",
    actionName: "replace-with-conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Error Boundary Event",
    actionName: "replace-with-error-boundary",
    className: "bpmn-icon-intermediate-event-catch-error",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition"
    }
  },
  {
    label: "Cancel Boundary Event",
    actionName: "replace-with-cancel-boundary",
    className: "bpmn-icon-intermediate-event-catch-cancel",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition"
    }
  },
  {
    label: "Signal Boundary Event",
    actionName: "replace-with-signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Compensation Boundary Event",
    actionName: "replace-with-compensation-boundary",
    className: "bpmn-icon-intermediate-event-catch-compensation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Message Boundary Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-message-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Timer Boundary Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Escalation Boundary Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Conditional Boundary Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Signal Boundary Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      cancelActivity: false
    }
  }
];
var EVENT_SUB_PROCESS_START_EVENT = [
  {
    label: "Message Start Event",
    actionName: "replace-with-message-start",
    className: "bpmn-icon-start-event-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer Start Event",
    actionName: "replace-with-timer-start",
    className: "bpmn-icon-start-event-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Conditional Start Event",
    actionName: "replace-with-conditional-start",
    className: "bpmn-icon-start-event-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Signal Start Event",
    actionName: "replace-with-signal-start",
    className: "bpmn-icon-start-event-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Error Start Event",
    actionName: "replace-with-error-start",
    className: "bpmn-icon-start-event-error",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition"
    }
  },
  {
    label: "Escalation Start Event",
    actionName: "replace-with-escalation-start",
    className: "bpmn-icon-start-event-escalation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Compensation Start Event",
    actionName: "replace-with-compensation-start",
    className: "bpmn-icon-start-event-compensation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Message Start Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-message-start",
    className: "bpmn-icon-start-event-non-interrupting-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Timer Start Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-timer-start",
    className: "bpmn-icon-start-event-non-interrupting-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Conditional Start Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-conditional-start",
    className: "bpmn-icon-start-event-non-interrupting-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Signal Start Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-signal-start",
    className: "bpmn-icon-start-event-non-interrupting-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Escalation Start Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-escalation-start",
    className: "bpmn-icon-start-event-non-interrupting-escalation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      isInterrupting: false
    }
  }
];
var SEQUENCE_FLOW = [
  {
    label: "Sequence Flow",
    actionName: "replace-with-sequence-flow",
    className: "bpmn-icon-connection"
  },
  {
    label: "Default Flow",
    actionName: "replace-with-default-flow",
    className: "bpmn-icon-default-flow"
  },
  {
    label: "Conditional Flow",
    actionName: "replace-with-conditional-flow",
    className: "bpmn-icon-conditional-flow"
  }
];
var PARTICIPANT = [
  {
    label: "Expanded Pool",
    actionName: "replace-with-expanded-pool",
    className: "bpmn-icon-participant",
    target: {
      type: "bpmn:Participant",
      isExpanded: true
    }
  },
  {
    label: function(element) {
      var label2 = "Empty Pool";
      if (element.children && element.children.length) {
        label2 += " (removes content)";
      }
      return label2;
    },
    actionName: "replace-with-collapsed-pool",
    className: "bpmn-icon-lane",
    target: {
      type: "bpmn:Participant",
      isExpanded: false
    }
  }
];
function ReplaceMenuProvider(bpmnFactory, popupMenu, modeling, moddle, bpmnReplace, rules, translate2) {
  this._bpmnFactory = bpmnFactory;
  this._popupMenu = popupMenu;
  this._modeling = modeling;
  this._moddle = moddle;
  this._bpmnReplace = bpmnReplace;
  this._rules = rules;
  this._translate = translate2;
  this.register();
}
ReplaceMenuProvider.$inject = [
  "bpmnFactory",
  "popupMenu",
  "modeling",
  "moddle",
  "bpmnReplace",
  "rules",
  "translate"
];
ReplaceMenuProvider.prototype.register = function() {
  this._popupMenu.registerProvider("bpmn-replace", this);
};
ReplaceMenuProvider.prototype.getEntries = function(element) {
  var businessObject = element.businessObject;
  var rules = this._rules;
  var entries;
  if (!rules.allowed("shape.replace", { element })) {
    return [];
  }
  var differentType = isDifferentType(element);
  if (is$O(businessObject, "bpmn:DataObjectReference")) {
    return this._createEntries(element, DATA_OBJECT_REFERENCE);
  }
  if (is$O(businessObject, "bpmn:DataStoreReference") && !is$O(element.parent, "bpmn:Collaboration")) {
    return this._createEntries(element, DATA_STORE_REFERENCE);
  }
  if (is$O(businessObject, "bpmn:StartEvent") && !is$O(businessObject.$parent, "bpmn:SubProcess")) {
    entries = filter$a(START_EVENT, differentType);
    return this._createEntries(element, entries);
  }
  if (is$O(businessObject, "bpmn:Participant")) {
    entries = filter$a(PARTICIPANT, function(entry) {
      return isExpanded(businessObject) !== entry.target.isExpanded;
    });
    return this._createEntries(element, entries);
  }
  if (is$O(businessObject, "bpmn:StartEvent") && isEventSubProcess$1(businessObject.$parent)) {
    entries = filter$a(EVENT_SUB_PROCESS_START_EVENT, function(entry) {
      var target = entry.target;
      var isInterrupting2 = target.isInterrupting !== false;
      var isInterruptingEqual = getBusinessObject$V(element).isInterrupting === isInterrupting2;
      return differentType(entry) || !differentType(entry) && !isInterruptingEqual;
    });
    return this._createEntries(element, entries);
  }
  if (is$O(businessObject, "bpmn:StartEvent") && !isEventSubProcess$1(businessObject.$parent) && is$O(businessObject.$parent, "bpmn:SubProcess")) {
    entries = filter$a(START_EVENT_SUB_PROCESS, differentType);
    return this._createEntries(element, entries);
  }
  if (is$O(businessObject, "bpmn:EndEvent")) {
    entries = filter$a(END_EVENT, function(entry) {
      var target = entry.target;
      if (target.eventDefinitionType == "bpmn:CancelEventDefinition" && !is$O(businessObject.$parent, "bpmn:Transaction")) {
        return false;
      }
      return differentType(entry);
    });
    return this._createEntries(element, entries);
  }
  if (is$O(businessObject, "bpmn:BoundaryEvent")) {
    entries = filter$a(BOUNDARY_EVENT, function(entry) {
      var target = entry.target;
      if (target.eventDefinitionType == "bpmn:CancelEventDefinition" && !is$O(businessObject.attachedToRef, "bpmn:Transaction")) {
        return false;
      }
      var cancelActivity = target.cancelActivity !== false;
      var isCancelActivityEqual = businessObject.cancelActivity == cancelActivity;
      return differentType(entry) || !differentType(entry) && !isCancelActivityEqual;
    });
    return this._createEntries(element, entries);
  }
  if (is$O(businessObject, "bpmn:IntermediateCatchEvent") || is$O(businessObject, "bpmn:IntermediateThrowEvent")) {
    entries = filter$a(INTERMEDIATE_EVENT, differentType);
    return this._createEntries(element, entries);
  }
  if (is$O(businessObject, "bpmn:Gateway")) {
    entries = filter$a(GATEWAY, differentType);
    return this._createEntries(element, entries);
  }
  if (is$O(businessObject, "bpmn:Transaction")) {
    entries = filter$a(TRANSACTION, differentType);
    return this._createEntries(element, entries);
  }
  if (isEventSubProcess$1(businessObject) && isExpanded(businessObject)) {
    entries = filter$a(EVENT_SUB_PROCESS, differentType);
    return this._createEntries(element, entries);
  }
  if (is$O(businessObject, "bpmn:SubProcess") && isExpanded(businessObject)) {
    entries = filter$a(SUBPROCESS_EXPANDED, differentType);
    return this._createEntries(element, entries);
  }
  if (is$O(businessObject, "bpmn:AdHocSubProcess") && !isExpanded(businessObject)) {
    entries = filter$a(TASK, function(entry) {
      var target = entry.target;
      var isTargetSubProcess = target.type === "bpmn:SubProcess";
      var isTargetExpanded = target.isExpanded === true;
      return isDifferentType(element) && (!isTargetSubProcess || isTargetExpanded);
    });
    return this._createEntries(element, entries);
  }
  if (is$O(businessObject, "bpmn:SequenceFlow")) {
    return this._createSequenceFlowEntries(element, SEQUENCE_FLOW);
  }
  if (is$O(businessObject, "bpmn:FlowNode")) {
    entries = filter$a(TASK, differentType);
    if (is$O(businessObject, "bpmn:SubProcess") && !isExpanded(businessObject)) {
      entries = filter$a(entries, function(entry) {
        return entry.label !== "Sub Process (collapsed)";
      });
    }
    return this._createEntries(element, entries);
  }
  return [];
};
ReplaceMenuProvider.prototype.getHeaderEntries = function(element) {
  var headerEntries = [];
  if (is$O(element, "bpmn:Activity") && !isEventSubProcess$1(element)) {
    headerEntries = headerEntries.concat(this._getLoopEntries(element));
  }
  if (is$O(element, "bpmn:DataObjectReference")) {
    headerEntries = headerEntries.concat(this._getDataObjectIsCollection(element));
  }
  if (is$O(element, "bpmn:Participant")) {
    headerEntries = headerEntries.concat(this._getParticipantMultiplicity(element));
  }
  if (is$O(element, "bpmn:SubProcess") && !is$O(element, "bpmn:Transaction") && !isEventSubProcess$1(element)) {
    headerEntries.push(this._getAdHocEntry(element));
  }
  return headerEntries;
};
ReplaceMenuProvider.prototype._createEntries = function(element, replaceOptions) {
  var menuEntries = [];
  var self2 = this;
  forEach$q(replaceOptions, function(definition) {
    var entry = self2._createMenuEntry(definition, element);
    menuEntries.push(entry);
  });
  return menuEntries;
};
ReplaceMenuProvider.prototype._createSequenceFlowEntries = function(element, replaceOptions) {
  var businessObject = getBusinessObject$V(element);
  var menuEntries = [];
  var modeling = this._modeling, moddle = this._moddle;
  var self2 = this;
  forEach$q(replaceOptions, function(entry) {
    switch (entry.actionName) {
      case "replace-with-default-flow":
        if (businessObject.sourceRef.default !== businessObject && (is$O(businessObject.sourceRef, "bpmn:ExclusiveGateway") || is$O(businessObject.sourceRef, "bpmn:InclusiveGateway") || is$O(businessObject.sourceRef, "bpmn:ComplexGateway") || is$O(businessObject.sourceRef, "bpmn:Activity"))) {
          menuEntries.push(self2._createMenuEntry(entry, element, function() {
            modeling.updateProperties(element.source, { default: businessObject });
          }));
        }
        break;
      case "replace-with-conditional-flow":
        if (!businessObject.conditionExpression && is$O(businessObject.sourceRef, "bpmn:Activity")) {
          menuEntries.push(self2._createMenuEntry(entry, element, function() {
            var conditionExpression = moddle.create("bpmn:FormalExpression", { body: "" });
            modeling.updateProperties(element, { conditionExpression });
          }));
        }
        break;
      default:
        if (is$O(businessObject.sourceRef, "bpmn:Activity") && businessObject.conditionExpression) {
          return menuEntries.push(self2._createMenuEntry(entry, element, function() {
            modeling.updateProperties(element, { conditionExpression: void 0 });
          }));
        }
        if ((is$O(businessObject.sourceRef, "bpmn:ExclusiveGateway") || is$O(businessObject.sourceRef, "bpmn:InclusiveGateway") || is$O(businessObject.sourceRef, "bpmn:ComplexGateway") || is$O(businessObject.sourceRef, "bpmn:Activity")) && businessObject.sourceRef.default === businessObject) {
          return menuEntries.push(self2._createMenuEntry(entry, element, function() {
            modeling.updateProperties(element.source, { default: void 0 });
          }));
        }
    }
  });
  return menuEntries;
};
ReplaceMenuProvider.prototype._createMenuEntry = function(definition, element, action) {
  var translate2 = this._translate;
  var replaceElement = this._bpmnReplace.replaceElement;
  var replaceAction = function() {
    return replaceElement(element, definition.target);
  };
  var label2 = definition.label;
  if (label2 && typeof label2 === "function") {
    label2 = label2(element);
  }
  action = action || replaceAction;
  var menuEntry = {
    label: translate2(label2),
    className: definition.className,
    id: definition.actionName,
    action
  };
  return menuEntry;
};
ReplaceMenuProvider.prototype._getLoopEntries = function(element) {
  var self2 = this;
  var translate2 = this._translate;
  function toggleLoopEntry(event, entry) {
    var loopCharacteristics2;
    if (entry.active) {
      loopCharacteristics2 = void 0;
    } else {
      loopCharacteristics2 = self2._moddle.create(entry.options.loopCharacteristics);
      if (entry.options.isSequential) {
        loopCharacteristics2.isSequential = entry.options.isSequential;
      }
    }
    self2._modeling.updateProperties(element, { loopCharacteristics: loopCharacteristics2 });
  }
  var businessObject = getBusinessObject$V(element), loopCharacteristics = businessObject.loopCharacteristics;
  var isSequential, isLoop, isParallel;
  if (loopCharacteristics) {
    isSequential = loopCharacteristics.isSequential;
    isLoop = loopCharacteristics.isSequential === void 0;
    isParallel = loopCharacteristics.isSequential !== void 0 && !loopCharacteristics.isSequential;
  }
  var loopEntries = [
    {
      id: "toggle-parallel-mi",
      className: "bpmn-icon-parallel-mi-marker",
      title: translate2("Parallel Multi Instance"),
      active: isParallel,
      action: toggleLoopEntry,
      options: {
        loopCharacteristics: "bpmn:MultiInstanceLoopCharacteristics",
        isSequential: false
      }
    },
    {
      id: "toggle-sequential-mi",
      className: "bpmn-icon-sequential-mi-marker",
      title: translate2("Sequential Multi Instance"),
      active: isSequential,
      action: toggleLoopEntry,
      options: {
        loopCharacteristics: "bpmn:MultiInstanceLoopCharacteristics",
        isSequential: true
      }
    },
    {
      id: "toggle-loop",
      className: "bpmn-icon-loop-marker",
      title: translate2("Loop"),
      active: isLoop,
      action: toggleLoopEntry,
      options: {
        loopCharacteristics: "bpmn:StandardLoopCharacteristics"
      }
    }
  ];
  return loopEntries;
};
ReplaceMenuProvider.prototype._getDataObjectIsCollection = function(element) {
  var self2 = this;
  var translate2 = this._translate;
  function toggleIsCollection(event, entry) {
    self2._modeling.updateModdleProperties(element, dataObject, { isCollection: !entry.active });
  }
  var dataObject = element.businessObject.dataObjectRef, isCollection2 = dataObject.isCollection;
  var dataObjectEntries = [
    {
      id: "toggle-is-collection",
      className: "bpmn-icon-parallel-mi-marker",
      title: translate2("Collection"),
      active: isCollection2,
      action: toggleIsCollection
    }
  ];
  return dataObjectEntries;
};
ReplaceMenuProvider.prototype._getParticipantMultiplicity = function(element) {
  var self2 = this;
  var bpmnFactory = this._bpmnFactory;
  var translate2 = this._translate;
  function toggleParticipantMultiplicity(event, entry) {
    var isActive = entry.active;
    var participantMultiplicity2;
    if (!isActive) {
      participantMultiplicity2 = bpmnFactory.create("bpmn:ParticipantMultiplicity");
    }
    self2._modeling.updateProperties(element, { participantMultiplicity: participantMultiplicity2 });
  }
  var participantMultiplicity = element.businessObject.participantMultiplicity;
  var participantEntries = [
    {
      id: "toggle-participant-multiplicity",
      className: "bpmn-icon-parallel-mi-marker",
      title: translate2("Participant Multiplicity"),
      active: !!participantMultiplicity,
      action: toggleParticipantMultiplicity
    }
  ];
  return participantEntries;
};
ReplaceMenuProvider.prototype._getAdHocEntry = function(element) {
  var translate2 = this._translate;
  var businessObject = getBusinessObject$V(element);
  var isAdHoc = is$O(businessObject, "bpmn:AdHocSubProcess");
  var replaceElement = this._bpmnReplace.replaceElement;
  var adHocEntry = {
    id: "toggle-adhoc",
    className: "bpmn-icon-ad-hoc-marker",
    title: translate2("Ad-hoc"),
    active: isAdHoc,
    action: function(event, entry) {
      if (isAdHoc) {
        return replaceElement(element, { type: "bpmn:SubProcess" }, {
          autoResize: false,
          layoutConnection: false
        });
      } else {
        return replaceElement(element, { type: "bpmn:AdHocSubProcess" }, {
          autoResize: false,
          layoutConnection: false
        });
      }
    }
  };
  return adHocEntry;
};
var PopupMenuModule = {
  __depends__: [
    PopupMenuModule$1,
    ReplaceModule
  ],
  __init__: ["replaceMenuProvider"],
  replaceMenuProvider: ["type", ReplaceMenuProvider]
};
var max$4 = Math.max, min$2 = Math.min;
var DEFAULT_CHILD_BOX_PADDING = 20;
function substractTRBL(trblA, trblB) {
  return {
    top: trblA.top - trblB.top,
    right: trblA.right - trblB.right,
    bottom: trblA.bottom - trblB.bottom,
    left: trblA.left - trblB.left
  };
}
function resizeBounds$1(bounds, direction, delta2) {
  var dx = delta2.x, dy = delta2.y;
  var newBounds = {
    x: bounds.x,
    y: bounds.y,
    width: bounds.width,
    height: bounds.height
  };
  if (direction.indexOf("n") !== -1) {
    newBounds.y = bounds.y + dy;
    newBounds.height = bounds.height - dy;
  } else if (direction.indexOf("s") !== -1) {
    newBounds.height = bounds.height + dy;
  }
  if (direction.indexOf("e") !== -1) {
    newBounds.width = bounds.width + dx;
  } else if (direction.indexOf("w") !== -1) {
    newBounds.x = bounds.x + dx;
    newBounds.width = bounds.width - dx;
  }
  return newBounds;
}
function resizeTRBL(bounds, resize) {
  return {
    x: bounds.x + (resize.left || 0),
    y: bounds.y + (resize.top || 0),
    width: bounds.width - (resize.left || 0) + (resize.right || 0),
    height: bounds.height - (resize.top || 0) + (resize.bottom || 0)
  };
}
function applyConstraints(attr2, trbl, resizeConstraints) {
  var value = trbl[attr2], minValue = resizeConstraints.min && resizeConstraints.min[attr2], maxValue = resizeConstraints.max && resizeConstraints.max[attr2];
  if (isNumber$1(minValue)) {
    value = (/top|left/.test(attr2) ? min$2 : max$4)(value, minValue);
  }
  if (isNumber$1(maxValue)) {
    value = (/top|left/.test(attr2) ? max$4 : min$2)(value, maxValue);
  }
  return value;
}
function ensureConstraints$1(currentBounds, resizeConstraints) {
  if (!resizeConstraints) {
    return currentBounds;
  }
  var currentTrbl = asTRBL(currentBounds);
  return asBounds({
    top: applyConstraints("top", currentTrbl, resizeConstraints),
    right: applyConstraints("right", currentTrbl, resizeConstraints),
    bottom: applyConstraints("bottom", currentTrbl, resizeConstraints),
    left: applyConstraints("left", currentTrbl, resizeConstraints)
  });
}
function getMinResizeBounds(direction, currentBounds, minDimensions, childrenBounds) {
  var currentBox = asTRBL(currentBounds);
  var minBox = {
    top: /n/.test(direction) ? currentBox.bottom - minDimensions.height : currentBox.top,
    left: /w/.test(direction) ? currentBox.right - minDimensions.width : currentBox.left,
    bottom: /s/.test(direction) ? currentBox.top + minDimensions.height : currentBox.bottom,
    right: /e/.test(direction) ? currentBox.left + minDimensions.width : currentBox.right
  };
  var childrenBox = childrenBounds ? asTRBL(childrenBounds) : minBox;
  var combinedBox = {
    top: min$2(minBox.top, childrenBox.top),
    left: min$2(minBox.left, childrenBox.left),
    bottom: max$4(minBox.bottom, childrenBox.bottom),
    right: max$4(minBox.right, childrenBox.right)
  };
  return asBounds(combinedBox);
}
function asPadding(mayBePadding, defaultValue) {
  if (typeof mayBePadding !== "undefined") {
    return mayBePadding;
  } else {
    return DEFAULT_CHILD_BOX_PADDING;
  }
}
function addPadding$1(bbox, padding) {
  var left, right, top, bottom;
  if (typeof padding === "object") {
    left = asPadding(padding.left);
    right = asPadding(padding.right);
    top = asPadding(padding.top);
    bottom = asPadding(padding.bottom);
  } else {
    left = right = top = bottom = asPadding(padding);
  }
  return {
    x: bbox.x - left,
    y: bbox.y - top,
    width: bbox.width + left + right,
    height: bbox.height + top + bottom
  };
}
function isBBoxChild(element) {
  if (element.waypoints) {
    return false;
  }
  if (element.type === "label") {
    return false;
  }
  return true;
}
function computeChildrenBBox(shapeOrChildren, padding) {
  var elements;
  if (shapeOrChildren.length === void 0) {
    elements = filter$a(shapeOrChildren.children, isBBoxChild);
  } else {
    elements = shapeOrChildren;
  }
  if (elements.length) {
    return addPadding$1(getBBox(elements), padding);
  }
}
var abs$4 = Math.abs;
function getTRBLResize(oldBounds, newBounds) {
  return substractTRBL(asTRBL(newBounds), asTRBL(oldBounds));
}
var LANE_PARENTS = [
  "bpmn:Participant",
  "bpmn:Process",
  "bpmn:SubProcess"
];
var LANE_INDENTATION = 30;
function collectLanes(shape, collectedShapes) {
  collectedShapes = collectedShapes || [];
  shape.children.filter(function(s) {
    if (is$O(s, "bpmn:Lane")) {
      collectLanes(s, collectedShapes);
      collectedShapes.push(s);
    }
  });
  return collectedShapes;
}
function getChildLanes(shape) {
  return shape.children.filter(function(c) {
    return is$O(c, "bpmn:Lane");
  });
}
function getLanesRoot(shape) {
  return getParent$1(shape, LANE_PARENTS) || shape;
}
function computeLanesResize(shape, newBounds) {
  var rootElement = getLanesRoot(shape);
  var initialShapes = is$O(rootElement, "bpmn:Process") ? [] : [rootElement];
  var allLanes = collectLanes(rootElement, initialShapes), shapeTrbl = asTRBL(shape), shapeNewTrbl = asTRBL(newBounds), trblResize = getTRBLResize(shape, newBounds), resizeNeeded = [];
  allLanes.forEach(function(other) {
    if (other === shape) {
      return;
    }
    var topResize = 0, rightResize = trblResize.right, bottomResize = 0, leftResize = trblResize.left;
    var otherTrbl = asTRBL(other);
    if (trblResize.top) {
      if (abs$4(otherTrbl.bottom - shapeTrbl.top) < 10) {
        bottomResize = shapeNewTrbl.top - otherTrbl.bottom;
      }
      if (abs$4(otherTrbl.top - shapeTrbl.top) < 5) {
        topResize = shapeNewTrbl.top - otherTrbl.top;
      }
    }
    if (trblResize.bottom) {
      if (abs$4(otherTrbl.top - shapeTrbl.bottom) < 10) {
        topResize = shapeNewTrbl.bottom - otherTrbl.top;
      }
      if (abs$4(otherTrbl.bottom - shapeTrbl.bottom) < 5) {
        bottomResize = shapeNewTrbl.bottom - otherTrbl.bottom;
      }
    }
    if (topResize || rightResize || bottomResize || leftResize) {
      resizeNeeded.push({
        shape: other,
        newBounds: resizeTRBL(other, {
          top: topResize,
          right: rightResize,
          bottom: bottomResize,
          left: leftResize
        })
      });
    }
  });
  return resizeNeeded;
}
function ContextPadProvider(config, injector, eventBus, contextPad, modeling, elementFactory, connect, create2, popupMenu, canvas, rules, translate2) {
  config = config || {};
  contextPad.registerProvider(this);
  this._contextPad = contextPad;
  this._modeling = modeling;
  this._elementFactory = elementFactory;
  this._connect = connect;
  this._create = create2;
  this._popupMenu = popupMenu;
  this._canvas = canvas;
  this._rules = rules;
  this._translate = translate2;
  if (config.autoPlace !== false) {
    this._autoPlace = injector.get("autoPlace", false);
  }
  eventBus.on("create.end", 250, function(event) {
    var context = event.context, shape = context.shape;
    if (!hasPrimaryModifier(event) || !contextPad.isOpen(shape)) {
      return;
    }
    var entries = contextPad.getEntries(shape);
    if (entries.replace) {
      entries.replace.action.click(event, shape);
    }
  });
}
ContextPadProvider.$inject = [
  "config.contextPad",
  "injector",
  "eventBus",
  "contextPad",
  "modeling",
  "elementFactory",
  "connect",
  "create",
  "popupMenu",
  "canvas",
  "rules",
  "translate"
];
ContextPadProvider.prototype.getContextPadEntries = function(element) {
  var contextPad = this._contextPad, modeling = this._modeling, elementFactory = this._elementFactory, connect = this._connect, create2 = this._create, popupMenu = this._popupMenu, canvas = this._canvas, rules = this._rules, autoPlace = this._autoPlace, translate2 = this._translate;
  var actions = {};
  if (element.type === "label") {
    return actions;
  }
  var businessObject = element.businessObject;
  function startConnect(event, element2) {
    connect.start(event, element2);
  }
  function removeElement2(e) {
    modeling.removeElements([element]);
  }
  function getReplaceMenuPosition(element2) {
    var Y_OFFSET = 5;
    var diagramContainer = canvas.getContainer(), pad = contextPad.getPad(element2).html;
    var diagramRect = diagramContainer.getBoundingClientRect(), padRect = pad.getBoundingClientRect();
    var top = padRect.top - diagramRect.top;
    var left = padRect.left - diagramRect.left;
    var pos = {
      x: left,
      y: top + padRect.height + Y_OFFSET
    };
    return pos;
  }
  function appendAction(type, className, title, options) {
    if (typeof title !== "string") {
      options = title;
      title = translate2("Append {type}", { type: type.replace(/^bpmn:/, "") });
    }
    function appendStart(event, element2) {
      var shape = elementFactory.createShape(assign$e({ type }, options));
      create2.start(event, shape, {
        source: element2
      });
    }
    var append2 = autoPlace ? function(event, element2) {
      var shape = elementFactory.createShape(assign$e({ type }, options));
      autoPlace.append(element2, shape);
    } : appendStart;
    return {
      group: "model",
      className,
      title,
      action: {
        dragstart: appendStart,
        click: append2
      }
    };
  }
  function splitLaneHandler(count) {
    return function(event, element2) {
      modeling.splitLane(element2, count);
      contextPad.open(element2, true);
    };
  }
  if (isAny$b(businessObject, ["bpmn:Lane", "bpmn:Participant"]) && isExpanded(businessObject)) {
    var childLanes = getChildLanes(element);
    assign$e(actions, {
      "lane-insert-above": {
        group: "lane-insert-above",
        className: "bpmn-icon-lane-insert-above",
        title: translate2("Add Lane above"),
        action: {
          click: function(event, element2) {
            modeling.addLane(element2, "top");
          }
        }
      }
    });
    if (childLanes.length < 2) {
      if (element.height >= 120) {
        assign$e(actions, {
          "lane-divide-two": {
            group: "lane-divide",
            className: "bpmn-icon-lane-divide-two",
            title: translate2("Divide into two Lanes"),
            action: {
              click: splitLaneHandler(2)
            }
          }
        });
      }
      if (element.height >= 180) {
        assign$e(actions, {
          "lane-divide-three": {
            group: "lane-divide",
            className: "bpmn-icon-lane-divide-three",
            title: translate2("Divide into three Lanes"),
            action: {
              click: splitLaneHandler(3)
            }
          }
        });
      }
    }
    assign$e(actions, {
      "lane-insert-below": {
        group: "lane-insert-below",
        className: "bpmn-icon-lane-insert-below",
        title: translate2("Add Lane below"),
        action: {
          click: function(event, element2) {
            modeling.addLane(element2, "bottom");
          }
        }
      }
    });
  }
  if (is$O(businessObject, "bpmn:FlowNode")) {
    if (is$O(businessObject, "bpmn:EventBasedGateway")) {
      assign$e(actions, {
        "append.receive-task": appendAction("bpmn:ReceiveTask", "bpmn-icon-receive-task", translate2("Append ReceiveTask")),
        "append.message-intermediate-event": appendAction("bpmn:IntermediateCatchEvent", "bpmn-icon-intermediate-event-catch-message", translate2("Append MessageIntermediateCatchEvent"), { eventDefinitionType: "bpmn:MessageEventDefinition" }),
        "append.timer-intermediate-event": appendAction("bpmn:IntermediateCatchEvent", "bpmn-icon-intermediate-event-catch-timer", translate2("Append TimerIntermediateCatchEvent"), { eventDefinitionType: "bpmn:TimerEventDefinition" }),
        "append.condition-intermediate-event": appendAction("bpmn:IntermediateCatchEvent", "bpmn-icon-intermediate-event-catch-condition", translate2("Append ConditionIntermediateCatchEvent"), { eventDefinitionType: "bpmn:ConditionalEventDefinition" }),
        "append.signal-intermediate-event": appendAction("bpmn:IntermediateCatchEvent", "bpmn-icon-intermediate-event-catch-signal", translate2("Append SignalIntermediateCatchEvent"), { eventDefinitionType: "bpmn:SignalEventDefinition" })
      });
    } else if (isEventType(businessObject, "bpmn:BoundaryEvent", "bpmn:CompensateEventDefinition")) {
      assign$e(actions, {
        "append.compensation-activity": appendAction("bpmn:Task", "bpmn-icon-task", translate2("Append compensation activity"), {
          isForCompensation: true
        })
      });
    } else if (!is$O(businessObject, "bpmn:EndEvent") && !businessObject.isForCompensation && !isEventType(businessObject, "bpmn:IntermediateThrowEvent", "bpmn:LinkEventDefinition") && !isEventSubProcess$1(businessObject)) {
      assign$e(actions, {
        "append.end-event": appendAction("bpmn:EndEvent", "bpmn-icon-end-event-none", translate2("Append EndEvent")),
        "append.gateway": appendAction("bpmn:ExclusiveGateway", "bpmn-icon-gateway-none", translate2("Append Gateway")),
        "append.append-task": appendAction("bpmn:Task", "bpmn-icon-task", translate2("Append Task")),
        "append.intermediate-event": appendAction("bpmn:IntermediateThrowEvent", "bpmn-icon-intermediate-event-none", translate2("Append Intermediate/Boundary Event"))
      });
    }
  }
  if (!popupMenu.isEmpty(element, "bpmn-replace")) {
    assign$e(actions, {
      "replace": {
        group: "edit",
        className: "bpmn-icon-screw-wrench",
        title: translate2("Change type"),
        action: {
          click: function(event, element2) {
            var position = assign$e(getReplaceMenuPosition(element2), {
              cursor: { x: event.x, y: event.y }
            });
            popupMenu.open(element2, "bpmn-replace", position);
          }
        }
      }
    });
  }
  if (isAny$b(businessObject, [
    "bpmn:FlowNode",
    "bpmn:InteractionNode",
    "bpmn:DataObjectReference",
    "bpmn:DataStoreReference"
  ])) {
    assign$e(actions, {
      "append.text-annotation": appendAction("bpmn:TextAnnotation", "bpmn-icon-text-annotation"),
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate2("Connect using " + (businessObject.isForCompensation ? "" : "Sequence/MessageFlow or ") + "Association"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (is$O(businessObject, "bpmn:TextAnnotation")) {
    assign$e(actions, {
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate2("Connect using Association"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (isAny$b(businessObject, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"])) {
    assign$e(actions, {
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate2("Connect using DataInputAssociation"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (is$O(businessObject, "bpmn:Group")) {
    assign$e(actions, {
      "append.text-annotation": appendAction("bpmn:TextAnnotation", "bpmn-icon-text-annotation")
    });
  }
  var deleteAllowed = rules.allowed("elements.delete", { elements: [element] });
  if (isArray$n(deleteAllowed)) {
    deleteAllowed = deleteAllowed[0] === element;
  }
  if (deleteAllowed) {
    assign$e(actions, {
      "delete": {
        group: "edit",
        className: "bpmn-icon-trash",
        title: translate2("Remove"),
        action: {
          click: removeElement2
        }
      }
    });
  }
  return actions;
};
function isEventType(eventBo, type, definition) {
  var isType2 = eventBo.$instanceOf(type);
  var isDefinition = false;
  var definitions = eventBo.eventDefinitions || [];
  forEach$q(definitions, function(def) {
    if (def.$type === definition) {
      isDefinition = true;
    }
  });
  return isType2 && isDefinition;
}
var ContextPadModule = {
  __depends__: [
    DirectEditingModule,
    ContextPadModule$1,
    SelectionModule,
    ConnectModule,
    CreateModule,
    PopupMenuModule
  ],
  __init__: ["contextPadProvider"],
  contextPadProvider: ["type", ContextPadProvider]
};
var AXIS_DIMENSIONS = {
  horizontal: ["x", "width"],
  vertical: ["y", "height"]
};
var THRESHOLD = 5;
function DistributeElements$1(modeling) {
  this._modeling = modeling;
  this._filters = [];
  this.registerFilter(function(elements, axis, dimension) {
    var elementsSize = 0, numOfShapes = 0, avgDimension;
    forEach$q(elements, function(element) {
      if (element.waypoints || element.labelTarget) {
        return;
      }
      elementsSize += element[dimension];
      numOfShapes += 1;
    });
    avgDimension = Math.round(elementsSize / numOfShapes);
    return filter$a(elements, function(element) {
      return element[dimension] < avgDimension + 50;
    });
  });
}
DistributeElements$1.$inject = ["modeling"];
DistributeElements$1.prototype.registerFilter = function(filterFn) {
  if (typeof filterFn !== "function") {
    throw new Error("the filter has to be a function");
  }
  this._filters.push(filterFn);
};
DistributeElements$1.prototype.trigger = function(elements, orientation) {
  var modeling = this._modeling;
  var groups, distributableElements;
  if (elements.length < 3) {
    return;
  }
  this._setOrientation(orientation);
  distributableElements = this._filterElements(elements);
  groups = this._createGroups(distributableElements);
  if (groups.length <= 2) {
    return;
  }
  modeling.distributeElements(groups, this._axis, this._dimension);
  return groups;
};
DistributeElements$1.prototype._filterElements = function(elements) {
  var filters = this._filters, axis = this._axis, dimension = this._dimension, distributableElements = [].concat(elements);
  if (!filters.length) {
    return elements;
  }
  forEach$q(filters, function(filterFn) {
    distributableElements = filterFn(distributableElements, axis, dimension);
  });
  return distributableElements;
};
DistributeElements$1.prototype._createGroups = function(elements) {
  var rangeGroups = [], self2 = this, axis = this._axis, dimension = this._dimension;
  if (!axis) {
    throw new Error('must have a defined "axis" and "dimension"');
  }
  var sortedElements = sortBy$2(elements, axis);
  forEach$q(sortedElements, function(element, idx) {
    var elementRange = self2._findRange(element, axis, dimension), range2;
    var previous = rangeGroups[rangeGroups.length - 1];
    if (previous && self2._hasIntersection(previous.range, elementRange)) {
      rangeGroups[rangeGroups.length - 1].elements.push(element);
    } else {
      range2 = { range: elementRange, elements: [element] };
      rangeGroups.push(range2);
    }
  });
  return rangeGroups;
};
DistributeElements$1.prototype._setOrientation = function(direction) {
  var orientation = AXIS_DIMENSIONS[direction];
  this._axis = orientation[0];
  this._dimension = orientation[1];
};
DistributeElements$1.prototype._hasIntersection = function(rangeA, rangeB) {
  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) && Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);
};
DistributeElements$1.prototype._findRange = function(element) {
  var axis = element[this._axis], dimension = element[this._dimension];
  return {
    min: axis + THRESHOLD,
    max: axis + dimension - THRESHOLD
  };
};
var DistributeElementsModule$1 = {
  __init__: ["distributeElements"],
  distributeElements: ["type", DistributeElements$1]
};
function BpmnDistributeElements(distributeElements) {
  distributeElements.registerFilter(function(elements) {
    return filter$a(elements, function(element) {
      var cannotDistribute = isAny$b(element, [
        "bpmn:Association",
        "bpmn:BoundaryEvent",
        "bpmn:DataInputAssociation",
        "bpmn:DataOutputAssociation",
        "bpmn:Lane",
        "bpmn:MessageFlow",
        "bpmn:Participant",
        "bpmn:SequenceFlow",
        "bpmn:TextAnnotation"
      ]);
      return !(element.labelTarget || cannotDistribute);
    });
  });
}
BpmnDistributeElements.$inject = ["distributeElements"];
var DistributeElementsModule = {
  __depends__: [
    DistributeElementsModule$1
  ],
  __init__: ["bpmnDistributeElements"],
  bpmnDistributeElements: ["type", BpmnDistributeElements]
};
var NOT_REGISTERED_ERROR = "is not a registered action", IS_REGISTERED_ERROR = "is already registered";
function EditorActions(eventBus, injector) {
  this._actions = {};
  var self2 = this;
  eventBus.on("diagram.init", function() {
    self2._registerDefaultActions(injector);
    eventBus.fire("editorActions.init", {
      editorActions: self2
    });
  });
}
EditorActions.$inject = [
  "eventBus",
  "injector"
];
EditorActions.prototype._registerDefaultActions = function(injector) {
  var commandStack = injector.get("commandStack", false);
  var modeling = injector.get("modeling", false);
  var selection = injector.get("selection", false);
  var zoomScroll = injector.get("zoomScroll", false);
  var copyPaste = injector.get("copyPaste", false);
  var canvas = injector.get("canvas", false);
  var rules = injector.get("rules", false);
  var keyboardMove = injector.get("keyboardMove", false);
  var keyboardMoveSelection = injector.get("keyboardMoveSelection", false);
  if (commandStack) {
    this.register("undo", function() {
      commandStack.undo();
    });
    this.register("redo", function() {
      commandStack.redo();
    });
  }
  if (copyPaste && selection) {
    this.register("copy", function() {
      var selectedElements = selection.get();
      copyPaste.copy(selectedElements);
    });
  }
  if (copyPaste) {
    this.register("paste", function() {
      copyPaste.paste();
    });
  }
  if (zoomScroll) {
    this.register("stepZoom", function(opts) {
      zoomScroll.stepZoom(opts.value);
    });
  }
  if (canvas) {
    this.register("zoom", function(opts) {
      canvas.zoom(opts.value);
    });
  }
  if (modeling && selection && rules) {
    this.register("removeSelection", function() {
      var selectedElements = selection.get();
      if (!selectedElements.length) {
        return;
      }
      var allowed = rules.allowed("elements.delete", { elements: selectedElements }), removableElements;
      if (allowed === false) {
        return;
      } else if (isArray$n(allowed)) {
        removableElements = allowed;
      } else {
        removableElements = selectedElements;
      }
      if (removableElements.length) {
        modeling.removeElements(removableElements.slice());
      }
    });
  }
  if (keyboardMove) {
    this.register("moveCanvas", function(opts) {
      keyboardMove.moveCanvas(opts);
    });
  }
  if (keyboardMoveSelection) {
    this.register("moveSelection", function(opts) {
      keyboardMoveSelection.moveSelection(opts.direction, opts.accelerated);
    });
  }
};
EditorActions.prototype.trigger = function(action, opts) {
  if (!this._actions[action]) {
    throw error$2(action, NOT_REGISTERED_ERROR);
  }
  return this._actions[action](opts);
};
EditorActions.prototype.register = function(actions, listener2) {
  var self2 = this;
  if (typeof actions === "string") {
    return this._registerAction(actions, listener2);
  }
  forEach$q(actions, function(listener3, action) {
    self2._registerAction(action, listener3);
  });
};
EditorActions.prototype._registerAction = function(action, listener2) {
  if (this.isRegistered(action)) {
    throw error$2(action, IS_REGISTERED_ERROR);
  }
  this._actions[action] = listener2;
};
EditorActions.prototype.unregister = function(action) {
  if (!this.isRegistered(action)) {
    throw error$2(action, NOT_REGISTERED_ERROR);
  }
  this._actions[action] = void 0;
};
EditorActions.prototype.getActions = function() {
  return Object.keys(this._actions);
};
EditorActions.prototype.isRegistered = function(action) {
  return !!this._actions[action];
};
function error$2(action, message2) {
  return new Error(action + " " + message2);
}
var EditorActionsModule$1 = {
  __init__: ["editorActions"],
  editorActions: ["type", EditorActions]
};
function BpmnEditorActions(injector) {
  injector.invoke(EditorActions, this);
}
inherits$6(BpmnEditorActions, EditorActions);
BpmnEditorActions.$inject = [
  "injector"
];
BpmnEditorActions.prototype._registerDefaultActions = function(injector) {
  EditorActions.prototype._registerDefaultActions.call(this, injector);
  var canvas = injector.get("canvas", false);
  var elementRegistry = injector.get("elementRegistry", false);
  var selection = injector.get("selection", false);
  var spaceTool = injector.get("spaceTool", false);
  var lassoTool = injector.get("lassoTool", false);
  var handTool = injector.get("handTool", false);
  var globalConnect = injector.get("globalConnect", false);
  var distributeElements = injector.get("distributeElements", false);
  var alignElements = injector.get("alignElements", false);
  var directEditing = injector.get("directEditing", false);
  var searchPad = injector.get("searchPad", false);
  var modeling = injector.get("modeling", false);
  if (canvas && elementRegistry && selection) {
    this._registerAction("selectElements", function() {
      var rootElement = canvas.getRootElement();
      var elements = elementRegistry.filter(function(element) {
        return element !== rootElement;
      });
      selection.select(elements);
      return elements;
    });
  }
  if (spaceTool) {
    this._registerAction("spaceTool", function() {
      spaceTool.toggle();
    });
  }
  if (lassoTool) {
    this._registerAction("lassoTool", function() {
      lassoTool.toggle();
    });
  }
  if (handTool) {
    this._registerAction("handTool", function() {
      handTool.toggle();
    });
  }
  if (globalConnect) {
    this._registerAction("globalConnectTool", function() {
      globalConnect.toggle();
    });
  }
  if (selection && distributeElements) {
    this._registerAction("distributeElements", function(opts) {
      var currentSelection = selection.get(), type = opts.type;
      if (currentSelection.length) {
        distributeElements.trigger(currentSelection, type);
      }
    });
  }
  if (selection && alignElements) {
    this._registerAction("alignElements", function(opts) {
      var currentSelection = selection.get(), aligneableElements = [], type = opts.type;
      if (currentSelection.length) {
        aligneableElements = filter$a(currentSelection, function(element) {
          return !is$O(element, "bpmn:Lane");
        });
        alignElements.trigger(aligneableElements, type);
      }
    });
  }
  if (selection && modeling) {
    this._registerAction("setColor", function(opts) {
      var currentSelection = selection.get();
      if (currentSelection.length) {
        modeling.setColor(currentSelection, opts);
      }
    });
  }
  if (selection && directEditing) {
    this._registerAction("directEditing", function() {
      var currentSelection = selection.get();
      if (currentSelection.length) {
        directEditing.activate(currentSelection[0]);
      }
    });
  }
  if (searchPad) {
    this._registerAction("find", function() {
      searchPad.toggle();
    });
  }
  if (canvas && modeling) {
    this._registerAction("moveToOrigin", function() {
      var rootElement = canvas.getRootElement(), boundingBox, elements;
      if (is$O(rootElement, "bpmn:Collaboration")) {
        elements = elementRegistry.filter(function(element) {
          return is$O(element.parent, "bpmn:Collaboration");
        });
      } else {
        elements = elementRegistry.filter(function(element) {
          return element !== rootElement && !is$O(element.parent, "bpmn:SubProcess");
        });
      }
      boundingBox = getBBox(elements);
      modeling.moveElements(elements, { x: -boundingBox.x, y: -boundingBox.y }, rootElement);
    });
  }
};
var EditorActionsModule = {
  __depends__: [
    EditorActionsModule$1
  ],
  editorActions: ["type", BpmnEditorActions]
};
function BpmnGridSnapping(eventBus) {
  eventBus.on([
    "create.init",
    "shape.move.init"
  ], function(event) {
    var context = event.context, shape = event.shape;
    if (isAny$b(shape, [
      "bpmn:Participant",
      "bpmn:SubProcess",
      "bpmn:TextAnnotation"
    ])) {
      if (!context.gridSnappingContext) {
        context.gridSnappingContext = {};
      }
      context.gridSnappingContext.snapLocation = "top-left";
    }
  });
}
BpmnGridSnapping.$inject = ["eventBus"];
var SPACING = 10;
function quantize(value, quantum, fn) {
  if (!fn) {
    fn = "round";
  }
  return Math[fn](value / quantum) * quantum;
}
var LOWER_PRIORITY = 1200;
var LOW_PRIORITY$f = 800;
function GridSnapping(elementRegistry, eventBus, config) {
  var active = !config || config.active !== false;
  this._eventBus = eventBus;
  var self2 = this;
  eventBus.on("diagram.init", LOW_PRIORITY$f, function() {
    self2.setActive(active);
  });
  eventBus.on([
    "create.move",
    "create.end",
    "bendpoint.move.move",
    "bendpoint.move.end",
    "connect.move",
    "connect.end",
    "connectionSegment.move.move",
    "connectionSegment.move.end",
    "resize.move",
    "resize.end",
    "shape.move.move",
    "shape.move.end"
  ], LOWER_PRIORITY, function(event) {
    var originalEvent = event.originalEvent;
    if (!self2.active || originalEvent && isCmd(originalEvent)) {
      return;
    }
    var context = event.context, gridSnappingContext = context.gridSnappingContext;
    if (!gridSnappingContext) {
      gridSnappingContext = context.gridSnappingContext = {};
    }
    ["x", "y"].forEach(function(axis) {
      var options = {};
      var snapOffset = getSnapOffset(event, axis, elementRegistry);
      if (snapOffset) {
        options.offset = snapOffset;
      }
      var snapConstraints = getSnapConstraints(event, axis);
      if (snapConstraints) {
        assign$e(options, snapConstraints);
      }
      if (!isSnapped(event, axis)) {
        self2.snapEvent(event, axis, options);
      }
    });
  });
}
GridSnapping.prototype.snapEvent = function(event, axis, options) {
  var snappedValue = this.snapValue(event[axis], options);
  setSnapped(event, axis, snappedValue);
};
GridSnapping.prototype.getGridSpacing = function() {
  return SPACING;
};
GridSnapping.prototype.snapValue = function(value, options) {
  var offset2 = 0;
  if (options && options.offset) {
    offset2 = options.offset;
  }
  value += offset2;
  value = quantize(value, SPACING);
  var min2, max2;
  if (options && options.min) {
    min2 = options.min;
    if (isNumber$1(min2)) {
      min2 = quantize(min2 + offset2, SPACING, "ceil");
      value = Math.max(value, min2);
    }
  }
  if (options && options.max) {
    max2 = options.max;
    if (isNumber$1(max2)) {
      max2 = quantize(max2 + offset2, SPACING, "floor");
      value = Math.min(value, max2);
    }
  }
  value -= offset2;
  return value;
};
GridSnapping.prototype.isActive = function() {
  return this.active;
};
GridSnapping.prototype.setActive = function(active) {
  this.active = active;
  this._eventBus.fire("gridSnapping.toggle", { active });
};
GridSnapping.prototype.toggleActive = function() {
  this.setActive(!this.active);
};
GridSnapping.$inject = [
  "elementRegistry",
  "eventBus",
  "config.gridSnapping"
];
function getSnapConstraints(event, axis) {
  var context = event.context, createConstraints = context.createConstraints, resizeConstraints = context.resizeConstraints || {}, gridSnappingContext = context.gridSnappingContext, snapConstraints = gridSnappingContext.snapConstraints;
  if (snapConstraints && snapConstraints[axis]) {
    return snapConstraints[axis];
  }
  if (!snapConstraints) {
    snapConstraints = gridSnappingContext.snapConstraints = {};
  }
  if (!snapConstraints[axis]) {
    snapConstraints[axis] = {};
  }
  var direction = context.direction;
  if (createConstraints) {
    if (isHorizontal$3(axis)) {
      snapConstraints.x.min = createConstraints.left;
      snapConstraints.x.max = createConstraints.right;
    } else {
      snapConstraints.y.min = createConstraints.top;
      snapConstraints.y.max = createConstraints.bottom;
    }
  }
  var minResizeConstraints = resizeConstraints.min, maxResizeConstraints = resizeConstraints.max;
  if (minResizeConstraints) {
    if (isHorizontal$3(axis)) {
      if (isWest(direction)) {
        snapConstraints.x.max = minResizeConstraints.left;
      } else {
        snapConstraints.x.min = minResizeConstraints.right;
      }
    } else {
      if (isNorth(direction)) {
        snapConstraints.y.max = minResizeConstraints.top;
      } else {
        snapConstraints.y.min = minResizeConstraints.bottom;
      }
    }
  }
  if (maxResizeConstraints) {
    if (isHorizontal$3(axis)) {
      if (isWest(direction)) {
        snapConstraints.x.min = maxResizeConstraints.left;
      } else {
        snapConstraints.x.max = maxResizeConstraints.right;
      }
    } else {
      if (isNorth(direction)) {
        snapConstraints.y.min = maxResizeConstraints.top;
      } else {
        snapConstraints.y.max = maxResizeConstraints.bottom;
      }
    }
  }
  return snapConstraints[axis];
}
function getSnapOffset(event, axis, elementRegistry) {
  var context = event.context, shape = event.shape, gridSnappingContext = context.gridSnappingContext, snapLocation = gridSnappingContext.snapLocation, snapOffset = gridSnappingContext.snapOffset;
  if (snapOffset && isNumber$1(snapOffset[axis])) {
    return snapOffset[axis];
  }
  if (!snapOffset) {
    snapOffset = gridSnappingContext.snapOffset = {};
  }
  if (!isNumber$1(snapOffset[axis])) {
    snapOffset[axis] = 0;
  }
  if (!shape) {
    return snapOffset[axis];
  }
  if (!elementRegistry.get(shape.id)) {
    if (isHorizontal$3(axis)) {
      snapOffset[axis] += shape[axis] + shape.width / 2;
    } else {
      snapOffset[axis] += shape[axis] + shape.height / 2;
    }
  }
  if (!snapLocation) {
    return snapOffset[axis];
  }
  if (axis === "x") {
    if (/left/.test(snapLocation)) {
      snapOffset[axis] -= shape.width / 2;
    } else if (/right/.test(snapLocation)) {
      snapOffset[axis] += shape.width / 2;
    }
  } else {
    if (/top/.test(snapLocation)) {
      snapOffset[axis] -= shape.height / 2;
    } else if (/bottom/.test(snapLocation)) {
      snapOffset[axis] += shape.height / 2;
    }
  }
  return snapOffset[axis];
}
function isHorizontal$3(axis) {
  return axis === "x";
}
function isNorth(direction) {
  return direction.indexOf("n") !== -1;
}
function isWest(direction) {
  return direction.indexOf("w") !== -1;
}
function ResizeBehavior$1(eventBus, gridSnapping) {
  CommandInterceptor$5.call(this, eventBus);
  this._gridSnapping = gridSnapping;
  var self2 = this;
  this.preExecute("shape.resize", function(event) {
    var context = event.context, hints = context.hints || {}, autoResize = hints.autoResize;
    if (!autoResize) {
      return;
    }
    var shape = context.shape, newBounds = context.newBounds;
    if (isString$3(autoResize)) {
      context.newBounds = self2.snapComplex(newBounds, autoResize);
    } else {
      context.newBounds = self2.snapSimple(shape, newBounds);
    }
  });
}
ResizeBehavior$1.$inject = [
  "eventBus",
  "gridSnapping",
  "modeling"
];
inherits$6(ResizeBehavior$1, CommandInterceptor$5);
ResizeBehavior$1.prototype.snapSimple = function(shape, newBounds) {
  var gridSnapping = this._gridSnapping;
  newBounds.width = gridSnapping.snapValue(newBounds.width, {
    min: newBounds.width
  });
  newBounds.height = gridSnapping.snapValue(newBounds.height, {
    min: newBounds.height
  });
  newBounds.x = shape.x + shape.width / 2 - newBounds.width / 2;
  newBounds.y = shape.y + shape.height / 2 - newBounds.height / 2;
  return newBounds;
};
ResizeBehavior$1.prototype.snapComplex = function(newBounds, directions2) {
  if (/w|e/.test(directions2)) {
    newBounds = this.snapHorizontally(newBounds, directions2);
  }
  if (/n|s/.test(directions2)) {
    newBounds = this.snapVertically(newBounds, directions2);
  }
  return newBounds;
};
ResizeBehavior$1.prototype.snapHorizontally = function(newBounds, directions2) {
  var gridSnapping = this._gridSnapping, west = /w/.test(directions2), east = /e/.test(directions2);
  var snappedNewBounds = {};
  snappedNewBounds.width = gridSnapping.snapValue(newBounds.width, {
    min: newBounds.width
  });
  if (east) {
    if (west) {
      snappedNewBounds.x = gridSnapping.snapValue(newBounds.x, {
        max: newBounds.x
      });
      snappedNewBounds.width += gridSnapping.snapValue(newBounds.x - snappedNewBounds.x, {
        min: newBounds.x - snappedNewBounds.x
      });
    } else {
      newBounds.x = newBounds.x + newBounds.width - snappedNewBounds.width;
    }
  }
  assign$e(newBounds, snappedNewBounds);
  return newBounds;
};
ResizeBehavior$1.prototype.snapVertically = function(newBounds, directions2) {
  var gridSnapping = this._gridSnapping, north = /n/.test(directions2), south = /s/.test(directions2);
  var snappedNewBounds = {};
  snappedNewBounds.height = gridSnapping.snapValue(newBounds.height, {
    min: newBounds.height
  });
  if (north) {
    if (south) {
      snappedNewBounds.y = gridSnapping.snapValue(newBounds.y, {
        max: newBounds.y
      });
      snappedNewBounds.height += gridSnapping.snapValue(newBounds.y - snappedNewBounds.y, {
        min: newBounds.y - snappedNewBounds.y
      });
    } else {
      newBounds.y = newBounds.y + newBounds.height - snappedNewBounds.height;
    }
  }
  assign$e(newBounds, snappedNewBounds);
  return newBounds;
};
var HIGH_PRIORITY$f = 2e3;
function SpaceToolBehavior$1(eventBus, gridSnapping) {
  eventBus.on([
    "spaceTool.move",
    "spaceTool.end"
  ], HIGH_PRIORITY$f, function(event) {
    var context = event.context;
    if (!context.initialized) {
      return;
    }
    var axis = context.axis;
    var snapped;
    if (axis === "x") {
      snapped = gridSnapping.snapValue(event.dx);
      event.x = event.x + snapped - event.dx;
      event.dx = snapped;
    } else {
      snapped = gridSnapping.snapValue(event.dy);
      event.y = event.y + snapped - event.dy;
      event.dy = snapped;
    }
  });
}
SpaceToolBehavior$1.$inject = [
  "eventBus",
  "gridSnapping"
];
var GridSnappingBehaviorModule$1 = {
  __init__: [
    "gridSnappingResizeBehavior",
    "gridSnappingSpaceToolBehavior"
  ],
  gridSnappingResizeBehavior: ["type", ResizeBehavior$1],
  gridSnappingSpaceToolBehavior: ["type", SpaceToolBehavior$1]
};
var GridSnappingModule$1 = {
  __depends__: [GridSnappingBehaviorModule$1],
  __init__: ["gridSnapping"],
  gridSnapping: ["type", GridSnapping]
};
var HIGH_PRIORITY$e = 2e3;
function AutoPlaceBehavior(eventBus, gridSnapping) {
  eventBus.on("autoPlace", HIGH_PRIORITY$e, function(context) {
    var source = context.source, sourceMid = getMid(source), shape = context.shape;
    var position = getNewShapePosition(source, shape);
    ["x", "y"].forEach(function(axis) {
      var options = {};
      if (position[axis] === sourceMid[axis]) {
        return;
      }
      if (position[axis] > sourceMid[axis]) {
        options.min = position[axis];
      } else {
        options.max = position[axis];
      }
      if (is$O(shape, "bpmn:TextAnnotation")) {
        if (isHorizontal$2(axis)) {
          options.offset = -shape.width / 2;
        } else {
          options.offset = -shape.height / 2;
        }
      }
      position[axis] = gridSnapping.snapValue(position[axis], options);
    });
    return position;
  });
}
AutoPlaceBehavior.$inject = [
  "eventBus",
  "gridSnapping"
];
function isHorizontal$2(axis) {
  return axis === "x";
}
var HIGHER_PRIORITY$5 = 1750;
function CreateParticipantBehavior$1(canvas, eventBus, gridSnapping) {
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], HIGHER_PRIORITY$5, function(event) {
    var context = event.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (!is$O(shape, "bpmn:Participant") || !is$O(rootElement, "bpmn:Process") || !rootElement.children.length) {
      return;
    }
    var createConstraints = context.createConstraints;
    if (!createConstraints) {
      return;
    }
    shape.width = gridSnapping.snapValue(shape.width, { min: shape.width });
    shape.height = gridSnapping.snapValue(shape.height, { min: shape.height });
  });
}
CreateParticipantBehavior$1.$inject = [
  "canvas",
  "eventBus",
  "gridSnapping"
];
var HIGH_PRIORITY$d = 3e3;
function LayoutConnectionBehavior(eventBus, gridSnapping, modeling) {
  CommandInterceptor$5.call(this, eventBus);
  this._gridSnapping = gridSnapping;
  var self2 = this;
  this.postExecuted([
    "connection.create",
    "connection.layout"
  ], HIGH_PRIORITY$d, function(event) {
    var context = event.context, connection = context.connection, hints = context.hints || {}, waypoints = connection.waypoints;
    if (hints.connectionStart || hints.connectionEnd || hints.createElementsBehavior === false) {
      return;
    }
    if (!hasMiddleSegments(waypoints)) {
      return;
    }
    modeling.updateWaypoints(connection, self2.snapMiddleSegments(waypoints));
  });
}
LayoutConnectionBehavior.$inject = [
  "eventBus",
  "gridSnapping",
  "modeling"
];
inherits$6(LayoutConnectionBehavior, CommandInterceptor$5);
LayoutConnectionBehavior.prototype.snapMiddleSegments = function(waypoints) {
  var gridSnapping = this._gridSnapping, snapped;
  waypoints = waypoints.slice();
  for (var i = 1; i < waypoints.length - 2; i++) {
    snapped = snapSegment(gridSnapping, waypoints[i], waypoints[i + 1]);
    waypoints[i] = snapped[0];
    waypoints[i + 1] = snapped[1];
  }
  return waypoints;
};
function hasMiddleSegments(waypoints) {
  return waypoints.length > 3;
}
function horizontallyAligned(aligned) {
  return aligned === "h";
}
function verticallyAligned(aligned) {
  return aligned === "v";
}
function snapSegment(gridSnapping, segmentStart, segmentEnd) {
  var aligned = pointsAligned(segmentStart, segmentEnd);
  var snapped = {};
  if (horizontallyAligned(aligned)) {
    snapped.y = gridSnapping.snapValue(segmentStart.y);
  }
  if (verticallyAligned(aligned)) {
    snapped.x = gridSnapping.snapValue(segmentStart.x);
  }
  if ("x" in snapped || "y" in snapped) {
    segmentStart = assign$e({}, segmentStart, snapped);
    segmentEnd = assign$e({}, segmentEnd, snapped);
  }
  return [segmentStart, segmentEnd];
}
var GridSnappingBehaviorModule = {
  __init__: [
    "gridSnappingAutoPlaceBehavior",
    "gridSnappingCreateParticipantBehavior",
    "gridSnappingLayoutConnectionBehavior"
  ],
  gridSnappingAutoPlaceBehavior: ["type", AutoPlaceBehavior],
  gridSnappingCreateParticipantBehavior: ["type", CreateParticipantBehavior$1],
  gridSnappingLayoutConnectionBehavior: ["type", LayoutConnectionBehavior]
};
var GridSnappingModule = {
  __depends__: [
    GridSnappingModule$1,
    GridSnappingBehaviorModule
  ],
  __init__: ["bpmnGridSnapping"],
  bpmnGridSnapping: ["type", BpmnGridSnapping]
};
var LABEL_WIDTH = 30, LABEL_HEIGHT = 30;
function BpmnInteractionEvents(eventBus, interactionEvents) {
  this._interactionEvents = interactionEvents;
  var self2 = this;
  eventBus.on([
    "interactionEvents.createHit",
    "interactionEvents.updateHit"
  ], function(context) {
    var element = context.element, gfx = context.gfx;
    if (is$O(element, "bpmn:Lane")) {
      return self2.createParticipantHit(element, gfx);
    } else if (is$O(element, "bpmn:Participant")) {
      if (isExpanded(element)) {
        return self2.createParticipantHit(element, gfx);
      } else {
        return self2.createDefaultHit(element, gfx);
      }
    } else if (is$O(element, "bpmn:SubProcess")) {
      if (isExpanded(element)) {
        return self2.createSubProcessHit(element, gfx);
      } else {
        return self2.createDefaultHit(element, gfx);
      }
    }
  });
}
BpmnInteractionEvents.$inject = [
  "eventBus",
  "interactionEvents"
];
BpmnInteractionEvents.prototype.createDefaultHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createDefaultHit(element, gfx);
  return true;
};
BpmnInteractionEvents.prototype.createParticipantHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createBoxHit(gfx, "click-stroke", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "all", {
    width: LABEL_WIDTH,
    height: element.height
  });
  return true;
};
BpmnInteractionEvents.prototype.createSubProcessHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createBoxHit(gfx, "click-stroke", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "all", {
    width: element.width,
    height: LABEL_HEIGHT
  });
  return true;
};
var InteractionEventsModule = {
  __init__: ["bpmnInteractionEvents"],
  bpmnInteractionEvents: ["type", BpmnInteractionEvents]
};
function BpmnKeyboardBindings(injector) {
  injector.invoke(KeyboardBindings, this);
}
inherits$6(BpmnKeyboardBindings, KeyboardBindings);
BpmnKeyboardBindings.$inject = [
  "injector"
];
BpmnKeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {
  KeyboardBindings.prototype.registerBindings.call(this, keyboard, editorActions);
  function addListener(action, fn) {
    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn);
    }
  }
  addListener("selectElements", function(context) {
    var event = context.keyEvent;
    if (keyboard.isKey(["a", "A"], event) && keyboard.isCmd(event)) {
      editorActions.trigger("selectElements");
      return true;
    }
  });
  addListener("find", function(context) {
    var event = context.keyEvent;
    if (keyboard.isKey(["f", "F"], event) && keyboard.isCmd(event)) {
      editorActions.trigger("find");
      return true;
    }
  });
  addListener("spaceTool", function(context) {
    var event = context.keyEvent;
    if (keyboard.hasModifier(event)) {
      return;
    }
    if (keyboard.isKey(["s", "S"], event)) {
      editorActions.trigger("spaceTool");
      return true;
    }
  });
  addListener("lassoTool", function(context) {
    var event = context.keyEvent;
    if (keyboard.hasModifier(event)) {
      return;
    }
    if (keyboard.isKey(["l", "L"], event)) {
      editorActions.trigger("lassoTool");
      return true;
    }
  });
  addListener("handTool", function(context) {
    var event = context.keyEvent;
    if (keyboard.hasModifier(event)) {
      return;
    }
    if (keyboard.isKey(["h", "H"], event)) {
      editorActions.trigger("handTool");
      return true;
    }
  });
  addListener("globalConnectTool", function(context) {
    var event = context.keyEvent;
    if (keyboard.hasModifier(event)) {
      return;
    }
    if (keyboard.isKey(["c", "C"], event)) {
      editorActions.trigger("globalConnectTool");
      return true;
    }
  });
  addListener("directEditing", function(context) {
    var event = context.keyEvent;
    if (keyboard.hasModifier(event)) {
      return;
    }
    if (keyboard.isKey(["e", "E"], event)) {
      editorActions.trigger("directEditing");
      return true;
    }
  });
};
var KeyboardModule = {
  __depends__: [
    KeyboardModule$1
  ],
  __init__: ["keyboardBindings"],
  keyboardBindings: ["type", BpmnKeyboardBindings]
};
var DEFAULT_CONFIG = {
  moveSpeed: 1,
  moveSpeedAccelerated: 10
};
var HIGHER_PRIORITY$4 = 1500;
var LEFT = "left";
var UP = "up";
var RIGHT = "right";
var DOWN = "down";
var KEY_TO_DIRECTION = {
  ArrowLeft: LEFT,
  Left: LEFT,
  ArrowUp: UP,
  Up: UP,
  ArrowRight: RIGHT,
  Right: RIGHT,
  ArrowDown: DOWN,
  Down: DOWN
};
var DIRECTIONS_DELTA = {
  left: function(speed) {
    return {
      x: -speed,
      y: 0
    };
  },
  up: function(speed) {
    return {
      x: 0,
      y: -speed
    };
  },
  right: function(speed) {
    return {
      x: speed,
      y: 0
    };
  },
  down: function(speed) {
    return {
      x: 0,
      y: speed
    };
  }
};
function KeyboardMoveSelection(config, keyboard, modeling, rules, selection) {
  var self2 = this;
  this._config = assign$e({}, DEFAULT_CONFIG, config || {});
  keyboard.addListener(HIGHER_PRIORITY$4, function(event) {
    var keyEvent = event.keyEvent;
    var direction = KEY_TO_DIRECTION[keyEvent.key];
    if (!direction) {
      return;
    }
    if (keyboard.isCmd(keyEvent)) {
      return;
    }
    var accelerated = keyboard.isShift(keyEvent);
    self2.moveSelection(direction, accelerated);
    return true;
  });
  this.moveSelection = function(direction, accelerated) {
    var selectedElements = selection.get();
    if (!selectedElements.length) {
      return;
    }
    var speed = this._config[accelerated ? "moveSpeedAccelerated" : "moveSpeed"];
    var delta2 = DIRECTIONS_DELTA[direction](speed);
    var canMove2 = rules.allowed("elements.move", {
      shapes: selectedElements
    });
    if (canMove2) {
      modeling.moveElements(selectedElements, delta2);
    }
  };
}
KeyboardMoveSelection.$inject = [
  "config.keyboardMoveSelection",
  "keyboard",
  "modeling",
  "rules",
  "selection"
];
var KeyboardMoveSelectionModule = {
  __depends__: [
    KeyboardModule$1,
    SelectionModule
  ],
  __init__: [
    "keyboardMoveSelection"
  ],
  keyboardMoveSelection: ["type", KeyboardMoveSelection]
};
function ChangeSupport(eventBus, canvas, elementRegistry, graphicsFactory) {
  eventBus.on("element.changed", function(event) {
    var element = event.element;
    if (element.parent || element === canvas.getRootElement()) {
      event.gfx = elementRegistry.getGraphics(element);
    }
    if (!event.gfx) {
      return;
    }
    eventBus.fire(getType(element) + ".changed", event);
  });
  eventBus.on("elements.changed", function(event) {
    var elements = event.elements;
    elements.forEach(function(e) {
      eventBus.fire("element.changed", { element: e });
    });
    graphicsFactory.updateContainments(elements);
  });
  eventBus.on("shape.changed", function(event) {
    graphicsFactory.update("shape", event.element, event.gfx);
  });
  eventBus.on("connection.changed", function(event) {
    graphicsFactory.update("connection", event.element, event.gfx);
  });
}
ChangeSupport.$inject = [
  "eventBus",
  "canvas",
  "elementRegistry",
  "graphicsFactory"
];
var ChangeSupportModule = {
  __init__: ["changeSupport"],
  changeSupport: ["type", ChangeSupport]
};
var DEFAULT_MIN_WIDTH = 10;
function Resize(eventBus, rules, modeling, dragging) {
  this._dragging = dragging;
  this._rules = rules;
  var self2 = this;
  function handleMove(context, delta2) {
    var shape = context.shape, direction = context.direction, resizeConstraints = context.resizeConstraints, newBounds;
    context.delta = delta2;
    newBounds = resizeBounds$1(shape, direction, delta2);
    context.newBounds = ensureConstraints$1(newBounds, resizeConstraints);
    context.canExecute = self2.canResize(context);
  }
  function handleStart(context) {
    var resizeConstraints = context.resizeConstraints, minBounds = context.minBounds;
    if (resizeConstraints !== void 0) {
      return;
    }
    if (minBounds === void 0) {
      minBounds = self2.computeMinResizeBox(context);
    }
    context.resizeConstraints = {
      min: asTRBL(minBounds)
    };
  }
  function handleEnd(context) {
    var shape = context.shape, canExecute = context.canExecute, newBounds = context.newBounds;
    if (canExecute) {
      newBounds = roundBounds(newBounds);
      if (!boundsChanged(shape, newBounds)) {
        return;
      }
      modeling.resizeShape(shape, newBounds);
    }
  }
  eventBus.on("resize.start", function(event) {
    handleStart(event.context);
  });
  eventBus.on("resize.move", function(event) {
    var delta2 = {
      x: event.dx,
      y: event.dy
    };
    handleMove(event.context, delta2);
  });
  eventBus.on("resize.end", function(event) {
    handleEnd(event.context);
  });
}
Resize.prototype.canResize = function(context) {
  var rules = this._rules;
  var ctx = pick$3(context, ["newBounds", "shape", "delta", "direction"]);
  return rules.allowed("shape.resize", ctx);
};
Resize.prototype.activate = function(event, shape, contextOrDirection) {
  var dragging = this._dragging, context, direction;
  if (typeof contextOrDirection === "string") {
    contextOrDirection = {
      direction: contextOrDirection
    };
  }
  context = assign$e({ shape }, contextOrDirection);
  direction = context.direction;
  if (!direction) {
    throw new Error("must provide a direction (n|w|s|e|nw|se|ne|sw)");
  }
  dragging.init(event, getReferencePoint$1(shape, direction), "resize", {
    autoActivate: true,
    cursor: getCursor(direction),
    data: {
      shape,
      context
    }
  });
};
Resize.prototype.computeMinResizeBox = function(context) {
  var shape = context.shape, direction = context.direction, minDimensions, childrenBounds;
  minDimensions = context.minDimensions || {
    width: DEFAULT_MIN_WIDTH,
    height: DEFAULT_MIN_WIDTH
  };
  childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding);
  return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);
};
Resize.$inject = [
  "eventBus",
  "rules",
  "modeling",
  "dragging"
];
function boundsChanged(shape, newBounds) {
  return shape.x !== newBounds.x || shape.y !== newBounds.y || shape.width !== newBounds.width || shape.height !== newBounds.height;
}
function getReferencePoint$1(shape, direction) {
  var mid2 = getMid(shape), trbl = asTRBL(shape);
  var referencePoint = {
    x: mid2.x,
    y: mid2.y
  };
  if (direction.indexOf("n") !== -1) {
    referencePoint.y = trbl.top;
  } else if (direction.indexOf("s") !== -1) {
    referencePoint.y = trbl.bottom;
  }
  if (direction.indexOf("e") !== -1) {
    referencePoint.x = trbl.right;
  } else if (direction.indexOf("w") !== -1) {
    referencePoint.x = trbl.left;
  }
  return referencePoint;
}
function getCursor(direction) {
  var prefix2 = "resize-";
  if (direction === "n" || direction === "s") {
    return prefix2 + "ns";
  } else if (direction === "e" || direction === "w") {
    return prefix2 + "ew";
  } else if (direction === "nw" || direction === "se") {
    return prefix2 + "nwse";
  } else {
    return prefix2 + "nesw";
  }
}
var MARKER_RESIZING$1 = "djs-resizing", MARKER_RESIZE_NOT_OK = "resize-not-ok";
var LOW_PRIORITY$e = 500;
function ResizePreview(eventBus, canvas, previewSupport) {
  function updateFrame(context) {
    var shape = context.shape, bounds = context.newBounds, frame = context.frame;
    if (!frame) {
      frame = context.frame = previewSupport.addFrame(shape, canvas.getActiveLayer());
      canvas.addMarker(shape, MARKER_RESIZING$1);
    }
    if (bounds.width > 5) {
      attr(frame, { x: bounds.x, width: bounds.width });
    }
    if (bounds.height > 5) {
      attr(frame, { y: bounds.y, height: bounds.height });
    }
    if (context.canExecute) {
      classes(frame).remove(MARKER_RESIZE_NOT_OK);
    } else {
      classes(frame).add(MARKER_RESIZE_NOT_OK);
    }
  }
  function removeFrame(context) {
    var shape = context.shape, frame = context.frame;
    if (frame) {
      remove$4(context.frame);
    }
    canvas.removeMarker(shape, MARKER_RESIZING$1);
  }
  eventBus.on("resize.move", LOW_PRIORITY$e, function(event) {
    updateFrame(event.context);
  });
  eventBus.on("resize.cleanup", function(event) {
    removeFrame(event.context);
  });
}
ResizePreview.$inject = [
  "eventBus",
  "canvas",
  "previewSupport"
];
var HANDLE_OFFSET = -6, HANDLE_SIZE = 4, HANDLE_HIT_SIZE = 20;
var CLS_RESIZER = "djs-resizer";
var directions = ["n", "w", "s", "e", "nw", "ne", "se", "sw"];
function ResizeHandles(eventBus, canvas, selection, resize) {
  this._resize = resize;
  this._canvas = canvas;
  var self2 = this;
  eventBus.on("selection.changed", function(e) {
    var newSelection = e.newSelection;
    self2.removeResizers();
    if (newSelection.length === 1) {
      forEach$q(newSelection, bind$3(self2.addResizer, self2));
    }
  });
  eventBus.on("shape.changed", function(e) {
    var shape = e.element;
    if (selection.isSelected(shape)) {
      self2.removeResizers();
      self2.addResizer(shape);
    }
  });
}
ResizeHandles.prototype.makeDraggable = function(element, gfx, direction) {
  var resize = this._resize;
  function startResize(event) {
    if (isPrimaryButton$1(event)) {
      resize.activate(event, element, direction);
    }
  }
  componentEvent.bind(gfx, "mousedown", startResize);
  componentEvent.bind(gfx, "touchstart", startResize);
};
ResizeHandles.prototype._createResizer = function(element, x, y, direction) {
  var resizersParent = this._getResizersParent();
  var offset2 = getHandleOffset(direction);
  var group = create$2("g");
  classes(group).add(CLS_RESIZER);
  classes(group).add(CLS_RESIZER + "-" + element.id);
  classes(group).add(CLS_RESIZER + "-" + direction);
  append$3(resizersParent, group);
  var visual = create$2("rect");
  attr(visual, {
    x: -HANDLE_SIZE / 2 + offset2.x,
    y: -HANDLE_SIZE / 2 + offset2.y,
    width: HANDLE_SIZE,
    height: HANDLE_SIZE
  });
  classes(visual).add(CLS_RESIZER + "-visual");
  append$3(group, visual);
  var hit = create$2("rect");
  attr(hit, {
    x: -HANDLE_HIT_SIZE / 2 + offset2.x,
    y: -HANDLE_HIT_SIZE / 2 + offset2.y,
    width: HANDLE_HIT_SIZE,
    height: HANDLE_HIT_SIZE
  });
  classes(hit).add(CLS_RESIZER + "-hit");
  append$3(group, hit);
  transform$1(group, x, y);
  return group;
};
ResizeHandles.prototype.createResizer = function(element, direction) {
  var point = getReferencePoint$1(element, direction);
  var resizer = this._createResizer(element, point.x, point.y, direction);
  this.makeDraggable(element, resizer, direction);
};
ResizeHandles.prototype.addResizer = function(shape) {
  var self2 = this;
  var resize = this._resize;
  if (!resize.canResize({ shape })) {
    return;
  }
  forEach$q(directions, function(direction) {
    self2.createResizer(shape, direction);
  });
};
ResizeHandles.prototype.removeResizers = function() {
  var resizersParent = this._getResizersParent();
  clear(resizersParent);
};
ResizeHandles.prototype._getResizersParent = function() {
  return this._canvas.getLayer("resizers");
};
ResizeHandles.$inject = [
  "eventBus",
  "canvas",
  "selection",
  "resize"
];
function getHandleOffset(direction) {
  var offset2 = {
    x: 0,
    y: 0
  };
  if (direction.indexOf("e") !== -1) {
    offset2.x = -HANDLE_OFFSET;
  } else if (direction.indexOf("w") !== -1) {
    offset2.x = HANDLE_OFFSET;
  }
  if (direction.indexOf("s") !== -1) {
    offset2.y = -HANDLE_OFFSET;
  } else if (direction.indexOf("n") !== -1) {
    offset2.y = HANDLE_OFFSET;
  }
  return offset2;
}
var ResizeModule = {
  __depends__: [
    RulesModule$1,
    DraggingModule,
    PreviewSupportModule
  ],
  __init__: [
    "resize",
    "resizePreview",
    "resizeHandles"
  ],
  resize: ["type", Resize],
  resizePreview: ["type", ResizePreview],
  resizeHandles: ["type", ResizeHandles]
};
function createCategoryValue$1(definitions, bpmnFactory) {
  var categoryValue = bpmnFactory.create("bpmn:CategoryValue"), category = bpmnFactory.create("bpmn:Category", {
    categoryValue: [categoryValue]
  });
  add$2(definitions.get("rootElements"), category);
  getBusinessObject$V(category).$parent = definitions;
  getBusinessObject$V(categoryValue).$parent = category;
  return categoryValue;
}
function LabelEditingProvider(eventBus, bpmnFactory, canvas, directEditing, modeling, resizeHandles, textRenderer) {
  this._bpmnFactory = bpmnFactory;
  this._canvas = canvas;
  this._modeling = modeling;
  this._textRenderer = textRenderer;
  directEditing.registerProvider(this);
  eventBus.on("element.dblclick", function(event) {
    activateDirectEdit(event.element, true);
  });
  eventBus.on([
    "autoPlace.start",
    "canvas.viewbox.changing",
    "drag.init",
    "element.mousedown",
    "popupMenu.open"
  ], function(event) {
    if (directEditing.isActive()) {
      directEditing.complete();
    }
  });
  eventBus.on(["commandStack.changed"], function(e) {
    if (directEditing.isActive()) {
      directEditing.cancel();
    }
  });
  eventBus.on("directEditing.activate", function(event) {
    resizeHandles.removeResizers();
  });
  eventBus.on("create.end", 500, function(event) {
    var context = event.context, element = context.shape, canExecute = event.context.canExecute, isTouch = event.isTouch;
    if (isTouch) {
      return;
    }
    if (!canExecute) {
      return;
    }
    if (context.hints && context.hints.createElementsBehavior === false) {
      return;
    }
    activateDirectEdit(element);
  });
  eventBus.on("autoPlace.end", 500, function(event) {
    activateDirectEdit(event.shape);
  });
  function activateDirectEdit(element, force) {
    if (force || isAny$b(element, ["bpmn:Task", "bpmn:TextAnnotation"]) || isCollapsedSubProcess(element)) {
      directEditing.activate(element);
    }
  }
}
LabelEditingProvider.$inject = [
  "eventBus",
  "bpmnFactory",
  "canvas",
  "directEditing",
  "modeling",
  "resizeHandles",
  "textRenderer"
];
LabelEditingProvider.prototype.activate = function(element) {
  var text = getLabel(element);
  if (text === void 0) {
    return;
  }
  var context = {
    text
  };
  var bounds = this.getEditingBBox(element);
  assign$e(context, bounds);
  var options = {};
  if (isAny$b(element, [
    "bpmn:Task",
    "bpmn:Participant",
    "bpmn:Lane",
    "bpmn:CallActivity"
  ]) || isCollapsedSubProcess(element)) {
    assign$e(options, {
      centerVertically: true
    });
  }
  if (isLabelExternal(element)) {
    assign$e(options, {
      autoResize: true
    });
  }
  if (is$O(element, "bpmn:TextAnnotation")) {
    assign$e(options, {
      resizable: true,
      autoResize: true
    });
  }
  assign$e(context, {
    options
  });
  return context;
};
LabelEditingProvider.prototype.getEditingBBox = function(element) {
  var canvas = this._canvas;
  var target = element.label || element;
  var bbox = canvas.getAbsoluteBBox(target);
  var mid2 = {
    x: bbox.x + bbox.width / 2,
    y: bbox.y + bbox.height / 2
  };
  var bounds = { x: bbox.x, y: bbox.y };
  var zoom2 = canvas.zoom();
  var defaultStyle = this._textRenderer.getDefaultStyle(), externalStyle = this._textRenderer.getExternalStyle();
  var externalFontSize = externalStyle.fontSize * zoom2, externalLineHeight = externalStyle.lineHeight, defaultFontSize = defaultStyle.fontSize * zoom2, defaultLineHeight = defaultStyle.lineHeight;
  var style = {
    fontFamily: this._textRenderer.getDefaultStyle().fontFamily,
    fontWeight: this._textRenderer.getDefaultStyle().fontWeight
  };
  if (is$O(element, "bpmn:Lane") || isExpandedPool(element)) {
    assign$e(bounds, {
      width: bbox.height,
      height: 30 * zoom2,
      x: bbox.x - bbox.height / 2 + 15 * zoom2,
      y: mid2.y - 30 * zoom2 / 2
    });
    assign$e(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px",
      transform: "rotate(-90deg)"
    });
  }
  if (isAny$b(element, ["bpmn:Task", "bpmn:CallActivity"]) || isCollapsedPool(element) || isCollapsedSubProcess(element)) {
    assign$e(bounds, {
      width: bbox.width,
      height: bbox.height
    });
    assign$e(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px"
    });
  }
  if (isExpandedSubProcess$1(element)) {
    assign$e(bounds, {
      width: bbox.width,
      x: bbox.x
    });
    assign$e(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px"
    });
  }
  var width = 90 * zoom2, paddingTop = 7 * zoom2, paddingBottom = 4 * zoom2;
  if (target.labelTarget) {
    assign$e(bounds, {
      width,
      height: bbox.height + paddingTop + paddingBottom,
      x: mid2.x - width / 2,
      y: bbox.y - paddingTop
    });
    assign$e(style, {
      fontSize: externalFontSize + "px",
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + "px",
      paddingBottom: paddingBottom + "px"
    });
  }
  if (isLabelExternal(target) && !hasExternalLabel(target) && !isLabel$6(target)) {
    var externalLabelMid = getExternalLabelMid(element);
    var absoluteBBox = canvas.getAbsoluteBBox({
      x: externalLabelMid.x,
      y: externalLabelMid.y,
      width: 0,
      height: 0
    });
    var height = externalFontSize + paddingTop + paddingBottom;
    assign$e(bounds, {
      width,
      height,
      x: absoluteBBox.x - width / 2,
      y: absoluteBBox.y - height / 2
    });
    assign$e(style, {
      fontSize: externalFontSize + "px",
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + "px",
      paddingBottom: paddingBottom + "px"
    });
  }
  if (is$O(element, "bpmn:TextAnnotation")) {
    assign$e(bounds, {
      width: bbox.width,
      height: bbox.height,
      minWidth: 30 * zoom2,
      minHeight: 10 * zoom2
    });
    assign$e(style, {
      textAlign: "left",
      paddingTop: 5 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 7 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px",
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight
    });
  }
  return { bounds, style };
};
LabelEditingProvider.prototype.update = function(element, newLabel, activeContextText, bounds) {
  var newBounds, bbox;
  if (is$O(element, "bpmn:TextAnnotation")) {
    bbox = this._canvas.getAbsoluteBBox(element);
    newBounds = {
      x: element.x,
      y: element.y,
      width: element.width / bbox.width * bounds.width,
      height: element.height / bbox.height * bounds.height
    };
  }
  if (is$O(element, "bpmn:Group")) {
    var businessObject = getBusinessObject$V(element);
    if (!businessObject.categoryValueRef) {
      var rootElement = this._canvas.getRootElement(), definitions = getBusinessObject$V(rootElement).$parent;
      var categoryValue = createCategoryValue$1(definitions, this._bpmnFactory);
      getBusinessObject$V(element).categoryValueRef = categoryValue;
    }
  }
  if (isEmptyText$1(newLabel)) {
    newLabel = null;
  }
  this._modeling.updateLabel(element, newLabel, newBounds);
};
function isCollapsedSubProcess(element) {
  return is$O(element, "bpmn:SubProcess") && !isExpanded(element);
}
function isExpandedSubProcess$1(element) {
  return is$O(element, "bpmn:SubProcess") && isExpanded(element);
}
function isCollapsedPool(element) {
  return is$O(element, "bpmn:Participant") && !isExpanded(element);
}
function isExpandedPool(element) {
  return is$O(element, "bpmn:Participant") && isExpanded(element);
}
function isEmptyText$1(label2) {
  return !label2 || !label2.trim();
}
var MARKER_HIDDEN = "djs-element-hidden", MARKER_LABEL_HIDDEN = "djs-label-hidden";
function LabelEditingPreview(eventBus, canvas, elementRegistry, pathMap) {
  var self2 = this;
  var defaultLayer = canvas.getDefaultLayer();
  var element, absoluteElementBBox, gfx;
  eventBus.on("directEditing.activate", function(context) {
    var activeProvider = context.active;
    element = activeProvider.element.label || activeProvider.element;
    if (is$O(element, "bpmn:TextAnnotation")) {
      absoluteElementBBox = canvas.getAbsoluteBBox(element);
      gfx = create$2("g");
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0
        }
      });
      var path = self2.path = create$2("path");
      attr(path, {
        d: textPathData,
        strokeWidth: 2,
        stroke: getStrokeColor(element)
      });
      append$3(gfx, path);
      append$3(defaultLayer, gfx);
      translate$4(gfx, element.x, element.y);
    }
    if (is$O(element, "bpmn:TextAnnotation") || element.labelTarget) {
      canvas.addMarker(element, MARKER_HIDDEN);
    } else if (is$O(element, "bpmn:Task") || is$O(element, "bpmn:CallActivity") || is$O(element, "bpmn:SubProcess") || is$O(element, "bpmn:Participant")) {
      canvas.addMarker(element, MARKER_LABEL_HIDDEN);
    }
  });
  eventBus.on("directEditing.resize", function(context) {
    if (is$O(element, "bpmn:TextAnnotation")) {
      var height = context.height, dy = context.dy;
      var newElementHeight = Math.max(element.height / absoluteElementBBox.height * (height + dy), 0);
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: newElementHeight,
        position: {
          mx: 0,
          my: 0
        }
      });
      attr(self2.path, {
        d: textPathData
      });
    }
  });
  eventBus.on(["directEditing.complete", "directEditing.cancel"], function(context) {
    var activeProvider = context.active;
    if (activeProvider) {
      canvas.removeMarker(activeProvider.element.label || activeProvider.element, MARKER_HIDDEN);
      canvas.removeMarker(element, MARKER_LABEL_HIDDEN);
    }
    element = void 0;
    absoluteElementBBox = void 0;
    if (gfx) {
      remove$4(gfx);
      gfx = void 0;
    }
  });
}
LabelEditingPreview.$inject = [
  "eventBus",
  "canvas",
  "elementRegistry",
  "pathMap"
];
function getStrokeColor(element, defaultColor) {
  var bo = getBusinessObject$V(element);
  return bo.di.get("stroke") || defaultColor || "black";
}
var LabelEditingModule = {
  __depends__: [
    ChangeSupportModule,
    ResizeModule,
    DirectEditingModule
  ],
  __init__: [
    "labelEditingProvider",
    "labelEditingPreview"
  ],
  labelEditingProvider: ["type", LabelEditingProvider],
  labelEditingPreview: ["type", LabelEditingPreview]
};
var ALIGNMENTS = [
  "top",
  "bottom",
  "left",
  "right"
];
var ELEMENT_LABEL_DISTANCE = 10;
function AdaptiveLabelPositioningBehavior(eventBus, modeling) {
  CommandInterceptor$5.call(this, eventBus);
  this.postExecuted([
    "connection.create",
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event) {
    var context = event.context, connection = context.connection, source = connection.source, target = connection.target, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(source);
      checkLabelAdjustment(target);
    }
  });
  this.postExecuted([
    "label.create"
  ], function(event) {
    var context = event.context, shape = context.shape, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(shape.labelTarget);
    }
  });
  this.postExecuted([
    "elements.create"
  ], function(event) {
    var context = event.context, elements = context.elements, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      elements.forEach(function(element) {
        checkLabelAdjustment(element);
      });
    }
  });
  function checkLabelAdjustment(element) {
    if (!hasExternalLabel(element)) {
      return;
    }
    var optimalPosition = getOptimalPosition(element);
    if (!optimalPosition) {
      return;
    }
    adjustLabelPosition(element, optimalPosition);
  }
  function adjustLabelPosition(element, orientation) {
    var elementMid = getMid(element), label2 = element.label, labelMid = getMid(label2);
    if (!label2.parent) {
      return;
    }
    var elementTrbl = asTRBL(element);
    var newLabelMid;
    switch (orientation) {
      case "top":
        newLabelMid = {
          x: elementMid.x,
          y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label2.height / 2
        };
        break;
      case "left":
        newLabelMid = {
          x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label2.width / 2,
          y: elementMid.y
        };
        break;
      case "bottom":
        newLabelMid = {
          x: elementMid.x,
          y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label2.height / 2
        };
        break;
      case "right":
        newLabelMid = {
          x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label2.width / 2,
          y: elementMid.y
        };
        break;
    }
    var delta$1 = delta(newLabelMid, labelMid);
    modeling.moveShape(label2, delta$1);
  }
}
inherits$6(AdaptiveLabelPositioningBehavior, CommandInterceptor$5);
AdaptiveLabelPositioningBehavior.$inject = [
  "eventBus",
  "modeling"
];
function getTakenHostAlignments(element) {
  var hostElement = element.host, elementMid = getMid(element), hostOrientation = getOrientation(elementMid, hostElement);
  var freeAlignments;
  if (hostOrientation.indexOf("-") >= 0) {
    freeAlignments = hostOrientation.split("-");
  } else {
    freeAlignments = [hostOrientation];
  }
  var takenAlignments = ALIGNMENTS.filter(function(alignment) {
    return freeAlignments.indexOf(alignment) === -1;
  });
  return takenAlignments;
}
function getTakenConnectionAlignments(element) {
  var elementMid = getMid(element);
  var takenAlignments = [].concat(element.incoming.map(function(c) {
    return c.waypoints[c.waypoints.length - 2];
  }), element.outgoing.map(function(c) {
    return c.waypoints[1];
  })).map(function(point) {
    return getApproximateOrientation(elementMid, point);
  });
  return takenAlignments;
}
function getOptimalPosition(element) {
  var labelMid = getMid(element.label);
  var elementMid = getMid(element);
  var labelOrientation = getApproximateOrientation(elementMid, labelMid);
  if (!isAligned(labelOrientation)) {
    return;
  }
  var takenAlignments = getTakenConnectionAlignments(element);
  if (element.host) {
    var takenHostAlignments = getTakenHostAlignments(element);
    takenAlignments = takenAlignments.concat(takenHostAlignments);
  }
  var freeAlignments = ALIGNMENTS.filter(function(alignment) {
    return takenAlignments.indexOf(alignment) === -1;
  });
  if (freeAlignments.indexOf(labelOrientation) !== -1) {
    return;
  }
  return freeAlignments[0];
}
function getApproximateOrientation(p0, p1) {
  return getOrientation(p1, p0, 5);
}
function isAligned(orientation) {
  return ALIGNMENTS.indexOf(orientation) !== -1;
}
function AppendBehavior(eventBus, elementFactory, bpmnRules) {
  CommandInterceptor$5.call(this, eventBus);
  this.preExecute("shape.append", function(context) {
    var source = context.source, shape = context.shape;
    if (!context.position) {
      if (is$O(shape, "bpmn:TextAnnotation")) {
        context.position = {
          x: source.x + source.width / 2 + 75,
          y: source.y - 50 - shape.height / 2
        };
      } else {
        context.position = {
          x: source.x + source.width + 80 + shape.width / 2,
          y: source.y + source.height / 2
        };
      }
    }
  }, true);
}
inherits$6(AppendBehavior, CommandInterceptor$5);
AppendBehavior.$inject = [
  "eventBus",
  "elementFactory",
  "bpmnRules"
];
function AssociationBehavior(injector, modeling) {
  injector.invoke(CommandInterceptor$5, this);
  this.postExecute("shape.move", function(context) {
    var newParent = context.newParent, shape = context.shape;
    var associations2 = filter$a(shape.incoming.concat(shape.outgoing), function(connection) {
      return is$O(connection, "bpmn:Association");
    });
    forEach$q(associations2, function(association) {
      modeling.moveConnection(association, { x: 0, y: 0 }, newParent);
    });
  }, true);
}
inherits$6(AssociationBehavior, CommandInterceptor$5);
AssociationBehavior.$inject = [
  "injector",
  "modeling"
];
var LOW_PRIORITY$d = 500;
function AttachEventBehavior(bpmnReplace, injector) {
  injector.invoke(CommandInterceptor$5, this);
  this._bpmnReplace = bpmnReplace;
  var self2 = this;
  this.postExecuted("elements.create", LOW_PRIORITY$d, function(context) {
    var elements = context.elements;
    elements = elements.filter(function(shape) {
      var host = shape.host;
      return shouldReplace$1(shape, host);
    });
    if (elements.length !== 1) {
      return;
    }
    elements.map(function(element) {
      return elements.indexOf(element);
    }).forEach(function(index2) {
      var host = elements[index2];
      context.elements[index2] = self2.replaceShape(elements[index2], host);
    });
  }, true);
  this.preExecute("elements.move", LOW_PRIORITY$d, function(context) {
    var shapes = context.shapes, host = context.newHost;
    if (shapes.length !== 1) {
      return;
    }
    var shape = shapes[0];
    if (shouldReplace$1(shape, host)) {
      context.shapes = [self2.replaceShape(shape, host)];
    }
  }, true);
}
AttachEventBehavior.$inject = [
  "bpmnReplace",
  "injector"
];
inherits$6(AttachEventBehavior, CommandInterceptor$5);
AttachEventBehavior.prototype.replaceShape = function(shape, host) {
  var eventDefinition = getEventDefinition$1(shape);
  var boundaryEvent = {
    type: "bpmn:BoundaryEvent",
    host
  };
  if (eventDefinition) {
    boundaryEvent.eventDefinitionType = eventDefinition.$type;
  }
  return this._bpmnReplace.replaceElement(shape, boundaryEvent, { layoutConnection: false });
};
function getEventDefinition$1(element) {
  var businessObject = getBusinessObject$V(element), eventDefinitions = businessObject.eventDefinitions;
  return eventDefinitions && eventDefinitions[0];
}
function shouldReplace$1(shape, host) {
  return !isLabel$6(shape) && isAny$b(shape, ["bpmn:IntermediateThrowEvent", "bpmn:IntermediateCatchEvent"]) && !!host;
}
var HIGH_PRIORITY$c = 2e3;
function BoundaryEventBehavior(eventBus, moddle, modeling) {
  CommandInterceptor$5.call(this, eventBus);
  function getBoundaryEvents(element) {
    return filter$a(element.attachers, function(attacher) {
      return is$O(attacher, "bpmn:BoundaryEvent");
    });
  }
  this.postExecute("connection.create", function(event) {
    var source = event.context.source, target = event.context.target, boundaryEvents = getBoundaryEvents(target);
    if (is$O(source, "bpmn:EventBasedGateway") && is$O(target, "bpmn:ReceiveTask") && boundaryEvents.length > 0) {
      modeling.removeElements(boundaryEvents);
    }
  });
  this.postExecute("connection.reconnect", function(event) {
    var oldSource = event.context.oldSource, newSource = event.context.newSource;
    if (is$O(oldSource, "bpmn:Gateway") && is$O(newSource, "bpmn:EventBasedGateway")) {
      forEach$q(newSource.outgoing, function(connection) {
        var target = connection.target, attachedboundaryEvents = getBoundaryEvents(target);
        if (is$O(target, "bpmn:ReceiveTask") && attachedboundaryEvents.length > 0) {
          modeling.removeElements(attachedboundaryEvents);
        }
      });
    }
  });
  eventBus.on("moddleCopy.canCopyProperty", HIGH_PRIORITY$c, function(context) {
    var parent2 = context.parent, property2 = context.property, propertyName = context.propertyName;
    var propertyDescriptor = moddle.getPropertyDescriptor(parent2, propertyName);
    if (propertyDescriptor && propertyDescriptor.isReference && is$O(property2, "bpmn:RootElement")) {
      parent2.set(propertyName, property2);
    }
  });
}
BoundaryEventBehavior.$inject = [
  "eventBus",
  "moddle",
  "modeling"
];
inherits$6(BoundaryEventBehavior, CommandInterceptor$5);
var LOW_PRIORITY$c = 500;
function RootElementReferenceBehavior(bpmnjs, eventBus, injector, moddleCopy, bpmnFactory) {
  injector.invoke(CommandInterceptor$5, this);
  function canHaveRootElementReference(element) {
    return isAny$b(element, ["bpmn:ReceiveTask", "bpmn:SendTask"]) || hasAnyEventDefinition(element, [
      "bpmn:ErrorEventDefinition",
      "bpmn:EscalationEventDefinition",
      "bpmn:MessageEventDefinition",
      "bpmn:SignalEventDefinition"
    ]);
  }
  function hasRootElement(rootElement) {
    var definitions = bpmnjs.getDefinitions(), rootElements = definitions.get("rootElements");
    return !!find$e(rootElements, matchPattern$1({ id: rootElement.id }));
  }
  function getRootElementReferencePropertyName2(eventDefinition) {
    if (is$O(eventDefinition, "bpmn:ErrorEventDefinition")) {
      return "errorRef";
    } else if (is$O(eventDefinition, "bpmn:EscalationEventDefinition")) {
      return "escalationRef";
    } else if (is$O(eventDefinition, "bpmn:MessageEventDefinition")) {
      return "messageRef";
    } else if (is$O(eventDefinition, "bpmn:SignalEventDefinition")) {
      return "signalRef";
    }
  }
  function getRootElement2(businessObject) {
    if (isAny$b(businessObject, ["bpmn:ReceiveTask", "bpmn:SendTask"])) {
      return businessObject.get("messageRef");
    }
    var eventDefinitions = businessObject.get("eventDefinitions"), eventDefinition = eventDefinitions[0];
    return eventDefinition.get(getRootElementReferencePropertyName2(eventDefinition));
  }
  function setRootElement2(businessObject, rootElement) {
    if (isAny$b(businessObject, ["bpmn:ReceiveTask", "bpmn:SendTask"])) {
      return businessObject.set("messageRef", rootElement);
    }
    var eventDefinitions = businessObject.get("eventDefinitions"), eventDefinition = eventDefinitions[0];
    return eventDefinition.set(getRootElementReferencePropertyName2(eventDefinition), rootElement);
  }
  this.executed("shape.create", function(context) {
    var shape = context.shape;
    if (!canHaveRootElementReference(shape)) {
      return;
    }
    var businessObject = getBusinessObject$V(shape), rootElement = getRootElement2(businessObject), rootElements;
    if (rootElement && !hasRootElement(rootElement)) {
      rootElements = bpmnjs.getDefinitions().get("rootElements");
      add$2(rootElements, rootElement);
      context.addedRootElement = rootElement;
    }
  }, true);
  this.reverted("shape.create", function(context) {
    var addedRootElement = context.addedRootElement;
    if (!addedRootElement) {
      return;
    }
    var rootElements = bpmnjs.getDefinitions().get("rootElements");
    remove$3(rootElements, addedRootElement);
  }, true);
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element;
    if (!canHaveRootElementReference(element)) {
      return;
    }
    var businessObject = getBusinessObject$V(element), rootElement = getRootElement2(businessObject);
    if (rootElement) {
      descriptor.referencedRootElement = rootElement;
    }
  });
  eventBus.on("copyPaste.pasteElement", LOW_PRIORITY$c, function(context) {
    var descriptor = context.descriptor, businessObject = descriptor.businessObject;
    if (!canHaveRootElementReference(businessObject)) {
      return;
    }
    var referencedRootElement = descriptor.referencedRootElement;
    if (!referencedRootElement) {
      return;
    }
    if (!hasRootElement(referencedRootElement)) {
      referencedRootElement = moddleCopy.copyElement(referencedRootElement, bpmnFactory.create(referencedRootElement.$type));
    }
    setRootElement2(businessObject, referencedRootElement);
  });
}
RootElementReferenceBehavior.$inject = [
  "bpmnjs",
  "eventBus",
  "injector",
  "moddleCopy",
  "bpmnFactory"
];
inherits$6(RootElementReferenceBehavior, CommandInterceptor$5);
function hasAnyEventDefinition(element, types2) {
  if (!isArray$n(types2)) {
    types2 = [types2];
  }
  return some$1(types2, function(type) {
    return hasEventDefinition$2(element, type);
  });
}
function CreateBehavior(injector) {
  injector.invoke(CommandInterceptor$5, this);
  this.preExecute("shape.create", 1500, function(event) {
    var context = event.context, parent2 = context.parent, shape = context.shape;
    if (is$O(parent2, "bpmn:Lane") && !is$O(shape, "bpmn:Lane")) {
      context.parent = getParent$1(parent2, "bpmn:Participant");
    }
  });
}
CreateBehavior.$inject = ["injector"];
inherits$6(CreateBehavior, CommandInterceptor$5);
var HIGH_PRIORITY$b = 1500;
var HIGHEST_PRIORITY = 2e3;
function FixHoverBehavior(elementRegistry, eventBus, canvas) {
  eventBus.on([
    "create.hover",
    "create.move",
    "create.out",
    "create.end",
    "shape.move.hover",
    "shape.move.move",
    "shape.move.out",
    "shape.move.end"
  ], HIGH_PRIORITY$b, function(event) {
    var context = event.context, shape = context.shape || event.shape, hover = event.hover;
    if (is$O(hover, "bpmn:Lane") && !isAny$b(shape, ["bpmn:Lane", "bpmn:Participant"])) {
      event.hover = getLanesRoot(hover);
      event.hoverGfx = elementRegistry.getGraphics(event.hover);
    }
    var rootElement = canvas.getRootElement();
    if (hover !== rootElement && (shape.labelTarget || is$O(shape, "bpmn:Group"))) {
      event.hover = rootElement;
      event.hoverGfx = elementRegistry.getGraphics(event.hover);
    }
  });
  eventBus.on([
    "connect.hover",
    "connect.out",
    "connect.end",
    "connect.cleanup",
    "global-connect.hover",
    "global-connect.out",
    "global-connect.end",
    "global-connect.cleanup"
  ], HIGH_PRIORITY$b, function(event) {
    var hover = event.hover;
    if (is$O(hover, "bpmn:Lane")) {
      event.hover = getLanesRoot(hover) || hover;
      event.hoverGfx = elementRegistry.getGraphics(event.hover);
    }
  });
  eventBus.on([
    "bendpoint.move.hover"
  ], HIGH_PRIORITY$b, function(event) {
    var context = event.context, hover = event.hover, type = context.type;
    if (is$O(hover, "bpmn:Lane") && /reconnect/.test(type)) {
      event.hover = getLanesRoot(hover) || hover;
      event.hoverGfx = elementRegistry.getGraphics(event.hover);
    }
  });
  eventBus.on([
    "connect.start"
  ], HIGH_PRIORITY$b, function(event) {
    var context = event.context, start = context.start;
    if (is$O(start, "bpmn:Lane")) {
      context.start = getLanesRoot(start) || start;
    }
  });
  eventBus.on("shape.move.start", HIGHEST_PRIORITY, function(event) {
    var shape = event.shape;
    if (is$O(shape, "bpmn:Lane")) {
      event.shape = getLanesRoot(shape) || shape;
    }
  });
}
FixHoverBehavior.$inject = [
  "elementRegistry",
  "eventBus",
  "canvas"
];
function CreateDataObjectBehavior(eventBus, bpmnFactory, moddle) {
  CommandInterceptor$5.call(this, eventBus);
  this.preExecute("shape.create", function(event) {
    var context = event.context, shape = context.shape;
    if (is$O(shape, "bpmn:DataObjectReference") && shape.type !== "label") {
      var dataObject = bpmnFactory.create("bpmn:DataObject");
      shape.businessObject.dataObjectRef = dataObject;
    }
  });
}
CreateDataObjectBehavior.$inject = [
  "eventBus",
  "bpmnFactory",
  "moddle"
];
inherits$6(CreateDataObjectBehavior, CommandInterceptor$5);
var HORIZONTAL_PARTICIPANT_PADDING = 20, VERTICAL_PARTICIPANT_PADDING = 20;
var PARTICIPANT_BORDER_WIDTH = 30;
var HIGH_PRIORITY$a = 2e3;
function CreateParticipantBehavior(canvas, eventBus, modeling) {
  CommandInterceptor$5.call(this, eventBus);
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], HIGH_PRIORITY$a, function(event) {
    var context = event.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (!is$O(shape, "bpmn:Participant") || !is$O(rootElement, "bpmn:Process") || !rootElement.children.length) {
      return;
    }
    var children = rootElement.children.filter(function(element) {
      return !is$O(element, "bpmn:Group") && !isLabel$6(element) && !isConnection$9(element);
    });
    if (!children.length) {
      return;
    }
    var childrenBBox = getBBox(children);
    var participantBounds = getParticipantBounds(shape, childrenBBox);
    assign$e(shape, participantBounds);
    context.createConstraints = getParticipantCreateConstraints(shape, childrenBBox);
  });
  eventBus.on("create.start", HIGH_PRIORITY$a, function(event) {
    var context = event.context, shape = context.shape, rootElement = canvas.getRootElement(), rootElementGfx = canvas.getGraphics(rootElement);
    function ensureHoveringProcess(event2) {
      event2.element = rootElement;
      event2.gfx = rootElementGfx;
    }
    if (is$O(shape, "bpmn:Participant") && is$O(rootElement, "bpmn:Process")) {
      eventBus.on("element.hover", HIGH_PRIORITY$a, ensureHoveringProcess);
      eventBus.once("create.cleanup", function() {
        eventBus.off("element.hover", ensureHoveringProcess);
      });
    }
  });
  function getOrCreateCollaboration() {
    var rootElement = canvas.getRootElement();
    if (is$O(rootElement, "bpmn:Collaboration")) {
      return rootElement;
    }
    return modeling.makeCollaboration();
  }
  this.preExecute("elements.create", HIGH_PRIORITY$a, function(context) {
    var elements = context.elements, parent2 = context.parent, participant = findParticipant(elements), hints;
    if (participant && is$O(parent2, "bpmn:Process")) {
      context.parent = getOrCreateCollaboration();
      hints = context.hints = context.hints || {};
      hints.participant = participant;
      hints.process = parent2;
      hints.processRef = getBusinessObject$V(participant).get("processRef");
    }
  }, true);
  this.preExecute("shape.create", function(context) {
    var parent2 = context.parent, shape = context.shape;
    if (is$O(shape, "bpmn:Participant") && is$O(parent2, "bpmn:Process")) {
      context.parent = getOrCreateCollaboration();
      context.process = parent2;
      context.processRef = getBusinessObject$V(shape).get("processRef");
    }
  }, true);
  this.execute("shape.create", function(context) {
    var hints = context.hints || {}, process2 = context.process || hints.process, shape = context.shape, participant = hints.participant;
    if (process2 && (!participant || shape === participant)) {
      getBusinessObject$V(shape).set("processRef", getBusinessObject$V(process2));
    }
  }, true);
  this.revert("shape.create", function(context) {
    var hints = context.hints || {}, process2 = context.process || hints.process, processRef = context.processRef || hints.processRef, shape = context.shape, participant = hints.participant;
    if (process2 && (!participant || shape === participant)) {
      getBusinessObject$V(shape).set("processRef", processRef);
    }
  }, true);
  this.postExecute("shape.create", function(context) {
    var hints = context.hints || {}, process2 = context.process || context.hints.process, shape = context.shape, participant = hints.participant;
    if (process2) {
      var children = process2.children.slice();
      if (!participant) {
        modeling.moveElements(children, { x: 0, y: 0 }, shape);
      } else if (shape === participant) {
        modeling.moveElements(children, { x: 0, y: 0 }, participant);
      }
    }
  }, true);
}
CreateParticipantBehavior.$inject = [
  "canvas",
  "eventBus",
  "modeling"
];
inherits$6(CreateParticipantBehavior, CommandInterceptor$5);
function getParticipantBounds(shape, childrenBBox) {
  childrenBBox = {
    width: childrenBBox.width + HORIZONTAL_PARTICIPANT_PADDING * 2 + PARTICIPANT_BORDER_WIDTH,
    height: childrenBBox.height + VERTICAL_PARTICIPANT_PADDING * 2
  };
  var width = Math.max(shape.width, childrenBBox.width), height = Math.max(shape.height, childrenBBox.height);
  return {
    x: -width / 2,
    y: -height / 2,
    width,
    height
  };
}
function getParticipantCreateConstraints(shape, childrenBBox) {
  childrenBBox = asTRBL(childrenBBox);
  return {
    bottom: childrenBBox.top + shape.height / 2 - VERTICAL_PARTICIPANT_PADDING,
    left: childrenBBox.right - shape.width / 2 + HORIZONTAL_PARTICIPANT_PADDING,
    top: childrenBBox.bottom - shape.height / 2 + VERTICAL_PARTICIPANT_PADDING,
    right: childrenBBox.left + shape.width / 2 - HORIZONTAL_PARTICIPANT_PADDING - PARTICIPANT_BORDER_WIDTH
  };
}
function isConnection$9(element) {
  return !!element.waypoints;
}
function findParticipant(elements) {
  return find$e(elements, function(element) {
    return is$O(element, "bpmn:Participant");
  });
}
var TARGET_REF_PLACEHOLDER_NAME = "__targetRef_placeholder";
function DataInputAssociationBehavior(eventBus, bpmnFactory) {
  CommandInterceptor$5.call(this, eventBus);
  this.executed([
    "connection.create",
    "connection.delete",
    "connection.move",
    "connection.reconnect"
  ], ifDataInputAssociation(fixTargetRef));
  this.reverted([
    "connection.create",
    "connection.delete",
    "connection.move",
    "connection.reconnect"
  ], ifDataInputAssociation(fixTargetRef));
  function usesTargetRef(element, targetRef, removedConnection) {
    var inputAssociations = element.get("dataInputAssociations");
    return find$e(inputAssociations, function(association) {
      return association !== removedConnection && association.targetRef === targetRef;
    });
  }
  function getTargetRef(element, create2) {
    var properties2 = element.get("properties");
    var targetRefProp = find$e(properties2, function(p) {
      return p.name === TARGET_REF_PLACEHOLDER_NAME;
    });
    if (!targetRefProp && create2) {
      targetRefProp = bpmnFactory.create("bpmn:Property", {
        name: TARGET_REF_PLACEHOLDER_NAME
      });
      add$2(properties2, targetRefProp);
    }
    return targetRefProp;
  }
  function cleanupTargetRef(element, connection) {
    var targetRefProp = getTargetRef(element);
    if (!targetRefProp) {
      return;
    }
    if (!usesTargetRef(element, targetRefProp, connection)) {
      remove$3(element.get("properties"), targetRefProp);
    }
  }
  function fixTargetRef(event) {
    var context = event.context, connection = context.connection, connectionBo = connection.businessObject, target = connection.target, targetBo = target && target.businessObject, newTarget = context.newTarget, newTargetBo = newTarget && newTarget.businessObject, oldTarget = context.oldTarget || context.target, oldTargetBo = oldTarget && oldTarget.businessObject;
    var dataAssociation = connection.businessObject, targetRefProp;
    if (oldTargetBo && oldTargetBo !== targetBo) {
      cleanupTargetRef(oldTargetBo, connectionBo);
    }
    if (newTargetBo && newTargetBo !== targetBo) {
      cleanupTargetRef(newTargetBo, connectionBo);
    }
    if (targetBo) {
      targetRefProp = getTargetRef(targetBo, true);
      dataAssociation.targetRef = targetRefProp;
    } else {
      dataAssociation.targetRef = null;
    }
  }
}
DataInputAssociationBehavior.$inject = [
  "eventBus",
  "bpmnFactory"
];
inherits$6(DataInputAssociationBehavior, CommandInterceptor$5);
function ifDataInputAssociation(fn) {
  return function(event) {
    var context = event.context, connection = context.connection;
    if (is$O(connection, "bpmn:DataInputAssociation")) {
      return fn(event);
    }
  };
}
function UpdateSemanticParentHandler(bpmnUpdater) {
  this._bpmnUpdater = bpmnUpdater;
}
UpdateSemanticParentHandler.$inject = ["bpmnUpdater"];
UpdateSemanticParentHandler.prototype.execute = function(context) {
  var dataStoreBo = context.dataStoreBo, newSemanticParent = context.newSemanticParent, newDiParent = context.newDiParent;
  context.oldSemanticParent = dataStoreBo.$parent;
  context.oldDiParent = dataStoreBo.di.$parent;
  this._bpmnUpdater.updateSemanticParent(dataStoreBo, newSemanticParent);
  this._bpmnUpdater.updateDiParent(dataStoreBo.di, newDiParent);
};
UpdateSemanticParentHandler.prototype.revert = function(context) {
  var dataStoreBo = context.dataStoreBo, oldSemanticParent = context.oldSemanticParent, oldDiParent = context.oldDiParent;
  this._bpmnUpdater.updateSemanticParent(dataStoreBo, oldSemanticParent);
  this._bpmnUpdater.updateDiParent(dataStoreBo.di, oldDiParent);
};
function DataStoreBehavior(canvas, commandStack, elementRegistry, eventBus) {
  CommandInterceptor$5.call(this, eventBus);
  commandStack.registerHandler("dataStore.updateContainment", UpdateSemanticParentHandler);
  function getFirstParticipantWithProcessRef() {
    return elementRegistry.filter(function(element) {
      return is$O(element, "bpmn:Participant") && getBusinessObject$V(element).processRef;
    })[0];
  }
  function getDataStores(element) {
    return element.children.filter(function(child) {
      return is$O(child, "bpmn:DataStoreReference") && !child.labelTarget;
    });
  }
  function updateDataStoreParent(dataStore, newDataStoreParent) {
    var dataStoreBo = dataStore.businessObject || dataStore;
    newDataStoreParent = newDataStoreParent || getFirstParticipantWithProcessRef();
    if (newDataStoreParent) {
      var newDataStoreParentBo = newDataStoreParent.businessObject || newDataStoreParent;
      commandStack.execute("dataStore.updateContainment", {
        dataStoreBo,
        newSemanticParent: newDataStoreParentBo.processRef || newDataStoreParentBo,
        newDiParent: newDataStoreParentBo.di
      });
    }
  }
  this.preExecute("shape.create", function(event) {
    var context = event.context, shape = context.shape;
    if (is$O(shape, "bpmn:DataStoreReference") && shape.type !== "label") {
      if (!context.hints) {
        context.hints = {};
      }
      context.hints.autoResize = false;
    }
  });
  this.preExecute("elements.move", function(event) {
    var context = event.context, shapes = context.shapes;
    var dataStoreReferences = shapes.filter(function(shape) {
      return is$O(shape, "bpmn:DataStoreReference");
    });
    if (dataStoreReferences.length) {
      if (!context.hints) {
        context.hints = {};
      }
      context.hints.autoResize = shapes.filter(function(shape) {
        return !is$O(shape, "bpmn:DataStoreReference");
      });
    }
  });
  this.postExecute("shape.create", function(event) {
    var context = event.context, shape = context.shape, parent2 = shape.parent;
    if (is$O(shape, "bpmn:DataStoreReference") && shape.type !== "label" && is$O(parent2, "bpmn:Collaboration")) {
      updateDataStoreParent(shape);
    }
  });
  this.postExecute("shape.move", function(event) {
    var context = event.context, shape = context.shape, oldParent = context.oldParent, parent2 = shape.parent;
    if (is$O(oldParent, "bpmn:Collaboration")) {
      return;
    }
    if (is$O(shape, "bpmn:DataStoreReference") && shape.type !== "label" && is$O(parent2, "bpmn:Collaboration")) {
      var participant = is$O(oldParent, "bpmn:Participant") ? oldParent : getAncestor(oldParent, "bpmn:Participant");
      updateDataStoreParent(shape, participant);
    }
  });
  this.postExecute("shape.delete", function(event) {
    var context = event.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (isAny$b(shape, ["bpmn:Participant", "bpmn:SubProcess"]) && is$O(rootElement, "bpmn:Collaboration")) {
      getDataStores(rootElement).filter(function(dataStore) {
        return isDescendant(dataStore, shape);
      }).forEach(function(dataStore) {
        updateDataStoreParent(dataStore);
      });
    }
  });
  this.postExecute("canvas.updateRoot", function(event) {
    var context = event.context, oldRoot = context.oldRoot, newRoot = context.newRoot;
    var dataStores = getDataStores(oldRoot);
    dataStores.forEach(function(dataStore) {
      if (is$O(newRoot, "bpmn:Process")) {
        updateDataStoreParent(dataStore, newRoot);
      }
    });
  });
}
DataStoreBehavior.$inject = [
  "canvas",
  "commandStack",
  "elementRegistry",
  "eventBus"
];
inherits$6(DataStoreBehavior, CommandInterceptor$5);
function isDescendant(descendant, ancestor) {
  var descendantBo = descendant.businessObject || descendant, ancestorBo = ancestor.businessObject || ancestor;
  while (descendantBo.$parent) {
    if (descendantBo.$parent === ancestorBo.processRef || ancestorBo) {
      return true;
    }
    descendantBo = descendantBo.$parent;
  }
  return false;
}
function getAncestor(element, type) {
  while (element.parent) {
    if (is$O(element.parent, type)) {
      return element.parent;
    }
    element = element.parent;
  }
}
var LOW_PRIORITY$b = 500;
function DeleteLaneBehavior(eventBus, modeling, spaceTool) {
  CommandInterceptor$5.call(this, eventBus);
  function compensateLaneDelete(shape, oldParent) {
    var siblings = getChildLanes(oldParent);
    var topAffected = [];
    var bottomAffected = [];
    eachElement$1(siblings, function(element) {
      if (element.y > shape.y) {
        bottomAffected.push(element);
      } else {
        topAffected.push(element);
      }
      return element.children;
    });
    if (!siblings.length) {
      return;
    }
    var offset2;
    if (bottomAffected.length && topAffected.length) {
      offset2 = shape.height / 2;
    } else {
      offset2 = shape.height;
    }
    var topAdjustments, bottomAdjustments;
    if (topAffected.length) {
      topAdjustments = spaceTool.calculateAdjustments(topAffected, "y", offset2, shape.y - 10);
      spaceTool.makeSpace(topAdjustments.movingShapes, topAdjustments.resizingShapes, { x: 0, y: offset2 }, "s");
    }
    if (bottomAffected.length) {
      bottomAdjustments = spaceTool.calculateAdjustments(bottomAffected, "y", -offset2, shape.y + shape.height + 10);
      spaceTool.makeSpace(bottomAdjustments.movingShapes, bottomAdjustments.resizingShapes, { x: 0, y: -offset2 }, "n");
    }
  }
  this.postExecuted("shape.delete", LOW_PRIORITY$b, function(event) {
    var context = event.context, hints = context.hints, shape = context.shape, oldParent = context.oldParent;
    if (!is$O(shape, "bpmn:Lane")) {
      return;
    }
    if (hints && hints.nested) {
      return;
    }
    compensateLaneDelete(shape, oldParent);
  });
}
DeleteLaneBehavior.$inject = [
  "eventBus",
  "modeling",
  "spaceTool"
];
inherits$6(DeleteLaneBehavior, CommandInterceptor$5);
var LOW_PRIORITY$a = 500;
function DetachEventBehavior(bpmnReplace, injector) {
  injector.invoke(CommandInterceptor$5, this);
  this._bpmnReplace = bpmnReplace;
  var self2 = this;
  this.postExecuted("elements.create", LOW_PRIORITY$a, function(context) {
    var elements = context.elements;
    elements.filter(function(shape) {
      var host = shape.host;
      return shouldReplace(shape, host);
    }).map(function(shape) {
      return elements.indexOf(shape);
    }).forEach(function(index2) {
      context.elements[index2] = self2.replaceShape(elements[index2]);
    });
  }, true);
  this.preExecute("elements.move", LOW_PRIORITY$a, function(context) {
    var shapes = context.shapes, newHost = context.newHost;
    shapes.forEach(function(shape, index2) {
      var host = shape.host;
      if (shouldReplace(shape, includes$6(shapes, host) ? host : newHost)) {
        shapes[index2] = self2.replaceShape(shape);
      }
    });
  }, true);
}
DetachEventBehavior.$inject = [
  "bpmnReplace",
  "injector"
];
inherits$6(DetachEventBehavior, CommandInterceptor$5);
DetachEventBehavior.prototype.replaceShape = function(shape) {
  var eventDefinition = getEventDefinition(shape), intermediateEvent;
  if (eventDefinition) {
    intermediateEvent = {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: eventDefinition.$type
    };
  } else {
    intermediateEvent = {
      type: "bpmn:IntermediateThrowEvent"
    };
  }
  return this._bpmnReplace.replaceElement(shape, intermediateEvent, { layoutConnection: false });
};
function getEventDefinition(element) {
  var businessObject = getBusinessObject$V(element), eventDefinitions = businessObject.eventDefinitions;
  return eventDefinitions && eventDefinitions[0];
}
function shouldReplace(shape, host) {
  return !isLabel$6(shape) && is$O(shape, "bpmn:BoundaryEvent") && !host;
}
function includes$6(array, item) {
  return array.indexOf(item) !== -1;
}
function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {
  CommandInterceptor$5.call(this, eventBus);
  function insertShape(shape, targetFlow, positionOrBounds) {
    var waypoints = targetFlow.waypoints, waypointsBefore, waypointsAfter, dockingPoint, source, target, incomingConnection, outgoingConnection, oldOutgoing = shape.outgoing.slice(), oldIncoming = shape.incoming.slice();
    var mid2;
    if (isNumber$1(positionOrBounds.width)) {
      mid2 = getMid(positionOrBounds);
    } else {
      mid2 = positionOrBounds;
    }
    var intersection2 = getApproxIntersection(waypoints, mid2);
    if (intersection2) {
      waypointsBefore = waypoints.slice(0, intersection2.index);
      waypointsAfter = waypoints.slice(intersection2.index + (intersection2.bendpoint ? 1 : 0));
      if (!waypointsBefore.length || !waypointsAfter.length) {
        return;
      }
      dockingPoint = intersection2.bendpoint ? waypoints[intersection2.index] : mid2;
      if (waypointsBefore.length === 1 || !isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length - 1])) {
        waypointsBefore.push(copy(dockingPoint));
      }
      if (waypointsAfter.length === 1 || !isPointInsideBBox(shape, waypointsAfter[0])) {
        waypointsAfter.unshift(copy(dockingPoint));
      }
    }
    source = targetFlow.source;
    target = targetFlow.target;
    if (bpmnRules.canConnect(source, shape, targetFlow)) {
      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid2);
      incomingConnection = targetFlow;
    }
    if (bpmnRules.canConnect(shape, target, targetFlow)) {
      if (!incomingConnection) {
        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid2);
        outgoingConnection = targetFlow;
      } else {
        outgoingConnection = modeling.connect(shape, target, { type: targetFlow.type, waypoints: waypointsAfter });
      }
    }
    var duplicateConnections = [].concat(incomingConnection && filter$a(oldIncoming, function(connection) {
      return connection.source === incomingConnection.source;
    }) || [], outgoingConnection && filter$a(oldOutgoing, function(connection) {
      return connection.target === outgoingConnection.target;
    }) || []);
    if (duplicateConnections.length) {
      modeling.removeElements(duplicateConnections);
    }
  }
  this.preExecute("elements.move", function(context) {
    var newParent = context.newParent, shapes = context.shapes, delta2 = context.delta, shape = shapes[0];
    if (!shape || !newParent) {
      return;
    }
    if (newParent && newParent.waypoints) {
      context.newParent = newParent = newParent.parent;
    }
    var shapeMid = getMid(shape);
    var newShapeMid = {
      x: shapeMid.x + delta2.x,
      y: shapeMid.y + delta2.y
    };
    var connection = find$e(newParent.children, function(element) {
      var canInsert2 = bpmnRules.canInsert(shapes, element);
      return canInsert2 && getApproxIntersection(element.waypoints, newShapeMid);
    });
    if (connection) {
      context.targetFlow = connection;
      context.position = newShapeMid;
    }
  }, true);
  this.postExecuted("elements.move", function(context) {
    var shapes = context.shapes, targetFlow = context.targetFlow, position = context.position;
    if (targetFlow) {
      insertShape(shapes[0], targetFlow, position);
    }
  }, true);
  this.preExecute("shape.create", function(context) {
    var parent2 = context.parent, shape = context.shape;
    if (bpmnRules.canInsert(shape, parent2)) {
      context.targetFlow = parent2;
      context.parent = parent2.parent;
    }
  }, true);
  this.postExecuted("shape.create", function(context) {
    var shape = context.shape, targetFlow = context.targetFlow, positionOrBounds = context.position;
    if (targetFlow) {
      insertShape(shape, targetFlow, positionOrBounds);
    }
  }, true);
}
inherits$6(DropOnFlowBehavior, CommandInterceptor$5);
DropOnFlowBehavior.$inject = [
  "eventBus",
  "bpmnRules",
  "modeling"
];
function isPointInsideBBox(bbox, point) {
  var x = point.x, y = point.y;
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
}
function copy(obj) {
  return assign$e({}, obj);
}
function EventBasedGatewayBehavior(eventBus, modeling) {
  CommandInterceptor$5.call(this, eventBus);
  this.preExecuted("connection.create", function(event) {
    var context = event.context, source = context.source, target = context.target, existingIncomingConnections = target.incoming.slice();
    if (context.hints && context.hints.createElementsBehavior === false) {
      return;
    }
    if (is$O(source, "bpmn:EventBasedGateway") && target.incoming.length) {
      existingIncomingConnections.filter(isSequenceFlow).forEach(function(sequenceFlow) {
        modeling.removeConnection(sequenceFlow);
      });
    }
  });
  this.preExecuted("shape.replace", function(event) {
    var newShape = event.context.newShape, newShapeTargets, newShapeTargetsIncomingSequenceFlows;
    if (!is$O(newShape, "bpmn:EventBasedGateway")) {
      return;
    }
    newShapeTargets = newShape.outgoing.filter(isSequenceFlow).map(function(sequenceFlow) {
      return sequenceFlow.target;
    });
    newShapeTargetsIncomingSequenceFlows = newShapeTargets.reduce(function(sequenceFlows, target) {
      var incomingSequenceFlows = target.incoming.filter(isSequenceFlow);
      return sequenceFlows.concat(incomingSequenceFlows);
    }, []);
    newShapeTargetsIncomingSequenceFlows.forEach(function(sequenceFlow) {
      if (sequenceFlow.source !== newShape) {
        modeling.removeConnection(sequenceFlow);
      }
    });
  });
}
EventBasedGatewayBehavior.$inject = [
  "eventBus",
  "modeling"
];
inherits$6(EventBasedGatewayBehavior, CommandInterceptor$5);
function isSequenceFlow(connection) {
  return is$O(connection, "bpmn:SequenceFlow");
}
var HIGH_PRIORITY$9 = 2e3;
function GroupBehavior(bpmnFactory, canvas, elementRegistry, eventBus, injector, moddleCopy) {
  injector.invoke(CommandInterceptor$5, this);
  function getDefinitions2() {
    var rootElement = canvas.getRootElement(), businessObject = getBusinessObject$V(rootElement);
    return businessObject.$parent;
  }
  function removeReferencedCategoryValue(shape) {
    var businessObject = getBusinessObject$V(shape), categoryValue = businessObject.categoryValueRef;
    if (!categoryValue) {
      return;
    }
    var category = categoryValue.$parent;
    if (!categoryValue) {
      return;
    }
    remove$3(category.categoryValue, categoryValue);
    if (category && !category.categoryValue.length) {
      removeCategory(category);
    }
  }
  function removeCategory(category) {
    var definitions = getDefinitions2();
    remove$3(definitions.get("rootElements"), category);
  }
  function getGroupElements() {
    return elementRegistry.filter(function(e) {
      return is$O(e, "bpmn:Group");
    });
  }
  function isReferenced(elements, categoryValue) {
    return elements.some(function(e) {
      var businessObject = getBusinessObject$V(e);
      return businessObject.categoryValueRef && businessObject.categoryValueRef === categoryValue;
    });
  }
  this.executed("shape.delete", function(event) {
    var context = event.context, shape = context.shape;
    if (is$O(shape, "bpmn:Group")) {
      var businessObject = getBusinessObject$V(shape), categoryValueRef = businessObject.categoryValueRef, groupElements = getGroupElements();
      if (!isReferenced(groupElements, categoryValueRef)) {
        removeReferencedCategoryValue(shape);
      }
    }
  });
  this.reverted("shape.delete", function(event) {
    var context = event.context, shape = context.shape;
    if (is$O(shape, "bpmn:Group")) {
      var businessObject = getBusinessObject$V(shape), categoryValueRef = businessObject.categoryValueRef, definitions = getDefinitions2(), category = categoryValueRef ? categoryValueRef.$parent : null;
      add$2(category.get("categoryValue"), categoryValueRef);
      add$2(definitions.get("rootElements"), category);
    }
  });
  this.execute("shape.create", function(event) {
    var context = event.context, shape = context.shape, businessObject = getBusinessObject$V(shape);
    if (is$O(businessObject, "bpmn:Group") && !businessObject.categoryValueRef) {
      var definitions = getDefinitions2(), categoryValue = createCategoryValue$1(definitions, bpmnFactory);
      businessObject.categoryValueRef = categoryValue;
    }
  });
  this.revert("shape.create", function(event) {
    var context = event.context, shape = context.shape;
    if (is$O(shape, "bpmn:Group")) {
      removeReferencedCategoryValue(shape);
      delete getBusinessObject$V(shape).categoryValueRef;
    }
  });
  eventBus.on("moddleCopy.canCopyProperty", HIGH_PRIORITY$9, function(context) {
    var property2 = context.property, categoryValue;
    if (is$O(property2, "bpmn:CategoryValue")) {
      categoryValue = createCategoryValue$1(getDefinitions2(), bpmnFactory);
      return moddleCopy.copyElement(property2, categoryValue);
    }
  });
}
GroupBehavior.$inject = [
  "bpmnFactory",
  "canvas",
  "elementRegistry",
  "eventBus",
  "injector",
  "moddleCopy"
];
inherits$6(GroupBehavior, CommandInterceptor$5);
function lineIntersect(l1s, l1e, l2s, l2e) {
  var denominator, a, b, c, numerator;
  denominator = (l2e.y - l2s.y) * (l1e.x - l1s.x) - (l2e.x - l2s.x) * (l1e.y - l1s.y);
  if (denominator == 0) {
    return null;
  }
  a = l1s.y - l2s.y;
  b = l1s.x - l2s.x;
  numerator = (l2e.x - l2s.x) * a - (l2e.y - l2s.y) * b;
  c = numerator / denominator;
  return {
    x: Math.round(l1s.x + c * (l1e.x - l1s.x)),
    y: Math.round(l1s.y + c * (l1e.y - l1s.y))
  };
}
function ImportDockingFix(eventBus) {
  function adjustDocking(startPoint, nextPoint, elementMid) {
    var elementTop = {
      x: elementMid.x,
      y: elementMid.y - 50
    };
    var elementLeft = {
      x: elementMid.x - 50,
      y: elementMid.y
    };
    var verticalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementTop), horizontalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementLeft);
    var centerIntersect;
    if (verticalIntersect && horizontalIntersect) {
      if (getDistance$1(verticalIntersect, elementMid) > getDistance$1(horizontalIntersect, elementMid)) {
        centerIntersect = horizontalIntersect;
      } else {
        centerIntersect = verticalIntersect;
      }
    } else {
      centerIntersect = verticalIntersect || horizontalIntersect;
    }
    startPoint.original = centerIntersect;
  }
  function fixDockings(connection) {
    var waypoints = connection.waypoints;
    adjustDocking(waypoints[0], waypoints[1], getMid(connection.source));
    adjustDocking(waypoints[waypoints.length - 1], waypoints[waypoints.length - 2], getMid(connection.target));
  }
  eventBus.on("bpmnElement.added", function(e) {
    var element = e.element;
    if (element.waypoints) {
      fixDockings(element);
    }
  });
}
ImportDockingFix.$inject = [
  "eventBus"
];
function getDistance$1(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function IsHorizontalFix(eventBus) {
  CommandInterceptor$5.call(this, eventBus);
  var elementTypesToUpdate = [
    "bpmn:Participant",
    "bpmn:Lane"
  ];
  this.executed(["shape.move", "shape.create", "shape.resize"], function(event) {
    var bo = getBusinessObject$V(event.context.shape);
    if (isAny$b(bo, elementTypesToUpdate) && !bo.di.get("isHorizontal")) {
      bo.di.set("isHorizontal", true);
    }
  });
}
IsHorizontalFix.$inject = ["eventBus"];
inherits$6(IsHorizontalFix, CommandInterceptor$5);
function vectorLength(v) {
  return Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2));
}
function getAngle(line) {
  return Math.atan((line[1].y - line[0].y) / (line[1].x - line[0].x));
}
function rotateVector(vector, angle) {
  return !angle ? vector : {
    x: Math.cos(angle) * vector.x - Math.sin(angle) * vector.y,
    y: Math.sin(angle) * vector.x + Math.cos(angle) * vector.y
  };
}
function solveLambaSystem(a, b, c) {
  var system = [
    { n: a[0] - c[0], lambda: b[0] },
    { n: a[1] - c[1], lambda: b[1] }
  ];
  var n = system[0].n * b[0] + system[1].n * b[1], l = system[0].lambda * b[0] + system[1].lambda * b[1];
  return -n / l;
}
function perpendicularFoot(point, line) {
  var a = line[0], b = line[1];
  var bd = { x: b.x - a.x, y: b.y - a.y };
  var r = solveLambaSystem([a.x, a.y], [bd.x, bd.y], [point.x, point.y]);
  return { x: a.x + r * bd.x, y: a.y + r * bd.y };
}
function getDistancePointLine(point, line) {
  var pfPoint = perpendicularFoot(point, line);
  var connectionVector = {
    x: pfPoint.x - point.x,
    y: pfPoint.y - point.y
  };
  return vectorLength(connectionVector);
}
function getDistancePointPoint(point1, point2) {
  return vectorLength({
    x: point1.x - point2.x,
    y: point1.y - point2.y
  });
}
var sqrt = Math.sqrt, min$1 = Math.min, max$3 = Math.max, abs$3 = Math.abs;
function sq(n) {
  return Math.pow(n, 2);
}
function getDistance(p1, p2) {
  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));
}
function getAttachment(point, line) {
  var idx = 0, segmentStart, segmentEnd, segmentStartDistance, segmentEndDistance, attachmentPosition, minDistance, intersections, attachment, attachmentDistance, closestAttachmentDistance, closestAttachment;
  for (idx = 0; idx < line.length - 1; idx++) {
    segmentStart = line[idx];
    segmentEnd = line[idx + 1];
    if (pointsEqual(segmentStart, segmentEnd)) {
      intersections = [segmentStart];
    } else {
      segmentStartDistance = getDistance(point, segmentStart);
      segmentEndDistance = getDistance(point, segmentEnd);
      minDistance = min$1(segmentStartDistance, segmentEndDistance);
      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);
    }
    if (intersections.length < 1) {
      throw new Error("expected between [1, 2] circle -> line intersections");
    }
    if (intersections.length === 1) {
      attachment = {
        type: "bendpoint",
        position: intersections[0],
        segmentIndex: idx,
        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1
      };
    }
    if (intersections.length === 2) {
      attachmentPosition = mid$1(intersections[0], intersections[1]);
      attachment = {
        type: "segment",
        position: attachmentPosition,
        segmentIndex: idx,
        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)
      };
    }
    attachmentDistance = getDistance(attachment.position, point);
    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {
      closestAttachment = attachment;
      closestAttachmentDistance = attachmentDistance;
    }
  }
  return closestAttachment;
}
function getCircleSegmentIntersections(s1, s2, cc, cr) {
  var baX = s2.x - s1.x;
  var baY = s2.y - s1.y;
  var caX = cc.x - s1.x;
  var caY = cc.y - s1.y;
  var a = baX * baX + baY * baY;
  var bBy2 = baX * caX + baY * caY;
  var c = caX * caX + caY * caY - cr * cr;
  var pBy2 = bBy2 / a;
  var q = c / a;
  var disc = pBy2 * pBy2 - q;
  if (disc < 0 && disc > -1e-6) {
    disc = 0;
  }
  if (disc < 0) {
    return [];
  }
  var tmpSqrt = sqrt(disc);
  var abScalingFactor1 = -pBy2 + tmpSqrt;
  var abScalingFactor2 = -pBy2 - tmpSqrt;
  var i1 = {
    x: s1.x - baX * abScalingFactor1,
    y: s1.y - baY * abScalingFactor1
  };
  if (disc === 0) {
    return [i1];
  }
  var i2 = {
    x: s1.x - baX * abScalingFactor2,
    y: s1.y - baY * abScalingFactor2
  };
  return [i1, i2].filter(function(p) {
    return isPointInSegment(p, s1, s2);
  });
}
function isPointInSegment(p, segmentStart, segmentEnd) {
  return fenced(p.x, segmentStart.x, segmentEnd.x) && fenced(p.y, segmentStart.y, segmentEnd.y);
}
function fenced(n, rangeStart, rangeEnd) {
  return n >= min$1(rangeStart, rangeEnd) - EQUAL_THRESHOLD && n <= max$3(rangeStart, rangeEnd) + EQUAL_THRESHOLD;
}
function mid$1(p1, p2) {
  return {
    x: (p1.x + p2.x) / 2,
    y: (p1.y + p2.y) / 2
  };
}
var EQUAL_THRESHOLD = 0.1;
function pointsEqual(p1, p2) {
  return abs$3(p1.x - p2.x) <= EQUAL_THRESHOLD && abs$3(p1.y - p2.y) <= EQUAL_THRESHOLD;
}
function findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {
  var index2 = attachment.segmentIndex;
  var offset2 = newWaypoints.length - oldWaypoints.length;
  if (hints.segmentMove) {
    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex, newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;
    if (index2 === oldSegmentStartIndex) {
      return newSegmentStartIndex;
    }
    if (index2 >= newSegmentStartIndex) {
      return index2 + offset2 < newSegmentStartIndex ? newSegmentStartIndex : index2 + offset2;
    }
    return index2;
  }
  if (hints.bendpointMove) {
    var insert = hints.bendpointMove.insert, bendpointIndex = hints.bendpointMove.bendpointIndex, newIndex;
    if (offset2 === 0) {
      return index2;
    }
    if (index2 >= bendpointIndex) {
      newIndex = insert ? index2 + 1 : index2 - 1;
    }
    if (index2 < bendpointIndex) {
      newIndex = index2;
      if (insert && attachment.type !== "bendpoint" && bendpointIndex - 1 === index2) {
        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);
        if (rel < attachment.relativeLocation) {
          newIndex++;
        }
      }
    }
    return newIndex;
  }
  if (offset2 === 0) {
    return index2;
  }
  if (hints.connectionStart) {
    return index2 === 0 ? 0 : null;
  }
  if (hints.connectionEnd) {
    return index2 === oldWaypoints.length - 2 ? newWaypoints.length - 2 : null;
  }
  return null;
}
function getLabelAdjustment(label2, newWaypoints, oldWaypoints, hints) {
  var x = 0, y = 0;
  var labelPosition = getLabelMid(label2);
  var attachment = getAttachment(labelPosition, oldWaypoints), oldLabelLineIndex = attachment.segmentIndex, newLabelLineIndex = findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);
  if (newLabelLineIndex === null) {
    return { x, y };
  }
  if (newLabelLineIndex < 0 || newLabelLineIndex > newWaypoints.length - 2) {
    return { x, y };
  }
  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex), newLabelLine = getLine(newWaypoints, newLabelLineIndex), oldFoot = attachment.position;
  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot), angleDelta = getAngleDelta(oldLabelLine, newLabelLine);
  if (attachment.type === "bendpoint") {
    var offset2 = newWaypoints.length - oldWaypoints.length, oldBendpointIndex = attachment.bendpointIndex, oldBendpoint = oldWaypoints[oldBendpointIndex];
    if (newWaypoints.indexOf(oldBendpoint) !== -1) {
      return { x, y };
    }
    if (offset2 === 0) {
      var newBendpoint = newWaypoints[oldBendpointIndex];
      return {
        x: newBendpoint.x - attachment.position.x,
        y: newBendpoint.y - attachment.position.y
      };
    }
    if (offset2 < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {
      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);
    }
  }
  var newFoot = {
    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,
    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y
  };
  var newLabelVector = rotateVector({
    x: labelPosition.x - oldFoot.x,
    y: labelPosition.y - oldFoot.y
  }, angleDelta);
  x = newFoot.x + newLabelVector.x - labelPosition.x;
  y = newFoot.y + newLabelVector.y - labelPosition.y;
  return roundPoint({
    x,
    y
  });
}
function relativePositionMidWaypoint(waypoints, idx) {
  var distanceSegment1 = getDistancePointPoint(waypoints[idx - 1], waypoints[idx]), distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx + 1]);
  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);
  return relativePosition;
}
function getLabelMid(label2) {
  return {
    x: label2.x + label2.width / 2,
    y: label2.y + label2.height / 2
  };
}
function getAngleDelta(l1, l2) {
  var a1 = getAngle(l1), a2 = getAngle(l2);
  return a2 - a1;
}
function getLine(waypoints, idx) {
  return [waypoints[idx], waypoints[idx + 1]];
}
function getRelativeFootPosition(line, foot) {
  var length2 = getDistancePointPoint(line[0], line[1]), lengthToFoot = getDistancePointPoint(line[0], foot);
  return length2 === 0 ? 0 : lengthToFoot / length2;
}
function getNewAttachPoint(point, oldBounds, newBounds) {
  var oldCenter = center(oldBounds), newCenter = center(newBounds), oldDelta = delta(point, oldCenter);
  var newDelta = {
    x: oldDelta.x * (newBounds.width / oldBounds.width),
    y: oldDelta.y * (newBounds.height / oldBounds.height)
  };
  return roundPoint({
    x: newCenter.x + newDelta.x,
    y: newCenter.y + newDelta.y
  });
}
function getNewAttachShapeDelta(shape, oldBounds, newBounds) {
  var shapeCenter = center(shape), oldCenter = center(oldBounds), newCenter = center(newBounds), shapeDelta = delta(shape, shapeCenter), oldCenterDelta = delta(shapeCenter, oldCenter), stickyPositionDelta = getStickyPositionDelta(shapeCenter, oldBounds, newBounds);
  if (stickyPositionDelta) {
    return stickyPositionDelta;
  }
  var newCenterDelta = {
    x: oldCenterDelta.x * (newBounds.width / oldBounds.width),
    y: oldCenterDelta.y * (newBounds.height / oldBounds.height)
  };
  var newShapeCenter = {
    x: newCenter.x + newCenterDelta.x,
    y: newCenter.y + newCenterDelta.y
  };
  return roundPoint({
    x: newShapeCenter.x + shapeDelta.x - shape.x,
    y: newShapeCenter.y + shapeDelta.y - shape.y
  });
}
function getStickyPositionDelta(oldShapeCenter, oldBounds, newBounds) {
  var oldTRBL = asTRBL(oldBounds), newTRBL = asTRBL(newBounds);
  if (isMoved(oldTRBL, newTRBL)) {
    return null;
  }
  var oldOrientation = getOrientation(oldBounds, oldShapeCenter), stickyPositionDelta, newShapeCenter, newOrientation;
  if (oldOrientation === "top") {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.bottom - oldTRBL.bottom
    };
  } else if (oldOrientation === "bottom") {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.top - oldTRBL.top
    };
  } else if (oldOrientation === "right") {
    stickyPositionDelta = {
      x: newTRBL.left - oldTRBL.left,
      y: 0
    };
  } else if (oldOrientation === "left") {
    stickyPositionDelta = {
      x: newTRBL.right - oldTRBL.right,
      y: 0
    };
  } else {
    return null;
  }
  newShapeCenter = {
    x: oldShapeCenter.x + stickyPositionDelta.x,
    y: oldShapeCenter.y + stickyPositionDelta.y
  };
  newOrientation = getOrientation(newBounds, newShapeCenter);
  if (newOrientation !== oldOrientation) {
    return null;
  }
  return stickyPositionDelta;
}
function isMoved(oldTRBL, newTRBL) {
  return isHorizontallyMoved(oldTRBL, newTRBL) || isVerticallyMoved(oldTRBL, newTRBL);
}
function isHorizontallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.right !== newTRBL.right && oldTRBL.left !== newTRBL.left;
}
function isVerticallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.top !== newTRBL.top && oldTRBL.bottom !== newTRBL.bottom;
}
var DEFAULT_LABEL_DIMENSIONS = {
  width: 90,
  height: 20
};
var NAME_PROPERTY = "name";
var TEXT_PROPERTY = "text";
function LabelBehavior(eventBus, modeling, bpmnFactory, textRenderer) {
  CommandInterceptor$5.call(this, eventBus);
  this.postExecute("element.updateProperties", function(e) {
    var context = e.context, element = context.element, properties2 = context.properties;
    if (NAME_PROPERTY in properties2) {
      modeling.updateLabel(element, properties2[NAME_PROPERTY]);
    }
    if (TEXT_PROPERTY in properties2 && is$O(element, "bpmn:TextAnnotation")) {
      var newBounds = textRenderer.getTextAnnotationBounds({
        x: element.x,
        y: element.y,
        width: element.width,
        height: element.height
      }, properties2[TEXT_PROPERTY] || "");
      modeling.updateLabel(element, properties2.text, newBounds);
    }
  });
  this.postExecute(["shape.create", "connection.create"], function(e) {
    var context = e.context, hints = context.hints || {};
    if (hints.createElementsBehavior === false) {
      return;
    }
    var element = context.shape || context.connection, businessObject = element.businessObject;
    if (isLabel$6(element) || !isLabelExternal(element)) {
      return;
    }
    if (!getLabel(element)) {
      return;
    }
    var labelCenter = getExternalLabelMid(element);
    var labelDimensions = textRenderer.getExternalLabelBounds(DEFAULT_LABEL_DIMENSIONS, getLabel(element));
    modeling.createLabel(element, labelCenter, {
      id: businessObject.id + "_label",
      businessObject,
      width: labelDimensions.width,
      height: labelDimensions.height
    });
  });
  this.postExecute("shape.delete", function(event) {
    var context = event.context, labelTarget = context.labelTarget, hints = context.hints || {};
    if (labelTarget && hints.unsetLabel !== false) {
      modeling.updateLabel(labelTarget, null, null, { removeShape: false });
    }
  });
  this.postExecute(["label.create"], function(event) {
    var context = event.context, element = context.shape, businessObject, di;
    if (!element.labelTarget) {
      return;
    }
    if (!is$O(element.labelTarget || element, "bpmn:BaseElement")) {
      return;
    }
    businessObject = element.businessObject, di = businessObject.di;
    if (!di.label) {
      di.label = bpmnFactory.create("bpmndi:BPMNLabel", {
        bounds: bpmnFactory.create("dc:Bounds")
      });
    }
    assign$e(di.label.bounds, {
      x: element.x,
      y: element.y,
      width: element.width,
      height: element.height
    });
  });
  function getVisibleLabelAdjustment(event) {
    var context = event.context, connection = context.connection, label2 = connection.label, hints = assign$e({}, context.hints), newWaypoints = context.newWaypoints || connection.waypoints, oldWaypoints = context.oldWaypoints;
    if (typeof hints.startChanged === "undefined") {
      hints.startChanged = !!hints.connectionStart;
    }
    if (typeof hints.endChanged === "undefined") {
      hints.endChanged = !!hints.connectionEnd;
    }
    return getLabelAdjustment(label2, newWaypoints, oldWaypoints, hints);
  }
  this.postExecute([
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event) {
    var context = event.context, hints = context.hints || {};
    if (hints.labelBehavior === false) {
      return;
    }
    var connection = context.connection, label2 = connection.label, labelAdjustment;
    if (!label2 || !label2.parent) {
      return;
    }
    labelAdjustment = getVisibleLabelAdjustment(event);
    modeling.moveShape(label2, labelAdjustment);
  });
  this.postExecute(["shape.replace"], function(event) {
    var context = event.context, newShape = context.newShape, oldShape = context.oldShape;
    var businessObject = getBusinessObject$V(newShape);
    if (businessObject && isLabelExternal(businessObject) && oldShape.label && newShape.label) {
      newShape.label.x = oldShape.label.x;
      newShape.label.y = oldShape.label.y;
    }
  });
  this.postExecute("shape.resize", function(event) {
    var context = event.context, shape = context.shape, newBounds = context.newBounds, oldBounds = context.oldBounds;
    if (hasExternalLabel(shape)) {
      var label2 = shape.label, labelMid = getMid(label2), edges = asEdges(oldBounds);
      var referencePoint = getReferencePoint(labelMid, edges);
      var delta2 = getReferencePointDelta(referencePoint, oldBounds, newBounds);
      modeling.moveShape(label2, delta2);
    }
  });
}
inherits$6(LabelBehavior, CommandInterceptor$5);
LabelBehavior.$inject = [
  "eventBus",
  "modeling",
  "bpmnFactory",
  "textRenderer"
];
function getReferencePointDelta(referencePoint, oldBounds, newBounds) {
  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);
  return roundPoint(delta(newReferencePoint, referencePoint));
}
function getReferencePoint(point, lines) {
  if (!lines.length) {
    return;
  }
  var nearestLine = getNearestLine(point, lines);
  return perpendicularFoot(point, nearestLine);
}
function asEdges(bounds) {
  return [
    [
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      }
    ],
    [
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      }
    ]
  ];
}
function getNearestLine(point, lines) {
  var distances = lines.map(function(l) {
    return {
      line: l,
      distance: getDistancePointLine(point, l)
    };
  });
  var sorted = sortBy$2(distances, "distance");
  return sorted[0].line;
}
function getResizedSourceAnchor(connection, shape, oldBounds) {
  var waypoints = safeGetWaypoints(connection), waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape), oldAnchor = waypoints[0];
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[waypointsInsideNewBounds.length - 1];
  }
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
}
function getResizedTargetAnchor(connection, shape, oldBounds) {
  var waypoints = safeGetWaypoints(connection), waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape), oldAnchor = waypoints[waypoints.length - 1];
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[0];
  }
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
}
function getMovedSourceAnchor(connection, source, moveDelta) {
  var waypoints = safeGetWaypoints(connection), oldBounds = subtract(source, moveDelta), oldAnchor = waypoints[0];
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, source);
}
function getMovedTargetAnchor(connection, target, moveDelta) {
  var waypoints = safeGetWaypoints(connection), oldBounds = subtract(target, moveDelta), oldAnchor = waypoints[waypoints.length - 1];
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, target);
}
function subtract(bounds, delta2) {
  return {
    x: bounds.x - delta2.x,
    y: bounds.y - delta2.y,
    width: bounds.width,
    height: bounds.height
  };
}
function safeGetWaypoints(connection) {
  var waypoints = connection.waypoints;
  if (!waypoints.length) {
    throw new Error("connection#" + connection.id + ": no waypoints");
  }
  return waypoints;
}
function getWaypointsInsideBounds(waypoints, bounds) {
  var originalWaypoints = map$7(waypoints, getOriginal);
  return filter$a(originalWaypoints, function(waypoint) {
    return isInsideBounds(waypoint, bounds);
  });
}
function isInsideBounds(point, bounds) {
  return getOrientation(bounds, point, 1) === "intersect";
}
function getOriginal(point) {
  return point.original || point;
}
function MessageFlowBehavior(eventBus, modeling) {
  CommandInterceptor$5.call(this, eventBus);
  this.postExecute("shape.replace", function(context) {
    var oldShape = context.oldShape, newShape = context.newShape;
    if (!isParticipantCollapse(oldShape, newShape)) {
      return;
    }
    var messageFlows = getMessageFlows(oldShape);
    messageFlows.incoming.forEach(function(incoming) {
      var anchor = getResizedTargetAnchor(incoming, newShape, oldShape);
      modeling.reconnectEnd(incoming, newShape, anchor);
    });
    messageFlows.outgoing.forEach(function(outgoing) {
      var anchor = getResizedSourceAnchor(outgoing, newShape, oldShape);
      modeling.reconnectStart(outgoing, newShape, anchor);
    });
  }, true);
}
MessageFlowBehavior.$inject = ["eventBus", "modeling"];
inherits$6(MessageFlowBehavior, CommandInterceptor$5);
function isParticipantCollapse(oldShape, newShape) {
  return is$O(oldShape, "bpmn:Participant") && isExpanded(oldShape) && is$O(newShape, "bpmn:Participant") && !isExpanded(newShape);
}
function getMessageFlows(parent2) {
  var elements = selfAndAllChildren([parent2], false);
  var incoming = [], outgoing = [];
  elements.forEach(function(element) {
    if (element === parent2) {
      return;
    }
    element.incoming.forEach(function(connection) {
      if (is$O(connection, "bpmn:MessageFlow")) {
        incoming.push(connection);
      }
    });
    element.outgoing.forEach(function(connection) {
      if (is$O(connection, "bpmn:MessageFlow")) {
        outgoing.push(connection);
      }
    });
  }, []);
  return {
    incoming,
    outgoing
  };
}
var COLLAB_ERR_MSG = "flow elements must be children of pools/participants";
function ModelingFeedback(eventBus, tooltips, translate2) {
  function showError(position, message2, timeout) {
    tooltips.add({
      position: {
        x: position.x + 5,
        y: position.y + 5
      },
      type: "error",
      timeout: timeout || 2e3,
      html: "<div>" + message2 + "</div>"
    });
  }
  eventBus.on(["shape.move.rejected", "create.rejected"], function(event) {
    var context = event.context, shape = context.shape, target = context.target;
    if (is$O(target, "bpmn:Collaboration") && is$O(shape, "bpmn:FlowNode")) {
      showError(event, translate2(COLLAB_ERR_MSG));
    }
  });
}
ModelingFeedback.$inject = [
  "eventBus",
  "tooltips",
  "translate"
];
function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {
  CommandInterceptor$5.call(this, eventBus);
  var dragging = injector.get("dragging", false);
  function fixConnection(connection) {
    var source = connection.source, target = connection.target, parent2 = connection.parent;
    if (!parent2) {
      return;
    }
    var replacementType, remove2;
    if (is$O(connection, "bpmn:SequenceFlow")) {
      if (!bpmnRules.canConnectSequenceFlow(source, target)) {
        remove2 = true;
      }
      if (bpmnRules.canConnectMessageFlow(source, target)) {
        replacementType = "bpmn:MessageFlow";
      }
    }
    if (is$O(connection, "bpmn:MessageFlow")) {
      if (!bpmnRules.canConnectMessageFlow(source, target)) {
        remove2 = true;
      }
      if (bpmnRules.canConnectSequenceFlow(source, target)) {
        replacementType = "bpmn:SequenceFlow";
      }
    }
    if (is$O(connection, "bpmn:Association") && !bpmnRules.canConnectAssociation(source, target)) {
      remove2 = true;
    }
    if (remove2) {
      modeling.removeConnection(connection);
    }
    if (replacementType) {
      modeling.connect(source, target, {
        type: replacementType,
        waypoints: connection.waypoints.slice()
      });
    }
  }
  function replaceReconnectedConnection(event) {
    var context = event.context, connection = context.connection, source = context.newSource || connection.source, target = context.newTarget || connection.target, allowed, replacement;
    allowed = bpmnRules.canConnect(source, target);
    if (!allowed || allowed.type === connection.type) {
      return;
    }
    replacement = modeling.connect(source, target, {
      type: allowed.type,
      waypoints: connection.waypoints.slice()
    });
    modeling.removeConnection(connection);
    context.connection = replacement;
    if (dragging) {
      cleanDraggingSelection(connection, replacement);
    }
  }
  function cleanDraggingSelection(oldConnection, newConnection) {
    var context = dragging.context(), previousSelection = context && context.payload.previousSelection, index2;
    if (!previousSelection || !previousSelection.length) {
      return;
    }
    index2 = previousSelection.indexOf(oldConnection);
    if (index2 === -1) {
      return;
    }
    previousSelection.splice(index2, 1, newConnection);
  }
  this.postExecuted("elements.move", function(context) {
    var closure = context.closure, allConnections = closure.allConnections;
    forEach$q(allConnections, fixConnection);
  }, true);
  this.preExecute("connection.reconnect", replaceReconnectedConnection);
  this.postExecuted("element.updateProperties", function(event) {
    var context = event.context, properties2 = context.properties, element = context.element, businessObject = element.businessObject, connection;
    if (properties2.default) {
      connection = find$e(element.outgoing, matchPattern$1({ id: element.businessObject.default.id }));
      if (connection) {
        modeling.updateProperties(connection, { conditionExpression: void 0 });
      }
    }
    if (properties2.conditionExpression && businessObject.sourceRef.default === businessObject) {
      modeling.updateProperties(element.source, { default: void 0 });
    }
  });
}
inherits$6(ReplaceConnectionBehavior, CommandInterceptor$5);
ReplaceConnectionBehavior.$inject = [
  "eventBus",
  "modeling",
  "bpmnRules",
  "injector"
];
function RemoveParticipantBehavior(eventBus, modeling) {
  CommandInterceptor$5.call(this, eventBus);
  this.preExecute("shape.delete", function(context) {
    var shape = context.shape, parent2 = shape.parent;
    if (is$O(shape, "bpmn:Participant")) {
      context.collaborationRoot = parent2;
    }
  }, true);
  this.postExecute("shape.delete", function(context) {
    var collaborationRoot = context.collaborationRoot;
    if (collaborationRoot && !collaborationRoot.businessObject.participants.length) {
      modeling.makeProcess();
    }
  }, true);
}
RemoveParticipantBehavior.$inject = ["eventBus", "modeling"];
inherits$6(RemoveParticipantBehavior, CommandInterceptor$5);
function ReplaceElementBehaviour(bpmnReplace, bpmnRules, elementRegistry, injector, modeling, selection) {
  injector.invoke(CommandInterceptor$5, this);
  this._bpmnReplace = bpmnReplace;
  this._elementRegistry = elementRegistry;
  this._selection = selection;
  this.postExecuted(["elements.create"], 500, function(event) {
    var context = event.context, target = context.parent, elements = context.elements;
    var canReplace2 = bpmnRules.canReplace(elements, target);
    if (canReplace2) {
      this.replaceElements(elements, canReplace2.replacements);
    }
  }, this);
  this.postExecuted(["elements.move"], 500, function(event) {
    var context = event.context, target = context.newParent, newHost = context.newHost, elements = [];
    forEach$q(context.closure.topLevel, function(topLevelElements) {
      if (isEventSubProcess$1(topLevelElements)) {
        elements = elements.concat(topLevelElements.children);
      } else {
        elements = elements.concat(topLevelElements);
      }
    });
    if (elements.length === 1 && newHost) {
      target = newHost;
    }
    var canReplace2 = bpmnRules.canReplace(elements, target);
    if (canReplace2) {
      this.replaceElements(elements, canReplace2.replacements, newHost);
    }
  }, this);
  this.postExecute(["shape.replace"], 1500, function(e) {
    var context = e.context, oldShape = context.oldShape, newShape = context.newShape, attachers = oldShape.attachers, canReplace2;
    if (attachers && attachers.length) {
      canReplace2 = bpmnRules.canReplace(attachers, newShape);
      this.replaceElements(attachers, canReplace2.replacements);
    }
  }, this);
  this.postExecuted(["shape.replace"], 1500, function(e) {
    var context = e.context, oldShape = context.oldShape, newShape = context.newShape;
    modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);
    modeling.updateProperties(newShape, { id: oldShape.id });
  });
}
inherits$6(ReplaceElementBehaviour, CommandInterceptor$5);
ReplaceElementBehaviour.prototype.replaceElements = function(elements, newElements) {
  var elementRegistry = this._elementRegistry, bpmnReplace = this._bpmnReplace, selection = this._selection;
  forEach$q(newElements, function(replacement) {
    var newElement = {
      type: replacement.newElementType
    };
    var oldElement = elementRegistry.get(replacement.oldElementId);
    var idx = elements.indexOf(oldElement);
    elements[idx] = bpmnReplace.replaceElement(oldElement, newElement, { select: false });
  });
  if (newElements) {
    selection.select(elements);
  }
};
ReplaceElementBehaviour.$inject = [
  "bpmnReplace",
  "bpmnRules",
  "elementRegistry",
  "injector",
  "modeling",
  "selection"
];
var HIGH_PRIORITY$8 = 1500;
var LANE_MIN_DIMENSIONS = { width: 300, height: 60 };
var PARTICIPANT_MIN_DIMENSIONS = { width: 300, height: 150 };
var SUB_PROCESS_MIN_DIMENSIONS = { width: 140, height: 120 };
var TEXT_ANNOTATION_MIN_DIMENSIONS = { width: 50, height: 30 };
function ResizeBehavior(eventBus) {
  eventBus.on("resize.start", HIGH_PRIORITY$8, function(event) {
    var context = event.context, shape = context.shape, direction = context.direction, balanced = context.balanced;
    if (is$O(shape, "bpmn:Lane") || is$O(shape, "bpmn:Participant")) {
      context.resizeConstraints = getParticipantResizeConstraints(shape, direction, balanced);
    }
    if (is$O(shape, "bpmn:Participant")) {
      context.minDimensions = PARTICIPANT_MIN_DIMENSIONS;
    }
    if (is$O(shape, "bpmn:SubProcess") && isExpanded(shape)) {
      context.minDimensions = SUB_PROCESS_MIN_DIMENSIONS;
    }
    if (is$O(shape, "bpmn:TextAnnotation")) {
      context.minDimensions = TEXT_ANNOTATION_MIN_DIMENSIONS;
    }
  });
}
ResizeBehavior.$inject = ["eventBus"];
var abs$2 = Math.abs, min = Math.min, max$2 = Math.max;
function addToTrbl(trbl, attr2, value, choice) {
  var current = trbl[attr2];
  trbl[attr2] = current === void 0 ? value : choice(value, current);
}
function addMin(trbl, attr2, value) {
  return addToTrbl(trbl, attr2, value, min);
}
function addMax(trbl, attr2, value) {
  return addToTrbl(trbl, attr2, value, max$2);
}
var LANE_RIGHT_PADDING = 20, LANE_LEFT_PADDING = 50, LANE_TOP_PADDING = 20, LANE_BOTTOM_PADDING = 20;
function getParticipantResizeConstraints(laneShape, resizeDirection, balanced) {
  var lanesRoot = getLanesRoot(laneShape);
  var isFirst = true, isLast = true;
  var allLanes = collectLanes(lanesRoot, [lanesRoot]);
  var laneTrbl = asTRBL(laneShape);
  var maxTrbl = {}, minTrbl = {};
  if (/e/.test(resizeDirection)) {
    minTrbl.right = laneTrbl.left + LANE_MIN_DIMENSIONS.width;
  } else if (/w/.test(resizeDirection)) {
    minTrbl.left = laneTrbl.right - LANE_MIN_DIMENSIONS.width;
  }
  allLanes.forEach(function(other) {
    var otherTrbl = asTRBL(other);
    if (/n/.test(resizeDirection)) {
      if (otherTrbl.top < laneTrbl.top - 10) {
        isFirst = false;
      }
      if (balanced && abs$2(laneTrbl.top - otherTrbl.bottom) < 10) {
        addMax(maxTrbl, "top", otherTrbl.top + LANE_MIN_DIMENSIONS.height);
      }
      if (abs$2(laneTrbl.top - otherTrbl.top) < 5) {
        addMin(minTrbl, "top", otherTrbl.bottom - LANE_MIN_DIMENSIONS.height);
      }
    }
    if (/s/.test(resizeDirection)) {
      if (otherTrbl.bottom > laneTrbl.bottom + 10) {
        isLast = false;
      }
      if (balanced && abs$2(laneTrbl.bottom - otherTrbl.top) < 10) {
        addMin(maxTrbl, "bottom", otherTrbl.bottom - LANE_MIN_DIMENSIONS.height);
      }
      if (abs$2(laneTrbl.bottom - otherTrbl.bottom) < 5) {
        addMax(minTrbl, "bottom", otherTrbl.top + LANE_MIN_DIMENSIONS.height);
      }
    }
  });
  var flowElements = lanesRoot.children.filter(function(s) {
    return !s.hidden && !s.waypoints && (is$O(s, "bpmn:FlowElement") || is$O(s, "bpmn:Artifact"));
  });
  flowElements.forEach(function(flowElement) {
    var flowElementTrbl = asTRBL(flowElement);
    if (isFirst && /n/.test(resizeDirection)) {
      addMin(minTrbl, "top", flowElementTrbl.top - LANE_TOP_PADDING);
    }
    if (/e/.test(resizeDirection)) {
      addMax(minTrbl, "right", flowElementTrbl.right + LANE_RIGHT_PADDING);
    }
    if (isLast && /s/.test(resizeDirection)) {
      addMax(minTrbl, "bottom", flowElementTrbl.bottom + LANE_BOTTOM_PADDING);
    }
    if (/w/.test(resizeDirection)) {
      addMin(minTrbl, "left", flowElementTrbl.left - LANE_LEFT_PADDING);
    }
  });
  return {
    min: minTrbl,
    max: maxTrbl
  };
}
var SLIGHTLY_HIGHER_PRIORITY = 1001;
function ResizeLaneBehavior(eventBus, modeling) {
  eventBus.on("resize.start", SLIGHTLY_HIGHER_PRIORITY + 500, function(event) {
    var context = event.context, shape = context.shape;
    if (is$O(shape, "bpmn:Lane") || is$O(shape, "bpmn:Participant")) {
      context.balanced = !hasPrimaryModifier(event);
    }
  });
  eventBus.on("resize.end", SLIGHTLY_HIGHER_PRIORITY, function(event) {
    var context = event.context, shape = context.shape, canExecute = context.canExecute, newBounds = context.newBounds;
    if (is$O(shape, "bpmn:Lane") || is$O(shape, "bpmn:Participant")) {
      if (canExecute) {
        newBounds = roundBounds(newBounds);
        modeling.resizeLane(shape, newBounds, context.balanced);
      }
      return false;
    }
  });
}
ResizeLaneBehavior.$inject = [
  "eventBus",
  "modeling"
];
function RemoveElementBehavior(eventBus, bpmnRules, modeling) {
  CommandInterceptor$5.call(this, eventBus);
  this.preExecute("shape.delete", function(e) {
    var shape = e.context.shape;
    if (shape.incoming.length !== 1 || shape.outgoing.length !== 1) {
      return;
    }
    var inConnection = shape.incoming[0], outConnection = shape.outgoing[0];
    if (!is$O(inConnection, "bpmn:SequenceFlow") || !is$O(outConnection, "bpmn:SequenceFlow")) {
      return;
    }
    if (bpmnRules.canConnect(inConnection.source, outConnection.target, inConnection)) {
      var newWaypoints = getNewWaypoints(inConnection.waypoints, outConnection.waypoints);
      modeling.reconnectEnd(inConnection, outConnection.target, newWaypoints);
    }
  });
}
inherits$6(RemoveElementBehavior, CommandInterceptor$5);
RemoveElementBehavior.$inject = [
  "eventBus",
  "bpmnRules",
  "modeling"
];
function getDocking$1(point) {
  return point.original || point;
}
function getNewWaypoints(inWaypoints, outWaypoints) {
  var intersection2 = lineIntersect(getDocking$1(inWaypoints[inWaypoints.length - 2]), getDocking$1(inWaypoints[inWaypoints.length - 1]), getDocking$1(outWaypoints[1]), getDocking$1(outWaypoints[0]));
  if (intersection2) {
    return [].concat(inWaypoints.slice(0, inWaypoints.length - 1), [intersection2], outWaypoints.slice(1));
  } else {
    return [
      getDocking$1(inWaypoints[0]),
      getDocking$1(outWaypoints[outWaypoints.length - 1])
    ];
  }
}
var max$1 = Math.max;
function SpaceToolBehavior(eventBus) {
  eventBus.on("spaceTool.getMinDimensions", function(context) {
    var shapes = context.shapes, axis = context.axis, start = context.start, minDimensions = {};
    forEach$q(shapes, function(shape) {
      var id2 = shape.id;
      if (is$O(shape, "bpmn:Participant")) {
        if (isHorizontal$1(axis)) {
          minDimensions[id2] = PARTICIPANT_MIN_DIMENSIONS;
        } else {
          minDimensions[id2] = {
            width: PARTICIPANT_MIN_DIMENSIONS.width,
            height: getParticipantMinHeight(shape, start)
          };
        }
      }
      if (is$O(shape, "bpmn:SubProcess") && isExpanded(shape)) {
        minDimensions[id2] = SUB_PROCESS_MIN_DIMENSIONS;
      }
      if (is$O(shape, "bpmn:TextAnnotation")) {
        minDimensions[id2] = TEXT_ANNOTATION_MIN_DIMENSIONS;
      }
    });
    return minDimensions;
  });
}
SpaceToolBehavior.$inject = ["eventBus"];
function isHorizontal$1(axis) {
  return axis === "x";
}
function getParticipantMinHeight(participant, start) {
  var lanesMinHeight;
  if (!hasChildLanes(participant)) {
    return PARTICIPANT_MIN_DIMENSIONS.height;
  }
  lanesMinHeight = getLanesMinHeight(participant, start);
  return max$1(PARTICIPANT_MIN_DIMENSIONS.height, lanesMinHeight);
}
function hasChildLanes(element) {
  return !!getChildLanes(element).length;
}
function getLanesMinHeight(participant, resizeStart) {
  var lanes = getChildLanes(participant), resizedLane;
  resizedLane = findResizedLane(lanes, resizeStart);
  return participant.height - resizedLane.height + LANE_MIN_DIMENSIONS.height;
}
function findResizedLane(lanes, resizeStart) {
  var i, lane, childLanes;
  for (i = 0; i < lanes.length; i++) {
    lane = lanes[i];
    if (resizeStart >= lane.y && resizeStart <= lane.y + lane.height) {
      childLanes = getChildLanes(lane);
      if (childLanes.length) {
        return findResizedLane(childLanes, resizeStart);
      }
      return lane;
    }
  }
}
function SubProcessStartEventBehavior(injector, modeling) {
  injector.invoke(CommandInterceptor$5, this);
  this.postExecuted("shape.replace", function(event) {
    var oldShape = event.context.oldShape, newShape = event.context.newShape;
    if (!is$O(newShape, "bpmn:SubProcess") || !is$O(oldShape, "bpmn:Task") || !isExpanded(newShape)) {
      return;
    }
    var position = getStartEventPosition(newShape);
    modeling.createShape({ type: "bpmn:StartEvent" }, position, newShape);
  });
}
SubProcessStartEventBehavior.$inject = [
  "injector",
  "modeling"
];
inherits$6(SubProcessStartEventBehavior, CommandInterceptor$5);
function getStartEventPosition(shape) {
  return {
    x: shape.x + shape.width / 6,
    y: shape.y + shape.height / 2
  };
}
var LOW_PRIORITY$9 = 500;
function ToggleElementCollapseBehaviour(eventBus, elementFactory, modeling, resize) {
  CommandInterceptor$5.call(this, eventBus);
  function hideEmptyLabels(children) {
    if (children.length) {
      children.forEach(function(child) {
        if (child.type === "label" && !child.businessObject.name) {
          child.hidden = true;
        }
      });
    }
  }
  function expandedBounds(shape, defaultSize) {
    var children = shape.children, newBounds = defaultSize, visibleElements, visibleBBox;
    visibleElements = filterVisible(children).concat([shape]);
    visibleBBox = computeChildrenBBox(visibleElements);
    if (visibleBBox) {
      newBounds.width = Math.max(visibleBBox.width, newBounds.width);
      newBounds.height = Math.max(visibleBBox.height, newBounds.height);
      newBounds.x = visibleBBox.x + (visibleBBox.width - newBounds.width) / 2;
      newBounds.y = visibleBBox.y + (visibleBBox.height - newBounds.height) / 2;
    } else {
      newBounds.x = shape.x + (shape.width - newBounds.width) / 2;
      newBounds.y = shape.y + (shape.height - newBounds.height) / 2;
    }
    return newBounds;
  }
  function collapsedBounds(shape, defaultSize) {
    return {
      x: shape.x + (shape.width - defaultSize.width) / 2,
      y: shape.y + (shape.height - defaultSize.height) / 2,
      width: defaultSize.width,
      height: defaultSize.height
    };
  }
  this.executed(["shape.toggleCollapse"], LOW_PRIORITY$9, function(e) {
    var context = e.context, shape = context.shape;
    if (!is$O(shape, "bpmn:SubProcess")) {
      return;
    }
    if (!shape.collapsed) {
      hideEmptyLabels(shape.children);
      getBusinessObject$V(shape).di.isExpanded = true;
    } else {
      getBusinessObject$V(shape).di.isExpanded = false;
    }
  });
  this.reverted(["shape.toggleCollapse"], LOW_PRIORITY$9, function(e) {
    var context = e.context;
    var shape = context.shape;
    if (!shape.collapsed) {
      getBusinessObject$V(shape).di.isExpanded = true;
    } else {
      getBusinessObject$V(shape).di.isExpanded = false;
    }
  });
  this.postExecuted(["shape.toggleCollapse"], LOW_PRIORITY$9, function(e) {
    var shape = e.context.shape, defaultSize = elementFactory._getDefaultSize(shape), newBounds;
    if (shape.collapsed) {
      newBounds = collapsedBounds(shape, defaultSize);
    } else {
      newBounds = expandedBounds(shape, defaultSize);
    }
    modeling.resizeShape(shape, newBounds, null, {
      autoResize: shape.collapsed ? false : "nwse"
    });
  });
}
inherits$6(ToggleElementCollapseBehaviour, CommandInterceptor$5);
ToggleElementCollapseBehaviour.$inject = [
  "eventBus",
  "elementFactory",
  "modeling"
];
function filterVisible(elements) {
  return elements.filter(function(e) {
    return !e.hidden;
  });
}
function UnclaimIdBehavior(canvas, injector, moddle, modeling) {
  injector.invoke(CommandInterceptor$5, this);
  this.preExecute("shape.delete", function(event) {
    var context = event.context, shape = context.shape, shapeBo = shape.businessObject;
    if (isLabel$6(shape)) {
      return;
    }
    if (is$O(shape, "bpmn:Participant") && isExpanded(shape)) {
      moddle.ids.unclaim(shapeBo.processRef.id);
    }
    modeling.unclaimId(shapeBo.id, shapeBo);
  });
  this.preExecute("connection.delete", function(event) {
    var context = event.context, connection = context.connection, connectionBo = connection.businessObject;
    modeling.unclaimId(connectionBo.id, connectionBo);
  });
  this.preExecute("canvas.updateRoot", function() {
    var rootElement = canvas.getRootElement(), rootElementBo = rootElement.businessObject;
    if (is$O(rootElement, "bpmn:Collaboration")) {
      moddle.ids.unclaim(rootElementBo.id);
    }
  });
}
inherits$6(UnclaimIdBehavior, CommandInterceptor$5);
UnclaimIdBehavior.$inject = ["canvas", "injector", "moddle", "modeling"];
var LOW_PRIORITY$8 = 500, HIGH_PRIORITY$7 = 5e3;
function UpdateFlowNodeRefsBehavior(eventBus, modeling, translate2) {
  CommandInterceptor$5.call(this, eventBus);
  var context;
  function initContext() {
    context = context || new UpdateContext();
    context.enter();
    return context;
  }
  function getContext() {
    if (!context) {
      throw new Error(translate2("out of bounds release"));
    }
    return context;
  }
  function releaseContext() {
    if (!context) {
      throw new Error(translate2("out of bounds release"));
    }
    var triggerUpdate = context.leave();
    if (triggerUpdate) {
      modeling.updateLaneRefs(context.flowNodes, context.lanes);
      context = null;
    }
    return triggerUpdate;
  }
  var laneRefUpdateEvents = [
    "spaceTool",
    "lane.add",
    "lane.resize",
    "lane.split",
    "elements.create",
    "elements.delete",
    "elements.move",
    "shape.create",
    "shape.delete",
    "shape.move",
    "shape.resize"
  ];
  this.preExecute(laneRefUpdateEvents, HIGH_PRIORITY$7, function(event) {
    initContext();
  });
  this.postExecuted(laneRefUpdateEvents, LOW_PRIORITY$8, function(event) {
    releaseContext();
  });
  this.preExecute([
    "shape.create",
    "shape.move",
    "shape.delete",
    "shape.resize"
  ], function(event) {
    var context2 = event.context, shape = context2.shape;
    var updateContext = getContext();
    if (shape.labelTarget) {
      return;
    }
    if (is$O(shape, "bpmn:Lane")) {
      updateContext.addLane(shape);
    }
    if (is$O(shape, "bpmn:FlowNode")) {
      updateContext.addFlowNode(shape);
    }
  });
}
UpdateFlowNodeRefsBehavior.$inject = [
  "eventBus",
  "modeling",
  "translate"
];
inherits$6(UpdateFlowNodeRefsBehavior, CommandInterceptor$5);
function UpdateContext() {
  this.flowNodes = [];
  this.lanes = [];
  this.counter = 0;
  this.addLane = function(lane) {
    this.lanes.push(lane);
  };
  this.addFlowNode = function(flowNode) {
    this.flowNodes.push(flowNode);
  };
  this.enter = function() {
    this.counter++;
  };
  this.leave = function() {
    this.counter--;
    return !this.counter;
  };
}
function DeleteSequenceFlowBehavior(eventBus, modeling) {
  CommandInterceptor$5.call(this, eventBus);
  this.preExecute("connection.delete", function(event) {
    var context = event.context, connection = context.connection, source = connection.source;
    if (isDefaultFlow(connection, source)) {
      modeling.updateProperties(source, {
        "default": null
      });
    }
  });
}
inherits$6(DeleteSequenceFlowBehavior, CommandInterceptor$5);
DeleteSequenceFlowBehavior.$inject = [
  "eventBus",
  "modeling"
];
function isDefaultFlow(connection, source) {
  if (!is$O(connection, "bpmn:SequenceFlow")) {
    return false;
  }
  var sourceBo = getBusinessObject$V(source), sequenceFlow = getBusinessObject$V(connection);
  return sourceBo.get("default") === sequenceFlow;
}
var BehaviorModule = {
  __init__: [
    "adaptiveLabelPositioningBehavior",
    "appendBehavior",
    "associationBehavior",
    "attachEventBehavior",
    "boundaryEventBehavior",
    "rootElementReferenceBehavior",
    "createBehavior",
    "fixHoverBehavior",
    "createDataObjectBehavior",
    "createParticipantBehavior",
    "dataStoreBehavior",
    "dataInputAssociationBehavior",
    "deleteLaneBehavior",
    "detachEventBehavior",
    "dropOnFlowBehavior",
    "eventBasedGatewayBehavior",
    "groupBehavior",
    "importDockingFix",
    "isHorizontalFix",
    "labelBehavior",
    "messageFlowBehavior",
    "modelingFeedback",
    "removeElementBehavior",
    "removeParticipantBehavior",
    "replaceConnectionBehavior",
    "replaceElementBehaviour",
    "resizeBehavior",
    "resizeLaneBehavior",
    "toggleElementCollapseBehaviour",
    "spaceToolBehavior",
    "subProcessStartEventBehavior",
    "unclaimIdBehavior",
    "unsetDefaultFlowBehavior",
    "updateFlowNodeRefsBehavior"
  ],
  adaptiveLabelPositioningBehavior: ["type", AdaptiveLabelPositioningBehavior],
  appendBehavior: ["type", AppendBehavior],
  associationBehavior: ["type", AssociationBehavior],
  attachEventBehavior: ["type", AttachEventBehavior],
  boundaryEventBehavior: ["type", BoundaryEventBehavior],
  rootElementReferenceBehavior: ["type", RootElementReferenceBehavior],
  createBehavior: ["type", CreateBehavior],
  fixHoverBehavior: ["type", FixHoverBehavior],
  createDataObjectBehavior: ["type", CreateDataObjectBehavior],
  createParticipantBehavior: ["type", CreateParticipantBehavior],
  dataInputAssociationBehavior: ["type", DataInputAssociationBehavior],
  dataStoreBehavior: ["type", DataStoreBehavior],
  deleteLaneBehavior: ["type", DeleteLaneBehavior],
  detachEventBehavior: ["type", DetachEventBehavior],
  dropOnFlowBehavior: ["type", DropOnFlowBehavior],
  eventBasedGatewayBehavior: ["type", EventBasedGatewayBehavior],
  groupBehavior: ["type", GroupBehavior],
  importDockingFix: ["type", ImportDockingFix],
  isHorizontalFix: ["type", IsHorizontalFix],
  labelBehavior: ["type", LabelBehavior],
  messageFlowBehavior: ["type", MessageFlowBehavior],
  modelingFeedback: ["type", ModelingFeedback],
  replaceConnectionBehavior: ["type", ReplaceConnectionBehavior],
  removeParticipantBehavior: ["type", RemoveParticipantBehavior],
  replaceElementBehaviour: ["type", ReplaceElementBehaviour],
  resizeBehavior: ["type", ResizeBehavior],
  resizeLaneBehavior: ["type", ResizeLaneBehavior],
  removeElementBehavior: ["type", RemoveElementBehavior],
  toggleElementCollapseBehaviour: ["type", ToggleElementCollapseBehaviour],
  spaceToolBehavior: ["type", SpaceToolBehavior],
  subProcessStartEventBehavior: ["type", SubProcessStartEventBehavior],
  unclaimIdBehavior: ["type", UnclaimIdBehavior],
  updateFlowNodeRefsBehavior: ["type", UpdateFlowNodeRefsBehavior],
  unsetDefaultFlowBehavior: ["type", DeleteSequenceFlowBehavior]
};
function getBoundaryAttachment(position, targetBounds) {
  var orientation = getOrientation(position, targetBounds, -15);
  if (orientation !== "intersect") {
    return orientation;
  } else {
    return null;
  }
}
function BpmnRules(eventBus) {
  RuleProvider.call(this, eventBus);
}
inherits$6(BpmnRules, RuleProvider);
BpmnRules.$inject = ["eventBus"];
BpmnRules.prototype.init = function() {
  this.addRule("connection.start", function(context) {
    var source = context.source;
    return canStartConnection(source);
  });
  this.addRule("connection.create", function(context) {
    var source = context.source, target = context.target, hints = context.hints || {}, targetParent = hints.targetParent, targetAttach = hints.targetAttach;
    if (targetAttach) {
      return false;
    }
    if (targetParent) {
      target.parent = targetParent;
    }
    try {
      return canConnect(source, target);
    } finally {
      if (targetParent) {
        target.parent = null;
      }
    }
  });
  this.addRule("connection.reconnect", function(context) {
    var connection = context.connection, source = context.source, target = context.target;
    return canConnect(source, target, connection);
  });
  this.addRule("connection.updateWaypoints", function(context) {
    return {
      type: context.connection.type
    };
  });
  this.addRule("shape.resize", function(context) {
    var shape = context.shape, newBounds = context.newBounds;
    return canResize(shape, newBounds);
  });
  this.addRule("elements.create", function(context) {
    var elements = context.elements, position = context.position, target = context.target;
    if (isConnection$8(target) && !canInsert(elements, target)) {
      return false;
    }
    return every(elements, function(element) {
      if (isConnection$8(element)) {
        return canConnect(element.source, element.target, element);
      }
      if (element.host) {
        return canAttach(element, element.host, null, position);
      }
      return canCreate(element, target, null);
    });
  });
  this.addRule("elements.move", function(context) {
    var target = context.target, shapes = context.shapes, position = context.position;
    return canAttach(shapes, target, null, position) || canReplace(shapes, target, position) || canMove(shapes, target) || canInsert(shapes, target);
  });
  this.addRule("shape.create", function(context) {
    return canCreate(context.shape, context.target, context.source, context.position);
  });
  this.addRule("shape.attach", function(context) {
    return canAttach(context.shape, context.target, null, context.position);
  });
  this.addRule("element.copy", function(context) {
    var element = context.element, elements = context.elements;
    return canCopy(elements, element);
  });
};
BpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;
BpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;
BpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;
BpmnRules.prototype.canConnectAssociation = canConnectAssociation;
BpmnRules.prototype.canMove = canMove;
BpmnRules.prototype.canAttach = canAttach;
BpmnRules.prototype.canReplace = canReplace;
BpmnRules.prototype.canDrop = canDrop;
BpmnRules.prototype.canInsert = canInsert;
BpmnRules.prototype.canCreate = canCreate;
BpmnRules.prototype.canConnect = canConnect;
BpmnRules.prototype.canResize = canResize;
BpmnRules.prototype.canCopy = canCopy;
function canStartConnection(element) {
  if (nonExistingOrLabel(element)) {
    return null;
  }
  return isAny$b(element, [
    "bpmn:FlowNode",
    "bpmn:InteractionNode",
    "bpmn:DataObjectReference",
    "bpmn:DataStoreReference",
    "bpmn:Group",
    "bpmn:TextAnnotation"
  ]);
}
function nonExistingOrLabel(element) {
  return !element || isLabel$6(element);
}
function isSame$1(a, b) {
  return a === b;
}
function getOrganizationalParent(element) {
  do {
    if (is$O(element, "bpmn:Process")) {
      return getBusinessObject$V(element);
    }
    if (is$O(element, "bpmn:Participant")) {
      return getBusinessObject$V(element).processRef || getBusinessObject$V(element);
    }
  } while (element = element.parent);
}
function isTextAnnotation(element) {
  return is$O(element, "bpmn:TextAnnotation");
}
function isGroup(element) {
  return is$O(element, "bpmn:Group") && !element.labelTarget;
}
function isCompensationBoundary(element) {
  return is$O(element, "bpmn:BoundaryEvent") && hasEventDefinition(element, "bpmn:CompensateEventDefinition");
}
function isForCompensation(e) {
  return getBusinessObject$V(e).isForCompensation;
}
function isSameOrganization(a, b) {
  var parentA = getOrganizationalParent(a), parentB = getOrganizationalParent(b);
  return parentA === parentB;
}
function isMessageFlowSource(element) {
  return is$O(element, "bpmn:InteractionNode") && !is$O(element, "bpmn:BoundaryEvent") && (!is$O(element, "bpmn:Event") || is$O(element, "bpmn:ThrowEvent") && hasEventDefinitionOrNone(element, "bpmn:MessageEventDefinition"));
}
function isMessageFlowTarget(element) {
  return is$O(element, "bpmn:InteractionNode") && !isForCompensation(element) && (!is$O(element, "bpmn:Event") || is$O(element, "bpmn:CatchEvent") && hasEventDefinitionOrNone(element, "bpmn:MessageEventDefinition")) && !(is$O(element, "bpmn:BoundaryEvent") && !hasEventDefinition(element, "bpmn:MessageEventDefinition"));
}
function getScopeParent(element) {
  var parent2 = element;
  while (parent2 = parent2.parent) {
    if (is$O(parent2, "bpmn:FlowElementsContainer")) {
      return getBusinessObject$V(parent2);
    }
    if (is$O(parent2, "bpmn:Participant")) {
      return getBusinessObject$V(parent2).processRef;
    }
  }
  return null;
}
function isSameScope(a, b) {
  var scopeParentA = getScopeParent(a), scopeParentB = getScopeParent(b);
  return scopeParentA === scopeParentB;
}
function hasEventDefinition(element, eventDefinition) {
  var bo = getBusinessObject$V(element);
  return !!find$e(bo.eventDefinitions || [], function(definition) {
    return is$O(definition, eventDefinition);
  });
}
function hasEventDefinitionOrNone(element, eventDefinition) {
  var bo = getBusinessObject$V(element);
  return (bo.eventDefinitions || []).every(function(definition) {
    return is$O(definition, eventDefinition);
  });
}
function isSequenceFlowSource(element) {
  return is$O(element, "bpmn:FlowNode") && !is$O(element, "bpmn:EndEvent") && !isEventSubProcess$1(element) && !(is$O(element, "bpmn:IntermediateThrowEvent") && hasEventDefinition(element, "bpmn:LinkEventDefinition")) && !isCompensationBoundary(element) && !isForCompensation(element);
}
function isSequenceFlowTarget(element) {
  return is$O(element, "bpmn:FlowNode") && !is$O(element, "bpmn:StartEvent") && !is$O(element, "bpmn:BoundaryEvent") && !isEventSubProcess$1(element) && !(is$O(element, "bpmn:IntermediateCatchEvent") && hasEventDefinition(element, "bpmn:LinkEventDefinition")) && !isForCompensation(element);
}
function isEventBasedTarget(element) {
  return is$O(element, "bpmn:ReceiveTask") || is$O(element, "bpmn:IntermediateCatchEvent") && (hasEventDefinition(element, "bpmn:MessageEventDefinition") || hasEventDefinition(element, "bpmn:TimerEventDefinition") || hasEventDefinition(element, "bpmn:ConditionalEventDefinition") || hasEventDefinition(element, "bpmn:SignalEventDefinition"));
}
function isConnection$8(element) {
  return element.waypoints;
}
function getParents$1(element) {
  var parents = [];
  while (element) {
    element = element.parent;
    if (element) {
      parents.push(element);
    }
  }
  return parents;
}
function isParent(possibleParent, element) {
  var allParents = getParents$1(element);
  return allParents.indexOf(possibleParent) !== -1;
}
function canConnect(source, target, connection) {
  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {
    return null;
  }
  if (!is$O(connection, "bpmn:DataAssociation")) {
    if (canConnectMessageFlow(source, target)) {
      return { type: "bpmn:MessageFlow" };
    }
    if (canConnectSequenceFlow(source, target)) {
      return { type: "bpmn:SequenceFlow" };
    }
  }
  var connectDataAssociation = canConnectDataAssociation(source, target);
  if (connectDataAssociation) {
    return connectDataAssociation;
  }
  if (isCompensationBoundary(source) && isForCompensation(target)) {
    return {
      type: "bpmn:Association",
      associationDirection: "One"
    };
  }
  if (canConnectAssociation(source, target)) {
    return {
      type: "bpmn:Association"
    };
  }
  return false;
}
function canDrop(element, target, position) {
  if (isLabel$6(element) || isGroup(element)) {
    return true;
  }
  if (is$O(target, "bpmn:Participant") && !isExpanded(target)) {
    return false;
  }
  if (is$O(element, "bpmn:Participant")) {
    return is$O(target, "bpmn:Process") || is$O(target, "bpmn:Collaboration");
  }
  if (isAny$b(element, ["bpmn:DataInput", "bpmn:DataOutput"])) {
    if (element.parent) {
      return target === element.parent;
    }
  }
  if (is$O(element, "bpmn:Lane")) {
    return is$O(target, "bpmn:Participant") || is$O(target, "bpmn:Lane");
  }
  if (is$O(element, "bpmn:BoundaryEvent") && !isDroppableBoundaryEvent(element)) {
    return false;
  }
  if (is$O(element, "bpmn:FlowElement") && !is$O(element, "bpmn:DataStoreReference")) {
    if (is$O(target, "bpmn:FlowElementsContainer")) {
      return isExpanded(target);
    }
    return isAny$b(target, ["bpmn:Participant", "bpmn:Lane"]);
  }
  if (is$O(element, "bpmn:DataStoreReference") && is$O(target, "bpmn:Collaboration")) {
    return some$1(getBusinessObject$V(target).get("participants"), function(participant) {
      return !!participant.get("processRef");
    });
  }
  if (isAny$b(element, ["bpmn:Artifact", "bpmn:DataAssociation", "bpmn:DataStoreReference"])) {
    return isAny$b(target, [
      "bpmn:Collaboration",
      "bpmn:Lane",
      "bpmn:Participant",
      "bpmn:Process",
      "bpmn:SubProcess"
    ]);
  }
  if (is$O(element, "bpmn:MessageFlow")) {
    return is$O(target, "bpmn:Collaboration") || element.source.parent == target || element.target.parent == target;
  }
  return false;
}
function isDroppableBoundaryEvent(event) {
  return getBusinessObject$V(event).cancelActivity && (hasNoEventDefinition(event) || hasCommonBoundaryIntermediateEventDefinition(event));
}
function isBoundaryEvent(element) {
  return !isLabel$6(element) && is$O(element, "bpmn:BoundaryEvent");
}
function isLane(element) {
  return is$O(element, "bpmn:Lane");
}
function isBoundaryCandidate(element) {
  if (isBoundaryEvent(element)) {
    return true;
  }
  if (is$O(element, "bpmn:IntermediateThrowEvent") && hasNoEventDefinition(element)) {
    return true;
  }
  return is$O(element, "bpmn:IntermediateCatchEvent") && hasCommonBoundaryIntermediateEventDefinition(element);
}
function hasNoEventDefinition(element) {
  var bo = getBusinessObject$V(element);
  return bo && !(bo.eventDefinitions && bo.eventDefinitions.length);
}
function hasCommonBoundaryIntermediateEventDefinition(element) {
  return hasOneOfEventDefinitions(element, [
    "bpmn:MessageEventDefinition",
    "bpmn:TimerEventDefinition",
    "bpmn:SignalEventDefinition",
    "bpmn:ConditionalEventDefinition"
  ]);
}
function hasOneOfEventDefinitions(element, eventDefinitions) {
  return eventDefinitions.some(function(definition) {
    return hasEventDefinition(element, definition);
  });
}
function isReceiveTaskAfterEventBasedGateway(element) {
  return is$O(element, "bpmn:ReceiveTask") && find$e(element.incoming, function(incoming) {
    return is$O(incoming.source, "bpmn:EventBasedGateway");
  });
}
function canAttach(elements, target, source, position) {
  if (!Array.isArray(elements)) {
    elements = [elements];
  }
  if (elements.length !== 1) {
    return false;
  }
  var element = elements[0];
  if (isLabel$6(element)) {
    return false;
  }
  if (!isBoundaryCandidate(element)) {
    return false;
  }
  if (isEventSubProcess$1(target)) {
    return false;
  }
  if (!is$O(target, "bpmn:Activity") || isForCompensation(target)) {
    return false;
  }
  if (position && !getBoundaryAttachment(position, target)) {
    return false;
  }
  if (isReceiveTaskAfterEventBasedGateway(target)) {
    return false;
  }
  return "attach";
}
function canReplace(elements, target, position) {
  if (!target) {
    return false;
  }
  var canExecute = {
    replacements: []
  };
  forEach$q(elements, function(element) {
    if (!isEventSubProcess$1(target)) {
      if (is$O(element, "bpmn:StartEvent") && element.type !== "label" && canDrop(element, target)) {
        if (!isInterrupting(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
        if (hasErrorEventDefinition(element) || hasEscalationEventDefinition(element) || hasCompensateEventDefinition(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
        if (hasOneOfEventDefinitions(element, [
          "bpmn:MessageEventDefinition",
          "bpmn:TimerEventDefinition",
          "bpmn:SignalEventDefinition",
          "bpmn:ConditionalEventDefinition"
        ]) && is$O(target, "bpmn:SubProcess")) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
      }
    }
    if (!is$O(target, "bpmn:Transaction")) {
      if (hasEventDefinition(element, "bpmn:CancelEventDefinition") && element.type !== "label") {
        if (is$O(element, "bpmn:EndEvent") && canDrop(element, target)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:EndEvent"
          });
        }
        if (is$O(element, "bpmn:BoundaryEvent") && canAttach(element, target, null, position)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:BoundaryEvent"
          });
        }
      }
    }
  });
  return canExecute.replacements.length ? canExecute : false;
}
function canMove(elements, target) {
  if (some$1(elements, isLane)) {
    return false;
  }
  if (!target) {
    return true;
  }
  return elements.every(function(element) {
    return canDrop(element, target);
  });
}
function canCreate(shape, target, source, position) {
  if (!target) {
    return false;
  }
  if (isLabel$6(shape) || isGroup(shape)) {
    return true;
  }
  if (isSame$1(source, target)) {
    return false;
  }
  if (source && isParent(source, target)) {
    return false;
  }
  return canDrop(shape, target) || canInsert(shape, target);
}
function canResize(shape, newBounds) {
  if (is$O(shape, "bpmn:SubProcess")) {
    return isExpanded(shape) && (!newBounds || newBounds.width >= 100 && newBounds.height >= 80);
  }
  if (is$O(shape, "bpmn:Lane")) {
    return !newBounds || newBounds.width >= 130 && newBounds.height >= 60;
  }
  if (is$O(shape, "bpmn:Participant")) {
    return !newBounds || newBounds.width >= 250 && newBounds.height >= 50;
  }
  if (isTextAnnotation(shape)) {
    return true;
  }
  if (isGroup(shape)) {
    return true;
  }
  return false;
}
function isOneTextAnnotation(source, target) {
  var sourceTextAnnotation = isTextAnnotation(source), targetTextAnnotation = isTextAnnotation(target);
  return (sourceTextAnnotation || targetTextAnnotation) && sourceTextAnnotation !== targetTextAnnotation;
}
function canConnectAssociation(source, target) {
  if (isConnection$8(source) || isConnection$8(target)) {
    return false;
  }
  if (isCompensationBoundary(source) && isForCompensation(target)) {
    return true;
  }
  if (isParent(target, source) || isParent(source, target)) {
    return false;
  }
  if (isOneTextAnnotation(source, target)) {
    return true;
  }
  return !!canConnectDataAssociation(source, target);
}
function canConnectMessageFlow(source, target) {
  if (getRootElement$2(source) && !getRootElement$2(target)) {
    return false;
  }
  return isMessageFlowSource(source) && isMessageFlowTarget(target) && !isSameOrganization(source, target);
}
function canConnectSequenceFlow(source, target) {
  if (isEventBasedTarget(target) && target.incoming.length > 0 && areOutgoingEventBasedGatewayConnections(target.incoming) && !is$O(source, "bpmn:EventBasedGateway")) {
    return false;
  }
  return isSequenceFlowSource(source) && isSequenceFlowTarget(target) && isSameScope(source, target) && !(is$O(source, "bpmn:EventBasedGateway") && !isEventBasedTarget(target));
}
function canConnectDataAssociation(source, target) {
  if (isAny$b(source, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"]) && isAny$b(target, ["bpmn:Activity", "bpmn:ThrowEvent"])) {
    return { type: "bpmn:DataInputAssociation" };
  }
  if (isAny$b(target, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"]) && isAny$b(source, ["bpmn:Activity", "bpmn:CatchEvent"])) {
    return { type: "bpmn:DataOutputAssociation" };
  }
  return false;
}
function canInsert(shape, flow, position) {
  if (!flow) {
    return false;
  }
  if (Array.isArray(shape)) {
    if (shape.length !== 1) {
      return false;
    }
    shape = shape[0];
  }
  if (flow.source === shape || flow.target === shape) {
    return false;
  }
  return isAny$b(flow, ["bpmn:SequenceFlow", "bpmn:MessageFlow"]) && !isLabel$6(flow) && is$O(shape, "bpmn:FlowNode") && !is$O(shape, "bpmn:BoundaryEvent") && canDrop(shape, flow.parent);
}
function includes$5(elements, element) {
  return elements && element && elements.indexOf(element) !== -1;
}
function canCopy(elements, element) {
  if (isLabel$6(element)) {
    return true;
  }
  if (is$O(element, "bpmn:Lane") && !includes$5(elements, element.parent)) {
    return false;
  }
  return true;
}
function isOutgoingEventBasedGatewayConnection(connection) {
  if (connection && connection.source) {
    return is$O(connection.source, "bpmn:EventBasedGateway");
  }
}
function areOutgoingEventBasedGatewayConnections(connections) {
  connections = connections || [];
  return connections.some(isOutgoingEventBasedGatewayConnection);
}
function getRootElement$2(element) {
  return getParent$1(element, "bpmn:Process") || getParent$1(element, "bpmn:Collaboration");
}
var RulesModule = {
  __depends__: [
    RulesModule$1
  ],
  __init__: ["bpmnRules"],
  bpmnRules: ["type", BpmnRules]
};
var HIGH_PRIORITY$6 = 2e3;
function BpmnDiOrdering(eventBus, canvas) {
  eventBus.on("saveXML.start", HIGH_PRIORITY$6, orderDi);
  function orderDi() {
    var root2 = canvas.getRootElement(), rootDi = getBusinessObject$V(root2).di, elements, diElements;
    elements = selfAndAllChildren([root2], false);
    elements = filter$a(elements, function(element) {
      return element !== root2 && !element.labelTarget;
    });
    diElements = map$7(elements, getDi);
    rootDi.set("planeElement", diElements);
  }
}
BpmnDiOrdering.$inject = ["eventBus", "canvas"];
var DiOrderingModule = {
  __init__: [
    "bpmnDiOrdering"
  ],
  bpmnDiOrdering: ["type", BpmnDiOrdering]
};
function OrderingProvider(eventBus) {
  CommandInterceptor$5.call(this, eventBus);
  var self2 = this;
  this.preExecute(["shape.create", "connection.create"], function(event) {
    var context = event.context, element = context.shape || context.connection, parent2 = context.parent;
    var ordering = self2.getOrdering(element, parent2);
    if (ordering) {
      if (ordering.parent !== void 0) {
        context.parent = ordering.parent;
      }
      context.parentIndex = ordering.index;
    }
  });
  this.preExecute(["shape.move", "connection.move"], function(event) {
    var context = event.context, element = context.shape || context.connection, parent2 = context.newParent || element.parent;
    var ordering = self2.getOrdering(element, parent2);
    if (ordering) {
      if (ordering.parent !== void 0) {
        context.newParent = ordering.parent;
      }
      context.newParentIndex = ordering.index;
    }
  });
}
OrderingProvider.prototype.getOrdering = function(element, newParent) {
  return null;
};
inherits$6(OrderingProvider, CommandInterceptor$5);
function BpmnOrderingProvider(eventBus, canvas, translate2) {
  OrderingProvider.call(this, eventBus);
  var orders = [
    { type: "bpmn:SubProcess", order: { level: 6 } },
    {
      type: "bpmn:SequenceFlow",
      order: {
        level: 3,
        containers: [
          "bpmn:Participant",
          "bpmn:FlowElementsContainer"
        ]
      }
    },
    {
      type: "bpmn:DataAssociation",
      order: {
        level: 9,
        containers: [
          "bpmn:Collaboration",
          "bpmn:Process"
        ]
      }
    },
    {
      type: "bpmn:MessageFlow",
      order: {
        level: 9,
        containers: ["bpmn:Collaboration"]
      }
    },
    {
      type: "bpmn:Association",
      order: {
        level: 6,
        containers: [
          "bpmn:Participant",
          "bpmn:FlowElementsContainer",
          "bpmn:Collaboration"
        ]
      }
    },
    { type: "bpmn:BoundaryEvent", order: { level: 8 } },
    {
      type: "bpmn:Group",
      order: {
        level: 10,
        containers: [
          "bpmn:Collaboration",
          "bpmn:Process"
        ]
      }
    },
    { type: "bpmn:FlowElement", order: { level: 5 } },
    { type: "bpmn:Participant", order: { level: -2 } },
    { type: "bpmn:Lane", order: { level: -1 } }
  ];
  function computeOrder(element) {
    if (element.labelTarget) {
      return { level: 10 };
    }
    var entry = find$e(orders, function(o) {
      return isAny$b(element, [o.type]);
    });
    return entry && entry.order || { level: 1 };
  }
  function getOrder(element) {
    var order = element.order;
    if (!order) {
      element.order = order = computeOrder(element);
    }
    if (!order) {
      throw new Error("no order for <" + element.id + ">");
    }
    return order;
  }
  function findActualParent(element, newParent, containers) {
    var actualParent = newParent;
    while (actualParent) {
      if (isAny$b(actualParent, containers)) {
        break;
      }
      actualParent = actualParent.parent;
    }
    if (!actualParent) {
      throw new Error("no parent for <" + element.id + "> in <" + (newParent && newParent.id) + ">");
    }
    return actualParent;
  }
  this.getOrdering = function(element, newParent) {
    if (element.labelTarget) {
      return {
        parent: canvas.getRootElement(),
        index: -1
      };
    }
    var elementOrder = getOrder(element);
    if (elementOrder.containers) {
      newParent = findActualParent(element, newParent, elementOrder.containers);
    }
    var currentIndex = newParent.children.indexOf(element);
    var insertIndex = findIndex$4(newParent.children, function(child) {
      if (!element.labelTarget && child.labelTarget) {
        return false;
      }
      return elementOrder.level < getOrder(child).level;
    });
    if (insertIndex !== -1) {
      if (currentIndex !== -1 && currentIndex < insertIndex) {
        insertIndex -= 1;
      }
    }
    return {
      index: insertIndex,
      parent: newParent
    };
  };
}
BpmnOrderingProvider.$inject = ["eventBus", "canvas", "translate"];
inherits$6(BpmnOrderingProvider, OrderingProvider);
var OrderingModule = {
  __depends__: [
    translate$2
  ],
  __init__: ["bpmnOrderingProvider"],
  bpmnOrderingProvider: ["type", BpmnOrderingProvider]
};
function CommandStack(eventBus, injector) {
  this._handlerMap = {};
  this._stack = [];
  this._stackIdx = -1;
  this._currentExecution = {
    actions: [],
    dirty: [],
    trigger: null
  };
  this._injector = injector;
  this._eventBus = eventBus;
  this._uid = 1;
  eventBus.on([
    "diagram.destroy",
    "diagram.clear"
  ], function() {
    this.clear(false);
  }, this);
}
CommandStack.$inject = ["eventBus", "injector"];
CommandStack.prototype.execute = function(command, context) {
  if (!command) {
    throw new Error("command required");
  }
  this._currentExecution.trigger = "execute";
  var action = { command, context };
  this._pushAction(action);
  this._internalExecute(action);
  this._popAction(action);
};
CommandStack.prototype.canExecute = function(command, context) {
  var action = { command, context };
  var handler = this._getHandler(command);
  var result = this._fire(command, "canExecute", action);
  if (result === void 0) {
    if (!handler) {
      return false;
    }
    if (handler.canExecute) {
      result = handler.canExecute(context);
    }
  }
  return result;
};
CommandStack.prototype.clear = function(emit) {
  this._stack.length = 0;
  this._stackIdx = -1;
  if (emit !== false) {
    this._fire("changed", { trigger: "clear" });
  }
};
CommandStack.prototype.undo = function() {
  var action = this._getUndoAction(), next;
  if (action) {
    this._currentExecution.trigger = "undo";
    this._pushAction(action);
    while (action) {
      this._internalUndo(action);
      next = this._getUndoAction();
      if (!next || next.id !== action.id) {
        break;
      }
      action = next;
    }
    this._popAction();
  }
};
CommandStack.prototype.redo = function() {
  var action = this._getRedoAction(), next;
  if (action) {
    this._currentExecution.trigger = "redo";
    this._pushAction(action);
    while (action) {
      this._internalExecute(action, true);
      next = this._getRedoAction();
      if (!next || next.id !== action.id) {
        break;
      }
      action = next;
    }
    this._popAction();
  }
};
CommandStack.prototype.register = function(command, handler) {
  this._setHandler(command, handler);
};
CommandStack.prototype.registerHandler = function(command, handlerCls) {
  if (!command || !handlerCls) {
    throw new Error("command and handlerCls must be defined");
  }
  var handler = this._injector.instantiate(handlerCls);
  this.register(command, handler);
};
CommandStack.prototype.canUndo = function() {
  return !!this._getUndoAction();
};
CommandStack.prototype.canRedo = function() {
  return !!this._getRedoAction();
};
CommandStack.prototype._getRedoAction = function() {
  return this._stack[this._stackIdx + 1];
};
CommandStack.prototype._getUndoAction = function() {
  return this._stack[this._stackIdx];
};
CommandStack.prototype._internalUndo = function(action) {
  var self2 = this;
  var command = action.command, context = action.context;
  var handler = this._getHandler(command);
  this._atomicDo(function() {
    self2._fire(command, "revert", action);
    if (handler.revert) {
      self2._markDirty(handler.revert(context));
    }
    self2._revertedAction(action);
    self2._fire(command, "reverted", action);
  });
};
CommandStack.prototype._fire = function(command, qualifier, event) {
  if (arguments.length < 3) {
    event = qualifier;
    qualifier = null;
  }
  var names = qualifier ? [command + "." + qualifier, qualifier] : [command], i, name2, result;
  event = this._eventBus.createEvent(event);
  for (i = 0; name2 = names[i]; i++) {
    result = this._eventBus.fire("commandStack." + name2, event);
    if (event.cancelBubble) {
      break;
    }
  }
  return result;
};
CommandStack.prototype._createId = function() {
  return this._uid++;
};
CommandStack.prototype._atomicDo = function(fn) {
  var execution = this._currentExecution;
  execution.atomic = true;
  try {
    fn();
  } finally {
    execution.atomic = false;
  }
};
CommandStack.prototype._internalExecute = function(action, redo) {
  var self2 = this;
  var command = action.command, context = action.context;
  var handler = this._getHandler(command);
  if (!handler) {
    throw new Error("no command handler registered for <" + command + ">");
  }
  this._pushAction(action);
  if (!redo) {
    this._fire(command, "preExecute", action);
    if (handler.preExecute) {
      handler.preExecute(context);
    }
    this._fire(command, "preExecuted", action);
  }
  this._atomicDo(function() {
    self2._fire(command, "execute", action);
    if (handler.execute) {
      self2._markDirty(handler.execute(context));
    }
    self2._executedAction(action, redo);
    self2._fire(command, "executed", action);
  });
  if (!redo) {
    this._fire(command, "postExecute", action);
    if (handler.postExecute) {
      handler.postExecute(context);
    }
    this._fire(command, "postExecuted", action);
  }
  this._popAction(action);
};
CommandStack.prototype._pushAction = function(action) {
  var execution = this._currentExecution, actions = execution.actions;
  var baseAction = actions[0];
  if (execution.atomic) {
    throw new Error("illegal invocation in <execute> or <revert> phase (action: " + action.command + ")");
  }
  if (!action.id) {
    action.id = baseAction && baseAction.id || this._createId();
  }
  actions.push(action);
};
CommandStack.prototype._popAction = function() {
  var execution = this._currentExecution, trigger = execution.trigger, actions = execution.actions, dirty = execution.dirty;
  actions.pop();
  if (!actions.length) {
    this._eventBus.fire("elements.changed", { elements: uniqueBy("id", dirty.reverse()) });
    dirty.length = 0;
    this._fire("changed", { trigger });
    execution.trigger = null;
  }
};
CommandStack.prototype._markDirty = function(elements) {
  var execution = this._currentExecution;
  if (!elements) {
    return;
  }
  elements = isArray$n(elements) ? elements : [elements];
  execution.dirty = execution.dirty.concat(elements);
};
CommandStack.prototype._executedAction = function(action, redo) {
  var stackIdx = ++this._stackIdx;
  if (!redo) {
    this._stack.splice(stackIdx, this._stack.length, action);
  }
};
CommandStack.prototype._revertedAction = function(action) {
  this._stackIdx--;
};
CommandStack.prototype._getHandler = function(command) {
  return this._handlerMap[command];
};
CommandStack.prototype._setHandler = function(command, handler) {
  if (!command || !handler) {
    throw new Error("command and handler required");
  }
  if (this._handlerMap[command]) {
    throw new Error("overriding handler for command <" + command + ">");
  }
  this._handlerMap[command] = handler;
};
var CommandModule = {
  commandStack: ["type", CommandStack]
};
var ids = new IdGenerator("tt");
function createRoot(parentNode) {
  var root2 = domify$h('<div class="djs-tooltip-container" style="position: absolute; width: 0; height: 0;" />');
  parentNode.insertBefore(root2, parentNode.firstChild);
  return root2;
}
function setPosition$1(el, x, y) {
  assign$e(el.style, { left: x + "px", top: y + "px" });
}
function setVisible(el, visible) {
  el.style.display = visible === false ? "none" : "";
}
var tooltipClass = "djs-tooltip", tooltipSelector = "." + tooltipClass;
function Tooltips(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._ids = ids;
  this._tooltipDefaults = {
    show: {
      minZoom: 0.7,
      maxZoom: 5
    }
  };
  this._tooltips = {};
  this._tooltipRoot = createRoot(canvas.getContainer());
  var self2 = this;
  delegate$1.bind(this._tooltipRoot, tooltipSelector, "mousedown", function(event) {
    event.stopPropagation();
  });
  delegate$1.bind(this._tooltipRoot, tooltipSelector, "mouseover", function(event) {
    self2.trigger("mouseover", event);
  });
  delegate$1.bind(this._tooltipRoot, tooltipSelector, "mouseout", function(event) {
    self2.trigger("mouseout", event);
  });
  this._init();
}
Tooltips.$inject = ["eventBus", "canvas"];
Tooltips.prototype.add = function(tooltip) {
  if (!tooltip.position) {
    throw new Error("must specifiy tooltip position");
  }
  if (!tooltip.html) {
    throw new Error("must specifiy tooltip html");
  }
  var id2 = this._ids.next();
  tooltip = assign$e({}, this._tooltipDefaults, tooltip, {
    id: id2
  });
  this._addTooltip(tooltip);
  if (tooltip.timeout) {
    this.setTimeout(tooltip);
  }
  return id2;
};
Tooltips.prototype.trigger = function(action, event) {
  var node2 = event.delegateTarget || event.target;
  var tooltip = this.get(attr$1(node2, "data-tooltip-id"));
  if (!tooltip) {
    return;
  }
  if (action === "mouseover" && tooltip.timeout) {
    this.clearTimeout(tooltip);
  }
  if (action === "mouseout" && tooltip.timeout) {
    tooltip.timeout = 1e3;
    this.setTimeout(tooltip);
  }
};
Tooltips.prototype.get = function(id2) {
  if (typeof id2 !== "string") {
    id2 = id2.id;
  }
  return this._tooltips[id2];
};
Tooltips.prototype.clearTimeout = function(tooltip) {
  tooltip = this.get(tooltip);
  if (!tooltip) {
    return;
  }
  var removeTimer = tooltip.removeTimer;
  if (removeTimer) {
    clearTimeout(removeTimer);
    tooltip.removeTimer = null;
  }
};
Tooltips.prototype.setTimeout = function(tooltip) {
  tooltip = this.get(tooltip);
  if (!tooltip) {
    return;
  }
  this.clearTimeout(tooltip);
  var self2 = this;
  tooltip.removeTimer = setTimeout(function() {
    self2.remove(tooltip);
  }, tooltip.timeout);
};
Tooltips.prototype.remove = function(id2) {
  var tooltip = this.get(id2);
  if (tooltip) {
    remove$5(tooltip.html);
    remove$5(tooltip.htmlContainer);
    delete tooltip.htmlContainer;
    delete this._tooltips[tooltip.id];
  }
};
Tooltips.prototype.show = function() {
  setVisible(this._tooltipRoot);
};
Tooltips.prototype.hide = function() {
  setVisible(this._tooltipRoot, false);
};
Tooltips.prototype._updateRoot = function(viewbox) {
  var a = viewbox.scale || 1;
  var d = viewbox.scale || 1;
  var matrix = "matrix(" + a + ",0,0," + d + "," + -1 * viewbox.x * a + "," + -1 * viewbox.y * d + ")";
  this._tooltipRoot.style.transform = matrix;
  this._tooltipRoot.style["-ms-transform"] = matrix;
};
Tooltips.prototype._addTooltip = function(tooltip) {
  var id2 = tooltip.id, html = tooltip.html, htmlContainer, tooltipRoot = this._tooltipRoot;
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }
  if (isString$3(html)) {
    html = domify$h(html);
  }
  htmlContainer = domify$h('<div data-tooltip-id="' + id2 + '" class="' + tooltipClass + '" style="position: absolute">');
  htmlContainer.appendChild(html);
  if (tooltip.type) {
    classes$1(htmlContainer).add("djs-tooltip-" + tooltip.type);
  }
  if (tooltip.className) {
    classes$1(htmlContainer).add(tooltip.className);
  }
  tooltip.htmlContainer = htmlContainer;
  tooltipRoot.appendChild(htmlContainer);
  this._tooltips[id2] = tooltip;
  this._updateTooltip(tooltip);
};
Tooltips.prototype._updateTooltip = function(tooltip) {
  var position = tooltip.position, htmlContainer = tooltip.htmlContainer;
  setPosition$1(htmlContainer, position.x, position.y);
};
Tooltips.prototype._updateTooltipVisibilty = function(viewbox) {
  forEach$q(this._tooltips, function(tooltip) {
    var show = tooltip.show, htmlContainer = tooltip.htmlContainer, visible = true;
    if (show) {
      if (show.minZoom > viewbox.scale || show.maxZoom < viewbox.scale) {
        visible = false;
      }
      setVisible(htmlContainer, visible);
    }
  });
};
Tooltips.prototype._init = function() {
  var self2 = this;
  function updateViewbox(viewbox) {
    self2._updateRoot(viewbox);
    self2._updateTooltipVisibilty(viewbox);
    self2.show();
  }
  this._eventBus.on("canvas.viewbox.changing", function(event) {
    self2.hide();
  });
  this._eventBus.on("canvas.viewbox.changed", function(event) {
    updateViewbox(event.viewbox);
  });
};
var TooltipsModule = {
  __init__: ["tooltips"],
  tooltips: ["type", Tooltips]
};
function saveClear(collection2, removeFn) {
  if (typeof removeFn !== "function") {
    throw new Error("removeFn iterator must be a function");
  }
  if (!collection2) {
    return;
  }
  var e;
  while (e = collection2[0]) {
    removeFn(e);
  }
  return collection2;
}
var LOW_PRIORITY$7 = 250, HIGH_PRIORITY$5 = 1400;
function LabelSupport(injector, eventBus, modeling) {
  CommandInterceptor$5.call(this, eventBus);
  var movePreview = injector.get("movePreview", false);
  eventBus.on("shape.move.start", HIGH_PRIORITY$5, function(e) {
    var context = e.context, shapes = context.shapes, validatedShapes = context.validatedShapes;
    context.shapes = removeLabels(shapes);
    context.validatedShapes = removeLabels(validatedShapes);
  });
  movePreview && eventBus.on("shape.move.start", LOW_PRIORITY$7, function(e) {
    var context = e.context, shapes = context.shapes;
    var labels = [];
    forEach$q(shapes, function(element) {
      forEach$q(element.labels, function(label2) {
        if (!label2.hidden && context.shapes.indexOf(label2) === -1) {
          labels.push(label2);
        }
        if (element.labelTarget) {
          labels.push(element);
        }
      });
    });
    forEach$q(labels, function(label2) {
      movePreview.makeDraggable(context, label2, true);
    });
  });
  this.preExecuted("elements.move", HIGH_PRIORITY$5, function(e) {
    var context = e.context, closure = context.closure, enclosedElements = closure.enclosedElements;
    var enclosedLabels = [];
    forEach$q(enclosedElements, function(element) {
      forEach$q(element.labels, function(label2) {
        if (!enclosedElements[label2.id]) {
          enclosedLabels.push(label2);
        }
      });
    });
    closure.addAll(enclosedLabels);
  });
  this.preExecute([
    "connection.delete",
    "shape.delete"
  ], function(e) {
    var context = e.context, element = context.connection || context.shape;
    saveClear(element.labels, function(label2) {
      modeling.removeShape(label2, { nested: true });
    });
  });
  this.execute("shape.delete", function(e) {
    var context = e.context, shape = context.shape, labelTarget = shape.labelTarget;
    if (labelTarget) {
      context.labelTargetIndex = indexOf$1(labelTarget.labels, shape);
      context.labelTarget = labelTarget;
      shape.labelTarget = null;
    }
  });
  this.revert("shape.delete", function(e) {
    var context = e.context, shape = context.shape, labelTarget = context.labelTarget, labelTargetIndex = context.labelTargetIndex;
    if (labelTarget) {
      add$2(labelTarget.labels, shape, labelTargetIndex);
      shape.labelTarget = labelTarget;
    }
  });
}
inherits$6(LabelSupport, CommandInterceptor$5);
LabelSupport.$inject = [
  "injector",
  "eventBus",
  "modeling"
];
function removeLabels(elements) {
  return filter$a(elements, function(element) {
    return elements.indexOf(element.labelTarget) === -1;
  });
}
var LabelSupportModule = {
  __init__: ["labelSupport"],
  labelSupport: ["type", LabelSupport]
};
var LOW_PRIORITY$6 = 251, HIGH_PRIORITY$4 = 1401;
var MARKER_ATTACH$1 = "attach-ok";
function AttachSupport(injector, eventBus, canvas, rules, modeling) {
  CommandInterceptor$5.call(this, eventBus);
  var movePreview = injector.get("movePreview", false);
  eventBus.on("shape.move.start", HIGH_PRIORITY$4, function(e) {
    var context = e.context, shapes = context.shapes, validatedShapes = context.validatedShapes;
    context.shapes = addAttached(shapes);
    context.validatedShapes = removeAttached(validatedShapes);
  });
  movePreview && eventBus.on("shape.move.start", LOW_PRIORITY$6, function(e) {
    var context = e.context, shapes = context.shapes, attachers = getAttachers(shapes);
    forEach$q(attachers, function(attacher) {
      movePreview.makeDraggable(context, attacher, true);
      forEach$q(attacher.labels, function(label2) {
        movePreview.makeDraggable(context, label2, true);
      });
    });
  });
  movePreview && eventBus.on("shape.move.start", function(event) {
    var context = event.context, shapes = context.shapes;
    if (shapes.length !== 1) {
      return;
    }
    var shape = shapes[0];
    var host = shape.host;
    if (host) {
      canvas.addMarker(host, MARKER_ATTACH$1);
      eventBus.once([
        "shape.move.out",
        "shape.move.cleanup"
      ], function() {
        canvas.removeMarker(host, MARKER_ATTACH$1);
      });
    }
  });
  this.preExecuted("elements.move", HIGH_PRIORITY$4, function(e) {
    var context = e.context, closure = context.closure, shapes = context.shapes, attachers = getAttachers(shapes);
    forEach$q(attachers, function(attacher) {
      closure.add(attacher, closure.topLevel[attacher.host.id]);
    });
  });
  this.postExecuted("elements.move", function(e) {
    var context = e.context, shapes = context.shapes, newHost = context.newHost, attachers;
    if (newHost && shapes.length !== 1) {
      return;
    }
    if (newHost) {
      attachers = shapes;
    } else {
      attachers = filter$a(shapes, function(shape) {
        var host = shape.host;
        return isAttacher(shape) && !includes$4(shapes, host);
      });
    }
    forEach$q(attachers, function(attacher) {
      modeling.updateAttachment(attacher, newHost);
    });
  });
  this.postExecuted("elements.move", function(e) {
    var shapes = e.context.shapes;
    forEach$q(shapes, function(shape) {
      forEach$q(shape.attachers, function(attacher) {
        forEach$q(attacher.outgoing.slice(), function(connection) {
          var allowed = rules.allowed("connection.reconnect", {
            connection,
            source: connection.source,
            target: connection.target
          });
          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });
        forEach$q(attacher.incoming.slice(), function(connection) {
          var allowed = rules.allowed("connection.reconnect", {
            connection,
            source: connection.source,
            target: connection.target
          });
          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });
      });
    });
  });
  this.postExecute("shape.create", function(e) {
    var context = e.context, shape = context.shape, host = context.host;
    if (host) {
      modeling.updateAttachment(shape, host);
    }
  });
  this.postExecute("shape.replace", function(e) {
    var context = e.context, oldShape = context.oldShape, newShape = context.newShape;
    saveClear(oldShape.attachers, function(attacher) {
      var allowed = rules.allowed("elements.move", {
        target: newShape,
        shapes: [attacher]
      });
      if (allowed === "attach") {
        modeling.updateAttachment(attacher, newShape);
      } else {
        modeling.removeShape(attacher);
      }
    });
    if (newShape.attachers.length) {
      forEach$q(newShape.attachers, function(attacher) {
        var delta2 = getNewAttachShapeDelta(attacher, oldShape, newShape);
        modeling.moveShape(attacher, delta2, attacher.parent);
      });
    }
  });
  this.postExecute("shape.resize", function(event) {
    var context = event.context, shape = context.shape, oldBounds = context.oldBounds, newBounds = context.newBounds, attachers = shape.attachers, hints = context.hints || {};
    if (hints.attachSupport === false) {
      return;
    }
    forEach$q(attachers, function(attacher) {
      var delta2 = getNewAttachShapeDelta(attacher, oldBounds, newBounds);
      modeling.moveShape(attacher, delta2, attacher.parent);
      forEach$q(attacher.labels, function(label2) {
        modeling.moveShape(label2, delta2, label2.parent);
      });
    });
  });
  this.preExecute("shape.delete", function(event) {
    var shape = event.context.shape;
    saveClear(shape.attachers, function(attacher) {
      modeling.removeShape(attacher);
    });
    if (shape.host) {
      modeling.updateAttachment(shape, null);
    }
  });
}
inherits$6(AttachSupport, CommandInterceptor$5);
AttachSupport.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "rules",
  "modeling"
];
function getAttachers(shapes) {
  return flatten$a(map$7(shapes, function(s) {
    return s.attachers || [];
  }));
}
function addAttached(elements) {
  var attachers = getAttachers(elements);
  return unionBy("id", elements, attachers);
}
function removeAttached(elements) {
  var ids2 = groupBy$1(elements, "id");
  return filter$a(elements, function(element) {
    while (element) {
      if (element.host && ids2[element.host.id]) {
        return false;
      }
      element = element.parent;
    }
    return true;
  });
}
function isAttacher(shape) {
  return !!shape.host;
}
function includes$4(array, item) {
  return array.indexOf(item) !== -1;
}
var AttachSupportModule = {
  __depends__: [
    RulesModule$1
  ],
  __init__: ["attachSupport"],
  attachSupport: ["type", AttachSupport]
};
var LOW_PRIORITY$5 = 250;
function ToolManager(eventBus, dragging) {
  this._eventBus = eventBus;
  this._dragging = dragging;
  this._tools = [];
  this._active = null;
}
ToolManager.$inject = ["eventBus", "dragging"];
ToolManager.prototype.registerTool = function(name2, events) {
  var tools = this._tools;
  if (!events) {
    throw new Error(`A tool has to be registered with it's "events"`);
  }
  tools.push(name2);
  this.bindEvents(name2, events);
};
ToolManager.prototype.isActive = function(tool) {
  return tool && this._active === tool;
};
ToolManager.prototype.length = function(tool) {
  return this._tools.length;
};
ToolManager.prototype.setActive = function(tool) {
  var eventBus = this._eventBus;
  if (this._active !== tool) {
    this._active = tool;
    eventBus.fire("tool-manager.update", { tool });
  }
};
ToolManager.prototype.bindEvents = function(name2, events) {
  var eventBus = this._eventBus, dragging = this._dragging;
  var eventsToRegister = [];
  eventBus.on(events.tool + ".init", function(event) {
    var context = event.context;
    if (!context.reactivate && this.isActive(name2)) {
      this.setActive(null);
      dragging.cancel();
      return;
    }
    this.setActive(name2);
  }, this);
  forEach$q(events, function(event) {
    eventsToRegister.push(event + ".ended");
    eventsToRegister.push(event + ".canceled");
  });
  eventBus.on(eventsToRegister, LOW_PRIORITY$5, function(event) {
    if (!this._active) {
      return;
    }
    if (isPaletteClick(event)) {
      return;
    }
    this.setActive(null);
  }, this);
};
function isPaletteClick(event) {
  var target = event.originalEvent && event.originalEvent.target;
  return target && closest(target, '.group[data-group="tools"]');
}
var ToolManagerModule = {
  __depends__: [
    DraggingModule
  ],
  __init__: ["toolManager"],
  toolManager: ["type", ToolManager]
};
function getDirection(axis, delta2) {
  if (axis === "x") {
    if (delta2 > 0) {
      return "e";
    }
    if (delta2 < 0) {
      return "w";
    }
  }
  if (axis === "y") {
    if (delta2 > 0) {
      return "s";
    }
    if (delta2 < 0) {
      return "n";
    }
  }
  return null;
}
function getWaypointsUpdatingConnections(movingShapes, resizingShapes) {
  var waypointsUpdatingConnections = [];
  forEach$q(movingShapes.concat(resizingShapes), function(shape) {
    var incoming = shape.incoming, outgoing = shape.outgoing;
    forEach$q(incoming.concat(outgoing), function(connection) {
      var source = connection.source, target = connection.target;
      if (includes$3(movingShapes, source) || includes$3(movingShapes, target) || includes$3(resizingShapes, source) || includes$3(resizingShapes, target)) {
        if (!includes$3(waypointsUpdatingConnections, connection)) {
          waypointsUpdatingConnections.push(connection);
        }
      }
    });
  });
  return waypointsUpdatingConnections;
}
function includes$3(array, item) {
  return array.indexOf(item) !== -1;
}
function resizeBounds(bounds, direction, delta2) {
  var x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height, dx = delta2.x, dy = delta2.y;
  switch (direction) {
    case "n":
      return {
        x,
        y: y + dy,
        width,
        height: height - dy
      };
    case "s":
      return {
        x,
        y,
        width,
        height: height + dy
      };
    case "w":
      return {
        x: x + dx,
        y,
        width: width - dx,
        height
      };
    case "e":
      return {
        x,
        y,
        width: width + dx,
        height
      };
    default:
      throw new Error("unknown direction: " + direction);
  }
}
var abs$1 = Math.abs, round$4 = Math.round;
var AXIS_TO_DIMENSION = {
  x: "width",
  y: "height"
};
var CURSOR_CROSSHAIR = "crosshair";
var DIRECTION_TO_TRBL = {
  n: "top",
  w: "left",
  s: "bottom",
  e: "right"
};
var HIGH_PRIORITY$3 = 1500;
var DIRECTION_TO_OPPOSITE = {
  n: "s",
  w: "e",
  s: "n",
  e: "w"
};
var PADDING = 20;
function SpaceTool(canvas, dragging, eventBus, modeling, rules, toolManager, mouse) {
  this._canvas = canvas;
  this._dragging = dragging;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._rules = rules;
  this._toolManager = toolManager;
  this._mouse = mouse;
  var self2 = this;
  toolManager.registerTool("space", {
    tool: "spaceTool.selection",
    dragging: "spaceTool"
  });
  eventBus.on("spaceTool.selection.end", function(event) {
    eventBus.once("spaceTool.selection.ended", function() {
      self2.activateMakeSpace(event.originalEvent);
    });
  });
  eventBus.on("spaceTool.move", HIGH_PRIORITY$3, function(event) {
    var context = event.context, initialized = context.initialized;
    if (!initialized) {
      initialized = context.initialized = self2.init(event, context);
    }
    if (initialized) {
      ensureConstraints(event);
    }
  });
  eventBus.on("spaceTool.end", function(event) {
    var context = event.context, axis = context.axis, direction = context.direction, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes, start = context.start;
    if (!context.initialized) {
      return;
    }
    ensureConstraints(event);
    var delta2 = {
      x: 0,
      y: 0
    };
    delta2[axis] = round$4(event["d" + axis]);
    self2.makeSpace(movingShapes, resizingShapes, delta2, direction, start);
    eventBus.once("spaceTool.ended", function(event2) {
      self2.activateSelection(event2.originalEvent, true, true);
    });
  });
}
SpaceTool.$inject = [
  "canvas",
  "dragging",
  "eventBus",
  "modeling",
  "rules",
  "toolManager",
  "mouse"
];
SpaceTool.prototype.activateSelection = function(event, autoActivate, reactivate) {
  this._dragging.init(event, "spaceTool.selection", {
    autoActivate,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {
        reactivate
      }
    },
    trapClick: false
  });
};
SpaceTool.prototype.activateMakeSpace = function(event) {
  this._dragging.init(event, "spaceTool", {
    autoActivate: true,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {}
    }
  });
};
SpaceTool.prototype.makeSpace = function(movingShapes, resizingShapes, delta2, direction, start) {
  return this._modeling.createSpace(movingShapes, resizingShapes, delta2, direction, start);
};
SpaceTool.prototype.init = function(event, context) {
  var axis = abs$1(event.dx) > abs$1(event.dy) ? "x" : "y", delta2 = event["d" + axis], start = event[axis] - delta2;
  if (abs$1(delta2) < 5) {
    return false;
  }
  if (delta2 < 0) {
    delta2 *= -1;
  }
  if (hasPrimaryModifier(event)) {
    delta2 *= -1;
  }
  var direction = getDirection(axis, delta2);
  var root2 = this._canvas.getRootElement();
  var children = selfAndAllChildren(root2, true);
  var elements = this.calculateAdjustments(children, axis, delta2, start);
  var minDimensions = this._eventBus.fire("spaceTool.getMinDimensions", {
    axis,
    direction,
    shapes: elements.resizingShapes,
    start
  });
  var spaceToolConstraints = getSpaceToolConstraints(elements, axis, direction, start, minDimensions);
  assign$e(context, elements, {
    axis,
    direction,
    spaceToolConstraints,
    start
  });
  set("resize-" + (axis === "x" ? "ew" : "ns"));
  return true;
};
SpaceTool.prototype.calculateAdjustments = function(elements, axis, delta2, start) {
  var rules = this._rules;
  var movingShapes = [], resizingShapes = [];
  forEach$q(elements, function(element) {
    if (!element.parent || isConnection$7(element)) {
      return;
    }
    var shapeStart = element[axis], shapeEnd = shapeStart + element[AXIS_TO_DIMENSION[axis]];
    if (delta2 > 0 && shapeStart > start || delta2 < 0 && shapeEnd < start) {
      return movingShapes.push(element);
    }
    if (shapeStart < start && shapeEnd > start && rules.allowed("shape.resize", { shape: element })) {
      return resizingShapes.push(element);
    }
  });
  return {
    movingShapes,
    resizingShapes
  };
};
SpaceTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateSelection(mouseEvent, !!mouseEvent);
};
SpaceTool.prototype.isActive = function() {
  var context = this._dragging.context();
  return context && /^spaceTool/.test(context.prefix);
};
function addPadding(trbl) {
  return {
    top: trbl.top - PADDING,
    right: trbl.right + PADDING,
    bottom: trbl.bottom + PADDING,
    left: trbl.left - PADDING
  };
}
function ensureConstraints(event) {
  var context = event.context, spaceToolConstraints = context.spaceToolConstraints;
  if (!spaceToolConstraints) {
    return;
  }
  var x, y;
  if (isNumber$1(spaceToolConstraints.left)) {
    x = Math.max(event.x, spaceToolConstraints.left);
    event.dx = event.dx + x - event.x;
    event.x = x;
  }
  if (isNumber$1(spaceToolConstraints.right)) {
    x = Math.min(event.x, spaceToolConstraints.right);
    event.dx = event.dx + x - event.x;
    event.x = x;
  }
  if (isNumber$1(spaceToolConstraints.top)) {
    y = Math.max(event.y, spaceToolConstraints.top);
    event.dy = event.dy + y - event.y;
    event.y = y;
  }
  if (isNumber$1(spaceToolConstraints.bottom)) {
    y = Math.min(event.y, spaceToolConstraints.bottom);
    event.dy = event.dy + y - event.y;
    event.y = y;
  }
}
function getSpaceToolConstraints(elements, axis, direction, start, minDimensions) {
  var movingShapes = elements.movingShapes, resizingShapes = elements.resizingShapes;
  if (!resizingShapes.length) {
    return;
  }
  var spaceToolConstraints = {}, min2, max2;
  forEach$q(resizingShapes, function(resizingShape) {
    var resizingShapeBBox = asTRBL(resizingShape);
    var nonMovingResizingChildren = filter$a(resizingShape.children, function(child) {
      return !isConnection$7(child) && !isLabel$2(child) && !includes$2(movingShapes, child) && !includes$2(resizingShapes, child);
    });
    var movingChildren = filter$a(resizingShape.children, function(child) {
      return !isConnection$7(child) && !isLabel$2(child) && includes$2(movingShapes, child);
    });
    var minOrMax, nonMovingResizingChildrenBBox, movingChildrenBBox;
    if (nonMovingResizingChildren.length) {
      nonMovingResizingChildrenBBox = addPadding(asTRBL(getBBox(nonMovingResizingChildren)));
      minOrMax = start - resizingShapeBBox[DIRECTION_TO_TRBL[direction]] + nonMovingResizingChildrenBBox[DIRECTION_TO_TRBL[direction]];
      if (direction === "n") {
        spaceToolConstraints.bottom = max2 = isNumber$1(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "w") {
        spaceToolConstraints.right = max2 = isNumber$1(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "s") {
        spaceToolConstraints.top = min2 = isNumber$1(min2) ? Math.max(min2, minOrMax) : minOrMax;
      } else if (direction === "e") {
        spaceToolConstraints.left = min2 = isNumber$1(min2) ? Math.max(min2, minOrMax) : minOrMax;
      }
    }
    if (movingChildren.length) {
      movingChildrenBBox = addPadding(asTRBL(getBBox(movingChildren)));
      minOrMax = start - movingChildrenBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] + resizingShapeBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]];
      if (direction === "n") {
        spaceToolConstraints.bottom = max2 = isNumber$1(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "w") {
        spaceToolConstraints.right = max2 = isNumber$1(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "s") {
        spaceToolConstraints.top = min2 = isNumber$1(min2) ? Math.max(min2, minOrMax) : minOrMax;
      } else if (direction === "e") {
        spaceToolConstraints.left = min2 = isNumber$1(min2) ? Math.max(min2, minOrMax) : minOrMax;
      }
    }
    var resizingShapeMinDimensions = minDimensions && minDimensions[resizingShape.id];
    if (resizingShapeMinDimensions) {
      if (direction === "n") {
        minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.bottom = max2 = isNumber$1(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "w") {
        minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.right = max2 = isNumber$1(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "s") {
        minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.top = min2 = isNumber$1(min2) ? Math.max(min2, minOrMax) : minOrMax;
      } else if (direction === "e") {
        minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.left = min2 = isNumber$1(min2) ? Math.max(min2, minOrMax) : minOrMax;
      }
    }
  });
  return spaceToolConstraints;
}
function includes$2(array, item) {
  return array.indexOf(item) !== -1;
}
function isConnection$7(element) {
  return !!element.waypoints;
}
function isLabel$2(element) {
  return !!element.labelTarget;
}
var MARKER_DRAGGING$1 = "djs-dragging", MARKER_RESIZING = "djs-resizing";
var LOW_PRIORITY$4 = 250;
var max = Math.max;
function SpaceToolPreview(eventBus, elementRegistry, canvas, styles, previewSupport) {
  function addPreviewGfx(collection2, dragGroup) {
    forEach$q(collection2, function(element) {
      previewSupport.addDragger(element, dragGroup);
      canvas.addMarker(element, MARKER_DRAGGING$1);
    });
  }
  eventBus.on("spaceTool.selection.start", function(event) {
    var space = canvas.getLayer("space"), context = event.context;
    var orientation = {
      x: "M 0,-10000 L 0,10000",
      y: "M -10000,0 L 10000,0"
    };
    var crosshairGroup = create$2("g");
    attr(crosshairGroup, styles.cls("djs-crosshair-group", ["no-events"]));
    append$3(space, crosshairGroup);
    var pathX = create$2("path");
    attr(pathX, "d", orientation.x);
    classes(pathX).add("djs-crosshair");
    append$3(crosshairGroup, pathX);
    var pathY = create$2("path");
    attr(pathY, "d", orientation.y);
    classes(pathY).add("djs-crosshair");
    append$3(crosshairGroup, pathY);
    context.crosshairGroup = crosshairGroup;
  });
  eventBus.on("spaceTool.selection.move", function(event) {
    var crosshairGroup = event.context.crosshairGroup;
    translate$4(crosshairGroup, event.x, event.y);
  });
  eventBus.on("spaceTool.selection.cleanup", function(event) {
    var context = event.context, crosshairGroup = context.crosshairGroup;
    if (crosshairGroup) {
      remove$4(crosshairGroup);
    }
  });
  eventBus.on("spaceTool.move", LOW_PRIORITY$4, function(event) {
    var context = event.context, line = context.line, axis = context.axis, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes;
    if (!context.initialized) {
      return;
    }
    if (!context.dragGroup) {
      var spaceLayer = canvas.getLayer("space");
      line = create$2("path");
      attr(line, "d", "M0,0 L0,0");
      classes(line).add("djs-crosshair");
      append$3(spaceLayer, line);
      context.line = line;
      var dragGroup = create$2("g");
      attr(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
      append$3(canvas.getActiveLayer(), dragGroup);
      addPreviewGfx(movingShapes, dragGroup);
      var movingConnections = context.movingConnections = elementRegistry.filter(function(element) {
        var sourceIsMoving = false;
        forEach$q(movingShapes, function(shape) {
          forEach$q(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsMoving = true;
            }
          });
        });
        var targetIsMoving = false;
        forEach$q(movingShapes, function(shape) {
          forEach$q(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsMoving = true;
            }
          });
        });
        var sourceIsResizing = false;
        forEach$q(resizingShapes, function(shape) {
          forEach$q(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsResizing = true;
            }
          });
        });
        var targetIsResizing = false;
        forEach$q(resizingShapes, function(shape) {
          forEach$q(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsResizing = true;
            }
          });
        });
        return isConnection$6(element) && (sourceIsMoving || sourceIsResizing) && (targetIsMoving || targetIsResizing);
      });
      addPreviewGfx(movingConnections, dragGroup);
      context.dragGroup = dragGroup;
    }
    if (!context.frameGroup) {
      var frameGroup = create$2("g");
      attr(frameGroup, styles.cls("djs-frame-group", ["no-events"]));
      append$3(canvas.getActiveLayer(), frameGroup);
      var frames = [];
      forEach$q(resizingShapes, function(shape) {
        var frame = previewSupport.addFrame(shape, frameGroup);
        var initialBounds = frame.getBBox();
        frames.push({
          element: frame,
          initialBounds
        });
        canvas.addMarker(shape, MARKER_RESIZING);
      });
      context.frameGroup = frameGroup;
      context.frames = frames;
    }
    var orientation = {
      x: "M" + event.x + ", -10000 L" + event.x + ", 10000",
      y: "M -10000, " + event.y + " L 10000, " + event.y
    };
    attr(line, { d: orientation[axis] });
    var opposite = { x: "y", y: "x" };
    var delta2 = { x: event.dx, y: event.dy };
    delta2[opposite[context.axis]] = 0;
    translate$4(context.dragGroup, delta2.x, delta2.y);
    forEach$q(context.frames, function(frame) {
      var element = frame.element, initialBounds = frame.initialBounds, width, height;
      if (context.direction === "e") {
        attr(element, {
          width: max(initialBounds.width + delta2.x, 5)
        });
      } else {
        width = max(initialBounds.width - delta2.x, 5);
        attr(element, {
          width,
          x: initialBounds.x + initialBounds.width - width
        });
      }
      if (context.direction === "s") {
        attr(element, {
          height: max(initialBounds.height + delta2.y, 5)
        });
      } else {
        height = max(initialBounds.height - delta2.y, 5);
        attr(element, {
          height,
          y: initialBounds.y + initialBounds.height - height
        });
      }
    });
  });
  eventBus.on("spaceTool.cleanup", function(event) {
    var context = event.context, movingShapes = context.movingShapes, movingConnections = context.movingConnections, resizingShapes = context.resizingShapes, line = context.line, dragGroup = context.dragGroup, frameGroup = context.frameGroup;
    forEach$q(movingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_DRAGGING$1);
    });
    forEach$q(movingConnections, function(connection) {
      canvas.removeMarker(connection, MARKER_DRAGGING$1);
    });
    if (dragGroup) {
      remove$4(line);
      remove$4(dragGroup);
    }
    forEach$q(resizingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_RESIZING);
    });
    if (frameGroup) {
      remove$4(frameGroup);
    }
  });
}
SpaceToolPreview.$inject = [
  "eventBus",
  "elementRegistry",
  "canvas",
  "styles",
  "previewSupport"
];
function isConnection$6(element) {
  return element.waypoints;
}
var SpaceToolModule = {
  __init__: ["spaceToolPreview"],
  __depends__: [
    DraggingModule,
    RulesModule$1,
    ToolManagerModule,
    PreviewSupportModule,
    MouseModule
  ],
  spaceTool: ["type", SpaceTool],
  spaceToolPreview: ["type", SpaceToolPreview]
};
function BpmnFactory(moddle) {
  this._model = moddle;
}
BpmnFactory.$inject = ["moddle"];
BpmnFactory.prototype._needsId = function(element) {
  return isAny$b(element, [
    "bpmn:RootElement",
    "bpmn:FlowElement",
    "bpmn:MessageFlow",
    "bpmn:DataAssociation",
    "bpmn:Artifact",
    "bpmn:Participant",
    "bpmn:Lane",
    "bpmn:LaneSet",
    "bpmn:Process",
    "bpmn:Collaboration",
    "bpmndi:BPMNShape",
    "bpmndi:BPMNEdge",
    "bpmndi:BPMNDiagram",
    "bpmndi:BPMNPlane",
    "bpmn:Property",
    "bpmn:CategoryValue"
  ]);
};
BpmnFactory.prototype._ensureId = function(element) {
  if (element.id) {
    this._model.ids.claim(element.id, element);
    return;
  }
  var prefix2;
  if (is$O(element, "bpmn:Activity")) {
    prefix2 = "Activity";
  } else if (is$O(element, "bpmn:Event")) {
    prefix2 = "Event";
  } else if (is$O(element, "bpmn:Gateway")) {
    prefix2 = "Gateway";
  } else if (isAny$b(element, ["bpmn:SequenceFlow", "bpmn:MessageFlow"])) {
    prefix2 = "Flow";
  } else {
    prefix2 = (element.$type || "").replace(/^[^:]*:/g, "");
  }
  prefix2 += "_";
  if (!element.id && this._needsId(element)) {
    element.id = this._model.ids.nextPrefixed(prefix2, element);
  }
};
BpmnFactory.prototype.create = function(type, attrs) {
  var element = this._model.create(type, attrs || {});
  this._ensureId(element);
  return element;
};
BpmnFactory.prototype.createDiLabel = function() {
  return this.create("bpmndi:BPMNLabel", {
    bounds: this.createDiBounds()
  });
};
BpmnFactory.prototype.createDiShape = function(semantic, bounds, attrs) {
  return this.create("bpmndi:BPMNShape", assign$e({
    bpmnElement: semantic,
    bounds: this.createDiBounds(bounds)
  }, attrs));
};
BpmnFactory.prototype.createDiBounds = function(bounds) {
  return this.create("dc:Bounds", bounds);
};
BpmnFactory.prototype.createDiWaypoints = function(waypoints) {
  var self2 = this;
  return map$7(waypoints, function(pos) {
    return self2.createDiWaypoint(pos);
  });
};
BpmnFactory.prototype.createDiWaypoint = function(point) {
  return this.create("dc:Point", pick$3(point, ["x", "y"]));
};
BpmnFactory.prototype.createDiEdge = function(semantic, waypoints, attrs) {
  return this.create("bpmndi:BPMNEdge", assign$e({
    bpmnElement: semantic,
    waypoint: this.createDiWaypoints(waypoints)
  }, attrs));
};
BpmnFactory.prototype.createDiPlane = function(semantic) {
  return this.create("bpmndi:BPMNPlane", {
    bpmnElement: semantic
  });
};
function BpmnUpdater(eventBus, bpmnFactory, connectionDocking, translate2) {
  CommandInterceptor$5.call(this, eventBus);
  this._bpmnFactory = bpmnFactory;
  this._translate = translate2;
  var self2 = this;
  function cropConnection(e) {
    var context = e.context, hints = context.hints || {}, connection;
    if (!context.cropped && hints.createElementsBehavior !== false) {
      connection = context.connection;
      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
      context.cropped = true;
    }
  }
  this.executed([
    "connection.layout",
    "connection.create"
  ], cropConnection);
  this.reverted(["connection.layout"], function(e) {
    delete e.context.cropped;
  });
  function updateParent(e) {
    var context = e.context;
    self2.updateParent(context.shape || context.connection, context.oldParent);
  }
  function reverseUpdateParent(e) {
    var context = e.context;
    var element = context.shape || context.connection, oldParent = context.parent || context.newParent;
    self2.updateParent(element, oldParent);
  }
  this.executed([
    "shape.move",
    "shape.create",
    "shape.delete",
    "connection.create",
    "connection.move",
    "connection.delete"
  ], ifBpmn(updateParent));
  this.reverted([
    "shape.move",
    "shape.create",
    "shape.delete",
    "connection.create",
    "connection.move",
    "connection.delete"
  ], ifBpmn(reverseUpdateParent));
  function updateRoot(event) {
    var context = event.context, oldRoot = context.oldRoot, children = oldRoot.children;
    forEach$q(children, function(child) {
      if (is$O(child, "bpmn:BaseElement")) {
        self2.updateParent(child);
      }
    });
  }
  this.executed(["canvas.updateRoot"], updateRoot);
  this.reverted(["canvas.updateRoot"], updateRoot);
  function updateBounds(e) {
    var shape = e.context.shape;
    if (!is$O(shape, "bpmn:BaseElement")) {
      return;
    }
    self2.updateBounds(shape);
  }
  this.executed(["shape.move", "shape.create", "shape.resize"], ifBpmn(function(event) {
    if (event.context.shape.type === "label") {
      return;
    }
    updateBounds(event);
  }));
  this.reverted(["shape.move", "shape.create", "shape.resize"], ifBpmn(function(event) {
    if (event.context.shape.type === "label") {
      return;
    }
    updateBounds(event);
  }));
  eventBus.on("shape.changed", function(event) {
    if (event.element.type === "label") {
      updateBounds({ context: { shape: event.element } });
    }
  });
  function updateConnection(e) {
    self2.updateConnection(e.context);
  }
  this.executed([
    "connection.create",
    "connection.move",
    "connection.delete",
    "connection.reconnect"
  ], ifBpmn(updateConnection));
  this.reverted([
    "connection.create",
    "connection.move",
    "connection.delete",
    "connection.reconnect"
  ], ifBpmn(updateConnection));
  function updateConnectionWaypoints(e) {
    self2.updateConnectionWaypoints(e.context.connection);
  }
  this.executed([
    "connection.layout",
    "connection.move",
    "connection.updateWaypoints"
  ], ifBpmn(updateConnectionWaypoints));
  this.reverted([
    "connection.layout",
    "connection.move",
    "connection.updateWaypoints"
  ], ifBpmn(updateConnectionWaypoints));
  this.executed("connection.reconnect", ifBpmn(function(event) {
    var context = event.context, connection = context.connection, oldSource = context.oldSource, newSource = context.newSource, connectionBo = getBusinessObject$V(connection), oldSourceBo = getBusinessObject$V(oldSource), newSourceBo = getBusinessObject$V(newSource);
    if (connectionBo.conditionExpression && !isAny$b(newSourceBo, [
      "bpmn:Activity",
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway"
    ])) {
      context.oldConditionExpression = connectionBo.conditionExpression;
      delete connectionBo.conditionExpression;
    }
    if (oldSource !== newSource && oldSourceBo.default === connectionBo) {
      context.oldDefault = oldSourceBo.default;
      delete oldSourceBo.default;
    }
  }));
  this.reverted("connection.reconnect", ifBpmn(function(event) {
    var context = event.context, connection = context.connection, oldSource = context.oldSource, newSource = context.newSource, connectionBo = getBusinessObject$V(connection), oldSourceBo = getBusinessObject$V(oldSource), newSourceBo = getBusinessObject$V(newSource);
    if (context.oldConditionExpression) {
      connectionBo.conditionExpression = context.oldConditionExpression;
    }
    if (context.oldDefault) {
      oldSourceBo.default = context.oldDefault;
      delete newSourceBo.default;
    }
  }));
  function updateAttachment(e) {
    self2.updateAttachment(e.context);
  }
  this.executed(["element.updateAttachment"], ifBpmn(updateAttachment));
  this.reverted(["element.updateAttachment"], ifBpmn(updateAttachment));
}
inherits$6(BpmnUpdater, CommandInterceptor$5);
BpmnUpdater.$inject = [
  "eventBus",
  "bpmnFactory",
  "connectionDocking",
  "translate"
];
BpmnUpdater.prototype.updateAttachment = function(context) {
  var shape = context.shape, businessObject = shape.businessObject, host = shape.host;
  businessObject.attachedToRef = host && host.businessObject;
};
BpmnUpdater.prototype.updateParent = function(element, oldParent) {
  if (element instanceof Label) {
    return;
  }
  if (is$O(element, "bpmn:DataStoreReference") && element.parent && is$O(element.parent, "bpmn:Collaboration")) {
    return;
  }
  var parentShape = element.parent;
  var businessObject = element.businessObject, parentBusinessObject = parentShape && parentShape.businessObject, parentDi = parentBusinessObject && parentBusinessObject.di;
  if (is$O(element, "bpmn:FlowNode")) {
    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);
  }
  if (is$O(element, "bpmn:DataOutputAssociation")) {
    if (element.source) {
      parentBusinessObject = element.source.businessObject;
    } else {
      parentBusinessObject = null;
    }
  }
  if (is$O(element, "bpmn:DataInputAssociation")) {
    if (element.target) {
      parentBusinessObject = element.target.businessObject;
    } else {
      parentBusinessObject = null;
    }
  }
  this.updateSemanticParent(businessObject, parentBusinessObject);
  if (is$O(element, "bpmn:DataObjectReference") && businessObject.dataObjectRef) {
    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);
  }
  this.updateDiParent(businessObject.di, parentDi);
};
BpmnUpdater.prototype.updateBounds = function(shape) {
  var di = shape.businessObject.di;
  var target = shape instanceof Label ? this._getLabel(di) : di;
  var bounds = target.bounds;
  if (!bounds) {
    bounds = this._bpmnFactory.createDiBounds();
    target.set("bounds", bounds);
  }
  assign$e(bounds, {
    x: shape.x,
    y: shape.y,
    width: shape.width,
    height: shape.height
  });
};
BpmnUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {
  if (oldContainment === newContainment) {
    return;
  }
  var oldRefs, newRefs;
  if (is$O(oldContainment, "bpmn:Lane")) {
    oldRefs = oldContainment.get("flowNodeRef");
    remove$3(oldRefs, businessObject);
  }
  if (is$O(newContainment, "bpmn:Lane")) {
    newRefs = newContainment.get("flowNodeRef");
    add$2(newRefs, businessObject);
  }
};
BpmnUpdater.prototype.updateDiConnection = function(di, newSource, newTarget) {
  if (di.sourceElement && di.sourceElement.bpmnElement !== newSource) {
    di.sourceElement = newSource && newSource.di;
  }
  if (di.targetElement && di.targetElement.bpmnElement !== newTarget) {
    di.targetElement = newTarget && newTarget.di;
  }
};
BpmnUpdater.prototype.updateDiParent = function(di, parentDi) {
  if (parentDi && !is$O(parentDi, "bpmndi:BPMNPlane")) {
    parentDi = parentDi.$parent;
  }
  if (di.$parent === parentDi) {
    return;
  }
  var planeElements = (parentDi || di.$parent).get("planeElement");
  if (parentDi) {
    planeElements.push(di);
    di.$parent = parentDi;
  } else {
    remove$3(planeElements, di);
    di.$parent = null;
  }
};
function getDefinitions(element) {
  while (element && !is$O(element, "bpmn:Definitions")) {
    element = element.$parent;
  }
  return element;
}
BpmnUpdater.prototype.getLaneSet = function(container) {
  var laneSet, laneSets;
  if (is$O(container, "bpmn:Lane")) {
    laneSet = container.childLaneSet;
    if (!laneSet) {
      laneSet = this._bpmnFactory.create("bpmn:LaneSet");
      container.childLaneSet = laneSet;
      laneSet.$parent = container;
    }
    return laneSet;
  }
  if (is$O(container, "bpmn:Participant")) {
    container = container.processRef;
  }
  laneSets = container.get("laneSets");
  laneSet = laneSets[0];
  if (!laneSet) {
    laneSet = this._bpmnFactory.create("bpmn:LaneSet");
    laneSet.$parent = container;
    laneSets.push(laneSet);
  }
  return laneSet;
};
BpmnUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {
  var containment, translate2 = this._translate;
  if (businessObject.$parent === newParent) {
    return;
  }
  if (is$O(businessObject, "bpmn:DataInput") || is$O(businessObject, "bpmn:DataOutput")) {
    if (is$O(newParent, "bpmn:Participant") && "processRef" in newParent) {
      newParent = newParent.processRef;
    }
    if ("ioSpecification" in newParent && newParent.ioSpecification === businessObject.$parent) {
      return;
    }
  }
  if (is$O(businessObject, "bpmn:Lane")) {
    if (newParent) {
      newParent = this.getLaneSet(newParent);
    }
    containment = "lanes";
  } else if (is$O(businessObject, "bpmn:FlowElement")) {
    if (newParent) {
      if (is$O(newParent, "bpmn:Participant")) {
        newParent = newParent.processRef;
      } else if (is$O(newParent, "bpmn:Lane")) {
        do {
          newParent = newParent.$parent.$parent;
        } while (is$O(newParent, "bpmn:Lane"));
      }
    }
    containment = "flowElements";
  } else if (is$O(businessObject, "bpmn:Artifact")) {
    while (newParent && !is$O(newParent, "bpmn:Process") && !is$O(newParent, "bpmn:SubProcess") && !is$O(newParent, "bpmn:Collaboration")) {
      if (is$O(newParent, "bpmn:Participant")) {
        newParent = newParent.processRef;
        break;
      } else {
        newParent = newParent.$parent;
      }
    }
    containment = "artifacts";
  } else if (is$O(businessObject, "bpmn:MessageFlow")) {
    containment = "messageFlows";
  } else if (is$O(businessObject, "bpmn:Participant")) {
    containment = "participants";
    var process2 = businessObject.processRef, definitions;
    if (process2) {
      definitions = getDefinitions(businessObject.$parent || newParent);
      if (businessObject.$parent) {
        remove$3(definitions.get("rootElements"), process2);
        process2.$parent = null;
      }
      if (newParent) {
        add$2(definitions.get("rootElements"), process2);
        process2.$parent = definitions;
      }
    }
  } else if (is$O(businessObject, "bpmn:DataOutputAssociation")) {
    containment = "dataOutputAssociations";
  } else if (is$O(businessObject, "bpmn:DataInputAssociation")) {
    containment = "dataInputAssociations";
  }
  if (!containment) {
    throw new Error(translate2("no parent for {element} in {parent}", {
      element: businessObject.id,
      parent: newParent.id
    }));
  }
  var children;
  if (businessObject.$parent) {
    children = businessObject.$parent.get(containment);
    remove$3(children, businessObject);
  }
  if (!newParent) {
    businessObject.$parent = null;
  } else {
    children = newParent.get(containment);
    children.push(businessObject);
    businessObject.$parent = newParent;
  }
  if (visualParent) {
    var diChildren = visualParent.get(containment);
    remove$3(children, businessObject);
    if (newParent) {
      if (!diChildren) {
        diChildren = [];
        newParent.set(containment, diChildren);
      }
      diChildren.push(businessObject);
    }
  }
};
BpmnUpdater.prototype.updateConnectionWaypoints = function(connection) {
  connection.businessObject.di.set("waypoint", this._bpmnFactory.createDiWaypoints(connection.waypoints));
};
BpmnUpdater.prototype.updateConnection = function(context) {
  var connection = context.connection, businessObject = getBusinessObject$V(connection), newSource = getBusinessObject$V(connection.source), newTarget = getBusinessObject$V(connection.target), visualParent;
  if (!is$O(businessObject, "bpmn:DataAssociation")) {
    var inverseSet = is$O(businessObject, "bpmn:SequenceFlow");
    if (businessObject.sourceRef !== newSource) {
      if (inverseSet) {
        remove$3(businessObject.sourceRef && businessObject.sourceRef.get("outgoing"), businessObject);
        if (newSource && newSource.get("outgoing")) {
          newSource.get("outgoing").push(businessObject);
        }
      }
      businessObject.sourceRef = newSource;
    }
    if (businessObject.targetRef !== newTarget) {
      if (inverseSet) {
        remove$3(businessObject.targetRef && businessObject.targetRef.get("incoming"), businessObject);
        if (newTarget && newTarget.get("incoming")) {
          newTarget.get("incoming").push(businessObject);
        }
      }
      businessObject.targetRef = newTarget;
    }
  } else if (is$O(businessObject, "bpmn:DataInputAssociation")) {
    businessObject.get("sourceRef")[0] = newSource;
    visualParent = context.parent || context.newParent || newTarget;
    this.updateSemanticParent(businessObject, newTarget, visualParent);
  } else if (is$O(businessObject, "bpmn:DataOutputAssociation")) {
    visualParent = context.parent || context.newParent || newSource;
    this.updateSemanticParent(businessObject, newSource, visualParent);
    businessObject.targetRef = newTarget;
  }
  this.updateConnectionWaypoints(connection);
  this.updateDiConnection(businessObject.di, newSource, newTarget);
};
BpmnUpdater.prototype._getLabel = function(di) {
  if (!di.label) {
    di.label = this._bpmnFactory.createDiLabel();
  }
  return di.label;
};
function ifBpmn(fn) {
  return function(event) {
    var context = event.context, element = context.shape || context.connection;
    if (is$O(element, "bpmn:BaseElement")) {
      fn(event);
    }
  };
}
function ElementFactory(bpmnFactory, moddle, translate2) {
  ElementFactory$1.call(this);
  this._bpmnFactory = bpmnFactory;
  this._moddle = moddle;
  this._translate = translate2;
}
inherits$6(ElementFactory, ElementFactory$1);
ElementFactory.$inject = [
  "bpmnFactory",
  "moddle",
  "translate"
];
ElementFactory.prototype.baseCreate = ElementFactory$1.prototype.create;
ElementFactory.prototype.create = function(elementType, attrs) {
  if (elementType === "label") {
    return this.baseCreate(elementType, assign$e({ type: "label" }, DEFAULT_LABEL_SIZE, attrs));
  }
  return this.createBpmnElement(elementType, attrs);
};
ElementFactory.prototype.createBpmnElement = function(elementType, attrs) {
  var size2, translate2 = this._translate;
  attrs = attrs || {};
  var businessObject = attrs.businessObject;
  if (!businessObject) {
    if (!attrs.type) {
      throw new Error(translate2("no shape type specified"));
    }
    businessObject = this._bpmnFactory.create(attrs.type);
  }
  if (!businessObject.di) {
    if (elementType === "root") {
      businessObject.di = this._bpmnFactory.createDiPlane(businessObject, [], {
        id: businessObject.id + "_di"
      });
    } else if (elementType === "connection") {
      businessObject.di = this._bpmnFactory.createDiEdge(businessObject, [], {
        id: businessObject.id + "_di"
      });
    } else {
      businessObject.di = this._bpmnFactory.createDiShape(businessObject, {}, {
        id: businessObject.id + "_di"
      });
    }
  }
  if (is$O(businessObject, "bpmn:Group")) {
    attrs = assign$e({
      isFrame: true
    }, attrs);
  }
  if (attrs.di) {
    assign$e(businessObject.di, attrs.di);
    delete attrs.di;
  }
  applyAttributes(businessObject, attrs, [
    "processRef",
    "isInterrupting",
    "associationDirection",
    "isForCompensation"
  ]);
  if (attrs.isExpanded) {
    applyAttribute(businessObject.di, attrs, "isExpanded");
  }
  if (is$O(businessObject, "bpmn:ExclusiveGateway")) {
    businessObject.di.isMarkerVisible = true;
  }
  var eventDefinitions, newEventDefinition;
  if (attrs.eventDefinitionType) {
    eventDefinitions = businessObject.get("eventDefinitions") || [];
    newEventDefinition = this._bpmnFactory.create(attrs.eventDefinitionType, attrs.eventDefinitionAttrs);
    if (attrs.eventDefinitionType === "bpmn:ConditionalEventDefinition") {
      newEventDefinition.condition = this._bpmnFactory.create("bpmn:FormalExpression");
    }
    eventDefinitions.push(newEventDefinition);
    newEventDefinition.$parent = businessObject;
    businessObject.eventDefinitions = eventDefinitions;
    delete attrs.eventDefinitionType;
  }
  size2 = this._getDefaultSize(businessObject);
  attrs = assign$e({
    businessObject,
    id: businessObject.id
  }, size2, attrs);
  return this.baseCreate(elementType, attrs);
};
ElementFactory.prototype._getDefaultSize = function(semantic) {
  if (is$O(semantic, "bpmn:SubProcess")) {
    if (isExpanded(semantic)) {
      return { width: 350, height: 200 };
    } else {
      return { width: 100, height: 80 };
    }
  }
  if (is$O(semantic, "bpmn:Task")) {
    return { width: 100, height: 80 };
  }
  if (is$O(semantic, "bpmn:Gateway")) {
    return { width: 50, height: 50 };
  }
  if (is$O(semantic, "bpmn:Event")) {
    return { width: 36, height: 36 };
  }
  if (is$O(semantic, "bpmn:Participant")) {
    if (isExpanded(semantic)) {
      return { width: 600, height: 250 };
    } else {
      return { width: 400, height: 60 };
    }
  }
  if (is$O(semantic, "bpmn:Lane")) {
    return { width: 400, height: 100 };
  }
  if (is$O(semantic, "bpmn:DataObjectReference")) {
    return { width: 36, height: 50 };
  }
  if (is$O(semantic, "bpmn:DataStoreReference")) {
    return { width: 50, height: 50 };
  }
  if (is$O(semantic, "bpmn:TextAnnotation")) {
    return { width: 100, height: 30 };
  }
  if (is$O(semantic, "bpmn:Group")) {
    return { width: 300, height: 300 };
  }
  return { width: 100, height: 80 };
};
ElementFactory.prototype.createParticipantShape = function(attrs) {
  if (!isObject$e(attrs)) {
    attrs = { isExpanded: attrs };
  }
  attrs = assign$e({ type: "bpmn:Participant" }, attrs || {});
  if (attrs.isExpanded !== false) {
    attrs.processRef = this._bpmnFactory.create("bpmn:Process");
  }
  return this.createShape(attrs);
};
function applyAttributes(element, attrs, attributeNames) {
  forEach$q(attributeNames, function(property2) {
    if (attrs[property2] !== void 0) {
      applyAttribute(element, attrs, property2);
    }
  });
}
function applyAttribute(element, attrs, attributeName) {
  element[attributeName] = attrs[attributeName];
  delete attrs[attributeName];
}
function AlignElements(modeling, canvas) {
  this._modeling = modeling;
  this._canvas = canvas;
}
AlignElements.$inject = ["modeling", "canvas"];
AlignElements.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var elements = context.elements, alignment = context.alignment;
  forEach$q(elements, function(element) {
    var delta2 = {
      x: 0,
      y: 0
    };
    if (alignment.left) {
      delta2.x = alignment.left - element.x;
    } else if (alignment.right) {
      delta2.x = alignment.right - element.width - element.x;
    } else if (alignment.center) {
      delta2.x = alignment.center - Math.round(element.width / 2) - element.x;
    } else if (alignment.top) {
      delta2.y = alignment.top - element.y;
    } else if (alignment.bottom) {
      delta2.y = alignment.bottom - element.height - element.y;
    } else if (alignment.middle) {
      delta2.y = alignment.middle - Math.round(element.height / 2) - element.y;
    }
    modeling.moveElements([element], delta2, element.parent);
  });
};
AlignElements.prototype.postExecute = function(context) {
};
function AppendShapeHandler(modeling) {
  this._modeling = modeling;
}
AppendShapeHandler.$inject = ["modeling"];
AppendShapeHandler.prototype.preExecute = function(context) {
  var source = context.source;
  if (!source) {
    throw new Error("source required");
  }
  var target = context.target || source.parent, shape = context.shape, hints = context.hints || {};
  shape = context.shape = this._modeling.createShape(shape, context.position, target, { attach: hints.attach });
  context.shape = shape;
};
AppendShapeHandler.prototype.postExecute = function(context) {
  var hints = context.hints || {};
  if (!existsConnection(context.source, context.shape)) {
    if (hints.connectionTarget === context.source) {
      this._modeling.connect(context.shape, context.source, context.connection);
    } else {
      this._modeling.connect(context.source, context.shape, context.connection);
    }
  }
};
function existsConnection(source, target) {
  return some$1(source.outgoing, function(c) {
    return c.target === target;
  });
}
function CreateConnectionHandler(canvas, layouter) {
  this._canvas = canvas;
  this._layouter = layouter;
}
CreateConnectionHandler.$inject = ["canvas", "layouter"];
CreateConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, source = context.source, target = context.target, parent2 = context.parent, parentIndex = context.parentIndex, hints = context.hints;
  if (!source || !target) {
    throw new Error("source and target required");
  }
  if (!parent2) {
    throw new Error("parent required");
  }
  connection.source = source;
  connection.target = target;
  if (!connection.waypoints) {
    connection.waypoints = this._layouter.layoutConnection(connection, hints);
  }
  this._canvas.addConnection(connection, parent2, parentIndex);
  return connection;
};
CreateConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection;
  this._canvas.removeConnection(connection);
  connection.source = null;
  connection.target = null;
  return connection;
};
var round$3 = Math.round;
function CreateElementsHandler(modeling) {
  this._modeling = modeling;
}
CreateElementsHandler.$inject = [
  "modeling"
];
CreateElementsHandler.prototype.preExecute = function(context) {
  var elements = context.elements, parent2 = context.parent, parentIndex = context.parentIndex, position = context.position, hints = context.hints;
  var modeling = this._modeling;
  forEach$q(elements, function(element) {
    if (!isNumber$1(element.x)) {
      element.x = 0;
    }
    if (!isNumber$1(element.y)) {
      element.y = 0;
    }
  });
  var bbox = getBBox(elements);
  forEach$q(elements, function(element) {
    if (isConnection$5(element)) {
      element.waypoints = map$7(element.waypoints, function(waypoint) {
        return {
          x: round$3(waypoint.x - bbox.x - bbox.width / 2 + position.x),
          y: round$3(waypoint.y - bbox.y - bbox.height / 2 + position.y)
        };
      });
    }
    assign$e(element, {
      x: round$3(element.x - bbox.x - bbox.width / 2 + position.x),
      y: round$3(element.y - bbox.y - bbox.height / 2 + position.y)
    });
  });
  var parents = getParents$2(elements);
  var cache = {};
  forEach$q(elements, function(element) {
    if (isConnection$5(element)) {
      cache[element.id] = isNumber$1(parentIndex) ? modeling.createConnection(cache[element.source.id], cache[element.target.id], parentIndex, element, element.parent || parent2, hints) : modeling.createConnection(cache[element.source.id], cache[element.target.id], element, element.parent || parent2, hints);
      return;
    }
    var createShapeHints = assign$e({}, hints);
    if (parents.indexOf(element) === -1) {
      createShapeHints.autoResize = false;
    }
    cache[element.id] = isNumber$1(parentIndex) ? modeling.createShape(element, pick$3(element, ["x", "y", "width", "height"]), element.parent || parent2, parentIndex, createShapeHints) : modeling.createShape(element, pick$3(element, ["x", "y", "width", "height"]), element.parent || parent2, createShapeHints);
  });
  context.elements = values$2(cache);
};
function isConnection$5(element) {
  return !!element.waypoints;
}
var round$2 = Math.round;
function CreateShapeHandler(canvas) {
  this._canvas = canvas;
}
CreateShapeHandler.$inject = ["canvas"];
CreateShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, positionOrBounds = context.position, parent2 = context.parent, parentIndex = context.parentIndex;
  if (!parent2) {
    throw new Error("parent required");
  }
  if (!positionOrBounds) {
    throw new Error("position required");
  }
  if (positionOrBounds.width !== void 0) {
    assign$e(shape, positionOrBounds);
  } else {
    assign$e(shape, {
      x: positionOrBounds.x - round$2(shape.width / 2),
      y: positionOrBounds.y - round$2(shape.height / 2)
    });
  }
  this._canvas.addShape(shape, parent2, parentIndex);
  return shape;
};
CreateShapeHandler.prototype.revert = function(context) {
  var shape = context.shape;
  this._canvas.removeShape(shape);
  return shape;
};
function CreateLabelHandler(canvas) {
  CreateShapeHandler.call(this, canvas);
}
inherits$6(CreateLabelHandler, CreateShapeHandler);
CreateLabelHandler.$inject = ["canvas"];
var originalExecute = CreateShapeHandler.prototype.execute;
CreateLabelHandler.prototype.execute = function(context) {
  var label2 = context.shape;
  ensureValidDimensions(label2);
  label2.labelTarget = context.labelTarget;
  return originalExecute.call(this, context);
};
var originalRevert = CreateShapeHandler.prototype.revert;
CreateLabelHandler.prototype.revert = function(context) {
  context.shape.labelTarget = null;
  return originalRevert.call(this, context);
};
function ensureValidDimensions(label2) {
  ["width", "height"].forEach(function(prop) {
    if (typeof label2[prop] === "undefined") {
      label2[prop] = 0;
    }
  });
}
function DeleteConnectionHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
DeleteConnectionHandler.$inject = [
  "canvas",
  "modeling"
];
DeleteConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, parent2 = connection.parent;
  context.parent = parent2;
  context.parentIndex = indexOf$1(parent2.children, connection);
  context.source = connection.source;
  context.target = connection.target;
  this._canvas.removeConnection(connection);
  connection.source = null;
  connection.target = null;
  return connection;
};
DeleteConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection, parent2 = context.parent, parentIndex = context.parentIndex;
  connection.source = context.source;
  connection.target = context.target;
  add$2(parent2.children, connection, parentIndex);
  this._canvas.addConnection(connection, parent2);
  return connection;
};
function DeleteElementsHandler(modeling, elementRegistry) {
  this._modeling = modeling;
  this._elementRegistry = elementRegistry;
}
DeleteElementsHandler.$inject = [
  "modeling",
  "elementRegistry"
];
DeleteElementsHandler.prototype.postExecute = function(context) {
  var modeling = this._modeling, elementRegistry = this._elementRegistry, elements = context.elements;
  forEach$q(elements, function(element) {
    if (!elementRegistry.get(element.id)) {
      return;
    }
    if (element.waypoints) {
      modeling.removeConnection(element);
    } else {
      modeling.removeShape(element);
    }
  });
};
function DeleteShapeHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
DeleteShapeHandler.$inject = ["canvas", "modeling"];
DeleteShapeHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var shape = context.shape;
  saveClear(shape.incoming, function(connection) {
    modeling.removeConnection(connection, { nested: true });
  });
  saveClear(shape.outgoing, function(connection) {
    modeling.removeConnection(connection, { nested: true });
  });
  saveClear(shape.children, function(child) {
    if (isConnection$4(child)) {
      modeling.removeConnection(child, { nested: true });
    } else {
      modeling.removeShape(child, { nested: true });
    }
  });
};
DeleteShapeHandler.prototype.execute = function(context) {
  var canvas = this._canvas;
  var shape = context.shape, oldParent = shape.parent;
  context.oldParent = oldParent;
  context.oldParentIndex = indexOf$1(oldParent.children, shape);
  canvas.removeShape(shape);
  return shape;
};
DeleteShapeHandler.prototype.revert = function(context) {
  var canvas = this._canvas;
  var shape = context.shape, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex;
  add$2(oldParent.children, shape, oldParentIndex);
  canvas.addShape(shape, oldParent);
  return shape;
};
function isConnection$4(element) {
  return element.waypoints;
}
function DistributeElements(modeling) {
  this._modeling = modeling;
}
DistributeElements.$inject = ["modeling"];
var OFF_AXIS = {
  x: "y",
  y: "x"
};
DistributeElements.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var groups = context.groups, axis = context.axis, dimension = context.dimension;
  function updateRange(group, element) {
    group.range.min = Math.min(element[axis], group.range.min);
    group.range.max = Math.max(element[axis] + element[dimension], group.range.max);
  }
  function center2(element) {
    return element[axis] + element[dimension] / 2;
  }
  function lastIdx(arr) {
    return arr.length - 1;
  }
  function rangeDiff(range2) {
    return range2.max - range2.min;
  }
  function centerElement(refCenter, element) {
    var delta2 = { y: 0 };
    delta2[axis] = refCenter - center2(element);
    if (delta2[axis]) {
      delta2[OFF_AXIS[axis]] = 0;
      modeling.moveElements([element], delta2, element.parent);
    }
  }
  var firstGroup = groups[0], lastGroupIdx = lastIdx(groups), lastGroup = groups[lastGroupIdx];
  var margin, spaceInBetween, groupsSize = 0;
  forEach$q(groups, function(group, idx) {
    var sortedElements, refElem, refCenter;
    if (group.elements.length < 2) {
      if (idx && idx !== groups.length - 1) {
        updateRange(group, group.elements[0]);
        groupsSize += rangeDiff(group.range);
      }
      return;
    }
    sortedElements = sortBy$2(group.elements, axis);
    refElem = sortedElements[0];
    if (idx === lastGroupIdx) {
      refElem = sortedElements[lastIdx(sortedElements)];
    }
    refCenter = center2(refElem);
    group.range = null;
    forEach$q(sortedElements, function(element) {
      centerElement(refCenter, element);
      if (group.range === null) {
        group.range = {
          min: element[axis],
          max: element[axis] + element[dimension]
        };
        return;
      }
      updateRange(group, element);
    });
    if (idx && idx !== groups.length - 1) {
      groupsSize += rangeDiff(group.range);
    }
  });
  spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);
  margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));
  if (margin < groups.length - 1) {
    return;
  }
  forEach$q(groups, function(group, groupIdx) {
    var delta2 = {}, prevGroup;
    if (group === firstGroup || group === lastGroup) {
      return;
    }
    prevGroup = groups[groupIdx - 1];
    group.range.max = 0;
    forEach$q(group.elements, function(element, idx) {
      delta2[OFF_AXIS[axis]] = 0;
      delta2[axis] = prevGroup.range.max - element[axis] + margin;
      if (group.range.min !== element[axis]) {
        delta2[axis] += element[axis] - group.range.min;
      }
      if (delta2[axis]) {
        modeling.moveElements([element], delta2, element.parent);
      }
      group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);
    });
  });
};
DistributeElements.prototype.postExecute = function(context) {
};
function LayoutConnectionHandler(layouter, canvas) {
  this._layouter = layouter;
  this._canvas = canvas;
}
LayoutConnectionHandler.$inject = ["layouter", "canvas"];
LayoutConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection;
  var oldWaypoints = connection.waypoints;
  assign$e(context, {
    oldWaypoints
  });
  connection.waypoints = this._layouter.layoutConnection(connection, context.hints);
  return connection;
};
LayoutConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection;
  connection.waypoints = context.oldWaypoints;
  return connection;
};
function MoveConnectionHandler() {
}
MoveConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, delta2 = context.delta;
  var newParent = context.newParent || connection.parent, newParentIndex = context.newParentIndex, oldParent = connection.parent;
  context.oldParent = oldParent;
  context.oldParentIndex = remove$3(oldParent.children, connection);
  add$2(newParent.children, connection, newParentIndex);
  connection.parent = newParent;
  forEach$q(connection.waypoints, function(p) {
    p.x += delta2.x;
    p.y += delta2.y;
    if (p.original) {
      p.original.x += delta2.x;
      p.original.y += delta2.y;
    }
  });
  return connection;
};
MoveConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection, newParent = connection.parent, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex, delta2 = context.delta;
  remove$3(newParent.children, connection);
  add$2(oldParent.children, connection, oldParentIndex);
  connection.parent = oldParent;
  forEach$q(connection.waypoints, function(p) {
    p.x -= delta2.x;
    p.y -= delta2.y;
    if (p.original) {
      p.original.x -= delta2.x;
      p.original.y -= delta2.y;
    }
  });
  return connection;
};
function MoveClosure() {
  this.allShapes = {};
  this.allConnections = {};
  this.enclosedElements = {};
  this.enclosedConnections = {};
  this.topLevel = {};
}
MoveClosure.prototype.add = function(element, isTopLevel) {
  return this.addAll([element], isTopLevel);
};
MoveClosure.prototype.addAll = function(elements, isTopLevel) {
  var newClosure = getClosure(elements, !!isTopLevel, this);
  assign$e(this, newClosure);
  return this;
};
function MoveHelper(modeling) {
  this._modeling = modeling;
}
MoveHelper.prototype.moveRecursive = function(elements, delta2, newParent) {
  if (!elements) {
    return [];
  } else {
    return this.moveClosure(this.getClosure(elements), delta2, newParent);
  }
};
MoveHelper.prototype.moveClosure = function(closure, delta2, newParent, newHost, primaryShape) {
  var modeling = this._modeling;
  var allShapes = closure.allShapes, allConnections = closure.allConnections, enclosedConnections = closure.enclosedConnections, topLevel = closure.topLevel, keepParent = false;
  if (primaryShape && primaryShape.parent === newParent) {
    keepParent = true;
  }
  forEach$q(allShapes, function(shape) {
    modeling.moveShape(shape, delta2, topLevel[shape.id] && !keepParent && newParent, {
      recurse: false,
      layout: false
    });
  });
  forEach$q(allConnections, function(c) {
    var sourceMoved = !!allShapes[c.source.id], targetMoved = !!allShapes[c.target.id];
    if (enclosedConnections[c.id] && sourceMoved && targetMoved) {
      modeling.moveConnection(c, delta2, topLevel[c.id] && !keepParent && newParent);
    } else {
      modeling.layoutConnection(c, {
        connectionStart: sourceMoved && getMovedSourceAnchor(c, c.source, delta2),
        connectionEnd: targetMoved && getMovedTargetAnchor(c, c.target, delta2)
      });
    }
  });
};
MoveHelper.prototype.getClosure = function(elements) {
  return new MoveClosure().addAll(elements, true);
};
function MoveElementsHandler(modeling) {
  this._helper = new MoveHelper(modeling);
}
MoveElementsHandler.$inject = ["modeling"];
MoveElementsHandler.prototype.preExecute = function(context) {
  context.closure = this._helper.getClosure(context.shapes);
};
MoveElementsHandler.prototype.postExecute = function(context) {
  var hints = context.hints, primaryShape;
  if (hints && hints.primaryShape) {
    primaryShape = hints.primaryShape;
    hints.oldParent = primaryShape.parent;
  }
  this._helper.moveClosure(context.closure, context.delta, context.newParent, context.newHost, primaryShape);
};
function MoveShapeHandler(modeling) {
  this._modeling = modeling;
  this._helper = new MoveHelper(modeling);
}
MoveShapeHandler.$inject = ["modeling"];
MoveShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, delta2 = context.delta, newParent = context.newParent || shape.parent, newParentIndex = context.newParentIndex, oldParent = shape.parent;
  context.oldBounds = pick$3(shape, ["x", "y", "width", "height"]);
  context.oldParent = oldParent;
  context.oldParentIndex = remove$3(oldParent.children, shape);
  add$2(newParent.children, shape, newParentIndex);
  assign$e(shape, {
    parent: newParent,
    x: shape.x + delta2.x,
    y: shape.y + delta2.y
  });
  return shape;
};
MoveShapeHandler.prototype.postExecute = function(context) {
  var shape = context.shape, delta2 = context.delta, hints = context.hints;
  var modeling = this._modeling;
  if (hints.layout !== false) {
    forEach$q(shape.incoming, function(c) {
      modeling.layoutConnection(c, {
        connectionEnd: getMovedTargetAnchor(c, shape, delta2)
      });
    });
    forEach$q(shape.outgoing, function(c) {
      modeling.layoutConnection(c, {
        connectionStart: getMovedSourceAnchor(c, shape, delta2)
      });
    });
  }
  if (hints.recurse !== false) {
    this.moveChildren(context);
  }
};
MoveShapeHandler.prototype.revert = function(context) {
  var shape = context.shape, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex, delta2 = context.delta;
  add$2(oldParent.children, shape, oldParentIndex);
  assign$e(shape, {
    parent: oldParent,
    x: shape.x - delta2.x,
    y: shape.y - delta2.y
  });
  return shape;
};
MoveShapeHandler.prototype.moveChildren = function(context) {
  var delta2 = context.delta, shape = context.shape;
  this._helper.moveRecursive(shape.children, delta2, null);
};
MoveShapeHandler.prototype.getNewParent = function(context) {
  return context.newParent || context.shape.parent;
};
function ReconnectConnectionHandler(modeling) {
  this._modeling = modeling;
}
ReconnectConnectionHandler.$inject = ["modeling"];
ReconnectConnectionHandler.prototype.execute = function(context) {
  var newSource = context.newSource, newTarget = context.newTarget, connection = context.connection, dockingOrPoints = context.dockingOrPoints;
  if (!newSource && !newTarget) {
    throw new Error("newSource or newTarget required");
  }
  if (isArray$n(dockingOrPoints)) {
    context.oldWaypoints = connection.waypoints;
    connection.waypoints = dockingOrPoints;
  }
  if (newSource) {
    context.oldSource = connection.source;
    connection.source = newSource;
  }
  if (newTarget) {
    context.oldTarget = connection.target;
    connection.target = newTarget;
  }
  return connection;
};
ReconnectConnectionHandler.prototype.postExecute = function(context) {
  var connection = context.connection, newSource = context.newSource, newTarget = context.newTarget, dockingOrPoints = context.dockingOrPoints, hints = context.hints || {};
  var layoutConnectionHints = {};
  if (hints.connectionStart) {
    layoutConnectionHints.connectionStart = hints.connectionStart;
  }
  if (hints.connectionEnd) {
    layoutConnectionHints.connectionEnd = hints.connectionEnd;
  }
  if (hints.layoutConnection === false) {
    return;
  }
  if (newSource && (!newTarget || hints.docking === "source")) {
    layoutConnectionHints.connectionStart = layoutConnectionHints.connectionStart || getDocking(isArray$n(dockingOrPoints) ? dockingOrPoints[0] : dockingOrPoints);
  }
  if (newTarget && (!newSource || hints.docking === "target")) {
    layoutConnectionHints.connectionEnd = layoutConnectionHints.connectionEnd || getDocking(isArray$n(dockingOrPoints) ? dockingOrPoints[dockingOrPoints.length - 1] : dockingOrPoints);
  }
  if (hints.newWaypoints) {
    layoutConnectionHints.waypoints = hints.newWaypoints;
  }
  this._modeling.layoutConnection(connection, layoutConnectionHints);
};
ReconnectConnectionHandler.prototype.revert = function(context) {
  var oldSource = context.oldSource, oldTarget = context.oldTarget, oldWaypoints = context.oldWaypoints, connection = context.connection;
  if (oldSource) {
    connection.source = oldSource;
  }
  if (oldTarget) {
    connection.target = oldTarget;
  }
  if (oldWaypoints) {
    connection.waypoints = oldWaypoints;
  }
  return connection;
};
function getDocking(point) {
  return point.original || point;
}
function ReplaceShapeHandler(modeling, rules) {
  this._modeling = modeling;
  this._rules = rules;
}
ReplaceShapeHandler.$inject = ["modeling", "rules"];
ReplaceShapeHandler.prototype.preExecute = function(context) {
  var self2 = this, modeling = this._modeling, rules = this._rules;
  var oldShape = context.oldShape, newData = context.newData, hints = context.hints || {}, newShape;
  function canReconnect(source, target, connection) {
    return rules.allowed("connection.reconnect", {
      connection,
      source,
      target
    });
  }
  var position = {
    x: newData.x,
    y: newData.y
  };
  var oldBounds = {
    x: oldShape.x,
    y: oldShape.y,
    width: oldShape.width,
    height: oldShape.height
  };
  newShape = context.newShape = context.newShape || self2.createShape(newData, position, oldShape.parent, hints);
  if (oldShape.host) {
    modeling.updateAttachment(newShape, oldShape.host);
  }
  var children;
  if (hints.moveChildren !== false) {
    children = oldShape.children.slice();
    modeling.moveElements(children, { x: 0, y: 0 }, newShape, hints);
  }
  var incoming = oldShape.incoming.slice(), outgoing = oldShape.outgoing.slice();
  forEach$q(incoming, function(connection) {
    var source = connection.source, allowed = canReconnect(source, newShape, connection);
    if (allowed) {
      self2.reconnectEnd(connection, newShape, getResizedTargetAnchor(connection, newShape, oldBounds), hints);
    }
  });
  forEach$q(outgoing, function(connection) {
    var target = connection.target, allowed = canReconnect(newShape, target, connection);
    if (allowed) {
      self2.reconnectStart(connection, newShape, getResizedSourceAnchor(connection, newShape, oldBounds), hints);
    }
  });
};
ReplaceShapeHandler.prototype.postExecute = function(context) {
  var oldShape = context.oldShape;
  this._modeling.removeShape(oldShape);
};
ReplaceShapeHandler.prototype.execute = function(context) {
};
ReplaceShapeHandler.prototype.revert = function(context) {
};
ReplaceShapeHandler.prototype.createShape = function(shape, position, target, hints) {
  return this._modeling.createShape(shape, position, target, hints);
};
ReplaceShapeHandler.prototype.reconnectStart = function(connection, newSource, dockingPoint, hints) {
  this._modeling.reconnectStart(connection, newSource, dockingPoint, hints);
};
ReplaceShapeHandler.prototype.reconnectEnd = function(connection, newTarget, dockingPoint, hints) {
  this._modeling.reconnectEnd(connection, newTarget, dockingPoint, hints);
};
function ResizeShapeHandler(modeling) {
  this._modeling = modeling;
}
ResizeShapeHandler.$inject = ["modeling"];
ResizeShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, newBounds = context.newBounds, minBounds = context.minBounds;
  if (newBounds.x === void 0 || newBounds.y === void 0 || newBounds.width === void 0 || newBounds.height === void 0) {
    throw new Error("newBounds must have {x, y, width, height} properties");
  }
  if (minBounds && (newBounds.width < minBounds.width || newBounds.height < minBounds.height)) {
    throw new Error("width and height cannot be less than minimum height and width");
  } else if (!minBounds && newBounds.width < 10 || newBounds.height < 10) {
    throw new Error("width and height cannot be less than 10px");
  }
  context.oldBounds = {
    width: shape.width,
    height: shape.height,
    x: shape.x,
    y: shape.y
  };
  assign$e(shape, {
    width: newBounds.width,
    height: newBounds.height,
    x: newBounds.x,
    y: newBounds.y
  });
  return shape;
};
ResizeShapeHandler.prototype.postExecute = function(context) {
  var modeling = this._modeling;
  var shape = context.shape, oldBounds = context.oldBounds, hints = context.hints || {};
  if (hints.layout === false) {
    return;
  }
  forEach$q(shape.incoming, function(c) {
    modeling.layoutConnection(c, {
      connectionEnd: getResizedTargetAnchor(c, shape, oldBounds)
    });
  });
  forEach$q(shape.outgoing, function(c) {
    modeling.layoutConnection(c, {
      connectionStart: getResizedSourceAnchor(c, shape, oldBounds)
    });
  });
};
ResizeShapeHandler.prototype.revert = function(context) {
  var shape = context.shape, oldBounds = context.oldBounds;
  assign$e(shape, {
    width: oldBounds.width,
    height: oldBounds.height,
    x: oldBounds.x,
    y: oldBounds.y
  });
  return shape;
};
function SpaceToolHandler(modeling) {
  this._modeling = modeling;
}
SpaceToolHandler.$inject = ["modeling"];
SpaceToolHandler.prototype.preExecute = function(context) {
  var delta2 = context.delta, direction = context.direction, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes, start = context.start, oldBounds = {};
  this.moveShapes(movingShapes, delta2);
  forEach$q(resizingShapes, function(shape) {
    oldBounds[shape.id] = getBounds(shape);
  });
  this.resizeShapes(resizingShapes, delta2, direction);
  this.updateConnectionWaypoints(getWaypointsUpdatingConnections(movingShapes, resizingShapes), delta2, direction, start, movingShapes, resizingShapes, oldBounds);
};
SpaceToolHandler.prototype.execute = function() {
};
SpaceToolHandler.prototype.revert = function() {
};
SpaceToolHandler.prototype.moveShapes = function(shapes, delta2) {
  var self2 = this;
  forEach$q(shapes, function(element) {
    self2._modeling.moveShape(element, delta2, null, {
      autoResize: false,
      layout: false,
      recurse: false
    });
  });
};
SpaceToolHandler.prototype.resizeShapes = function(shapes, delta2, direction) {
  var self2 = this;
  forEach$q(shapes, function(shape) {
    var newBounds = resizeBounds(shape, direction, delta2);
    self2._modeling.resizeShape(shape, newBounds, null, {
      attachSupport: false,
      autoResize: false,
      layout: false
    });
  });
};
SpaceToolHandler.prototype.updateConnectionWaypoints = function(connections, delta2, direction, start, movingShapes, resizingShapes, oldBounds) {
  var self2 = this, affectedShapes = movingShapes.concat(resizingShapes);
  forEach$q(connections, function(connection) {
    var source = connection.source, target = connection.target, waypoints = copyWaypoints(connection), axis = getAxisFromDirection(direction), layoutHints = {
      labelBehavior: false
    };
    if (includes$1(affectedShapes, source) && includes$1(affectedShapes, target)) {
      waypoints = map$7(waypoints, function(waypoint) {
        if (shouldMoveWaypoint(waypoint, start, direction)) {
          waypoint[axis] = waypoint[axis] + delta2[axis];
        }
        if (waypoint.original && shouldMoveWaypoint(waypoint.original, start, direction)) {
          waypoint.original[axis] = waypoint.original[axis] + delta2[axis];
        }
        return waypoint;
      });
      self2._modeling.updateWaypoints(connection, waypoints, {
        labelBehavior: false
      });
    } else if (includes$1(affectedShapes, source) || includes$1(affectedShapes, target)) {
      if (includes$1(movingShapes, source)) {
        layoutHints.connectionStart = getMovedSourceAnchor(connection, source, delta2);
      } else if (includes$1(movingShapes, target)) {
        layoutHints.connectionEnd = getMovedTargetAnchor(connection, target, delta2);
      } else if (includes$1(resizingShapes, source)) {
        layoutHints.connectionStart = getResizedSourceAnchor(connection, source, oldBounds[source.id]);
      } else if (includes$1(resizingShapes, target)) {
        layoutHints.connectionEnd = getResizedTargetAnchor(connection, target, oldBounds[target.id]);
      }
      self2._modeling.layoutConnection(connection, layoutHints);
    }
  });
};
function copyWaypoint(waypoint) {
  return assign$e({}, waypoint);
}
function copyWaypoints(connection) {
  return map$7(connection.waypoints, function(waypoint) {
    waypoint = copyWaypoint(waypoint);
    if (waypoint.original) {
      waypoint.original = copyWaypoint(waypoint.original);
    }
    return waypoint;
  });
}
function getAxisFromDirection(direction) {
  switch (direction) {
    case "n":
      return "y";
    case "w":
      return "x";
    case "s":
      return "y";
    case "e":
      return "x";
  }
}
function shouldMoveWaypoint(waypoint, start, direction) {
  var relevantAxis = getAxisFromDirection(direction);
  if (/e|s/.test(direction)) {
    return waypoint[relevantAxis] > start;
  } else if (/n|w/.test(direction)) {
    return waypoint[relevantAxis] < start;
  }
}
function includes$1(array, item) {
  return array.indexOf(item) !== -1;
}
function getBounds(shape) {
  return {
    x: shape.x,
    y: shape.y,
    height: shape.height,
    width: shape.width
  };
}
function ToggleShapeCollapseHandler(modeling) {
  this._modeling = modeling;
}
ToggleShapeCollapseHandler.$inject = ["modeling"];
ToggleShapeCollapseHandler.prototype.execute = function(context) {
  var shape = context.shape, children = shape.children;
  context.oldChildrenVisibility = getElementsVisibilityRecursive(children);
  shape.collapsed = !shape.collapsed;
  var result = setHiddenRecursive(children, shape.collapsed);
  return [shape].concat(result);
};
ToggleShapeCollapseHandler.prototype.revert = function(context) {
  var shape = context.shape, oldChildrenVisibility = context.oldChildrenVisibility;
  var children = shape.children;
  var result = restoreVisibilityRecursive(children, oldChildrenVisibility);
  shape.collapsed = !shape.collapsed;
  return [shape].concat(result);
};
function getElementsVisibilityRecursive(elements) {
  var result = {};
  forEach$q(elements, function(element) {
    result[element.id] = element.hidden;
    if (element.children) {
      result = assign$e({}, result, getElementsVisibilityRecursive(element.children));
    }
  });
  return result;
}
function setHiddenRecursive(elements, newHidden) {
  var result = [];
  forEach$q(elements, function(element) {
    element.hidden = newHidden;
    result = result.concat(element);
    if (element.children) {
      result = result.concat(setHiddenRecursive(element.children, element.collapsed || newHidden));
    }
  });
  return result;
}
function restoreVisibilityRecursive(elements, lastState) {
  var result = [];
  forEach$q(elements, function(element) {
    element.hidden = lastState[element.id];
    result = result.concat(element);
    if (element.children) {
      result = result.concat(restoreVisibilityRecursive(element.children, lastState));
    }
  });
  return result;
}
function UpdateAttachmentHandler(modeling) {
  this._modeling = modeling;
}
UpdateAttachmentHandler.$inject = ["modeling"];
UpdateAttachmentHandler.prototype.execute = function(context) {
  var shape = context.shape, newHost = context.newHost, oldHost = shape.host;
  context.oldHost = oldHost;
  context.attacherIdx = removeAttacher(oldHost, shape);
  addAttacher(newHost, shape);
  shape.host = newHost;
  return shape;
};
UpdateAttachmentHandler.prototype.revert = function(context) {
  var shape = context.shape, newHost = context.newHost, oldHost = context.oldHost, attacherIdx = context.attacherIdx;
  shape.host = oldHost;
  removeAttacher(newHost, shape);
  addAttacher(oldHost, shape, attacherIdx);
  return shape;
};
function removeAttacher(host, attacher) {
  return remove$3(host && host.attachers, attacher);
}
function addAttacher(host, attacher, idx) {
  if (!host) {
    return;
  }
  var attachers = host.attachers;
  if (!attachers) {
    host.attachers = attachers = [];
  }
  add$2(attachers, attacher, idx);
}
function UpdateWaypointsHandler() {
}
UpdateWaypointsHandler.prototype.execute = function(context) {
  var connection = context.connection, newWaypoints = context.newWaypoints;
  context.oldWaypoints = connection.waypoints;
  connection.waypoints = newWaypoints;
  return connection;
};
UpdateWaypointsHandler.prototype.revert = function(context) {
  var connection = context.connection, oldWaypoints = context.oldWaypoints;
  connection.waypoints = oldWaypoints;
  return connection;
};
function Modeling$1(eventBus, elementFactory, commandStack) {
  this._eventBus = eventBus;
  this._elementFactory = elementFactory;
  this._commandStack = commandStack;
  var self2 = this;
  eventBus.on("diagram.init", function() {
    self2.registerHandlers(commandStack);
  });
}
Modeling$1.$inject = ["eventBus", "elementFactory", "commandStack"];
Modeling$1.prototype.getHandlers = function() {
  return {
    "shape.append": AppendShapeHandler,
    "shape.create": CreateShapeHandler,
    "shape.delete": DeleteShapeHandler,
    "shape.move": MoveShapeHandler,
    "shape.resize": ResizeShapeHandler,
    "shape.replace": ReplaceShapeHandler,
    "shape.toggleCollapse": ToggleShapeCollapseHandler,
    "spaceTool": SpaceToolHandler,
    "label.create": CreateLabelHandler,
    "connection.create": CreateConnectionHandler,
    "connection.delete": DeleteConnectionHandler,
    "connection.move": MoveConnectionHandler,
    "connection.layout": LayoutConnectionHandler,
    "connection.updateWaypoints": UpdateWaypointsHandler,
    "connection.reconnect": ReconnectConnectionHandler,
    "elements.create": CreateElementsHandler,
    "elements.move": MoveElementsHandler,
    "elements.delete": DeleteElementsHandler,
    "elements.distribute": DistributeElements,
    "elements.align": AlignElements,
    "element.updateAttachment": UpdateAttachmentHandler
  };
};
Modeling$1.prototype.registerHandlers = function(commandStack) {
  forEach$q(this.getHandlers(), function(handler, id2) {
    commandStack.registerHandler(id2, handler);
  });
};
Modeling$1.prototype.moveShape = function(shape, delta2, newParent, newParentIndex, hints) {
  if (typeof newParentIndex === "object") {
    hints = newParentIndex;
    newParentIndex = null;
  }
  var context = {
    shape,
    delta: delta2,
    newParent,
    newParentIndex,
    hints: hints || {}
  };
  this._commandStack.execute("shape.move", context);
};
Modeling$1.prototype.updateAttachment = function(shape, newHost) {
  var context = {
    shape,
    newHost
  };
  this._commandStack.execute("element.updateAttachment", context);
};
Modeling$1.prototype.moveElements = function(shapes, delta2, target, hints) {
  hints = hints || {};
  var attach = hints.attach;
  var newParent = target, newHost;
  if (attach === true) {
    newHost = target;
    newParent = target.parent;
  } else if (attach === false) {
    newHost = null;
  }
  var context = {
    shapes,
    delta: delta2,
    newParent,
    newHost,
    hints
  };
  this._commandStack.execute("elements.move", context);
};
Modeling$1.prototype.moveConnection = function(connection, delta2, newParent, newParentIndex, hints) {
  if (typeof newParentIndex === "object") {
    hints = newParentIndex;
    newParentIndex = void 0;
  }
  var context = {
    connection,
    delta: delta2,
    newParent,
    newParentIndex,
    hints: hints || {}
  };
  this._commandStack.execute("connection.move", context);
};
Modeling$1.prototype.layoutConnection = function(connection, hints) {
  var context = {
    connection,
    hints: hints || {}
  };
  this._commandStack.execute("connection.layout", context);
};
Modeling$1.prototype.createConnection = function(source, target, parentIndex, connection, parent2, hints) {
  if (typeof parentIndex === "object") {
    hints = parent2;
    parent2 = connection;
    connection = parentIndex;
    parentIndex = void 0;
  }
  connection = this._create("connection", connection);
  var context = {
    source,
    target,
    parent: parent2,
    parentIndex,
    connection,
    hints
  };
  this._commandStack.execute("connection.create", context);
  return context.connection;
};
Modeling$1.prototype.createShape = function(shape, position, target, parentIndex, hints) {
  if (typeof parentIndex !== "number") {
    hints = parentIndex;
    parentIndex = void 0;
  }
  hints = hints || {};
  var attach = hints.attach, parent2, host;
  shape = this._create("shape", shape);
  if (attach) {
    parent2 = target.parent;
    host = target;
  } else {
    parent2 = target;
  }
  var context = {
    position,
    shape,
    parent: parent2,
    parentIndex,
    host,
    hints
  };
  this._commandStack.execute("shape.create", context);
  return context.shape;
};
Modeling$1.prototype.createElements = function(elements, position, parent2, parentIndex, hints) {
  if (!isArray$n(elements)) {
    elements = [elements];
  }
  if (typeof parentIndex !== "number") {
    hints = parentIndex;
    parentIndex = void 0;
  }
  hints = hints || {};
  var context = {
    position,
    elements,
    parent: parent2,
    parentIndex,
    hints
  };
  this._commandStack.execute("elements.create", context);
  return context.elements;
};
Modeling$1.prototype.createLabel = function(labelTarget, position, label2, parent2) {
  label2 = this._create("label", label2);
  var context = {
    labelTarget,
    position,
    parent: parent2 || labelTarget.parent,
    shape: label2
  };
  this._commandStack.execute("label.create", context);
  return context.shape;
};
Modeling$1.prototype.appendShape = function(source, shape, position, target, hints) {
  hints = hints || {};
  shape = this._create("shape", shape);
  var context = {
    source,
    position,
    target,
    shape,
    connection: hints.connection,
    connectionParent: hints.connectionParent,
    hints
  };
  this._commandStack.execute("shape.append", context);
  return context.shape;
};
Modeling$1.prototype.removeElements = function(elements) {
  var context = {
    elements
  };
  this._commandStack.execute("elements.delete", context);
};
Modeling$1.prototype.distributeElements = function(groups, axis, dimension) {
  var context = {
    groups,
    axis,
    dimension
  };
  this._commandStack.execute("elements.distribute", context);
};
Modeling$1.prototype.removeShape = function(shape, hints) {
  var context = {
    shape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.delete", context);
};
Modeling$1.prototype.removeConnection = function(connection, hints) {
  var context = {
    connection,
    hints: hints || {}
  };
  this._commandStack.execute("connection.delete", context);
};
Modeling$1.prototype.replaceShape = function(oldShape, newShape, hints) {
  var context = {
    oldShape,
    newData: newShape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.replace", context);
  return context.newShape;
};
Modeling$1.prototype.alignElements = function(elements, alignment) {
  var context = {
    elements,
    alignment
  };
  this._commandStack.execute("elements.align", context);
};
Modeling$1.prototype.resizeShape = function(shape, newBounds, minBounds, hints) {
  var context = {
    shape,
    newBounds,
    minBounds,
    hints
  };
  this._commandStack.execute("shape.resize", context);
};
Modeling$1.prototype.createSpace = function(movingShapes, resizingShapes, delta2, direction, start) {
  var context = {
    delta: delta2,
    direction,
    movingShapes,
    resizingShapes,
    start
  };
  this._commandStack.execute("spaceTool", context);
};
Modeling$1.prototype.updateWaypoints = function(connection, newWaypoints, hints) {
  var context = {
    connection,
    newWaypoints,
    hints: hints || {}
  };
  this._commandStack.execute("connection.updateWaypoints", context);
};
Modeling$1.prototype.reconnect = function(connection, source, target, dockingOrPoints, hints) {
  var context = {
    connection,
    newSource: source,
    newTarget: target,
    dockingOrPoints,
    hints: hints || {}
  };
  this._commandStack.execute("connection.reconnect", context);
};
Modeling$1.prototype.reconnectStart = function(connection, newSource, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }
  this.reconnect(connection, newSource, connection.target, dockingOrPoints, assign$e(hints, {
    docking: "source"
  }));
};
Modeling$1.prototype.reconnectEnd = function(connection, newTarget, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }
  this.reconnect(connection, connection.source, newTarget, dockingOrPoints, assign$e(hints, {
    docking: "target"
  }));
};
Modeling$1.prototype.connect = function(source, target, attrs, hints) {
  return this.createConnection(source, target, attrs || {}, source.parent, hints);
};
Modeling$1.prototype._create = function(type, attrs) {
  if (attrs instanceof Base$1) {
    return attrs;
  } else {
    return this._elementFactory.create(type, attrs);
  }
};
Modeling$1.prototype.toggleCollapse = function(shape, hints) {
  var context = {
    shape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.toggleCollapse", context);
};
function UpdateModdlePropertiesHandler(elementRegistry) {
  this._elementRegistry = elementRegistry;
}
UpdateModdlePropertiesHandler.$inject = ["elementRegistry"];
UpdateModdlePropertiesHandler.prototype.execute = function(context) {
  var element = context.element, moddleElement = context.moddleElement, properties2 = context.properties;
  if (!moddleElement) {
    throw new Error("<moddleElement> required");
  }
  var changed = context.changed || this.getVisualReferences(moddleElement).concat(element);
  var oldProperties = context.oldProperties || getModdleProperties(moddleElement, keys$d(properties2));
  setModdleProperties(moddleElement, properties2);
  context.oldProperties = oldProperties;
  context.changed = changed;
  return changed;
};
UpdateModdlePropertiesHandler.prototype.revert = function(context) {
  var oldProperties = context.oldProperties, moddleElement = context.moddleElement, changed = context.changed;
  setModdleProperties(moddleElement, oldProperties);
  return changed;
};
UpdateModdlePropertiesHandler.prototype.getVisualReferences = function(moddleElement) {
  var elementRegistry = this._elementRegistry;
  if (is$O(moddleElement, "bpmn:DataObject")) {
    return getAllDataObjectReferences(moddleElement, elementRegistry);
  }
  return [];
};
function getModdleProperties(moddleElement, propertyNames) {
  return reduce$3(propertyNames, function(result, key) {
    result[key] = moddleElement.get(key);
    return result;
  }, {});
}
function setModdleProperties(moddleElement, properties2) {
  forEach$q(properties2, function(value, key) {
    moddleElement.set(key, value);
  });
}
function getAllDataObjectReferences(dataObject, elementRegistry) {
  return elementRegistry.filter(function(element) {
    return is$O(element, "bpmn:DataObjectReference") && getBusinessObject$V(element).dataObjectRef === dataObject;
  });
}
var DEFAULT_FLOW = "default", ID = "id", DI = "di";
var NULL_DIMENSIONS$1 = {
  width: 0,
  height: 0
};
function UpdatePropertiesHandler(elementRegistry, moddle, translate2, modeling, textRenderer) {
  this._elementRegistry = elementRegistry;
  this._moddle = moddle;
  this._translate = translate2;
  this._modeling = modeling;
  this._textRenderer = textRenderer;
}
UpdatePropertiesHandler.$inject = [
  "elementRegistry",
  "moddle",
  "translate",
  "modeling",
  "textRenderer"
];
UpdatePropertiesHandler.prototype.execute = function(context) {
  var element = context.element, changed = [element], translate2 = this._translate;
  if (!element) {
    throw new Error(translate2("element required"));
  }
  var elementRegistry = this._elementRegistry, ids2 = this._moddle.ids;
  var businessObject = element.businessObject, properties2 = unwrapBusinessObjects(context.properties), oldProperties = context.oldProperties || getProperties$1(businessObject, properties2);
  if (isIdChange(properties2, businessObject)) {
    ids2.unclaim(businessObject[ID]);
    elementRegistry.updateId(element, properties2[ID]);
    ids2.claim(properties2[ID], businessObject);
  }
  if (DEFAULT_FLOW in properties2) {
    if (properties2[DEFAULT_FLOW]) {
      changed.push(elementRegistry.get(properties2[DEFAULT_FLOW].id));
    }
    if (businessObject[DEFAULT_FLOW]) {
      changed.push(elementRegistry.get(businessObject[DEFAULT_FLOW].id));
    }
  }
  setProperties$1(businessObject, properties2);
  context.oldProperties = oldProperties;
  context.changed = changed;
  return changed;
};
UpdatePropertiesHandler.prototype.postExecute = function(context) {
  var element = context.element, label2 = element.label;
  var text = label2 && getBusinessObject$V(label2).name;
  if (!text) {
    return;
  }
  var newLabelBounds = this._textRenderer.getExternalLabelBounds(label2, text);
  this._modeling.resizeShape(label2, newLabelBounds, NULL_DIMENSIONS$1);
};
UpdatePropertiesHandler.prototype.revert = function(context) {
  var element = context.element, properties2 = context.properties, oldProperties = context.oldProperties, businessObject = element.businessObject, elementRegistry = this._elementRegistry, ids2 = this._moddle.ids;
  setProperties$1(businessObject, oldProperties);
  if (isIdChange(properties2, businessObject)) {
    ids2.unclaim(properties2[ID]);
    elementRegistry.updateId(element, oldProperties[ID]);
    ids2.claim(oldProperties[ID], businessObject);
  }
  return context.changed;
};
function isIdChange(properties2, businessObject) {
  return ID in properties2 && properties2[ID] !== businessObject[ID];
}
function getProperties$1(businessObject, properties2) {
  var propertyNames = keys$d(properties2);
  return reduce$3(propertyNames, function(result, key) {
    if (key !== DI) {
      result[key] = businessObject.get(key);
    } else {
      result[key] = getDiProperties(businessObject.di, keys$d(properties2.di));
    }
    return result;
  }, {});
}
function getDiProperties(di, propertyNames) {
  return reduce$3(propertyNames, function(result, key) {
    result[key] = di.get(key);
    return result;
  }, {});
}
function setProperties$1(businessObject, properties2) {
  forEach$q(properties2, function(value, key) {
    if (key !== DI) {
      businessObject.set(key, value);
    } else {
      if (businessObject.di) {
        setDiProperties(businessObject.di, value);
      }
    }
  });
}
function setDiProperties(di, properties2) {
  forEach$q(properties2, function(value, key) {
    di.set(key, value);
  });
}
var referencePropertyNames = ["default"];
function unwrapBusinessObjects(properties2) {
  var unwrappedProps = assign$e({}, properties2);
  referencePropertyNames.forEach(function(name2) {
    if (name2 in properties2) {
      unwrappedProps[name2] = getBusinessObject$V(unwrappedProps[name2]);
    }
  });
  return unwrappedProps;
}
function UpdateCanvasRootHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
UpdateCanvasRootHandler.$inject = [
  "canvas",
  "modeling"
];
UpdateCanvasRootHandler.prototype.execute = function(context) {
  var canvas = this._canvas;
  var newRoot = context.newRoot, newRootBusinessObject = newRoot.businessObject, oldRoot = canvas.getRootElement(), oldRootBusinessObject = oldRoot.businessObject, bpmnDefinitions = oldRootBusinessObject.$parent, diPlane = oldRootBusinessObject.di;
  canvas.setRootElement(newRoot, true);
  add$2(bpmnDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = bpmnDefinitions;
  remove$3(bpmnDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = null;
  oldRootBusinessObject.di = null;
  diPlane.bpmnElement = newRootBusinessObject;
  newRootBusinessObject.di = diPlane;
  context.oldRoot = oldRoot;
};
UpdateCanvasRootHandler.prototype.revert = function(context) {
  var canvas = this._canvas;
  var newRoot = context.newRoot, newRootBusinessObject = newRoot.businessObject, oldRoot = context.oldRoot, oldRootBusinessObject = oldRoot.businessObject, bpmnDefinitions = newRootBusinessObject.$parent, diPlane = newRootBusinessObject.di;
  canvas.setRootElement(oldRoot, true);
  remove$3(bpmnDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = null;
  add$2(bpmnDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = bpmnDefinitions;
  newRootBusinessObject.di = null;
  diPlane.bpmnElement = oldRootBusinessObject;
  oldRootBusinessObject.di = diPlane;
};
function AddLaneHandler(modeling, spaceTool) {
  this._modeling = modeling;
  this._spaceTool = spaceTool;
}
AddLaneHandler.$inject = [
  "modeling",
  "spaceTool"
];
AddLaneHandler.prototype.preExecute = function(context) {
  var spaceTool = this._spaceTool, modeling = this._modeling;
  var shape = context.shape, location = context.location;
  var lanesRoot = getLanesRoot(shape);
  var isRoot = lanesRoot === shape, laneParent = isRoot ? shape : shape.parent;
  var existingChildLanes = getChildLanes(laneParent);
  if (!existingChildLanes.length) {
    modeling.createShape({ type: "bpmn:Lane" }, {
      x: shape.x + LANE_INDENTATION,
      y: shape.y,
      width: shape.width - LANE_INDENTATION,
      height: shape.height
    }, laneParent);
  }
  var allAffected = [];
  eachElement$1(lanesRoot, function(element) {
    allAffected.push(element);
    if (element.label) {
      allAffected.push(element.label);
    }
    if (element === shape) {
      return [];
    }
    return filter$a(element.children, function(c) {
      return c !== shape;
    });
  });
  var offset2 = location === "top" ? -120 : 120, lanePosition = location === "top" ? shape.y : shape.y + shape.height, spacePos = lanePosition + (location === "top" ? 10 : -10), direction = location === "top" ? "n" : "s";
  var adjustments = spaceTool.calculateAdjustments(allAffected, "y", offset2, spacePos);
  spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: offset2 }, direction, spacePos);
  context.newLane = modeling.createShape({ type: "bpmn:Lane" }, {
    x: shape.x + (isRoot ? LANE_INDENTATION : 0),
    y: lanePosition - (location === "top" ? 120 : 0),
    width: shape.width - (isRoot ? LANE_INDENTATION : 0),
    height: 120
  }, laneParent);
};
function SplitLaneHandler(modeling, translate2) {
  this._modeling = modeling;
  this._translate = translate2;
}
SplitLaneHandler.$inject = [
  "modeling",
  "translate"
];
SplitLaneHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling, translate2 = this._translate;
  var shape = context.shape, newLanesCount = context.count;
  var childLanes = getChildLanes(shape), existingLanesCount = childLanes.length;
  if (existingLanesCount > newLanesCount) {
    throw new Error(translate2("more than {count} child lanes", { count: newLanesCount }));
  }
  var newLanesHeight = Math.round(shape.height / newLanesCount);
  var laneY, laneHeight, laneBounds, newLaneAttrs, idx;
  for (idx = 0; idx < newLanesCount; idx++) {
    laneY = shape.y + idx * newLanesHeight;
    if (idx === newLanesCount - 1) {
      laneHeight = shape.height - newLanesHeight * idx;
    } else {
      laneHeight = newLanesHeight;
    }
    laneBounds = {
      x: shape.x + LANE_INDENTATION,
      y: laneY,
      width: shape.width - LANE_INDENTATION,
      height: laneHeight
    };
    if (idx < existingLanesCount) {
      modeling.resizeShape(childLanes[idx], laneBounds);
    } else {
      newLaneAttrs = {
        type: "bpmn:Lane"
      };
      modeling.createShape(newLaneAttrs, laneBounds, shape);
    }
  }
};
function ResizeLaneHandler(modeling, spaceTool) {
  this._modeling = modeling;
  this._spaceTool = spaceTool;
}
ResizeLaneHandler.$inject = [
  "modeling",
  "spaceTool"
];
ResizeLaneHandler.prototype.preExecute = function(context) {
  var shape = context.shape, newBounds = context.newBounds, balanced = context.balanced;
  if (balanced !== false) {
    this.resizeBalanced(shape, newBounds);
  } else {
    this.resizeSpace(shape, newBounds);
  }
};
ResizeLaneHandler.prototype.resizeBalanced = function(shape, newBounds) {
  var modeling = this._modeling;
  var resizeNeeded = computeLanesResize(shape, newBounds);
  modeling.resizeShape(shape, newBounds);
  resizeNeeded.forEach(function(r) {
    modeling.resizeShape(r.shape, r.newBounds);
  });
};
ResizeLaneHandler.prototype.resizeSpace = function(shape, newBounds) {
  var spaceTool = this._spaceTool;
  var shapeTrbl = asTRBL(shape), newTrbl = asTRBL(newBounds);
  var trblDiff = substractTRBL(newTrbl, shapeTrbl);
  var lanesRoot = getLanesRoot(shape);
  var allAffected = [], allLanes = [];
  eachElement$1(lanesRoot, function(element) {
    allAffected.push(element);
    if (is$O(element, "bpmn:Lane") || is$O(element, "bpmn:Participant")) {
      allLanes.push(element);
    }
    return element.children;
  });
  var change, spacePos, direction, offset2, adjustments;
  if (trblDiff.bottom || trblDiff.top) {
    change = trblDiff.bottom || trblDiff.top;
    spacePos = shape.y + (trblDiff.bottom ? shape.height : 0) + (trblDiff.bottom ? -10 : 10);
    direction = trblDiff.bottom ? "s" : "n";
    offset2 = trblDiff.top > 0 || trblDiff.bottom < 0 ? -change : change;
    adjustments = spaceTool.calculateAdjustments(allAffected, "y", offset2, spacePos);
    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: change }, direction);
  }
  if (trblDiff.left || trblDiff.right) {
    change = trblDiff.right || trblDiff.left;
    spacePos = shape.x + (trblDiff.right ? shape.width : 0) + (trblDiff.right ? -10 : 100);
    direction = trblDiff.right ? "e" : "w";
    offset2 = trblDiff.left > 0 || trblDiff.right < 0 ? -change : change;
    adjustments = spaceTool.calculateAdjustments(allLanes, "x", offset2, spacePos);
    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: change, y: 0 }, direction);
  }
};
var FLOW_NODE_REFS_ATTR = "flowNodeRef", LANES_ATTR = "lanes";
function UpdateFlowNodeRefsHandler(elementRegistry) {
  this._elementRegistry = elementRegistry;
}
UpdateFlowNodeRefsHandler.$inject = [
  "elementRegistry"
];
UpdateFlowNodeRefsHandler.prototype.computeUpdates = function(flowNodeShapes, laneShapes) {
  var handledNodes = [];
  var updates = [];
  var participantCache = {};
  var allFlowNodeShapes = [];
  function isInLaneShape(element, laneShape) {
    var laneTrbl = asTRBL(laneShape);
    var elementMid = {
      x: element.x + element.width / 2,
      y: element.y + element.height / 2
    };
    return elementMid.x > laneTrbl.left && elementMid.x < laneTrbl.right && elementMid.y > laneTrbl.top && elementMid.y < laneTrbl.bottom;
  }
  function addFlowNodeShape(flowNodeShape) {
    if (handledNodes.indexOf(flowNodeShape) === -1) {
      allFlowNodeShapes.push(flowNodeShape);
      handledNodes.push(flowNodeShape);
    }
  }
  function getAllLaneShapes(flowNodeShape) {
    var root2 = getLanesRoot(flowNodeShape);
    if (!participantCache[root2.id]) {
      participantCache[root2.id] = collectLanes(root2);
    }
    return participantCache[root2.id];
  }
  function getNewLanes(flowNodeShape) {
    if (!flowNodeShape.parent) {
      return [];
    }
    var allLaneShapes = getAllLaneShapes(flowNodeShape);
    return allLaneShapes.filter(function(l) {
      return isInLaneShape(flowNodeShape, l);
    }).map(function(shape) {
      return shape.businessObject;
    });
  }
  laneShapes.forEach(function(laneShape) {
    var root2 = getLanesRoot(laneShape);
    if (!root2 || handledNodes.indexOf(root2) !== -1) {
      return;
    }
    var children = root2.children.filter(function(c) {
      return is$O(c, "bpmn:FlowNode");
    });
    children.forEach(addFlowNodeShape);
    handledNodes.push(root2);
  });
  flowNodeShapes.forEach(addFlowNodeShape);
  allFlowNodeShapes.forEach(function(flowNodeShape) {
    var flowNode = flowNodeShape.businessObject;
    var lanes = flowNode.get(LANES_ATTR), remove2 = lanes.slice(), add2 = getNewLanes(flowNodeShape);
    updates.push({ flowNode, remove: remove2, add: add2 });
  });
  laneShapes.forEach(function(laneShape) {
    var lane = laneShape.businessObject;
    if (!laneShape.parent) {
      lane.get(FLOW_NODE_REFS_ATTR).forEach(function(flowNode) {
        updates.push({ flowNode, remove: [lane], add: [] });
      });
    }
  });
  return updates;
};
UpdateFlowNodeRefsHandler.prototype.execute = function(context) {
  var updates = context.updates;
  if (!updates) {
    updates = context.updates = this.computeUpdates(context.flowNodeShapes, context.laneShapes);
  }
  updates.forEach(function(update2) {
    var flowNode = update2.flowNode, lanes = flowNode.get(LANES_ATTR);
    update2.remove.forEach(function(oldLane) {
      remove$3(lanes, oldLane);
      remove$3(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
    update2.add.forEach(function(newLane) {
      add$2(lanes, newLane);
      add$2(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
  });
};
UpdateFlowNodeRefsHandler.prototype.revert = function(context) {
  var updates = context.updates;
  updates.forEach(function(update2) {
    var flowNode = update2.flowNode, lanes = flowNode.get(LANES_ATTR);
    update2.add.forEach(function(newLane) {
      remove$3(lanes, newLane);
      remove$3(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
    update2.remove.forEach(function(oldLane) {
      add$2(lanes, oldLane);
      add$2(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
  });
};
function IdClaimHandler(moddle) {
  this._moddle = moddle;
}
IdClaimHandler.$inject = ["moddle"];
IdClaimHandler.prototype.execute = function(context) {
  var ids2 = this._moddle.ids, id2 = context.id, element = context.element, claiming = context.claiming;
  if (claiming) {
    ids2.claim(id2, element);
  } else {
    ids2.unclaim(id2);
  }
};
IdClaimHandler.prototype.revert = function(context) {
  var ids2 = this._moddle.ids, id2 = context.id, element = context.element, claiming = context.claiming;
  if (claiming) {
    ids2.unclaim(id2);
  } else {
    ids2.claim(id2, element);
  }
};
var DEFAULT_COLORS = {
  fill: void 0,
  stroke: void 0
};
function SetColorHandler(commandStack) {
  this._commandStack = commandStack;
  this._normalizeColor = function(color) {
    if (!color) {
      return void 0;
    }
    if (isString$3(color)) {
      var hexColor = colorToHex(color);
      if (hexColor) {
        return hexColor;
      }
    }
    throw new Error("invalid color value: " + color);
  };
}
SetColorHandler.$inject = [
  "commandStack"
];
SetColorHandler.prototype.postExecute = function(context) {
  var elements = context.elements, colors = context.colors || DEFAULT_COLORS;
  var self2 = this;
  var di = {};
  if ("fill" in colors) {
    assign$e(di, {
      "background-color": this._normalizeColor(colors.fill)
    });
  }
  if ("stroke" in colors) {
    assign$e(di, {
      "border-color": this._normalizeColor(colors.stroke)
    });
  }
  forEach$q(elements, function(element) {
    var assignedDi = isConnection$3(element) ? pick$3(di, ["border-color"]) : di;
    ensureLegacySupport(assignedDi);
    if (element.labelTarget) {
      self2._commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: element.businessObject.di.label,
        properties: {
          color: di["background-color"]
        }
      });
    } else {
      self2._commandStack.execute("element.updateProperties", {
        element,
        properties: {
          di: assignedDi
        }
      });
    }
  });
};
function colorToHex(color) {
  var context = document.createElement("canvas").getContext("2d");
  context.fillStyle = "transparent";
  context.fillStyle = color;
  return /^#[0-9a-fA-F]{6}$/.test(context.fillStyle) ? context.fillStyle : null;
}
function isConnection$3(element) {
  return !!element.waypoints;
}
function ensureLegacySupport(di) {
  if ("border-color" in di) {
    di.stroke = di["border-color"];
  }
  if ("background-color" in di) {
    di.fill = di["background-color"];
  }
}
var NULL_DIMENSIONS = {
  width: 0,
  height: 0
};
function UpdateLabelHandler(modeling, textRenderer) {
  function setText(element, text) {
    var label2 = element.label || element;
    var labelTarget = element.labelTarget || element;
    setLabel(label2, text);
    return [label2, labelTarget];
  }
  function preExecute(ctx) {
    var element = ctx.element, businessObject = element.businessObject, newLabel = ctx.newLabel;
    if (!isLabel$6(element) && isLabelExternal(element) && !hasExternalLabel(element) && !isEmptyText(newLabel)) {
      var paddingTop = 7;
      var labelCenter = getExternalLabelMid(element);
      labelCenter = {
        x: labelCenter.x,
        y: labelCenter.y + paddingTop
      };
      modeling.createLabel(element, labelCenter, {
        id: businessObject.id + "_label",
        businessObject
      });
    }
  }
  function execute(ctx) {
    ctx.oldLabel = getLabel(ctx.element);
    return setText(ctx.element, ctx.newLabel);
  }
  function revert(ctx) {
    return setText(ctx.element, ctx.oldLabel);
  }
  function postExecute(ctx) {
    var element = ctx.element, label2 = element.label || element, newLabel = ctx.newLabel, newBounds = ctx.newBounds, hints = ctx.hints || {};
    if (!isLabel$6(label2) && !is$O(label2, "bpmn:TextAnnotation")) {
      return;
    }
    if (isLabel$6(label2) && isEmptyText(newLabel)) {
      if (hints.removeShape !== false) {
        modeling.removeShape(label2, { unsetLabel: false });
      }
      return;
    }
    var text = getLabel(label2);
    if (typeof newBounds === "undefined") {
      newBounds = textRenderer.getExternalLabelBounds(label2, text);
    }
    if (newBounds) {
      modeling.resizeShape(label2, newBounds, NULL_DIMENSIONS);
    }
  }
  this.preExecute = preExecute;
  this.execute = execute;
  this.revert = revert;
  this.postExecute = postExecute;
}
UpdateLabelHandler.$inject = [
  "modeling",
  "textRenderer"
];
function isEmptyText(label2) {
  return !label2 || !label2.trim();
}
function Modeling(eventBus, elementFactory, commandStack, bpmnRules) {
  Modeling$1.call(this, eventBus, elementFactory, commandStack);
  this._bpmnRules = bpmnRules;
}
inherits$6(Modeling, Modeling$1);
Modeling.$inject = [
  "eventBus",
  "elementFactory",
  "commandStack",
  "bpmnRules"
];
Modeling.prototype.getHandlers = function() {
  var handlers = Modeling$1.prototype.getHandlers.call(this);
  handlers["element.updateModdleProperties"] = UpdateModdlePropertiesHandler;
  handlers["element.updateProperties"] = UpdatePropertiesHandler;
  handlers["canvas.updateRoot"] = UpdateCanvasRootHandler;
  handlers["lane.add"] = AddLaneHandler;
  handlers["lane.resize"] = ResizeLaneHandler;
  handlers["lane.split"] = SplitLaneHandler;
  handlers["lane.updateRefs"] = UpdateFlowNodeRefsHandler;
  handlers["id.updateClaim"] = IdClaimHandler;
  handlers["element.setColor"] = SetColorHandler;
  handlers["element.updateLabel"] = UpdateLabelHandler;
  return handlers;
};
Modeling.prototype.updateLabel = function(element, newLabel, newBounds, hints) {
  this._commandStack.execute("element.updateLabel", {
    element,
    newLabel,
    newBounds,
    hints: hints || {}
  });
};
Modeling.prototype.connect = function(source, target, attrs, hints) {
  var bpmnRules = this._bpmnRules;
  if (!attrs) {
    attrs = bpmnRules.canConnect(source, target);
  }
  if (!attrs) {
    return;
  }
  return this.createConnection(source, target, attrs, source.parent, hints);
};
Modeling.prototype.updateModdleProperties = function(element, moddleElement, properties2) {
  this._commandStack.execute("element.updateModdleProperties", {
    element,
    moddleElement,
    properties: properties2
  });
};
Modeling.prototype.updateProperties = function(element, properties2) {
  this._commandStack.execute("element.updateProperties", {
    element,
    properties: properties2
  });
};
Modeling.prototype.resizeLane = function(laneShape, newBounds, balanced) {
  this._commandStack.execute("lane.resize", {
    shape: laneShape,
    newBounds,
    balanced
  });
};
Modeling.prototype.addLane = function(targetLaneShape, location) {
  var context = {
    shape: targetLaneShape,
    location
  };
  this._commandStack.execute("lane.add", context);
  return context.newLane;
};
Modeling.prototype.splitLane = function(targetLane, count) {
  this._commandStack.execute("lane.split", {
    shape: targetLane,
    count
  });
};
Modeling.prototype.makeCollaboration = function() {
  var collaborationElement = this._create("root", {
    type: "bpmn:Collaboration"
  });
  var context = {
    newRoot: collaborationElement
  };
  this._commandStack.execute("canvas.updateRoot", context);
  return collaborationElement;
};
Modeling.prototype.updateLaneRefs = function(flowNodeShapes, laneShapes) {
  this._commandStack.execute("lane.updateRefs", {
    flowNodeShapes,
    laneShapes
  });
};
Modeling.prototype.makeProcess = function() {
  var processElement = this._create("root", {
    type: "bpmn:Process"
  });
  var context = {
    newRoot: processElement
  };
  this._commandStack.execute("canvas.updateRoot", context);
};
Modeling.prototype.claimId = function(id2, moddleElement) {
  this._commandStack.execute("id.updateClaim", {
    id: id2,
    element: moddleElement,
    claiming: true
  });
};
Modeling.prototype.unclaimId = function(id2, moddleElement) {
  this._commandStack.execute("id.updateClaim", {
    id: id2,
    element: moddleElement
  });
};
Modeling.prototype.setColor = function(elements, colors) {
  if (!elements.length) {
    elements = [elements];
  }
  this._commandStack.execute("element.setColor", {
    elements,
    colors
  });
};
function BaseLayouter() {
}
BaseLayouter.prototype.layoutConnection = function(connection, hints) {
  hints = hints || {};
  return [
    hints.connectionStart || getMid(hints.source || connection.source),
    hints.connectionEnd || getMid(hints.target || connection.target)
  ];
};
var MIN_SEGMENT_LENGTH = 20, POINT_ORIENTATION_PADDING = 5;
var round$1 = Math.round;
var INTERSECTION_THRESHOLD = 20, ORIENTATION_THRESHOLD = {
  "h:h": 20,
  "v:v": 20,
  "h:v": -10,
  "v:h": -10
};
function needsTurn(orientation, startDirection) {
  return !{
    t: /top/,
    r: /right/,
    b: /bottom/,
    l: /left/,
    h: /./,
    v: /./
  }[startDirection].test(orientation);
}
function canLayoutStraight(direction, targetOrientation) {
  return {
    t: /top/,
    r: /right/,
    b: /bottom/,
    l: /left/,
    h: /left|right/,
    v: /top|bottom/
  }[direction].test(targetOrientation);
}
function getSegmentBendpoints(a, b, directions2) {
  var orientation = getOrientation(b, a, POINT_ORIENTATION_PADDING);
  var startDirection = directions2.split(":")[0];
  var xmid = round$1((b.x - a.x) / 2 + a.x), ymid = round$1((b.y - a.y) / 2 + a.y);
  var segmentEnd, segmentDirections;
  var layoutStraight = canLayoutStraight(startDirection, orientation), layoutHorizontal = /h|r|l/.test(startDirection), layoutTurn = false;
  var turnNextDirections = false;
  if (layoutStraight) {
    segmentEnd = layoutHorizontal ? { x: xmid, y: a.y } : { x: a.x, y: ymid };
    segmentDirections = layoutHorizontal ? "h:h" : "v:v";
  } else {
    layoutTurn = needsTurn(orientation, startDirection);
    segmentDirections = layoutHorizontal ? "h:v" : "v:h";
    if (layoutTurn) {
      if (layoutHorizontal) {
        turnNextDirections = ymid === a.y;
        segmentEnd = {
          x: a.x + MIN_SEGMENT_LENGTH * (/l/.test(startDirection) ? -1 : 1),
          y: turnNextDirections ? ymid + MIN_SEGMENT_LENGTH : ymid
        };
      } else {
        turnNextDirections = xmid === a.x;
        segmentEnd = {
          x: turnNextDirections ? xmid + MIN_SEGMENT_LENGTH : xmid,
          y: a.y + MIN_SEGMENT_LENGTH * (/t/.test(startDirection) ? -1 : 1)
        };
      }
    } else {
      segmentEnd = {
        x: xmid,
        y: ymid
      };
    }
  }
  return {
    waypoints: getBendpoints(a, segmentEnd, segmentDirections).concat(segmentEnd),
    directions: segmentDirections,
    turnNextDirections
  };
}
function getStartSegment(a, b, directions2) {
  return getSegmentBendpoints(a, b, directions2);
}
function getEndSegment(a, b, directions2) {
  var invertedSegment = getSegmentBendpoints(b, a, invertDirections(directions2));
  return {
    waypoints: invertedSegment.waypoints.slice().reverse(),
    directions: invertDirections(invertedSegment.directions),
    turnNextDirections: invertedSegment.turnNextDirections
  };
}
function getMidSegment(startSegment, endSegment) {
  var startDirection = startSegment.directions.split(":")[1], endDirection = endSegment.directions.split(":")[0];
  if (startSegment.turnNextDirections) {
    startDirection = startDirection == "h" ? "v" : "h";
  }
  if (endSegment.turnNextDirections) {
    endDirection = endDirection == "h" ? "v" : "h";
  }
  var directions2 = startDirection + ":" + endDirection;
  var bendpoints = getBendpoints(startSegment.waypoints[startSegment.waypoints.length - 1], endSegment.waypoints[0], directions2);
  return {
    waypoints: bendpoints,
    directions: directions2
  };
}
function invertDirections(directions2) {
  return directions2.split(":").reverse().join(":");
}
function getSimpleBendpoints(a, b, directions2) {
  var xmid = round$1((b.x - a.x) / 2 + a.x), ymid = round$1((b.y - a.y) / 2 + a.y);
  if (directions2 === "h:v") {
    return [{ x: b.x, y: a.y }];
  }
  if (directions2 === "v:h") {
    return [{ x: a.x, y: b.y }];
  }
  if (directions2 === "h:h") {
    return [
      { x: xmid, y: a.y },
      { x: xmid, y: b.y }
    ];
  }
  if (directions2 === "v:v") {
    return [
      { x: a.x, y: ymid },
      { x: b.x, y: ymid }
    ];
  }
  throw new Error("invalid directions: can only handle varians of [hv]:[hv]");
}
function getBendpoints(a, b, directions2) {
  directions2 = directions2 || "h:h";
  if (!isValidDirections(directions2)) {
    throw new Error("unknown directions: <" + directions2 + ">: must be specified as <start>:<end> with start/end in { h,v,t,r,b,l }");
  }
  if (isExplicitDirections(directions2)) {
    var startSegment = getStartSegment(a, b, directions2), endSegment = getEndSegment(a, b, directions2), midSegment = getMidSegment(startSegment, endSegment);
    return [].concat(startSegment.waypoints, midSegment.waypoints, endSegment.waypoints);
  }
  return getSimpleBendpoints(a, b, directions2);
}
function connectPoints(a, b, directions2) {
  var points = getBendpoints(a, b, directions2);
  points.unshift(a);
  points.push(b);
  return withoutRedundantPoints(points);
}
function connectRectangles(source, target, start, end, hints) {
  var preferredLayouts = hints && hints.preferredLayouts || [];
  var preferredLayout = without(preferredLayouts, "straight")[0] || "h:h";
  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;
  var orientation = getOrientation(source, target, threshold);
  var directions2 = getDirections(orientation, preferredLayout);
  start = start || getMid(source);
  end = end || getMid(target);
  var directionSplit = directions2.split(":");
  var startDocking = getDockingPoint(start, source, directionSplit[0], invertOrientation(orientation)), endDocking = getDockingPoint(end, target, directionSplit[1], orientation);
  return connectPoints(startDocking, endDocking, directions2);
}
function repairConnection(source, target, start, end, waypoints, hints) {
  if (isArray$n(start)) {
    waypoints = start;
    hints = end;
    start = getMid(source);
    end = getMid(target);
  }
  hints = assign$e({ preferredLayouts: [] }, hints);
  waypoints = waypoints || [];
  var preferredLayouts = hints.preferredLayouts, preferStraight = preferredLayouts.indexOf("straight") !== -1, repairedWaypoints;
  repairedWaypoints = preferStraight && tryLayoutStraight(source, target, start, end, hints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  repairedWaypoints = hints.connectionEnd && tryRepairConnectionEnd(target, source, end, waypoints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  repairedWaypoints = hints.connectionStart && tryRepairConnectionStart(source, target, start, waypoints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  if (!hints.connectionStart && !hints.connectionEnd && waypoints && waypoints.length) {
    return waypoints;
  }
  return connectRectangles(source, target, start, end, hints);
}
function inRange(a, start, end) {
  return a >= start && a <= end;
}
function isInRange(axis, a, b) {
  var size2 = {
    x: "width",
    y: "height"
  };
  return inRange(a[axis], b[axis], b[axis] + b[size2[axis]]);
}
function tryLayoutStraight(source, target, start, end, hints) {
  var axis = {}, primaryAxis, orientation;
  orientation = getOrientation(source, target);
  if (!/^(top|bottom|left|right)$/.test(orientation)) {
    return null;
  }
  if (/top|bottom/.test(orientation)) {
    primaryAxis = "x";
  }
  if (/left|right/.test(orientation)) {
    primaryAxis = "y";
  }
  if (hints.preserveDocking === "target") {
    if (!isInRange(primaryAxis, end, source)) {
      return null;
    }
    axis[primaryAxis] = end[primaryAxis];
    return [
      {
        x: axis.x !== void 0 ? axis.x : start.x,
        y: axis.y !== void 0 ? axis.y : start.y,
        original: {
          x: axis.x !== void 0 ? axis.x : start.x,
          y: axis.y !== void 0 ? axis.y : start.y
        }
      },
      {
        x: end.x,
        y: end.y
      }
    ];
  } else {
    if (!isInRange(primaryAxis, start, target)) {
      return null;
    }
    axis[primaryAxis] = start[primaryAxis];
    return [
      {
        x: start.x,
        y: start.y
      },
      {
        x: axis.x !== void 0 ? axis.x : end.x,
        y: axis.y !== void 0 ? axis.y : end.y,
        original: {
          x: axis.x !== void 0 ? axis.x : end.x,
          y: axis.y !== void 0 ? axis.y : end.y
        }
      }
    ];
  }
}
function tryRepairConnectionStart(moved, other, newDocking, points) {
  return _tryRepairConnectionSide(moved, other, newDocking, points);
}
function tryRepairConnectionEnd(moved, other, newDocking, points) {
  var waypoints = points.slice().reverse();
  waypoints = _tryRepairConnectionSide(moved, other, newDocking, waypoints);
  return waypoints ? waypoints.reverse() : null;
}
function _tryRepairConnectionSide(moved, other, newDocking, points) {
  function needsRelayout(points2) {
    if (points2.length < 3) {
      return true;
    }
    if (points2.length > 4) {
      return false;
    }
    return !!find$e(points2, function(p, idx) {
      var q = points2[idx - 1];
      return q && pointDistance(p, q) < 3;
    });
  }
  function repairBendpoint(candidate, oldPeer, newPeer) {
    var alignment = pointsAligned(oldPeer, candidate);
    switch (alignment) {
      case "v":
        return { x: newPeer.x, y: candidate.y };
      case "h":
        return { x: candidate.x, y: newPeer.y };
    }
    return { x: candidate.x, y: candidate.y };
  }
  function removeOverlapping(points2, a, b) {
    var i;
    for (i = points2.length - 2; i !== 0; i--) {
      if (pointInRect(points2[i], a, INTERSECTION_THRESHOLD) || pointInRect(points2[i], b, INTERSECTION_THRESHOLD)) {
        return points2.slice(i);
      }
    }
    return points2;
  }
  if (needsRelayout(points)) {
    return null;
  }
  var oldDocking = points[0], newPoints = points.slice(), slicedPoints;
  newPoints[0] = newDocking;
  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);
  slicedPoints = removeOverlapping(newPoints, moved, other);
  if (slicedPoints !== newPoints) {
    newPoints = _tryRepairConnectionSide(moved, other, newDocking, slicedPoints);
  }
  if (newPoints && pointsAligned(newPoints)) {
    return null;
  }
  return newPoints;
}
function getDirections(orientation, defaultLayout) {
  if (isExplicitDirections(defaultLayout)) {
    return defaultLayout;
  }
  switch (orientation) {
    case "intersect":
      return "t:t";
    case "top":
    case "bottom":
      return "v:v";
    case "left":
    case "right":
      return "h:h";
    default:
      return defaultLayout;
  }
}
function isValidDirections(directions2) {
  return directions2 && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(directions2);
}
function isExplicitDirections(directions2) {
  return directions2 && /t|r|b|l/.test(directions2);
}
function invertOrientation(orientation) {
  return {
    "top": "bottom",
    "bottom": "top",
    "left": "right",
    "right": "left",
    "top-left": "bottom-right",
    "bottom-right": "top-left",
    "top-right": "bottom-left",
    "bottom-left": "top-right"
  }[orientation];
}
function getDockingPoint(point, rectangle, dockingDirection, targetOrientation) {
  if (dockingDirection === "h") {
    dockingDirection = /left/.test(targetOrientation) ? "l" : "r";
  }
  if (dockingDirection === "v") {
    dockingDirection = /top/.test(targetOrientation) ? "t" : "b";
  }
  if (dockingDirection === "t") {
    return { original: point, x: point.x, y: rectangle.y };
  }
  if (dockingDirection === "r") {
    return { original: point, x: rectangle.x + rectangle.width, y: point.y };
  }
  if (dockingDirection === "b") {
    return { original: point, x: point.x, y: rectangle.y + rectangle.height };
  }
  if (dockingDirection === "l") {
    return { original: point, x: rectangle.x, y: point.y };
  }
  throw new Error("unexpected dockingDirection: <" + dockingDirection + ">");
}
function withoutRedundantPoints(waypoints) {
  return waypoints.reduce(function(points, p, idx) {
    var previous = points[points.length - 1], next = waypoints[idx + 1];
    if (!pointsOnLine(previous, next, p, 0)) {
      points.push(p);
    }
    return points;
  }, []);
}
var ATTACH_ORIENTATION_PADDING = -10, BOUNDARY_TO_HOST_THRESHOLD$1 = 40;
var oppositeOrientationMapping = {
  "top": "bottom",
  "top-right": "bottom-left",
  "top-left": "bottom-right",
  "right": "left",
  "bottom": "top",
  "bottom-right": "top-left",
  "bottom-left": "top-right",
  "left": "right"
};
var orientationDirectionMapping = {
  top: "t",
  right: "r",
  bottom: "b",
  left: "l"
};
function BpmnLayouter() {
}
inherits$6(BpmnLayouter, BaseLayouter);
BpmnLayouter.prototype.layoutConnection = function(connection, hints) {
  if (!hints) {
    hints = {};
  }
  var source = hints.source || connection.source, target = hints.target || connection.target, waypoints = hints.waypoints || connection.waypoints, connectionStart = hints.connectionStart, connectionEnd = hints.connectionEnd;
  var manhattanOptions, updatedWaypoints;
  if (!connectionStart) {
    connectionStart = getConnectionDocking(waypoints && waypoints[0], source);
  }
  if (!connectionEnd) {
    connectionEnd = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);
  }
  if (is$O(connection, "bpmn:Association") || is$O(connection, "bpmn:DataAssociation")) {
    if (waypoints && !isCompensationAssociation(source, target)) {
      return [].concat([connectionStart], waypoints.slice(1, -1), [connectionEnd]);
    }
  }
  if (is$O(connection, "bpmn:MessageFlow")) {
    manhattanOptions = getMessageFlowManhattanOptions(source, target);
  } else if (is$O(connection, "bpmn:SequenceFlow") || isCompensationAssociation(source, target)) {
    if (source === target) {
      manhattanOptions = {
        preferredLayouts: getLoopPreferredLayout(source, connection)
      };
    } else if (is$O(source, "bpmn:BoundaryEvent")) {
      manhattanOptions = {
        preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd)
      };
    } else if (isExpandedSubProcess(source) || isExpandedSubProcess(target)) {
      manhattanOptions = getSubProcessManhattanOptions(source);
    } else if (is$O(source, "bpmn:Gateway")) {
      manhattanOptions = {
        preferredLayouts: ["v:h"]
      };
    } else if (is$O(target, "bpmn:Gateway")) {
      manhattanOptions = {
        preferredLayouts: ["h:v"]
      };
    } else {
      manhattanOptions = {
        preferredLayouts: ["h:h"]
      };
    }
  }
  if (manhattanOptions) {
    manhattanOptions = assign$e(manhattanOptions, hints);
    updatedWaypoints = withoutRedundantPoints(repairConnection(source, target, connectionStart, connectionEnd, waypoints, manhattanOptions));
  }
  return updatedWaypoints || [connectionStart, connectionEnd];
};
function getAttachOrientation(attachedElement) {
  var hostElement = attachedElement.host;
  return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);
}
function getMessageFlowManhattanOptions(source, target) {
  return {
    preferredLayouts: ["straight", "v:v"],
    preserveDocking: getMessageFlowPreserveDocking(source, target)
  };
}
function getMessageFlowPreserveDocking(source, target) {
  if (is$O(target, "bpmn:Participant")) {
    return "source";
  }
  if (is$O(source, "bpmn:Participant")) {
    return "target";
  }
  if (isExpandedSubProcess(target)) {
    return "source";
  }
  if (isExpandedSubProcess(source)) {
    return "target";
  }
  if (is$O(target, "bpmn:Event")) {
    return "target";
  }
  if (is$O(source, "bpmn:Event")) {
    return "source";
  }
  return null;
}
function getSubProcessManhattanOptions(source) {
  return {
    preferredLayouts: ["straight", "h:h"],
    preserveDocking: getSubProcessPreserveDocking(source)
  };
}
function getSubProcessPreserveDocking(source) {
  return isExpandedSubProcess(source) ? "target" : "source";
}
function getConnectionDocking(point, shape) {
  return point ? point.original || point : getMid(shape);
}
function isCompensationAssociation(source, target) {
  return is$O(target, "bpmn:Activity") && is$O(source, "bpmn:BoundaryEvent") && target.businessObject.isForCompensation;
}
function isExpandedSubProcess(element) {
  return is$O(element, "bpmn:SubProcess") && isExpanded(element);
}
function isSame(a, b) {
  return a === b;
}
function isAnyOrientation(orientation, orientations) {
  return orientations.indexOf(orientation) !== -1;
}
function getHorizontalOrientation(orientation) {
  var matches = /right|left/.exec(orientation);
  return matches && matches[0];
}
function getVerticalOrientation(orientation) {
  var matches = /top|bottom/.exec(orientation);
  return matches && matches[0];
}
function isOppositeOrientation(a, b) {
  return oppositeOrientationMapping[a] === b;
}
function isOppositeHorizontalOrientation(a, b) {
  var horizontalOrientation = getHorizontalOrientation(a);
  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];
  return b.indexOf(oppositeHorizontalOrientation) !== -1;
}
function isOppositeVerticalOrientation(a, b) {
  var verticalOrientation = getVerticalOrientation(a);
  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];
  return b.indexOf(oppositeVerticalOrientation) !== -1;
}
function isHorizontalOrientation(orientation) {
  return orientation === "right" || orientation === "left";
}
function getLoopPreferredLayout(source, connection) {
  var waypoints = connection.waypoints;
  var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);
  if (orientation === "top") {
    return ["t:r"];
  } else if (orientation === "right") {
    return ["r:b"];
  } else if (orientation === "left") {
    return ["l:t"];
  }
  return ["b:l"];
}
function getBoundaryEventPreferredLayouts(source, target, end) {
  var sourceMid = getMid(source), targetMid = getMid(target), attachOrientation = getAttachOrientation(source), sourceLayout, targetLayout;
  var isLoop = isSame(source.host, target);
  var attachedToSide = isAnyOrientation(attachOrientation, ["top", "right", "bottom", "left"]);
  var targetOrientation = getOrientation(targetMid, sourceMid, {
    x: source.width / 2 + target.width / 2,
    y: source.height / 2 + target.height / 2
  });
  if (isLoop) {
    return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end);
  }
  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide);
  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide);
  return [sourceLayout + ":" + targetLayout];
}
function getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end) {
  var orientation = attachedToSide ? attachOrientation : getVerticalOrientation(attachOrientation), sourceLayout = orientationDirectionMapping[orientation], targetLayout;
  if (attachedToSide) {
    if (isHorizontalOrientation(attachOrientation)) {
      targetLayout = shouldConnectToSameSide("y", source, target, end) ? "h" : "b";
    } else {
      targetLayout = shouldConnectToSameSide("x", source, target, end) ? "v" : "l";
    }
  } else {
    targetLayout = "v";
  }
  return [sourceLayout + ":" + targetLayout];
}
function shouldConnectToSameSide(axis, source, target, end) {
  var threshold = BOUNDARY_TO_HOST_THRESHOLD$1;
  return !(areCloseOnAxis(axis, end, target, threshold) || areCloseOnAxis(axis, end, {
    x: target.x + target.width,
    y: target.y + target.height
  }, threshold) || areCloseOnAxis(axis, end, getMid(source), threshold));
}
function areCloseOnAxis(axis, a, b, threshold) {
  return Math.abs(a[axis] - b[axis]) < threshold;
}
function getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide) {
  if (attachedToSide) {
    return orientationDirectionMapping[attachOrientation];
  }
  if (isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) || isOppositeOrientation(getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation))) {
    return orientationDirectionMapping[getVerticalOrientation(attachOrientation)];
  }
  return orientationDirectionMapping[getHorizontalOrientation(attachOrientation)];
}
function getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide) {
  if (attachedToSide) {
    if (isHorizontalOrientation(attachOrientation)) {
      if (isOppositeHorizontalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {
        return "h";
      }
      return "v";
    } else {
      if (isOppositeVerticalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {
        return "v";
      }
      return "h";
    }
  }
  if (isHorizontalOrientation(targetOrientation) || isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) && getHorizontalOrientation(targetOrientation)) {
    return "h";
  } else {
    return "v";
  }
}
function dockingToPoint(docking) {
  return assign$e({ original: docking.point.original || docking.point }, docking.actual);
}
function CroppingConnectionDocking(elementRegistry, graphicsFactory) {
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;
}
CroppingConnectionDocking.$inject = ["elementRegistry", "graphicsFactory"];
CroppingConnectionDocking.prototype.getCroppedWaypoints = function(connection, source, target) {
  source = source || connection.source;
  target = target || connection.target;
  var sourceDocking = this.getDockingPoint(connection, source, true), targetDocking = this.getDockingPoint(connection, target);
  var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);
  croppedWaypoints.unshift(dockingToPoint(sourceDocking));
  croppedWaypoints.push(dockingToPoint(targetDocking));
  return croppedWaypoints;
};
CroppingConnectionDocking.prototype.getDockingPoint = function(connection, shape, dockStart) {
  var waypoints = connection.waypoints, dockingIdx, dockingPoint, croppedPoint;
  dockingIdx = dockStart ? 0 : waypoints.length - 1;
  dockingPoint = waypoints[dockingIdx];
  croppedPoint = this._getIntersection(shape, connection, dockStart);
  return {
    point: dockingPoint,
    actual: croppedPoint || dockingPoint,
    idx: dockingIdx
  };
};
CroppingConnectionDocking.prototype._getIntersection = function(shape, connection, takeFirst) {
  var shapePath = this._getShapePath(shape), connectionPath = this._getConnectionPath(connection);
  return getElementLineIntersection(shapePath, connectionPath, takeFirst);
};
CroppingConnectionDocking.prototype._getConnectionPath = function(connection) {
  return this._graphicsFactory.getConnectionPath(connection);
};
CroppingConnectionDocking.prototype._getShapePath = function(shape) {
  return this._graphicsFactory.getShapePath(shape);
};
CroppingConnectionDocking.prototype._getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};
var ModelingModule = {
  __init__: [
    "modeling",
    "bpmnUpdater"
  ],
  __depends__: [
    BehaviorModule,
    RulesModule,
    DiOrderingModule,
    OrderingModule,
    ReplaceModule,
    CommandModule,
    TooltipsModule,
    LabelSupportModule,
    AttachSupportModule,
    SelectionModule,
    ChangeSupportModule,
    SpaceToolModule
  ],
  bpmnFactory: ["type", BpmnFactory],
  bpmnUpdater: ["type", BpmnUpdater],
  elementFactory: ["type", ElementFactory],
  modeling: ["type", Modeling],
  layouter: ["type", BpmnLayouter],
  connectionDocking: ["type", CroppingConnectionDocking]
};
var LOW_PRIORITY$3 = 500, MEDIUM_PRIORITY = 1250, HIGH_PRIORITY$2 = 1500;
var round = Math.round;
function mid(element) {
  return {
    x: element.x + round(element.width / 2),
    y: element.y + round(element.height / 2)
  };
}
function MoveEvents(eventBus, dragging, modeling, selection, rules) {
  function canMove2(shapes, delta2, position, target) {
    return rules.allowed("elements.move", {
      shapes,
      delta: delta2,
      position,
      target
    });
  }
  eventBus.on("shape.move.start", HIGH_PRIORITY$2, function(event) {
    var context = event.context, shape = event.shape, shapes = selection.get().slice();
    if (shapes.indexOf(shape) === -1) {
      shapes = [shape];
    }
    shapes = removeNested(shapes);
    assign$e(context, {
      shapes,
      validatedShapes: shapes,
      shape
    });
  });
  eventBus.on("shape.move.start", MEDIUM_PRIORITY, function(event) {
    var context = event.context, validatedShapes = context.validatedShapes, canExecute;
    canExecute = context.canExecute = canMove2(validatedShapes);
    if (!canExecute) {
      return false;
    }
  });
  eventBus.on("shape.move.move", LOW_PRIORITY$3, function(event) {
    var context = event.context, validatedShapes = context.validatedShapes, hover = event.hover, delta2 = { x: event.dx, y: event.dy }, position = { x: event.x, y: event.y }, canExecute;
    canExecute = canMove2(validatedShapes, delta2, position, hover);
    context.delta = delta2;
    context.canExecute = canExecute;
    if (canExecute === null) {
      context.target = null;
      return;
    }
    context.target = hover;
  });
  eventBus.on("shape.move.end", function(event) {
    var context = event.context;
    var delta2 = context.delta, canExecute = context.canExecute, isAttach = canExecute === "attach", shapes = context.shapes;
    if (canExecute === false) {
      return false;
    }
    delta2.x = round(delta2.x);
    delta2.y = round(delta2.y);
    if (delta2.x === 0 && delta2.y === 0) {
      return;
    }
    modeling.moveElements(shapes, delta2, context.target, {
      primaryShape: context.shape,
      attach: isAttach
    });
  });
  eventBus.on("element.mousedown", function(event) {
    if (!isPrimaryButton$1(event)) {
      return;
    }
    var originalEvent = getOriginal$2(event);
    if (!originalEvent) {
      throw new Error("must supply DOM mousedown event");
    }
    return start(originalEvent, event.element);
  });
  function start(event, element, activate, context) {
    if (isObject$e(activate)) {
      context = activate;
      activate = false;
    }
    if (element.waypoints || !element.parent) {
      return;
    }
    var referencePoint = mid(element);
    dragging.init(event, referencePoint, "shape.move", {
      cursor: "grabbing",
      autoActivate: activate,
      data: {
        shape: element,
        context: context || {}
      }
    });
    return true;
  }
  this.start = start;
}
MoveEvents.$inject = [
  "eventBus",
  "dragging",
  "modeling",
  "selection",
  "rules"
];
function removeNested(elements) {
  var ids2 = groupBy$1(elements, "id");
  return filter$a(elements, function(element) {
    while (element = element.parent) {
      if (ids2[element.id]) {
        return false;
      }
    }
    return true;
  });
}
var LOW_PRIORITY$2 = 499;
var MARKER_DRAGGING = "djs-dragging", MARKER_OK$1 = "drop-ok", MARKER_NOT_OK$1 = "drop-not-ok", MARKER_NEW_PARENT = "new-parent", MARKER_ATTACH = "attach-ok";
function MovePreview(eventBus, canvas, styles, previewSupport) {
  function getVisualDragShapes(shapes) {
    var elements = getAllDraggedElements(shapes);
    var filteredElements = removeEdges(elements);
    return filteredElements;
  }
  function getAllDraggedElements(shapes) {
    var allShapes = selfAndAllChildren(shapes, true);
    var allConnections = map$7(allShapes, function(shape) {
      return (shape.incoming || []).concat(shape.outgoing || []);
    });
    return flatten$a(allShapes.concat(allConnections));
  }
  function setMarker(element, marker) {
    [MARKER_ATTACH, MARKER_OK$1, MARKER_NOT_OK$1, MARKER_NEW_PARENT].forEach(function(m) {
      if (m === marker) {
        canvas.addMarker(element, m);
      } else {
        canvas.removeMarker(element, m);
      }
    });
  }
  function makeDraggable(context, element, addMarker) {
    previewSupport.addDragger(element, context.dragGroup);
    if (addMarker) {
      canvas.addMarker(element, MARKER_DRAGGING);
    }
    if (context.allDraggedElements) {
      context.allDraggedElements.push(element);
    } else {
      context.allDraggedElements = [element];
    }
  }
  eventBus.on("shape.move.start", LOW_PRIORITY$2, function(event) {
    var context = event.context, dragShapes = context.shapes, allDraggedElements = context.allDraggedElements;
    var visuallyDraggedShapes = getVisualDragShapes(dragShapes);
    if (!context.dragGroup) {
      var dragGroup = create$2("g");
      attr(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
      var activeLayer = canvas.getActiveLayer();
      append$3(activeLayer, dragGroup);
      context.dragGroup = dragGroup;
    }
    visuallyDraggedShapes.forEach(function(shape) {
      previewSupport.addDragger(shape, context.dragGroup);
    });
    if (!allDraggedElements) {
      allDraggedElements = getAllDraggedElements(dragShapes);
    } else {
      allDraggedElements = flatten$a([
        allDraggedElements,
        getAllDraggedElements(dragShapes)
      ]);
    }
    forEach$q(allDraggedElements, function(e) {
      canvas.addMarker(e, MARKER_DRAGGING);
    });
    context.allDraggedElements = allDraggedElements;
    context.differentParents = haveDifferentParents(dragShapes);
  });
  eventBus.on("shape.move.move", LOW_PRIORITY$2, function(event) {
    var context = event.context, dragGroup = context.dragGroup, target = context.target, parent2 = context.shape.parent, canExecute = context.canExecute;
    if (target) {
      if (canExecute === "attach") {
        setMarker(target, MARKER_ATTACH);
      } else if (context.canExecute && target && target.id !== parent2.id) {
        setMarker(target, MARKER_NEW_PARENT);
      } else {
        setMarker(target, context.canExecute ? MARKER_OK$1 : MARKER_NOT_OK$1);
      }
    }
    translate$4(dragGroup, event.dx, event.dy);
  });
  eventBus.on(["shape.move.out", "shape.move.cleanup"], function(event) {
    var context = event.context, target = context.target;
    if (target) {
      setMarker(target, null);
    }
  });
  eventBus.on("shape.move.cleanup", function(event) {
    var context = event.context, allDraggedElements = context.allDraggedElements, dragGroup = context.dragGroup;
    forEach$q(allDraggedElements, function(e) {
      canvas.removeMarker(e, MARKER_DRAGGING);
    });
    if (dragGroup) {
      remove$4(dragGroup);
    }
  });
  this.makeDraggable = makeDraggable;
}
MovePreview.$inject = [
  "eventBus",
  "canvas",
  "styles",
  "previewSupport"
];
function removeEdges(elements) {
  var filteredElements = filter$a(elements, function(element) {
    if (!isConnection$2(element)) {
      return true;
    } else {
      return find$e(elements, matchPattern$1({ id: element.source.id })) && find$e(elements, matchPattern$1({ id: element.target.id }));
    }
  });
  return filteredElements;
}
function haveDifferentParents(elements) {
  return size(groupBy$1(elements, function(e) {
    return e.parent && e.parent.id;
  })) !== 1;
}
function isConnection$2(element) {
  return element.waypoints;
}
var MoveModule = {
  __depends__: [
    InteractionEventsModule$2,
    SelectionModule,
    OutlineModule,
    RulesModule$1,
    DraggingModule,
    PreviewSupportModule
  ],
  __init__: [
    "move",
    "movePreview"
  ],
  move: ["type", MoveEvents],
  movePreview: ["type", MovePreview]
};
var TOGGLE_SELECTOR = ".djs-palette-toggle", ENTRY_SELECTOR = ".entry", ELEMENT_SELECTOR = TOGGLE_SELECTOR + ", " + ENTRY_SELECTOR;
var PALETTE_PREFIX = "djs-palette-", PALETTE_SHOWN_CLS = "shown", PALETTE_OPEN_CLS = "open", PALETTE_TWO_COLUMN_CLS = "two-column";
var DEFAULT_PRIORITY$3 = 1e3;
function Palette(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  var self2 = this;
  eventBus.on("tool-manager.update", function(event) {
    var tool = event.tool;
    self2.updateToolHighlight(tool);
  });
  eventBus.on("i18n.changed", function() {
    self2._update();
  });
  eventBus.on("diagram.init", function() {
    self2._diagramInitialized = true;
    self2._rebuild();
  });
}
Palette.$inject = ["eventBus", "canvas"];
Palette.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY$3;
  }
  this._eventBus.on("palette.getProviders", priority, function(event) {
    event.providers.push(provider);
  });
  this._rebuild();
};
Palette.prototype.getEntries = function() {
  var providers = this._getProviders();
  return providers.reduce(addPaletteEntries, {});
};
Palette.prototype._rebuild = function() {
  if (!this._diagramInitialized) {
    return;
  }
  var providers = this._getProviders();
  if (!providers.length) {
    return;
  }
  if (!this._container) {
    this._init();
  }
  this._update();
};
Palette.prototype._init = function() {
  var self2 = this;
  var eventBus = this._eventBus;
  var parentContainer = this._getParentContainer();
  var container = this._container = domify$h(Palette.HTML_MARKUP);
  parentContainer.appendChild(container);
  classes$1(parentContainer).add(PALETTE_PREFIX + PALETTE_SHOWN_CLS);
  delegate$1.bind(container, ELEMENT_SELECTOR, "click", function(event) {
    var target = event.delegateTarget;
    if (matchesSelector(target, TOGGLE_SELECTOR)) {
      return self2.toggle();
    }
    self2.trigger("click", event);
  });
  componentEvent.bind(container, "mousedown", function(event) {
    event.stopPropagation();
  });
  delegate$1.bind(container, ENTRY_SELECTOR, "dragstart", function(event) {
    self2.trigger("dragstart", event);
  });
  eventBus.on("canvas.resized", this._layoutChanged, this);
  eventBus.fire("palette.create", {
    container
  });
};
Palette.prototype._getProviders = function(id2) {
  var event = this._eventBus.createEvent({
    type: "palette.getProviders",
    providers: []
  });
  this._eventBus.fire(event);
  return event.providers;
};
Palette.prototype._toggleState = function(state) {
  state = state || {};
  var parent2 = this._getParentContainer(), container = this._container;
  var eventBus = this._eventBus;
  var twoColumn;
  var cls = classes$1(container), parentCls = classes$1(parent2);
  if ("twoColumn" in state) {
    twoColumn = state.twoColumn;
  } else {
    twoColumn = this._needsCollapse(parent2.clientHeight, this._entries || {});
  }
  cls.toggle(PALETTE_TWO_COLUMN_CLS, twoColumn);
  parentCls.toggle(PALETTE_PREFIX + PALETTE_TWO_COLUMN_CLS, twoColumn);
  if ("open" in state) {
    cls.toggle(PALETTE_OPEN_CLS, state.open);
    parentCls.toggle(PALETTE_PREFIX + PALETTE_OPEN_CLS, state.open);
  }
  eventBus.fire("palette.changed", {
    twoColumn,
    open: this.isOpen()
  });
};
Palette.prototype._update = function() {
  var entriesContainer = query(".djs-palette-entries", this._container), entries = this._entries = this.getEntries();
  clear$1(entriesContainer);
  forEach$q(entries, function(entry, id2) {
    var grouping = entry.group || "default";
    var container = query("[data-group=" + grouping + "]", entriesContainer);
    if (!container) {
      container = domify$h('<div class="group" data-group="' + grouping + '"></div>');
      entriesContainer.appendChild(container);
    }
    var html = entry.html || (entry.separator ? '<hr class="separator" />' : '<div class="entry" draggable="true"></div>');
    var control = domify$h(html);
    container.appendChild(control);
    if (!entry.separator) {
      attr$1(control, "data-action", id2);
      if (entry.title) {
        attr$1(control, "title", entry.title);
      }
      if (entry.className) {
        addClasses(control, entry.className);
      }
      if (entry.imageUrl) {
        control.appendChild(domify$h('<img src="' + entry.imageUrl + '">'));
      }
    }
  });
  this.open();
};
Palette.prototype.trigger = function(action, event, autoActivate) {
  var entries = this._entries, entry, handler, originalEvent, button = event.delegateTarget || event.target;
  if (!button) {
    return event.preventDefault();
  }
  entry = entries[attr$1(button, "data-action")];
  if (!entry) {
    return;
  }
  handler = entry.action;
  originalEvent = event.originalEvent || event;
  if (isFunction$6(handler)) {
    if (action === "click") {
      handler(originalEvent, autoActivate);
    }
  } else {
    if (handler[action]) {
      handler[action](originalEvent, autoActivate);
    }
  }
  event.preventDefault();
};
Palette.prototype._layoutChanged = function() {
  this._toggleState({});
};
Palette.prototype._needsCollapse = function(availableHeight, entries) {
  var margin = 20 + 10 + 20;
  var entriesHeight = Object.keys(entries).length * 46;
  return availableHeight < entriesHeight + margin;
};
Palette.prototype.close = function() {
  this._toggleState({
    open: false,
    twoColumn: false
  });
};
Palette.prototype.open = function() {
  this._toggleState({ open: true });
};
Palette.prototype.toggle = function(open3) {
  if (this.isOpen()) {
    this.close();
  } else {
    this.open();
  }
};
Palette.prototype.isActiveTool = function(tool) {
  return tool && this._activeTool === tool;
};
Palette.prototype.updateToolHighlight = function(name2) {
  var entriesContainer, toolsContainer;
  if (!this._toolsContainer) {
    entriesContainer = query(".djs-palette-entries", this._container);
    this._toolsContainer = query("[data-group=tools]", entriesContainer);
  }
  toolsContainer = this._toolsContainer;
  forEach$q(toolsContainer.children, function(tool) {
    var actionName = tool.getAttribute("data-action");
    if (!actionName) {
      return;
    }
    var toolClasses = classes$1(tool);
    actionName = actionName.replace("-tool", "");
    if (toolClasses.contains("entry") && actionName === name2) {
      toolClasses.add("highlighted-entry");
    } else {
      toolClasses.remove("highlighted-entry");
    }
  });
};
Palette.prototype.isOpen = function() {
  return classes$1(this._container).has(PALETTE_OPEN_CLS);
};
Palette.prototype._getParentContainer = function() {
  return this._canvas.getContainer();
};
Palette.HTML_MARKUP = '<div class="djs-palette"><div class="djs-palette-entries"></div><div class="djs-palette-toggle"></div></div>';
function addClasses(element, classNames) {
  var classes2 = classes$1(element);
  var actualClassNames = isArray$n(classNames) ? classNames : classNames.split(/\s+/g);
  actualClassNames.forEach(function(cls) {
    classes2.add(cls);
  });
}
function addPaletteEntries(entries, provider) {
  var entriesOrUpdater = provider.getPaletteEntries();
  if (isFunction$6(entriesOrUpdater)) {
    return entriesOrUpdater(entries);
  }
  forEach$q(entriesOrUpdater, function(entry, id2) {
    entries[id2] = entry;
  });
  return entries;
}
var PaletteModule$1 = {
  __init__: ["palette"],
  palette: ["type", Palette]
};
var LASSO_TOOL_CURSOR = "crosshair";
function LassoTool(eventBus, canvas, dragging, elementRegistry, selection, toolManager, mouse) {
  this._selection = selection;
  this._dragging = dragging;
  this._mouse = mouse;
  var self2 = this;
  var visuals = {
    create: function(context) {
      var container = canvas.getActiveLayer(), frame;
      frame = context.frame = create$2("rect");
      attr(frame, {
        class: "djs-lasso-overlay",
        width: 1,
        height: 1,
        x: 0,
        y: 0
      });
      append$3(container, frame);
    },
    update: function(context) {
      var frame = context.frame, bbox = context.bbox;
      attr(frame, {
        x: bbox.x,
        y: bbox.y,
        width: bbox.width,
        height: bbox.height
      });
    },
    remove: function(context) {
      if (context.frame) {
        remove$4(context.frame);
      }
    }
  };
  toolManager.registerTool("lasso", {
    tool: "lasso.selection",
    dragging: "lasso"
  });
  eventBus.on("lasso.selection.end", function(event) {
    var target = event.originalEvent.target;
    if (!event.hover && !(target instanceof SVGElement)) {
      return;
    }
    eventBus.once("lasso.selection.ended", function() {
      self2.activateLasso(event.originalEvent, true);
    });
  });
  eventBus.on("lasso.end", function(event) {
    var bbox = toBBox(event);
    var elements = elementRegistry.filter(function(element) {
      return element;
    });
    self2.select(elements, bbox);
  });
  eventBus.on("lasso.start", function(event) {
    var context = event.context;
    context.bbox = toBBox(event);
    visuals.create(context);
  });
  eventBus.on("lasso.move", function(event) {
    var context = event.context;
    context.bbox = toBBox(event);
    visuals.update(context);
  });
  eventBus.on("lasso.cleanup", function(event) {
    var context = event.context;
    visuals.remove(context);
  });
  eventBus.on("element.mousedown", 1500, function(event) {
    if (!hasSecondaryModifier(event)) {
      return;
    }
    self2.activateLasso(event.originalEvent);
    return true;
  });
}
LassoTool.$inject = [
  "eventBus",
  "canvas",
  "dragging",
  "elementRegistry",
  "selection",
  "toolManager",
  "mouse"
];
LassoTool.prototype.activateLasso = function(event, autoActivate) {
  this._dragging.init(event, "lasso", {
    autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    }
  });
};
LassoTool.prototype.activateSelection = function(event, autoActivate) {
  this._dragging.init(event, "lasso.selection", {
    trapClick: false,
    autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    }
  });
};
LassoTool.prototype.select = function(elements, bbox) {
  var selectedElements = getEnclosedElements(elements, bbox);
  this._selection.select(values$2(selectedElements));
};
LassoTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateSelection(mouseEvent, !!mouseEvent);
};
LassoTool.prototype.isActive = function() {
  var context = this._dragging.context();
  return context && /^lasso/.test(context.prefix);
};
function toBBox(event) {
  var start = {
    x: event.x - event.dx,
    y: event.y - event.dy
  };
  var end = {
    x: event.x,
    y: event.y
  };
  var bbox;
  if (start.x <= end.x && start.y < end.y || start.x < end.x && start.y <= end.y) {
    bbox = {
      x: start.x,
      y: start.y,
      width: end.x - start.x,
      height: end.y - start.y
    };
  } else if (start.x >= end.x && start.y < end.y || start.x > end.x && start.y <= end.y) {
    bbox = {
      x: end.x,
      y: start.y,
      width: start.x - end.x,
      height: end.y - start.y
    };
  } else if (start.x <= end.x && start.y > end.y || start.x < end.x && start.y >= end.y) {
    bbox = {
      x: start.x,
      y: end.y,
      width: end.x - start.x,
      height: start.y - end.y
    };
  } else if (start.x >= end.x && start.y > end.y || start.x > end.x && start.y >= end.y) {
    bbox = {
      x: end.x,
      y: end.y,
      width: start.x - end.x,
      height: start.y - end.y
    };
  } else {
    bbox = {
      x: end.x,
      y: end.y,
      width: 0,
      height: 0
    };
  }
  return bbox;
}
var LassoToolModule = {
  __depends__: [
    ToolManagerModule,
    MouseModule
  ],
  __init__: ["lassoTool"],
  lassoTool: ["type", LassoTool]
};
var HIGH_PRIORITY$1 = 1500;
var HAND_CURSOR = "grab";
function HandTool(eventBus, canvas, dragging, injector, toolManager, mouse) {
  this._dragging = dragging;
  this._mouse = mouse;
  var self2 = this, keyboard = injector.get("keyboard", false);
  toolManager.registerTool("hand", {
    tool: "hand",
    dragging: "hand.move"
  });
  eventBus.on("element.mousedown", HIGH_PRIORITY$1, function(event) {
    if (!hasPrimaryModifier(event)) {
      return;
    }
    self2.activateMove(event.originalEvent, true);
    return false;
  });
  keyboard && keyboard.addListener(HIGH_PRIORITY$1, function(e) {
    if (!isSpace(e.keyEvent) || self2.isActive()) {
      return;
    }
    var mouseEvent = self2._mouse.getLastMoveEvent();
    self2.activateMove(mouseEvent, !!mouseEvent);
  }, "keyboard.keydown");
  keyboard && keyboard.addListener(HIGH_PRIORITY$1, function(e) {
    if (!isSpace(e.keyEvent) || !self2.isActive()) {
      return;
    }
    self2.toggle();
  }, "keyboard.keyup");
  eventBus.on("hand.end", function(event) {
    var target = event.originalEvent.target;
    if (!event.hover && !(target instanceof SVGElement)) {
      return false;
    }
    eventBus.once("hand.ended", function() {
      self2.activateMove(event.originalEvent, { reactivate: true });
    });
  });
  eventBus.on("hand.move.move", function(event) {
    var scale = canvas.viewbox().scale;
    canvas.scroll({
      dx: event.dx * scale,
      dy: event.dy * scale
    });
  });
  eventBus.on("hand.move.end", function(event) {
    var context = event.context, reactivate = context.reactivate;
    if (!hasPrimaryModifier(event) && reactivate) {
      eventBus.once("hand.move.ended", function(event2) {
        self2.activateHand(event2.originalEvent, true, true);
      });
    }
    return false;
  });
}
HandTool.$inject = [
  "eventBus",
  "canvas",
  "dragging",
  "injector",
  "toolManager",
  "mouse"
];
HandTool.prototype.activateMove = function(event, autoActivate, context) {
  if (typeof autoActivate === "object") {
    context = autoActivate;
    autoActivate = false;
  }
  this._dragging.init(event, "hand.move", {
    autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: context || {}
    }
  });
};
HandTool.prototype.activateHand = function(event, autoActivate, reactivate) {
  this._dragging.init(event, "hand", {
    trapClick: false,
    autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: {
        reactivate
      }
    }
  });
};
HandTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateHand(mouseEvent, !!mouseEvent);
};
HandTool.prototype.isActive = function() {
  var context = this._dragging.context();
  if (context) {
    return /^(hand|hand\.move)$/.test(context.prefix);
  }
  return false;
};
function isSpace(keyEvent) {
  return isKey$4(" ", keyEvent);
}
var HandToolModule = {
  __depends__: [
    ToolManagerModule,
    MouseModule
  ],
  __init__: ["handTool"],
  handTool: ["type", HandTool]
};
var MARKER_OK = "connect-ok", MARKER_NOT_OK = "connect-not-ok";
function GlobalConnect(eventBus, dragging, connect, canvas, toolManager, rules, mouse) {
  var self2 = this;
  this._dragging = dragging;
  this._rules = rules;
  this._mouse = mouse;
  toolManager.registerTool("global-connect", {
    tool: "global-connect",
    dragging: "global-connect.drag"
  });
  eventBus.on("global-connect.hover", function(event) {
    var context = event.context, startTarget = event.hover;
    var canStartConnect = context.canStartConnect = self2.canStartConnect(startTarget);
    if (canStartConnect === null) {
      return;
    }
    context.startTarget = startTarget;
    canvas.addMarker(startTarget, canStartConnect ? MARKER_OK : MARKER_NOT_OK);
  });
  eventBus.on(["global-connect.out", "global-connect.cleanup"], function(event) {
    var startTarget = event.context.startTarget, canStartConnect = event.context.canStartConnect;
    if (startTarget) {
      canvas.removeMarker(startTarget, canStartConnect ? MARKER_OK : MARKER_NOT_OK);
    }
  });
  eventBus.on(["global-connect.ended"], function(event) {
    var context = event.context, startTarget = context.startTarget, startPosition = {
      x: event.x,
      y: event.y
    };
    var canStartConnect = self2.canStartConnect(startTarget);
    if (!canStartConnect) {
      return;
    }
    eventBus.once("element.out", function() {
      eventBus.once(["connect.ended", "connect.canceled"], function() {
        eventBus.fire("global-connect.drag.ended");
      });
      connect.start(null, startTarget, startPosition);
    });
    return false;
  });
}
GlobalConnect.$inject = [
  "eventBus",
  "dragging",
  "connect",
  "canvas",
  "toolManager",
  "rules",
  "mouse"
];
GlobalConnect.prototype.start = function(event, autoActivate) {
  this._dragging.init(event, "global-connect", {
    autoActivate,
    trapClick: false,
    data: {
      context: {}
    }
  });
};
GlobalConnect.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  return this.start(mouseEvent, !!mouseEvent);
};
GlobalConnect.prototype.isActive = function() {
  var context = this._dragging.context();
  return context && /^global-connect/.test(context.prefix);
};
GlobalConnect.prototype.canStartConnect = function(startTarget) {
  return this._rules.allowed("connection.start", { source: startTarget });
};
var GlobalConnectModule = {
  __depends__: [
    ConnectModule,
    RulesModule$1,
    DraggingModule,
    ToolManagerModule,
    MouseModule
  ],
  globalConnect: ["type", GlobalConnect]
};
function PaletteProvider(palette, create2, elementFactory, spaceTool, lassoTool, handTool, globalConnect, translate2) {
  this._palette = palette;
  this._create = create2;
  this._elementFactory = elementFactory;
  this._spaceTool = spaceTool;
  this._lassoTool = lassoTool;
  this._handTool = handTool;
  this._globalConnect = globalConnect;
  this._translate = translate2;
  palette.registerProvider(this);
}
PaletteProvider.$inject = [
  "palette",
  "create",
  "elementFactory",
  "spaceTool",
  "lassoTool",
  "handTool",
  "globalConnect",
  "translate"
];
PaletteProvider.prototype.getPaletteEntries = function(element) {
  var actions = {}, create2 = this._create, elementFactory = this._elementFactory, spaceTool = this._spaceTool, lassoTool = this._lassoTool, handTool = this._handTool, globalConnect = this._globalConnect, translate2 = this._translate;
  function createAction(type, group, className, title, options) {
    function createListener(event) {
      var shape = elementFactory.createShape(assign$e({ type }, options));
      if (options) {
        shape.businessObject.di.isExpanded = options.isExpanded;
      }
      create2.start(event, shape);
    }
    var shortType = type.replace(/^bpmn:/, "");
    return {
      group,
      className,
      title: title || translate2("Create {type}", { type: shortType }),
      action: {
        dragstart: createListener,
        click: createListener
      }
    };
  }
  function createSubprocess(event) {
    var subProcess = elementFactory.createShape({
      type: "bpmn:SubProcess",
      x: 0,
      y: 0,
      isExpanded: true
    });
    var startEvent = elementFactory.createShape({
      type: "bpmn:StartEvent",
      x: 40,
      y: 82,
      parent: subProcess
    });
    create2.start(event, [subProcess, startEvent], {
      hints: {
        autoSelect: [subProcess]
      }
    });
  }
  function createParticipant(event) {
    create2.start(event, elementFactory.createParticipantShape());
  }
  assign$e(actions, {
    "hand-tool": {
      group: "tools",
      className: "bpmn-icon-hand-tool",
      title: translate2("Activate the hand tool"),
      action: {
        click: function(event) {
          handTool.activateHand(event);
        }
      }
    },
    "lasso-tool": {
      group: "tools",
      className: "bpmn-icon-lasso-tool",
      title: translate2("Activate the lasso tool"),
      action: {
        click: function(event) {
          lassoTool.activateSelection(event);
        }
      }
    },
    "space-tool": {
      group: "tools",
      className: "bpmn-icon-space-tool",
      title: translate2("Activate the create/remove space tool"),
      action: {
        click: function(event) {
          spaceTool.activateSelection(event);
        }
      }
    },
    "global-connect-tool": {
      group: "tools",
      className: "bpmn-icon-connection-multi",
      title: translate2("Activate the global connect tool"),
      action: {
        click: function(event) {
          globalConnect.start(event);
        }
      }
    },
    "tool-separator": {
      group: "tools",
      separator: true
    },
    "create.start-event": createAction("bpmn:StartEvent", "event", "bpmn-icon-start-event-none", translate2("Create StartEvent")),
    "create.intermediate-event": createAction("bpmn:IntermediateThrowEvent", "event", "bpmn-icon-intermediate-event-none", translate2("Create Intermediate/Boundary Event")),
    "create.end-event": createAction("bpmn:EndEvent", "event", "bpmn-icon-end-event-none", translate2("Create EndEvent")),
    "create.exclusive-gateway": createAction("bpmn:ExclusiveGateway", "gateway", "bpmn-icon-gateway-none", translate2("Create Gateway")),
    "create.task": createAction("bpmn:Task", "activity", "bpmn-icon-task", translate2("Create Task")),
    "create.data-object": createAction("bpmn:DataObjectReference", "data-object", "bpmn-icon-data-object", translate2("Create DataObjectReference")),
    "create.data-store": createAction("bpmn:DataStoreReference", "data-store", "bpmn-icon-data-store", translate2("Create DataStoreReference")),
    "create.subprocess-expanded": {
      group: "activity",
      className: "bpmn-icon-subprocess-expanded",
      title: translate2("Create expanded SubProcess"),
      action: {
        dragstart: createSubprocess,
        click: createSubprocess
      }
    },
    "create.participant-expanded": {
      group: "collaboration",
      className: "bpmn-icon-participant",
      title: translate2("Create Pool/Participant"),
      action: {
        dragstart: createParticipant,
        click: createParticipant
      }
    },
    "create.group": createAction("bpmn:Group", "artifact", "bpmn-icon-group", translate2("Create Group"))
  });
  return actions;
};
var PaletteModule = {
  __depends__: [
    PaletteModule$1,
    CreateModule,
    SpaceToolModule,
    LassoToolModule,
    HandToolModule,
    GlobalConnectModule,
    translate$2
  ],
  __init__: ["paletteProvider"],
  paletteProvider: ["type", PaletteProvider]
};
var LOW_PRIORITY$1 = 250;
function BpmnReplacePreview(eventBus, elementRegistry, elementFactory, canvas, previewSupport) {
  CommandInterceptor$5.call(this, eventBus);
  function replaceVisual(context) {
    var replacements = context.canExecute.replacements;
    forEach$q(replacements, function(replacement) {
      var id2 = replacement.oldElementId;
      var newElement = {
        type: replacement.newElementType
      };
      if (context.visualReplacements[id2]) {
        return;
      }
      var element = elementRegistry.get(id2);
      assign$e(newElement, { x: element.x, y: element.y });
      var tempShape = elementFactory.createShape(newElement);
      canvas.addShape(tempShape, element.parent);
      var gfx = query('[data-element-id="' + cssEscape(element.id) + '"]', context.dragGroup);
      if (gfx) {
        attr(gfx, { display: "none" });
      }
      var dragger = previewSupport.addDragger(tempShape, context.dragGroup);
      context.visualReplacements[id2] = dragger;
      canvas.removeShape(tempShape);
    });
  }
  function restoreVisual(context) {
    var visualReplacements = context.visualReplacements;
    forEach$q(visualReplacements, function(dragger, id2) {
      var originalGfx = query('[data-element-id="' + cssEscape(id2) + '"]', context.dragGroup);
      if (originalGfx) {
        attr(originalGfx, { display: "inline" });
      }
      dragger.remove();
      if (visualReplacements[id2]) {
        delete visualReplacements[id2];
      }
    });
  }
  eventBus.on("shape.move.move", LOW_PRIORITY$1, function(event) {
    var context = event.context, canExecute = context.canExecute;
    if (!context.visualReplacements) {
      context.visualReplacements = {};
    }
    if (canExecute && canExecute.replacements) {
      replaceVisual(context);
    } else {
      restoreVisual(context);
    }
  });
}
BpmnReplacePreview.$inject = [
  "eventBus",
  "elementRegistry",
  "elementFactory",
  "canvas",
  "previewSupport"
];
inherits$6(BpmnReplacePreview, CommandInterceptor$5);
var ReplacePreviewModule = {
  __depends__: [
    PreviewSupportModule
  ],
  __init__: ["bpmnReplacePreview"],
  bpmnReplacePreview: ["type", BpmnReplacePreview]
};
var HIGHER_PRIORITY$3 = 1250;
var BOUNDARY_TO_HOST_THRESHOLD = 40;
var TARGET_BOUNDS_PADDING = 20, TASK_BOUNDS_PADDING = 10;
var TARGET_CENTER_PADDING = 20;
var AXES = ["x", "y"];
var abs = Math.abs;
function BpmnConnectSnapping(eventBus) {
  eventBus.on([
    "connect.hover",
    "connect.move",
    "connect.end"
  ], HIGHER_PRIORITY$3, function(event) {
    var context = event.context, canExecute = context.canExecute, start = context.start, hover = context.hover, source = context.source, target = context.target;
    if (event.originalEvent && isCmd(event.originalEvent)) {
      return;
    }
    if (!context.initialConnectionStart) {
      context.initialConnectionStart = context.connectionStart;
    }
    if (canExecute && hover) {
      snapToShape(event, hover, getTargetBoundsPadding(hover));
    }
    if (hover && isAnyType(canExecute, [
      "bpmn:Association",
      "bpmn:DataInputAssociation",
      "bpmn:DataOutputAssociation",
      "bpmn:SequenceFlow"
    ])) {
      context.connectionStart = mid$2(start);
      if (isAny$b(hover, ["bpmn:Event", "bpmn:Gateway"])) {
        snapToPosition(event, mid$2(hover));
      }
      if (isAny$b(hover, ["bpmn:Task", "bpmn:SubProcess"])) {
        snapToTargetMid(event, hover);
      }
      if (is$O(source, "bpmn:BoundaryEvent") && target === source.host) {
        snapBoundaryEventLoop(event);
      }
    } else if (isType(canExecute, "bpmn:MessageFlow")) {
      if (is$O(start, "bpmn:Event")) {
        context.connectionStart = mid$2(start);
      }
      if (is$O(hover, "bpmn:Event")) {
        snapToPosition(event, mid$2(hover));
      }
    } else {
      context.connectionStart = context.initialConnectionStart;
    }
  });
}
BpmnConnectSnapping.$inject = ["eventBus"];
function snapToShape(event, target, padding) {
  AXES.forEach(function(axis) {
    var dimensionForAxis = getDimensionForAxis(axis, target);
    if (event[axis] < target[axis] + padding) {
      setSnapped(event, axis, target[axis] + padding);
    } else if (event[axis] > target[axis] + dimensionForAxis - padding) {
      setSnapped(event, axis, target[axis] + dimensionForAxis - padding);
    }
  });
}
function snapToTargetMid(event, target) {
  var targetMid = mid$2(target);
  AXES.forEach(function(axis) {
    if (isMid(event, target, axis)) {
      setSnapped(event, axis, targetMid[axis]);
    }
  });
}
function snapBoundaryEventLoop(event) {
  var context = event.context, source = context.source, target = context.target;
  if (isReverse(context)) {
    return;
  }
  var sourceMid = mid$2(source), orientation = getOrientation(sourceMid, target, -10), axes = [];
  if (/top|bottom/.test(orientation)) {
    axes.push("x");
  }
  if (/left|right/.test(orientation)) {
    axes.push("y");
  }
  axes.forEach(function(axis) {
    var coordinate = event[axis], newCoordinate;
    if (abs(coordinate - sourceMid[axis]) < BOUNDARY_TO_HOST_THRESHOLD) {
      if (coordinate > sourceMid[axis]) {
        newCoordinate = sourceMid[axis] + BOUNDARY_TO_HOST_THRESHOLD;
      } else {
        newCoordinate = sourceMid[axis] - BOUNDARY_TO_HOST_THRESHOLD;
      }
      setSnapped(event, axis, newCoordinate);
    }
  });
}
function snapToPosition(event, position) {
  setSnapped(event, "x", position.x);
  setSnapped(event, "y", position.y);
}
function isType(attrs, type) {
  return attrs && attrs.type === type;
}
function isAnyType(attrs, types2) {
  return some$1(types2, function(type) {
    return isType(attrs, type);
  });
}
function getDimensionForAxis(axis, element) {
  return axis === "x" ? element.width : element.height;
}
function getTargetBoundsPadding(target) {
  if (is$O(target, "bpmn:Task")) {
    return TASK_BOUNDS_PADDING;
  } else {
    return TARGET_BOUNDS_PADDING;
  }
}
function isMid(event, target, axis) {
  return event[axis] > target[axis] + TARGET_CENTER_PADDING && event[axis] < target[axis] + getDimensionForAxis(axis, target) - TARGET_CENTER_PADDING;
}
function isReverse(context) {
  var hover = context.hover, source = context.source;
  return hover && source && hover === source;
}
function SnapContext() {
  this._targets = {};
  this._snapOrigins = {};
  this._snapLocations = [];
  this._defaultSnaps = {};
}
SnapContext.prototype.getSnapOrigin = function(snapLocation) {
  return this._snapOrigins[snapLocation];
};
SnapContext.prototype.setSnapOrigin = function(snapLocation, initialValue) {
  this._snapOrigins[snapLocation] = initialValue;
  if (this._snapLocations.indexOf(snapLocation) === -1) {
    this._snapLocations.push(snapLocation);
  }
};
SnapContext.prototype.addDefaultSnap = function(type, point) {
  var snapValues = this._defaultSnaps[type];
  if (!snapValues) {
    snapValues = this._defaultSnaps[type] = [];
  }
  snapValues.push(point);
};
SnapContext.prototype.getSnapLocations = function() {
  return this._snapLocations;
};
SnapContext.prototype.setSnapLocations = function(snapLocations) {
  this._snapLocations = snapLocations;
};
SnapContext.prototype.pointsForTarget = function(target) {
  var targetId = target.id || target;
  var snapPoints = this._targets[targetId];
  if (!snapPoints) {
    snapPoints = this._targets[targetId] = new SnapPoints();
    snapPoints.initDefaults(this._defaultSnaps);
  }
  return snapPoints;
};
function SnapPoints(defaultSnaps) {
  this._snapValues = {};
}
SnapPoints.prototype.add = function(snapLocation, point) {
  var snapValues = this._snapValues[snapLocation];
  if (!snapValues) {
    snapValues = this._snapValues[snapLocation] = { x: [], y: [] };
  }
  if (snapValues.x.indexOf(point.x) === -1) {
    snapValues.x.push(point.x);
  }
  if (snapValues.y.indexOf(point.y) === -1) {
    snapValues.y.push(point.y);
  }
};
SnapPoints.prototype.snap = function(point, snapLocation, axis, tolerance) {
  var snappingValues = this._snapValues[snapLocation];
  return snappingValues && snapTo(point[axis], snappingValues[axis], tolerance);
};
SnapPoints.prototype.initDefaults = function(defaultSnaps) {
  var self2 = this;
  forEach$q(defaultSnaps || {}, function(snapPoints, snapLocation) {
    forEach$q(snapPoints, function(point) {
      self2.add(snapLocation, point);
    });
  });
};
var HIGHER_PRIORITY$2 = 1250;
function CreateMoveSnapping(elementRegistry, eventBus, snapping) {
  var self2 = this;
  this._elementRegistry = elementRegistry;
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], function(event) {
    self2.initSnap(event);
  });
  eventBus.on([
    "create.move",
    "create.end",
    "shape.move.move",
    "shape.move.end"
  ], HIGHER_PRIORITY$2, function(event) {
    var context = event.context, shape = context.shape, snapContext = context.snapContext, target = context.target;
    if (event.originalEvent && isCmd(event.originalEvent)) {
      return;
    }
    if (isSnapped(event) || !target) {
      return;
    }
    var snapPoints = snapContext.pointsForTarget(target);
    if (!snapPoints.initialized) {
      snapPoints = self2.addSnapTargetPoints(snapPoints, shape, target);
      snapPoints.initialized = true;
    }
    snapping.snap(event, snapPoints);
  });
  eventBus.on([
    "create.cleanup",
    "shape.move.cleanup"
  ], function() {
    snapping.hide();
  });
}
CreateMoveSnapping.$inject = [
  "elementRegistry",
  "eventBus",
  "snapping"
];
CreateMoveSnapping.prototype.initSnap = function(event) {
  var elementRegistry = this._elementRegistry;
  var context = event.context, shape = context.shape, snapContext = context.snapContext;
  if (!snapContext) {
    snapContext = context.snapContext = new SnapContext();
  }
  var shapeMid;
  if (elementRegistry.get(shape.id)) {
    shapeMid = mid$2(shape, event);
  } else {
    shapeMid = {
      x: event.x + mid$2(shape).x,
      y: event.y + mid$2(shape).y
    };
  }
  var shapeTopLeft = {
    x: shapeMid.x - shape.width / 2,
    y: shapeMid.y - shape.height / 2
  }, shapeBottomRight = {
    x: shapeMid.x + shape.width / 2,
    y: shapeMid.y + shape.height / 2
  };
  snapContext.setSnapOrigin("mid", {
    x: shapeMid.x - event.x,
    y: shapeMid.y - event.y
  });
  if (isLabel$1(shape)) {
    return snapContext;
  }
  snapContext.setSnapOrigin("top-left", {
    x: shapeTopLeft.x - event.x,
    y: shapeTopLeft.y - event.y
  });
  snapContext.setSnapOrigin("bottom-right", {
    x: shapeBottomRight.x - event.x,
    y: shapeBottomRight.y - event.y
  });
  return snapContext;
};
CreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  var snapTargets = this.getSnapTargets(shape, target);
  forEach$q(snapTargets, function(snapTarget) {
    if (isLabel$1(snapTarget)) {
      if (isLabel$1(shape)) {
        snapPoints.add("mid", mid$2(snapTarget));
      }
      return;
    }
    if (isConnection$1(snapTarget)) {
      if (snapTarget.waypoints.length < 3) {
        return;
      }
      var waypoints = snapTarget.waypoints.slice(1, -1);
      forEach$q(waypoints, function(waypoint) {
        snapPoints.add("mid", waypoint);
      });
      return;
    }
    snapPoints.add("mid", mid$2(snapTarget));
  });
  if (!isNumber$1(shape.x) || !isNumber$1(shape.y)) {
    return snapPoints;
  }
  if (this._elementRegistry.get(shape.id)) {
    snapPoints.add("mid", mid$2(shape));
  }
  return snapPoints;
};
CreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return getChildren(target).filter(function(child) {
    return !isHidden$1(child);
  });
};
function isConnection$1(element) {
  return !!element.waypoints;
}
function isHidden$1(element) {
  return !!element.hidden;
}
function isLabel$1(element) {
  return !!element.labelTarget;
}
var HIGH_PRIORITY = 1500;
function BpmnCreateMoveSnapping(eventBus, injector) {
  injector.invoke(CreateMoveSnapping, this);
  eventBus.on(["create.move", "create.end"], HIGH_PRIORITY, setSnappedIfConstrained);
  eventBus.on([
    "create.move",
    "create.end",
    "shape.move.move",
    "shape.move.end"
  ], HIGH_PRIORITY, function(event) {
    var context = event.context, canExecute = context.canExecute, target = context.target;
    var canAttach2 = canExecute && (canExecute === "attach" || canExecute.attach);
    if (canAttach2 && !isSnapped(event)) {
      snapBoundaryEvent(event, target);
    }
  });
}
inherits$6(BpmnCreateMoveSnapping, CreateMoveSnapping);
BpmnCreateMoveSnapping.$inject = [
  "eventBus",
  "injector"
];
BpmnCreateMoveSnapping.prototype.initSnap = function(event) {
  var snapContext = CreateMoveSnapping.prototype.initSnap.call(this, event);
  var shape = event.shape;
  var isMove = !!this._elementRegistry.get(shape.id);
  forEach$q(shape.outgoing, function(connection) {
    var docking = connection.waypoints[0];
    docking = docking.original || docking;
    snapContext.setSnapOrigin(connection.id + "-docking", getDockingSnapOrigin(docking, isMove, event));
  });
  forEach$q(shape.incoming, function(connection) {
    var docking = connection.waypoints[connection.waypoints.length - 1];
    docking = docking.original || docking;
    snapContext.setSnapOrigin(connection.id + "-docking", getDockingSnapOrigin(docking, isMove, event));
  });
  if (is$O(shape, "bpmn:Participant")) {
    snapContext.setSnapLocations(["top-left", "bottom-right", "mid"]);
  }
  return snapContext;
};
BpmnCreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  CreateMoveSnapping.prototype.addSnapTargetPoints.call(this, snapPoints, shape, target);
  var snapTargets = this.getSnapTargets(shape, target);
  forEach$q(snapTargets, function(snapTarget) {
    if (isContainer(snapTarget) || areAll([shape, snapTarget], "bpmn:TextAnnotation")) {
      snapPoints.add("top-left", topLeft(snapTarget));
      snapPoints.add("bottom-right", bottomRight(snapTarget));
    }
  });
  var elementRegistry = this._elementRegistry;
  forEach$q(shape.incoming, function(connection) {
    if (elementRegistry.get(shape.id)) {
      if (!includes(snapTargets, connection.source)) {
        snapPoints.add("mid", getMid(connection.source));
      }
      var docking = connection.waypoints[0];
      snapPoints.add(connection.id + "-docking", docking.original || docking);
    }
  });
  forEach$q(shape.outgoing, function(connection) {
    if (elementRegistry.get(shape.id)) {
      if (!includes(snapTargets, connection.target)) {
        snapPoints.add("mid", getMid(connection.target));
      }
      var docking = connection.waypoints[connection.waypoints.length - 1];
      snapPoints.add(connection.id + "-docking", docking.original || docking);
    }
  });
  if (is$O(target, "bpmn:SequenceFlow")) {
    snapPoints = this.addSnapTargetPoints(snapPoints, shape, target.parent);
  }
  return snapPoints;
};
BpmnCreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return CreateMoveSnapping.prototype.getSnapTargets.call(this, shape, target).filter(function(snapTarget) {
    return !is$O(snapTarget, "bpmn:Lane");
  });
};
function snapBoundaryEvent(event, target) {
  var targetTRBL = asTRBL(target);
  var direction = getBoundaryAttachment(event, target);
  var context = event.context, shape = context.shape;
  var offset2;
  if (shape.parent) {
    offset2 = { x: 0, y: 0 };
  } else {
    offset2 = getMid(shape);
  }
  if (/top/.test(direction)) {
    setSnapped(event, "y", targetTRBL.top - offset2.y);
  } else if (/bottom/.test(direction)) {
    setSnapped(event, "y", targetTRBL.bottom - offset2.y);
  }
  if (/left/.test(direction)) {
    setSnapped(event, "x", targetTRBL.left - offset2.x);
  } else if (/right/.test(direction)) {
    setSnapped(event, "x", targetTRBL.right - offset2.x);
  }
}
function areAll(elements, type) {
  return elements.every(function(el) {
    return is$O(el, type);
  });
}
function isContainer(element) {
  if (is$O(element, "bpmn:SubProcess") && isExpanded(element)) {
    return true;
  }
  return is$O(element, "bpmn:Participant");
}
function setSnappedIfConstrained(event) {
  var context = event.context, createConstraints = context.createConstraints;
  if (!createConstraints) {
    return;
  }
  var top = createConstraints.top, right = createConstraints.right, bottom = createConstraints.bottom, left = createConstraints.left;
  if (left && left >= event.x || right && right <= event.x) {
    setSnapped(event, "x", event.x);
  }
  if (top && top >= event.y || bottom && bottom <= event.y) {
    setSnapped(event, "y", event.y);
  }
}
function includes(array, value) {
  return array.indexOf(value) !== -1;
}
function getDockingSnapOrigin(docking, isMove, event) {
  return isMove ? {
    x: docking.x - event.x,
    y: docking.y - event.y
  } : {
    x: docking.x,
    y: docking.y
  };
}
var HIGHER_PRIORITY$1 = 1250;
function ResizeSnapping(eventBus, snapping) {
  var self2 = this;
  eventBus.on(["resize.start"], function(event) {
    self2.initSnap(event);
  });
  eventBus.on([
    "resize.move",
    "resize.end"
  ], HIGHER_PRIORITY$1, function(event) {
    var context = event.context, shape = context.shape, parent2 = shape.parent, direction = context.direction, snapContext = context.snapContext;
    if (event.originalEvent && isCmd(event.originalEvent)) {
      return;
    }
    if (isSnapped(event)) {
      return;
    }
    var snapPoints = snapContext.pointsForTarget(parent2);
    if (!snapPoints.initialized) {
      snapPoints = self2.addSnapTargetPoints(snapPoints, shape, parent2, direction);
      snapPoints.initialized = true;
    }
    if (isHorizontal(direction)) {
      setSnapped(event, "x", event.x);
    }
    if (isVertical(direction)) {
      setSnapped(event, "y", event.y);
    }
    snapping.snap(event, snapPoints);
  });
  eventBus.on(["resize.cleanup"], function() {
    snapping.hide();
  });
}
ResizeSnapping.prototype.initSnap = function(event) {
  var context = event.context, shape = context.shape, direction = context.direction, snapContext = context.snapContext;
  if (!snapContext) {
    snapContext = context.snapContext = new SnapContext();
  }
  var snapOrigin = getSnapOrigin(shape, direction);
  snapContext.setSnapOrigin("corner", {
    x: snapOrigin.x - event.x,
    y: snapOrigin.y - event.y
  });
  return snapContext;
};
ResizeSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target, direction) {
  var snapTargets = this.getSnapTargets(shape, target);
  forEach$q(snapTargets, function(snapTarget) {
    snapPoints.add("corner", bottomRight(snapTarget));
    snapPoints.add("corner", topLeft(snapTarget));
  });
  snapPoints.add("corner", getSnapOrigin(shape, direction));
  return snapPoints;
};
ResizeSnapping.$inject = [
  "eventBus",
  "snapping"
];
ResizeSnapping.prototype.getSnapTargets = function(shape, target) {
  return getChildren(target).filter(function(child) {
    return !isAttached(child, shape) && !isConnection(child) && !isHidden(child) && !isLabel(child);
  });
};
function getSnapOrigin(shape, direction) {
  var mid2 = getMid(shape), trbl = asTRBL(shape);
  var snapOrigin = {
    x: mid2.x,
    y: mid2.y
  };
  if (direction.indexOf("n") !== -1) {
    snapOrigin.y = trbl.top;
  } else if (direction.indexOf("s") !== -1) {
    snapOrigin.y = trbl.bottom;
  }
  if (direction.indexOf("e") !== -1) {
    snapOrigin.x = trbl.right;
  } else if (direction.indexOf("w") !== -1) {
    snapOrigin.x = trbl.left;
  }
  return snapOrigin;
}
function isAttached(element, host) {
  return element.host === host;
}
function isConnection(element) {
  return !!element.waypoints;
}
function isHidden(element) {
  return !!element.hidden;
}
function isLabel(element) {
  return !!element.labelTarget;
}
function isHorizontal(direction) {
  return direction === "n" || direction === "s";
}
function isVertical(direction) {
  return direction === "e" || direction === "w";
}
var SNAP_TOLERANCE = 7;
var SNAP_LINE_HIDE_DELAY = 1e3;
function Snapping(canvas) {
  this._canvas = canvas;
  this._asyncHide = debounce$3(bind$3(this.hide, this), SNAP_LINE_HIDE_DELAY);
}
Snapping.$inject = ["canvas"];
Snapping.prototype.snap = function(event, snapPoints) {
  var context = event.context, snapContext = context.snapContext, snapLocations = snapContext.getSnapLocations();
  var snapping = {
    x: isSnapped(event, "x"),
    y: isSnapped(event, "y")
  };
  forEach$q(snapLocations, function(location) {
    var snapOrigin = snapContext.getSnapOrigin(location);
    var snapCurrent = {
      x: event.x + snapOrigin.x,
      y: event.y + snapOrigin.y
    };
    forEach$q(["x", "y"], function(axis) {
      var locationSnapping;
      if (!snapping[axis]) {
        locationSnapping = snapPoints.snap(snapCurrent, location, axis, SNAP_TOLERANCE);
        if (locationSnapping !== void 0) {
          snapping[axis] = {
            value: locationSnapping,
            originValue: locationSnapping - snapOrigin[axis]
          };
        }
      }
    });
    if (snapping.x && snapping.y) {
      return false;
    }
  });
  this.showSnapLine("vertical", snapping.x && snapping.x.value);
  this.showSnapLine("horizontal", snapping.y && snapping.y.value);
  forEach$q(["x", "y"], function(axis) {
    var axisSnapping = snapping[axis];
    if (isObject$e(axisSnapping)) {
      setSnapped(event, axis, axisSnapping.originValue);
    }
  });
};
Snapping.prototype._createLine = function(orientation) {
  var root2 = this._canvas.getLayer("snap");
  var line = create$2("path");
  attr(line, { d: "M0,0 L0,0" });
  classes(line).add("djs-snap-line");
  append$3(root2, line);
  return {
    update: function(position) {
      if (!isNumber$1(position)) {
        attr(line, { display: "none" });
      } else {
        if (orientation === "horizontal") {
          attr(line, {
            d: "M-100000," + position + " L+100000," + position,
            display: ""
          });
        } else {
          attr(line, {
            d: "M " + position + ",-100000 L " + position + ", +100000",
            display: ""
          });
        }
      }
    }
  };
};
Snapping.prototype._createSnapLines = function() {
  this._snapLines = {
    horizontal: this._createLine("horizontal"),
    vertical: this._createLine("vertical")
  };
};
Snapping.prototype.showSnapLine = function(orientation, position) {
  var line = this.getSnapLine(orientation);
  if (line) {
    line.update(position);
  }
  this._asyncHide();
};
Snapping.prototype.getSnapLine = function(orientation) {
  if (!this._snapLines) {
    this._createSnapLines();
  }
  return this._snapLines[orientation];
};
Snapping.prototype.hide = function() {
  forEach$q(this._snapLines, function(snapLine) {
    snapLine.update();
  });
};
var SnappingModule$1 = {
  __init__: [
    "createMoveSnapping",
    "resizeSnapping",
    "snapping"
  ],
  createMoveSnapping: ["type", CreateMoveSnapping],
  resizeSnapping: ["type", ResizeSnapping],
  snapping: ["type", Snapping]
};
var SnappingModule = {
  __depends__: [SnappingModule$1],
  __init__: [
    "connectSnapping",
    "createMoveSnapping"
  ],
  connectSnapping: ["type", BpmnConnectSnapping],
  createMoveSnapping: ["type", BpmnCreateMoveSnapping]
};
function SearchPad(canvas, eventBus, overlays, selection) {
  this._open = false;
  this._results = [];
  this._eventMaps = [];
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._overlays = overlays;
  this._selection = selection;
  this._container = domify$h(SearchPad.BOX_HTML);
  this._searchInput = query(SearchPad.INPUT_SELECTOR, this._container);
  this._resultsContainer = query(SearchPad.RESULTS_CONTAINER_SELECTOR, this._container);
  this._canvas.getContainer().appendChild(this._container);
  eventBus.on(["canvas.destroy", "diagram.destroy"], this.close, this);
}
SearchPad.$inject = [
  "canvas",
  "eventBus",
  "overlays",
  "selection"
];
SearchPad.prototype._bindEvents = function() {
  var self2 = this;
  function listen(el, selector2, type, fn) {
    self2._eventMaps.push({
      el,
      type,
      listener: delegate$1.bind(el, selector2, type, fn)
    });
  }
  listen(document, "html", "click", function(e) {
    self2.close();
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "click", function(e) {
    e.stopPropagation();
    e.delegateTarget.focus();
  });
  listen(this._container, SearchPad.RESULT_SELECTOR, "mouseover", function(e) {
    e.stopPropagation();
    self2._scrollToNode(e.delegateTarget);
    self2._preselect(e.delegateTarget);
  });
  listen(this._container, SearchPad.RESULT_SELECTOR, "click", function(e) {
    e.stopPropagation();
    self2._select(e.delegateTarget);
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "keydown", function(e) {
    if (e.keyCode === 38) {
      e.preventDefault();
    }
    if (e.keyCode === 40) {
      e.preventDefault();
    }
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "keyup", function(e) {
    if (e.keyCode === 27) {
      return self2.close();
    }
    if (e.keyCode === 13) {
      var selected = self2._getCurrentResult();
      return selected ? self2._select(selected) : self2.close();
    }
    if (e.keyCode === 38) {
      return self2._scrollToDirection(true);
    }
    if (e.keyCode === 40) {
      return self2._scrollToDirection();
    }
    if (e.keyCode === 37 || e.keyCode === 39) {
      return;
    }
    self2._search(e.delegateTarget.value);
  });
};
SearchPad.prototype._unbindEvents = function() {
  this._eventMaps.forEach(function(m) {
    delegate$1.unbind(m.el, m.type, m.listener);
  });
};
SearchPad.prototype._search = function(pattern) {
  var self2 = this;
  this._clearResults();
  if (!pattern || pattern === "") {
    return;
  }
  var searchResults = this._searchProvider.find(pattern);
  if (!searchResults.length) {
    return;
  }
  searchResults.forEach(function(result) {
    var id2 = result.element.id;
    var node3 = self2._createResultNode(result, id2);
    self2._results[id2] = {
      element: result.element,
      node: node3
    };
  });
  var node2 = query(SearchPad.RESULT_SELECTOR, this._resultsContainer);
  this._scrollToNode(node2);
  this._preselect(node2);
};
SearchPad.prototype._scrollToDirection = function(previous) {
  var selected = this._getCurrentResult();
  if (!selected) {
    return;
  }
  var node2 = previous ? selected.previousElementSibling : selected.nextElementSibling;
  if (node2) {
    this._scrollToNode(node2);
    this._preselect(node2);
  }
};
SearchPad.prototype._scrollToNode = function(node2) {
  if (!node2 || node2 === this._getCurrentResult()) {
    return;
  }
  var nodeOffset = node2.offsetTop;
  var containerScroll = this._resultsContainer.scrollTop;
  var bottomScroll = nodeOffset - this._resultsContainer.clientHeight + node2.clientHeight;
  if (nodeOffset < containerScroll) {
    this._resultsContainer.scrollTop = nodeOffset;
  } else if (containerScroll < bottomScroll) {
    this._resultsContainer.scrollTop = bottomScroll;
  }
};
SearchPad.prototype._clearResults = function() {
  clear$1(this._resultsContainer);
  this._results = [];
  this._resetOverlay();
  this._eventBus.fire("searchPad.cleared");
};
SearchPad.prototype._getCurrentResult = function() {
  return query(SearchPad.RESULT_SELECTED_SELECTOR, this._resultsContainer);
};
SearchPad.prototype._createResultNode = function(result, id2) {
  var node2 = domify$h(SearchPad.RESULT_HTML);
  if (result.primaryTokens.length > 0) {
    createInnerTextNode(node2, result.primaryTokens, SearchPad.RESULT_PRIMARY_HTML);
  }
  createInnerTextNode(node2, result.secondaryTokens, SearchPad.RESULT_SECONDARY_HTML);
  attr$1(node2, SearchPad.RESULT_ID_ATTRIBUTE, id2);
  this._resultsContainer.appendChild(node2);
  return node2;
};
SearchPad.prototype.registerProvider = function(provider) {
  this._searchProvider = provider;
};
SearchPad.prototype.open = function() {
  if (!this._searchProvider) {
    throw new Error("no search provider registered");
  }
  if (this.isOpen()) {
    return;
  }
  this._bindEvents();
  this._open = true;
  classes$1(this._container).add("open");
  this._searchInput.focus();
  this._eventBus.fire("searchPad.opened");
};
SearchPad.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }
  this._unbindEvents();
  this._open = false;
  classes$1(this._container).remove("open");
  this._clearResults();
  this._searchInput.value = "";
  this._searchInput.blur();
  this._resetOverlay();
  this._eventBus.fire("searchPad.closed");
};
SearchPad.prototype.toggle = function() {
  this.isOpen() ? this.close() : this.open();
};
SearchPad.prototype.isOpen = function() {
  return this._open;
};
SearchPad.prototype._preselect = function(node2) {
  var selectedNode = this._getCurrentResult();
  if (node2 === selectedNode) {
    return;
  }
  if (selectedNode) {
    classes$1(selectedNode).remove(SearchPad.RESULT_SELECTED_CLASS);
  }
  var id2 = attr$1(node2, SearchPad.RESULT_ID_ATTRIBUTE);
  var element = this._results[id2].element;
  classes$1(node2).add(SearchPad.RESULT_SELECTED_CLASS);
  this._resetOverlay(element);
  this._canvas.scrollToElement(element, { top: 400 });
  this._selection.select(element);
  this._eventBus.fire("searchPad.preselected", element);
};
SearchPad.prototype._select = function(node2) {
  var id2 = attr$1(node2, SearchPad.RESULT_ID_ATTRIBUTE);
  var element = this._results[id2].element;
  this.close();
  this._resetOverlay();
  this._canvas.scrollToElement(element, { top: 400 });
  this._selection.select(element);
  this._eventBus.fire("searchPad.selected", element);
};
SearchPad.prototype._resetOverlay = function(element) {
  if (this._overlayId) {
    this._overlays.remove(this._overlayId);
  }
  if (element) {
    var box = getBBox(element);
    var overlay = constructOverlay(box);
    this._overlayId = this._overlays.add(element, overlay);
  }
};
function constructOverlay(box) {
  var offset2 = 6;
  var w = box.width + offset2 * 2;
  var h = box.height + offset2 * 2;
  var styles = [
    "width: " + w + "px",
    "height: " + h + "px"
  ].join("; ");
  return {
    position: {
      bottom: h - offset2,
      right: w - offset2
    },
    show: true,
    html: '<div style="' + styles + '" class="' + SearchPad.OVERLAY_CLASS + '"></div>'
  };
}
function createInnerTextNode(parentNode, tokens, template2) {
  var text = createHtmlText(tokens);
  var childNode = domify$h(template2);
  childNode.innerHTML = text;
  parentNode.appendChild(childNode);
}
function createHtmlText(tokens) {
  var htmlText = "";
  tokens.forEach(function(t) {
    if (t.matched) {
      htmlText += '<strong class="' + SearchPad.RESULT_HIGHLIGHT_CLASS + '">' + escapeHTML$n(t.matched) + "</strong>";
    } else {
      htmlText += escapeHTML$n(t.normal);
    }
  });
  return htmlText !== "" ? htmlText : null;
}
SearchPad.CONTAINER_SELECTOR = ".djs-search-container";
SearchPad.INPUT_SELECTOR = ".djs-search-input input";
SearchPad.RESULTS_CONTAINER_SELECTOR = ".djs-search-results";
SearchPad.RESULT_SELECTOR = ".djs-search-result";
SearchPad.RESULT_SELECTED_CLASS = "djs-search-result-selected";
SearchPad.RESULT_SELECTED_SELECTOR = "." + SearchPad.RESULT_SELECTED_CLASS;
SearchPad.RESULT_ID_ATTRIBUTE = "data-result-id";
SearchPad.RESULT_HIGHLIGHT_CLASS = "djs-search-highlight";
SearchPad.OVERLAY_CLASS = "djs-search-overlay";
SearchPad.BOX_HTML = '<div class="djs-search-container djs-draggable djs-scrollable"><div class="djs-search-input"><input type="text"/></div><div class="djs-search-results"></div></div>';
SearchPad.RESULT_HTML = '<div class="djs-search-result"></div>';
SearchPad.RESULT_PRIMARY_HTML = '<div class="djs-search-result-primary"></div>';
SearchPad.RESULT_SECONDARY_HTML = '<p class="djs-search-result-secondary"></p>';
var SearchPadModule = {
  __depends__: [
    OverlaysModule,
    SelectionModule
  ],
  searchPad: ["type", SearchPad]
};
function BpmnSearchProvider(elementRegistry, searchPad, canvas) {
  this._elementRegistry = elementRegistry;
  this._canvas = canvas;
  searchPad.registerProvider(this);
}
BpmnSearchProvider.$inject = [
  "elementRegistry",
  "searchPad",
  "canvas"
];
BpmnSearchProvider.prototype.find = function(pattern) {
  var rootElement = this._canvas.getRootElement();
  var elements = this._elementRegistry.filter(function(element) {
    if (element.labelTarget) {
      return false;
    }
    return true;
  });
  elements = filter$a(elements, function(element) {
    return element !== rootElement;
  });
  elements = map$7(elements, function(element) {
    return {
      primaryTokens: matchAndSplit(getLabel(element), pattern),
      secondaryTokens: matchAndSplit(element.id, pattern),
      element
    };
  });
  elements = filter$a(elements, function(element) {
    return hasMatched(element.primaryTokens) || hasMatched(element.secondaryTokens);
  });
  elements = sortBy$2(elements, function(element) {
    return getLabel(element.element) + element.element.id;
  });
  return elements;
};
function hasMatched(tokens) {
  var matched = filter$a(tokens, function(t) {
    return !!t.matched;
  });
  return matched.length > 0;
}
function matchAndSplit(text, pattern) {
  var tokens = [], originalText = text;
  if (!text) {
    return tokens;
  }
  text = text.toLowerCase();
  pattern = pattern.toLowerCase();
  var i = text.indexOf(pattern);
  if (i > -1) {
    if (i !== 0) {
      tokens.push({
        normal: originalText.substr(0, i)
      });
    }
    tokens.push({
      matched: originalText.substr(i, pattern.length)
    });
    if (pattern.length + i < text.length) {
      tokens.push({
        normal: originalText.substr(pattern.length + i, text.length)
      });
    }
  } else {
    tokens.push({
      normal: originalText
    });
  }
  return tokens;
}
var SearchModule = {
  __depends__: [
    SearchPadModule
  ],
  __init__: ["bpmnSearch"],
  bpmnSearch: ["type", BpmnSearchProvider]
};
var initialDiagram = '<?xml version="1.0" encoding="UTF-8"?><bpmn:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" targetNamespace="http://bpmn.io/schema/bpmn" id="Definitions_1"><bpmn:process id="Process_1" isExecutable="false"><bpmn:startEvent id="StartEvent_1"/></bpmn:process><bpmndi:BPMNDiagram id="BPMNDiagram_1"><bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1"><bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1"><dc:Bounds height="36.0" width="36.0" x="173.0" y="102.0"/></bpmndi:BPMNShape></bpmndi:BPMNPlane></bpmndi:BPMNDiagram></bpmn:definitions>';
function Modeler(options) {
  BaseModeler.call(this, options);
}
inherits$6(Modeler, BaseModeler);
Modeler.Viewer = Viewer;
Modeler.NavigatedViewer = NavigatedViewer;
Modeler.prototype.createDiagram = wrapForCompatibility(function createDiagram() {
  return this.importXML(initialDiagram);
});
Modeler.prototype._interactionModules = [
  KeyboardMoveModule,
  MoveCanvasModule,
  TouchModule,
  ZoomScrollModule
];
Modeler.prototype._modelingModules = [
  AlignElementsModule,
  AutoPlaceModule,
  AutoScrollModule,
  AutoResizeModule,
  BendpointsModule,
  ConnectModule,
  ConnectionPreviewModule,
  ContextPadModule,
  CopyPasteModule,
  CreateModule,
  DistributeElementsModule,
  EditorActionsModule,
  GridSnappingModule,
  InteractionEventsModule,
  KeyboardModule,
  KeyboardMoveSelectionModule,
  LabelEditingModule,
  ModelingModule,
  MoveModule,
  PaletteModule,
  ReplacePreviewModule,
  ResizeModule,
  SnappingModule,
  SearchModule
];
Modeler.prototype._modules = [].concat(Viewer.prototype._modules, Modeler.prototype._interactionModules, Modeler.prototype._modelingModules);
function arrayEach$3(array, iteratee) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$3;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key = props[fromRight ? length2 : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
function baseTimes$1(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$d = freeGlobal || freeSelf || Function("return this")();
var _root = root$d;
var root$c = _root;
var Symbol$6 = root$c.Symbol;
var _Symbol = Symbol$6;
var Symbol$5 = _Symbol;
var objectProto$g = Object.prototype;
var hasOwnProperty$d = objectProto$g.hasOwnProperty;
var nativeObjectToString$1 = objectProto$g.toString;
var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$d.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$f = Object.prototype;
var nativeObjectToString = objectProto$f.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$4 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : void 0;
function baseGetTag$7(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$7;
function isObjectLike$9(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$9;
var baseGetTag$6 = _baseGetTag, isObjectLike$8 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$8(value) && baseGetTag$6(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$7 = isObjectLike_1;
var objectProto$e = Object.prototype;
var hasOwnProperty$c = objectProto$e.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable;
var isArguments$4 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$7(value) && hasOwnProperty$c.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$4;
var isArray$k = Array.isArray;
var isArray_1 = isArray$k;
var isBuffer$4 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$4, isBuffer$4.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$6(value, length2) {
  var type = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
var _isIndex = isIndex$6;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$3;
var baseGetTag$5 = _baseGetTag, isLength$2 = isLength_1, isObjectLike$6 = isObjectLike_1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$3 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$3] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$3] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$6(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$5(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$2(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$2;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary$1 = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$4 = nodeIsTypedArray ? baseUnary$1(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$4;
var baseTimes = _baseTimes, isArguments$3 = isArguments_1, isArray$j = isArray_1, isBuffer$3 = isBuffer$4.exports, isIndex$5 = _isIndex, isTypedArray$3 = isTypedArray_1;
var objectProto$d = Object.prototype;
var hasOwnProperty$b = objectProto$d.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$j(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$3(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray$3(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$b.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex$5(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$c = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$c;
  return value === proto2;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$b = Object.prototype;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
function baseKeys$2(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$a.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$2;
function isObject$d(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$d;
var baseGetTag$4 = _baseGetTag, isObject$c = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$5(value) {
  if (!isObject$c(value)) {
    return false;
  }
  var tag = baseGetTag$4(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$5;
var isFunction$4 = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$8(value) {
  return value != null && isLength$1(value.length) && !isFunction$4(value);
}
var isArrayLike_1 = isArrayLike$8;
var arrayLikeKeys = _arrayLikeKeys, baseKeys$1 = _baseKeys, isArrayLike$7 = isArrayLike_1;
function keys$c(object) {
  return isArrayLike$7(object) ? arrayLikeKeys(object) : baseKeys$1(object);
}
var keys_1 = keys$c;
var baseFor = _baseFor, keys$b = keys_1;
function baseForOwn$2(object, iteratee) {
  return object && baseFor(object, iteratee, keys$b);
}
var _baseForOwn = baseForOwn$2;
var isArrayLike$6 = isArrayLike_1;
function createBaseEach$1(eachFunc, fromRight) {
  return function(collection2, iteratee) {
    if (collection2 == null) {
      return collection2;
    }
    if (!isArrayLike$6(collection2)) {
      return eachFunc(collection2, iteratee);
    }
    var length2 = collection2.length, index2 = fromRight ? length2 : -1, iterable = Object(collection2);
    while (fromRight ? index2-- : ++index2 < length2) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection2;
  };
}
var _createBaseEach = createBaseEach$1;
var baseForOwn$1 = _baseForOwn, createBaseEach = _createBaseEach;
var baseEach$5 = createBaseEach(baseForOwn$1);
var _baseEach = baseEach$5;
function identity$5(value) {
  return value;
}
var identity_1 = identity$5;
var identity$4 = identity_1;
function castFunction$1(value) {
  return typeof value == "function" ? value : identity$4;
}
var _castFunction = castFunction$1;
var arrayEach$2 = _arrayEach, baseEach$4 = _baseEach, castFunction = _castFunction, isArray$i = isArray_1;
function forEach$p(collection2, iteratee) {
  var func = isArray$i(collection2) ? arrayEach$2 : baseEach$4;
  return func(collection2, castFunction(iteratee));
}
var forEach_1 = forEach$p;
var isObject$b = isObject_1;
var objectCreate = Object.create;
var baseCreate$4 = function() {
  function object() {
  }
  return function(proto2) {
    if (!isObject$b(proto2)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto2);
    }
    object.prototype = proto2;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$4;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$4;
var eq$3 = eq_1;
function assocIndexOf$4(array, key) {
  var length2 = array.length;
  while (length2--) {
    if (eq$3(array[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto$1 = Array.prototype;
var splice$1 = arrayProto$1.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var root$b = _root;
var coreJsData$1 = root$b["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$3 = isFunction_1, isMasked = _isMasked, isObject$a = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$a = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
  if (!isObject$a(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$3(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative, root$a = _root;
var Map$4 = getNative$6(root$a, "Map");
var _Map = Map$4;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$2 = _MapCache;
var LARGE_ARRAY_SIZE$2 = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$2(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$2(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$3(values2) {
  var index2 = -1, length2 = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache$1();
  while (++index2 < length2) {
    this.add(values2[index2]);
  }
}
SetCache$3.prototype.add = SetCache$3.prototype.push = setCacheAdd;
SetCache$3.prototype.has = setCacheHas;
var _SetCache = SetCache$3;
function arraySome$1(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$3(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$3;
var SetCache$2 = _SetCache, arraySome = _arraySome, cacheHas$2 = _cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache$2() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas$2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
var root$9 = _root;
var Uint8Array$1 = root$9.Uint8Array;
var _Uint8Array = Uint8Array$1;
function mapToArray$1(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$3(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$3;
var Symbol$3 = _Symbol, Uint8Array = _Uint8Array, eq$2 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray$2 = _setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$1 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$2 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]";
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;
    case boolTag$1:
    case dateTag:
    case numberTag:
      return eq$2(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag$1:
      return object == other + "";
    case mapTag$2:
      var convert = mapToArray;
    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray$2);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$2(array, values2) {
  var index2 = -1, length2 = values2.length, offset2 = array.length;
  while (++index2 < length2) {
    array[offset2 + index2] = values2[index2];
  }
  return array;
}
var _arrayPush = arrayPush$2;
var arrayPush$1 = _arrayPush, isArray$h = isArray_1;
function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$h(object) ? result : arrayPush$1(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$1;
function arrayFilter$3(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$3;
function stubArray$1() {
  return [];
}
var stubArray_1 = stubArray$1;
var arrayFilter$2 = _arrayFilter, stubArray = stubArray_1;
var objectProto$7 = Object.prototype;
var propertyIsEnumerable = objectProto$7.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter$2(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys$a = keys_1;
function getAllKeys$1(object) {
  return baseGetAllKeys(object, keys$a, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$6.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$4 = _getNative, root$8 = _root;
var DataView$1 = getNative$4(root$8, "DataView");
var _DataView = DataView$1;
var getNative$3 = _getNative, root$7 = _root;
var Promise$2 = getNative$3(root$7, "Promise");
var _Promise = Promise$2;
var getNative$2 = _getNative, root$6 = _root;
var Set$3 = getNative$2(root$6, "Set");
var _Set = Set$3;
var getNative$1 = _getNative, root$5 = _root;
var WeakMap$2 = getNative$1(root$5, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$2 = _Set, WeakMap$1 = _WeakMap, baseGetTag$3 = _baseGetTag, toSource = _toSource;
var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
var getTag$2 = baseGetTag$3;
if (DataView && getTag$2(new DataView(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$2(new Map$1()) != mapTag$1 || Promise$1 && getTag$2(Promise$1.resolve()) != promiseTag || Set$2 && getTag$2(new Set$2()) != setTag$1 || WeakMap$1 && getTag$2(new WeakMap$1()) != weakMapTag) {
  getTag$2 = function(value) {
    var result = baseGetTag$3(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag$1;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$1;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var _getTag = getTag$2;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag$1 = _getTag, isArray$g = isArray_1, isBuffer$2 = isBuffer$4.exports, isTypedArray$2 = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$g(object), othIsArr = isArray$g(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$2(object)) {
    if (!isBuffer$2(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray$2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$5.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$5.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$5 = isObjectLike_1;
function baseIsEqual$2(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$5(value) && !isObjectLike$5(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);
}
var _baseIsEqual = baseIsEqual$2;
var Stack = _Stack, baseIsEqual$1 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(object, source, matchData, customizer) {
  var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length2) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject$9 = isObject_1;
function isStrictComparable$2(value) {
  return value === value && !isObject$9(value);
}
var _isStrictComparable = isStrictComparable$2;
var isStrictComparable$1 = _isStrictComparable, keys$9 = keys_1;
function getMatchData$1(object) {
  var result = keys$9(object), length2 = result.length;
  while (length2--) {
    var key = result[length2], value = object[key];
    result[length2] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2;
var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
var baseGetTag$2 = _baseGetTag, isObjectLike$4 = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$4(value) {
  return typeof value == "symbol" || isObjectLike$4(value) && baseGetTag$2(value) == symbolTag;
}
var isSymbol_1 = isSymbol$4;
var isArray$f = isArray_1, isSymbol$3 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$3(value, object) {
  if (isArray$f(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$3(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$3;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT$2 = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match2, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap$4(array, iteratee) {
  var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
  while (++index2 < length2) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var _arrayMap = arrayMap$4;
var Symbol$2 = _Symbol, arrayMap$3 = _arrayMap, isArray$e = isArray_1, isSymbol$2 = isSymbol_1;
var INFINITY$4 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$e(value)) {
    return arrayMap$3(value, baseToString$1) + "";
  }
  if (isSymbol$2(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$4 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$1(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$1;
var isArray$d = isArray_1, isKey$2 = _isKey, stringToPath = _stringToPath, toString = toString_1;
function castPath$5(value, object) {
  if (isArray$d(value)) {
    return value;
  }
  return isKey$2(value, object) ? [value] : stringToPath(toString(value));
}
var _castPath = castPath$5;
var isSymbol$1 = isSymbol_1;
var INFINITY$3 = 1 / 0;
function toKey$6(value) {
  if (typeof value == "string" || isSymbol$1(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
}
var _toKey = toKey$6;
var castPath$4 = _castPath, toKey$5 = _toKey;
function baseGet$4(object, path) {
  path = castPath$4(path, object);
  var index2 = 0, length2 = path.length;
  while (object != null && index2 < length2) {
    object = object[toKey$5(path[index2++])];
  }
  return index2 && index2 == length2 ? object : void 0;
}
var _baseGet = baseGet$4;
var baseGet$3 = _baseGet;
function get$3(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet$3(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$3;
function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath$3 = _castPath, isArguments$2 = isArguments_1, isArray$c = isArray_1, isIndex$4 = _isIndex, isLength = isLength_1, toKey$4 = _toKey;
function hasPath$1(object, path, hasFunc) {
  path = castPath$3(path, object);
  var index2 = -1, length2 = path.length, result = false;
  while (++index2 < length2) {
    var key = toKey$4(path[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length2) {
    return result;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength(length2) && isIndex$4(key, length2) && (isArray$c(object) || isArguments$2(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn, hasPath = _hasPath;
function hasIn$2(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var hasIn_1 = hasIn$2;
var baseIsEqual = _baseIsEqual, get$2 = get_1, hasIn$1 = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$3 = _toKey;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(path, srcValue) {
  if (isKey$1(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$3(path), srcValue);
  }
  return function(object) {
    var objValue = get$2(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn$1(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function baseProperty$1(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var _baseProperty = baseProperty$1;
var baseGet$2 = _baseGet;
function basePropertyDeep$1(path) {
  return function(object) {
    return baseGet$2(object, path);
  };
}
var _basePropertyDeep = basePropertyDeep$1;
var baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey$2 = _toKey;
function property$1(path) {
  return isKey(path) ? baseProperty(toKey$2(path)) : basePropertyDeep(path);
}
var property_1 = property$1;
var baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity$3 = identity_1, isArray$b = isArray_1, property = property_1;
function baseIteratee$8(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$3;
  }
  if (typeof value == "object") {
    return isArray$b(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var _baseIteratee = baseIteratee$8;
var overArg = _overArg;
var getPrototype$1 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$1;
var arrayEach$1 = _arrayEach, baseCreate$3 = _baseCreate, baseForOwn = _baseForOwn, baseIteratee$7 = _baseIteratee, getPrototype = _getPrototype, isArray$a = isArray_1, isBuffer$1 = isBuffer$4.exports, isFunction$2 = isFunction_1, isObject$8 = isObject_1, isTypedArray$1 = isTypedArray_1;
function transform(object, iteratee, accumulator) {
  var isArr = isArray$a(object), isArrLike = isArr || isBuffer$1(object) || isTypedArray$1(object);
  iteratee = baseIteratee$7(iteratee);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject$8(object)) {
      accumulator = isFunction$2(Ctor) ? baseCreate$3(getPrototype(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach$1 : baseForOwn)(object, function(value, index2, object2) {
    return iteratee(accumulator, value, index2, object2);
  });
  return accumulator;
}
var transform_1 = transform;
var require$$2$2 = /* @__PURE__ */ getAugmentedNamespace(ModelUtil$4);
var reduce$2 = transform_1, is$M = require$$2$2.is, keys$8 = keys_1, forEach$o = forEach_1;
function UpdateBusinessObjectHandler(elementRegistry) {
  this._elementRegistry = elementRegistry;
}
UpdateBusinessObjectHandler.$inject = ["elementRegistry"];
var UpdateBusinessObjectHandler_1 = UpdateBusinessObjectHandler;
function getRoot$3(businessObject) {
  var parent2 = businessObject;
  while (parent2.$parent) {
    parent2 = parent2.$parent;
  }
  return parent2;
}
function getProperties(businessObject, propertyNames) {
  return reduce$2(propertyNames, function(result, key) {
    result[key] = businessObject.get(key);
    return result;
  }, {});
}
function setProperties(businessObject, properties2) {
  forEach$o(properties2, function(value, key) {
    businessObject.set(key, value);
  });
}
UpdateBusinessObjectHandler.prototype.execute = function(context) {
  var element = context.element, businessObject = context.businessObject, rootElements = getRoot$3(businessObject).rootElements, referenceType = context.referenceType, referenceProperty = context.referenceProperty, changed = [element];
  if (!element) {
    throw new Error("element required");
  }
  if (!businessObject) {
    throw new Error("businessObject required");
  }
  var properties2 = context.properties, oldProperties = context.oldProperties || getProperties(businessObject, keys$8(properties2));
  if (typeof referenceType !== "undefined" && typeof referenceProperty !== "undefined") {
    forEach$o(rootElements, function(rootElement) {
      if (is$M(rootElement, referenceType)) {
        if (rootElement.id === properties2[referenceProperty]) {
          properties2[referenceProperty] = rootElement;
        }
      }
    });
  }
  setProperties(businessObject, properties2);
  context.oldProperties = oldProperties;
  context.changed = changed;
  return changed;
};
UpdateBusinessObjectHandler.prototype.revert = function(context) {
  var oldProperties = context.oldProperties, businessObject = context.businessObject;
  setProperties(businessObject, oldProperties);
  return context.changed;
};
var ElementHelper = {};
var ElementHelper_1 = ElementHelper;
ElementHelper.createElement = function(elementType, properties2, parent2, factory2) {
  var element = factory2.create(elementType, properties2);
  element.$parent = parent2;
  return element;
};
var elementHelper$n = ElementHelper_1;
function CreateAndReferenceElementHandler(elementRegistry, bpmnFactory) {
  this._elementRegistry = elementRegistry;
  this._bpmnFactory = bpmnFactory;
}
CreateAndReferenceElementHandler.$inject = ["elementRegistry", "bpmnFactory"];
var CreateAndReferenceHandler = CreateAndReferenceElementHandler;
CreateAndReferenceElementHandler.prototype.execute = function(context) {
  var referencingObject = ensureNotNull$3(context.referencingObject, "referencingObject"), referenceProperty = ensureNotNull$3(context.referenceProperty, "referenceProperty"), newObject = ensureNotNull$3(context.newObject, "newObject"), newObjectContainer = ensureNotNull$3(context.newObjectContainer, "newObjectContainer"), newObjectParent = ensureNotNull$3(context.newObjectParent, "newObjectParent"), changed = [context.element];
  var referencedObject = elementHelper$n.createElement(newObject.type, newObject.properties, newObjectParent, this._bpmnFactory);
  context.referencedObject = referencedObject;
  newObjectContainer.push(referencedObject);
  context.previousReference = referencingObject[referenceProperty];
  referencingObject[referenceProperty] = referencedObject;
  context.changed = changed;
  return changed;
};
CreateAndReferenceElementHandler.prototype.revert = function(context) {
  var referencingObject = context.referencingObject, referenceProperty = context.referenceProperty, previousReference = context.previousReference, referencedObject = context.referencedObject, newObjectContainer = context.newObjectContainer;
  referencingObject.set(referenceProperty, previousReference);
  newObjectContainer.splice(newObjectContainer.indexOf(referencedObject), 1);
  return context.changed;
};
function ensureNotNull$3(prop, name2) {
  if (!prop) {
    throw new Error(name2 + " required");
  }
  return prop;
}
var forEach$n = forEach_1;
var elementHelper$m = ElementHelper_1;
function CreateBusinessObjectListHandler(elementRegistry, bpmnFactory) {
  this._elementRegistry = elementRegistry;
  this._bpmnFactory = bpmnFactory;
}
CreateBusinessObjectListHandler.$inject = ["elementRegistry", "bpmnFactory"];
var CreateBusinessObjectListHandler_1 = CreateBusinessObjectListHandler;
function ensureNotNull$2(prop, name2) {
  if (!prop) {
    throw new Error(name2 + " required");
  }
  return prop;
}
function ensureList(prop, name2) {
  if (!prop || Object.prototype.toString.call(prop) !== "[object Array]") {
    throw new Error(name2 + " needs to be a list");
  }
  return prop;
}
CreateBusinessObjectListHandler.prototype.execute = function(context) {
  var currentObject = ensureNotNull$2(context.currentObject, "currentObject"), propertyName = ensureNotNull$2(context.propertyName, "propertyName"), newObjects = ensureList(context.newObjects, "newObjects"), changed = [context.element];
  var childObjects = [];
  var self2 = this;
  forEach$n(newObjects, function(obj) {
    var element = elementHelper$m.createElement(obj.type, obj.properties, currentObject, self2._bpmnFactory);
    childObjects.push(element);
  });
  context.childObject = childObjects;
  context.previousChilds = currentObject[propertyName];
  currentObject[propertyName] = childObjects;
  context.changed = changed;
  return changed;
};
CreateBusinessObjectListHandler.prototype.revert = function(context) {
  var currentObject = context.currentObject, propertyName = context.propertyName, previousChilds = context.previousChilds;
  currentObject.set(propertyName, previousChilds);
  return context.changed;
};
var forEach$m = forEach_1;
function UpdateBusinessObjectListHandler(elementRegistry, bpmnFactory) {
  this._elementRegistry = elementRegistry;
  this._bpmnFactory = bpmnFactory;
}
UpdateBusinessObjectListHandler.$inject = ["elementRegistry", "bpmnFactory"];
var UpdateBusinessObjectListHandler_1 = UpdateBusinessObjectListHandler;
function ensureNotNull$1(prop, name2) {
  if (!prop) {
    throw new Error(name2 + "required");
  }
  return prop;
}
UpdateBusinessObjectListHandler.prototype.execute = function(context) {
  var currentObject = ensureNotNull$1(context.currentObject, "currentObject"), propertyName = ensureNotNull$1(context.propertyName, "propertyName"), updatedObjectList = context.updatedObjectList, objectsToRemove = context.objectsToRemove || [], objectsToAdd = context.objectsToAdd || [], objectsToPrepend = context.objectsToPrepend || [], changed = [context.element], referencePropertyName;
  if (context.referencePropertyName) {
    referencePropertyName = context.referencePropertyName;
  }
  var objectList = currentObject[propertyName];
  context.previousList = currentObject[propertyName];
  if (updatedObjectList) {
    currentObject[propertyName] = updatedObjectList;
  } else {
    var listCopy = objectsToPrepend.slice();
    forEach$m(objectList, function(object) {
      if (objectsToRemove.indexOf(object) == -1) {
        listCopy.push(object);
      }
    });
    listCopy = listCopy.concat(objectsToAdd);
    if (listCopy.length > 0 || !referencePropertyName) {
      currentObject[propertyName] = listCopy;
    } else if (referencePropertyName) {
      var parentObject = currentObject.$parent;
      parentObject.set(referencePropertyName, void 0);
    }
  }
  context.changed = changed;
  return changed;
};
UpdateBusinessObjectListHandler.prototype.revert = function(context) {
  var currentObject = context.currentObject, propertyName = context.propertyName, previousList = context.previousList, parentObject = currentObject.$parent;
  if (context.referencePropertyName) {
    parentObject.set(context.referencePropertyName, currentObject);
  }
  currentObject.set(propertyName, previousList);
  return context.changed;
};
var forEach$l = forEach_1;
function MultiCommandHandler(commandStack) {
  this._commandStack = commandStack;
}
MultiCommandHandler.$inject = ["commandStack"];
var MultiCommandHandler_1 = MultiCommandHandler;
MultiCommandHandler.prototype.preExecute = function(context) {
  var commandStack = this._commandStack;
  forEach$l(context, function(command) {
    commandStack.execute(command.cmd, command.context);
  });
};
var forEach$k = forEach_1;
var HANDLERS = {
  "properties-panel.update-businessobject": UpdateBusinessObjectHandler_1,
  "properties-panel.create-and-reference": CreateAndReferenceHandler,
  "properties-panel.create-businessobject-list": CreateBusinessObjectListHandler_1,
  "properties-panel.update-businessobject-list": UpdateBusinessObjectListHandler_1,
  "properties-panel.multi-command-executor": MultiCommandHandler_1
};
function CommandInitializer(eventBus, commandStack) {
  eventBus.on("diagram.init", function() {
    forEach$k(HANDLERS, function(handler, id2) {
      commandStack.registerHandler(id2, handler);
    });
  });
}
CommandInitializer.$inject = ["eventBus", "commandStack"];
var cmd$1 = {
  __init__: [CommandInitializer]
};
function translate$1(template2, replacements) {
  replacements = replacements || {};
  return template2.replace(/{([^}]+)}/g, function(_, key) {
    return replacements[key] || "{" + key + "}";
  });
}
var index = {
  translate: ["value", translate$1]
};
var translate = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": index
}, Symbol.toStringTag, { value: "Module" }));
var require$$1$3 = /* @__PURE__ */ getAugmentedNamespace(translate);
var Utils = {};
var require$$6 = /* @__PURE__ */ getAugmentedNamespace(index_esm$2);
var require$$3$2 = /* @__PURE__ */ getAugmentedNamespace(index_esm$4);
var domQuery$l = require$$6.query, domClear = require$$6.clear, domClasses$8 = require$$6.classes, is$L = require$$2$2.is, forEach$j = forEach_1, domify$g = require$$6.domify, Ids = require$$3$2.default;
var SPACE_REGEX = /\s/;
var QNAME_REGEX = /^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i;
var ID_REGEX = /^[a-z_][\w-.]*$/i;
var HTML_ESCAPE_MAP = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function selectedOption(selectBox) {
  if (selectBox.selectedIndex >= 0) {
    return selectBox.options[selectBox.selectedIndex].value;
  }
}
Utils.selectedOption = selectedOption;
function selectedType(elementSyntax, inputNode) {
  var typeSelect = domQuery$l(elementSyntax, inputNode);
  return selectedOption(typeSelect);
}
Utils.selectedType = selectedType;
function getRoot$2(businessObject) {
  var parent2 = businessObject;
  while (parent2.$parent) {
    parent2 = parent2.$parent;
  }
  return parent2;
}
Utils.getRoot = getRoot$2;
function filterElementsByType(objectList, type) {
  var list = objectList || [];
  var result = [];
  forEach$j(list, function(obj) {
    if (is$L(obj, type)) {
      result.push(obj);
    }
  });
  return result;
}
Utils.filterElementsByType = filterElementsByType;
function findRootElementsByType(businessObject, referencedType) {
  var root2 = getRoot$2(businessObject);
  return filterElementsByType(root2.rootElements, referencedType);
}
Utils.findRootElementsByType = findRootElementsByType;
function removeAllChildren(domElement) {
  while (domElement.firstChild) {
    domElement.removeChild(domElement.firstChild);
  }
}
Utils.removeAllChildren = removeAllChildren;
function addEmptyParameter$1(list) {
  return list.push({ "label": "", "value": "", "name": "" });
}
Utils.addEmptyParameter = addEmptyParameter$1;
function getOptionLabel(obj) {
  var label2 = obj.name || "";
  if (obj.errorCode)
    label2 += " (code=" + obj.errorCode + ")";
  if (obj.escalationCode)
    label2 += " (code=" + obj.escalationCode + ")";
  return label2;
}
function refreshOptionsModel(businessObject, referencedType) {
  var model = [];
  var referableObjects = findRootElementsByType(businessObject, referencedType);
  forEach$j(referableObjects, function(obj) {
    model.push({
      label: getOptionLabel(obj),
      value: obj.id,
      name: obj.name
    });
  });
  return model;
}
Utils.refreshOptionsModel = refreshOptionsModel;
function updateOptionsDropDown(domSelector, businessObject, referencedType, entryNode) {
  var options = refreshOptionsModel(businessObject, referencedType);
  addEmptyParameter$1(options);
  var selectBox = domQuery$l(domSelector, entryNode);
  domClear(selectBox);
  forEach$j(options, function(option2) {
    var optionEntry = domify$g('<option value="' + escapeHTML$m(option2.value) + '">' + escapeHTML$m(option2.label) + "</option>");
    selectBox.appendChild(optionEntry);
  });
  return options;
}
Utils.updateOptionsDropDown = updateOptionsDropDown;
function isIdValid(bo, idValue, translate2) {
  var assigned = bo.$model.ids.assigned(idValue);
  var idExists = assigned && assigned !== bo;
  if (!idValue || idExists) {
    return translate2("Element must have an unique id.");
  }
  return validateId(idValue, translate2);
}
Utils.isIdValid = isIdValid;
function validateId(idValue, translate2) {
  if (containsSpace(idValue)) {
    return translate2("Id must not contain spaces.");
  }
  if (!ID_REGEX.test(idValue)) {
    if (QNAME_REGEX.test(idValue)) {
      return translate2("Id must not contain prefix.");
    }
    return translate2("Id must be a valid QName.");
  }
}
Utils.validateId = validateId;
function containsSpace(value) {
  return SPACE_REGEX.test(value);
}
Utils.containsSpace = containsSpace;
function nextId$1(prefix2) {
  var ids2 = new Ids([32, 32, 1]);
  return ids2.nextPrefixed(prefix2);
}
Utils.nextId = nextId$1;
function triggerClickEvent$1(element) {
  var evt;
  var eventType = "click";
  if (document.createEvent) {
    try {
      evt = new MouseEvent(eventType, { view: window, bubbles: true, cancelable: true });
    } catch (e) {
      evt = document.createEvent("MouseEvent");
      evt.initEvent(eventType, true, true);
    }
    return element.dispatchEvent(evt);
  } else {
    evt = document.createEventObject();
    return element.fireEvent("on" + eventType, evt);
  }
}
Utils.triggerClickEvent = triggerClickEvent$1;
function escapeHTML$m(str) {
  str = "" + str;
  return str && str.replace(/[&<>"']/g, function(match2) {
    return HTML_ESCAPE_MAP[match2];
  });
}
Utils.escapeHTML = escapeHTML$m;
function createDropdown$1(dropdown) {
  var menu = dropdown.menu;
  var dropdownNode = domify$g('<div class="group__dropdown"><button class="group__dropdown-button"><svg width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><path fill="currentColor" d="M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z"></path></svg></button><div class="group__dropdown-menu"></div></div>');
  var buttonNode = domQuery$l(".group__dropdown-button", dropdownNode), menuNode = domQuery$l(".group__dropdown-menu", dropdownNode);
  buttonNode.addEventListener("click", function(event) {
    domClasses$8(dropdownNode).toggle("group__dropdown--open");
    createOnGlobalClick(event);
  });
  forEach$j(menu, function(menuItem) {
    var menuItemNode = domify$g('<div class="group__dropdown-menu-item" data-dropdown-action="' + menuItem.id + '">' + escapeHTML$m(menuItem.label) + "</div>");
    menuItemNode.addEventListener("click", function() {
      menuItem.onClick();
      domClasses$8(dropdownNode).remove("group__dropdown--open");
    });
    menuNode.appendChild(menuItemNode);
  });
  var _onGlobalClick;
  function createOnGlobalClick(_event) {
    function onGlobalClick(event) {
      if (event === _event) {
        return;
      }
      var target = event.target;
      if (menuNode !== target && !menuNode.contains(target)) {
        domClasses$8(dropdownNode).remove("group__dropdown--open");
        document.removeEventListener("click", onGlobalClick);
      }
    }
    if (_onGlobalClick) {
      document.removeEventListener("click", _onGlobalClick);
    }
    document.addEventListener("click", onGlobalClick);
    _onGlobalClick = onGlobalClick;
  }
  return dropdownNode;
}
Utils.createDropdown = createDropdown$1;
var baseEach$3 = _baseEach;
function baseFilter$1(collection2, predicate) {
  var result = [];
  baseEach$3(collection2, function(value, index2, collection3) {
    if (predicate(value, index2, collection3)) {
      result.push(value);
    }
  });
  return result;
}
var _baseFilter = baseFilter$1;
var arrayFilter$1 = _arrayFilter, baseFilter = _baseFilter, baseIteratee$6 = _baseIteratee, isArray$9 = isArray_1;
function filter$9(collection2, predicate) {
  var func = isArray$9(collection2) ? arrayFilter$1 : baseFilter;
  return func(collection2, baseIteratee$6(predicate));
}
var filter_1 = filter$9;
var baseKeys = _baseKeys, getTag = _getTag, isArguments$1 = isArguments_1, isArray$8 = isArray_1, isArrayLike$5 = isArrayLike_1, isBuffer = isBuffer$4.exports, isPrototype$1 = _isPrototype, isTypedArray = isTypedArray_1;
var mapTag = "[object Map]", setTag = "[object Set]";
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function isEmpty$2(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike$5(value) && (isArray$8(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments$1(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype$1(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty$4.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_1 = isEmpty$2;
function apply$3(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$3;
var apply$2 = _apply;
var nativeMax$5 = Math.max;
function overRest$2(func, start, transform2) {
  start = nativeMax$5(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length2 = nativeMax$5(args.length - start, 0), array = Array(length2);
    while (++index2 < length2) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform2(array);
    return apply$2(func, this, otherArgs);
  };
}
var _overRest = overRest$2;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var getNative = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty = defineProperty$2;
var constant = constant_1, defineProperty$1 = _defineProperty, identity$2 = identity_1;
var baseSetToString$1 = !defineProperty$1 ? identity$2 : function(func, string) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$2(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$2;
var baseSetToString = _baseSetToString, shortOut$1 = _shortOut;
var setToString$3 = shortOut$1(baseSetToString);
var _setToString = setToString$3;
var identity$1 = identity_1, overRest$1 = _overRest, setToString$2 = _setToString;
function baseRest$3(func, start) {
  return setToString$2(overRest$1(func, start, identity$1), func + "");
}
var _baseRest = baseRest$3;
function baseFindIndex$2(array, predicate, fromIndex, fromRight) {
  var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex$2;
function baseIsNaN$1(value) {
  return value !== value;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(array, value, fromIndex) {
  var index2 = fromIndex - 1, length2 = array.length;
  while (++index2 < length2) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
var _strictIndexOf = strictIndexOf$1;
var baseFindIndex$1 = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
function baseIndexOf$1(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex$1(array, baseIsNaN, fromIndex);
}
var _baseIndexOf = baseIndexOf$1;
var baseIndexOf = _baseIndexOf;
function arrayIncludes$3(array, value) {
  var length2 = array == null ? 0 : array.length;
  return !!length2 && baseIndexOf(array, value, 0) > -1;
}
var _arrayIncludes = arrayIncludes$3;
function arrayIncludesWith$2(array, value, comparator) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (comparator(value, array[index2])) {
      return true;
    }
  }
  return false;
}
var _arrayIncludesWith = arrayIncludesWith$2;
var SetCache$1 = _SetCache, arrayIncludes$2 = _arrayIncludes, arrayIncludesWith$1 = _arrayIncludesWith, arrayMap$2 = _arrayMap, baseUnary = _baseUnary, cacheHas$1 = _cacheHas;
var LARGE_ARRAY_SIZE$1 = 200;
function baseDifference$1(array, values2, iteratee, comparator) {
  var index2 = -1, includes2 = arrayIncludes$2, isCommon = true, length2 = array.length, result = [], valuesLength = values2.length;
  if (!length2) {
    return result;
  }
  if (iteratee) {
    values2 = arrayMap$2(values2, baseUnary(iteratee));
  }
  if (comparator) {
    includes2 = arrayIncludesWith$1;
    isCommon = false;
  } else if (values2.length >= LARGE_ARRAY_SIZE$1) {
    includes2 = cacheHas$1;
    isCommon = false;
    values2 = new SetCache$1(values2);
  }
  outer:
    while (++index2 < length2) {
      var value = array[index2], computed = iteratee == null ? value : iteratee(value);
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values2[valuesIndex] === computed) {
            continue outer;
          }
        }
        result.push(value);
      } else if (!includes2(values2, computed, comparator)) {
        result.push(value);
      }
    }
  return result;
}
var _baseDifference = baseDifference$1;
var Symbol$1 = _Symbol, isArguments = isArguments_1, isArray$7 = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$7(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$3(array, depth, predicate, isStrict, result) {
  var index2 = -1, length2 = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length2) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$3(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$3;
function noop$4() {
}
var noop_1 = noop$4;
var Set$1 = _Set, noop$3 = noop_1, setToArray$1 = _setToArray;
var INFINITY$2 = 1 / 0;
var createSet$1 = !(Set$1 && 1 / setToArray$1(new Set$1([, -0]))[1] == INFINITY$2) ? noop$3 : function(values2) {
  return new Set$1(values2);
};
var _createSet = createSet$1;
var SetCache = _SetCache, arrayIncludes$1 = _arrayIncludes, arrayIncludesWith = _arrayIncludesWith, cacheHas = _cacheHas, createSet = _createSet, setToArray = _setToArray;
var LARGE_ARRAY_SIZE = 200;
function baseUniq$1(array, iteratee, comparator) {
  var index2 = -1, includes2 = arrayIncludes$1, length2 = array.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith;
  } else if (length2 >= LARGE_ARRAY_SIZE) {
    var set2 = iteratee ? null : createSet(array);
    if (set2) {
      return setToArray(set2);
    }
    isCommon = false;
    includes2 = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length2) {
      var value = array[index2], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes2(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var _baseUniq = baseUniq$1;
var baseDifference = _baseDifference, baseFlatten$2 = _baseFlatten, baseUniq = _baseUniq;
function baseXor$1(arrays, iteratee, comparator) {
  var length2 = arrays.length;
  if (length2 < 2) {
    return length2 ? baseUniq(arrays[0]) : [];
  }
  var index2 = -1, result = Array(length2);
  while (++index2 < length2) {
    var array = arrays[index2], othIndex = -1;
    while (++othIndex < length2) {
      if (othIndex != index2) {
        result[index2] = baseDifference(result[index2] || array, arrays[othIndex], iteratee, comparator);
      }
    }
  }
  return baseUniq(baseFlatten$2(result, 1), iteratee, comparator);
}
var _baseXor = baseXor$1;
var isArrayLike$4 = isArrayLike_1, isObjectLike$3 = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike$3(value) && isArrayLike$4(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var arrayFilter = _arrayFilter, baseRest$2 = _baseRest, baseXor = _baseXor, isArrayLikeObject = isArrayLikeObject_1;
var xor$1 = baseRest$2(function(arrays) {
  return baseXor(arrayFilter(arrays, isArrayLikeObject));
});
var xor_1 = xor$1;
var root$4 = _root;
var now$1 = function() {
  return root$4.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim, isObject$7 = isObject_1, isSymbol = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$2(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$7(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$7(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$2;
var isObject$6 = isObject_1, now = now_1, toNumber$1 = toNumber_1;
var FUNC_ERROR_TEXT$1 = "Expected a function";
var nativeMax$4 = Math.max, nativeMin$2 = Math.min;
function debounce$2(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber$1(wait) || 0;
  if (isObject$6(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$4(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin$2(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$2;
var baseFlatten$1 = _baseFlatten;
var INFINITY$1 = 1 / 0;
function flattenDeep$2(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? baseFlatten$1(array, INFINITY$1) : [];
}
var flattenDeep_1 = flattenDeep$2;
var defineProperty = _defineProperty;
function baseAssignValue$3(object, key, value) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
function arrayAggregator$1(array, setter, iteratee, accumulator) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    var value = array[index2];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}
var _arrayAggregator = arrayAggregator$1;
var baseEach$2 = _baseEach;
function baseAggregator$1(collection2, setter, iteratee, accumulator) {
  baseEach$2(collection2, function(value, key, collection3) {
    setter(accumulator, value, iteratee(value), collection3);
  });
  return accumulator;
}
var _baseAggregator = baseAggregator$1;
var arrayAggregator = _arrayAggregator, baseAggregator = _baseAggregator, baseIteratee$5 = _baseIteratee, isArray$6 = isArray_1;
function createAggregator$1(setter, initializer) {
  return function(collection2, iteratee) {
    var func = isArray$6(collection2) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
    return func(collection2, setter, baseIteratee$5(iteratee), accumulator);
  };
}
var _createAggregator = createAggregator$1;
var baseAssignValue$2 = _baseAssignValue, createAggregator = _createAggregator;
var keyBy$1 = createAggregator(function(result, value, key) {
  baseAssignValue$2(result, key, value);
});
var keyBy_1 = keyBy$1;
var baseEach$1 = _baseEach, isArrayLike$3 = isArrayLike_1;
function baseMap$1(collection2, iteratee) {
  var index2 = -1, result = isArrayLike$3(collection2) ? Array(collection2.length) : [];
  baseEach$1(collection2, function(value, key, collection3) {
    result[++index2] = iteratee(value, key, collection3);
  });
  return result;
}
var _baseMap = baseMap$1;
var arrayMap$1 = _arrayMap, baseIteratee$4 = _baseIteratee, baseMap = _baseMap, isArray$5 = isArray_1;
function map$5(collection2, iteratee) {
  var func = isArray$5(collection2) ? arrayMap$1 : baseMap;
  return func(collection2, baseIteratee$4(iteratee));
}
var map_1 = map$5;
function arrayReduce$1(array, iteratee, accumulator, initAccum) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  if (initAccum && length2) {
    accumulator = array[++index2];
  }
  while (++index2 < length2) {
    accumulator = iteratee(accumulator, array[index2], index2, array);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$1;
function baseReduce$1(collection2, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection2, function(value, index2, collection3) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection3);
  });
  return accumulator;
}
var _baseReduce = baseReduce$1;
var arrayReduce = _arrayReduce, baseEach = _baseEach, baseIteratee$3 = _baseIteratee, baseReduce = _baseReduce, isArray$4 = isArray_1;
function reduce$1(collection2, iteratee, accumulator) {
  var func = isArray$4(collection2) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
  return func(collection2, baseIteratee$3(iteratee), accumulator, initAccum, baseEach);
}
var reduce_1 = reduce$1;
var selectionUpdate = { exports: {} };
function calculateUpdate(currentSelection, currentValue, newValue) {
  var currentCursor = currentSelection.start, newCursor = currentCursor, diff2 = newValue.length - currentValue.length;
  newValue.length - currentValue.length;
  var currentTail = currentValue.substring(currentCursor);
  if (newValue.lastIndexOf(currentTail) === newValue.length - currentTail.length) {
    currentValue = currentValue.substring(0, currentValue.length - currentTail.length);
    newValue = newValue.substring(0, newValue.length - currentTail.length);
  }
  var diff2 = createDiff(currentValue, newValue);
  if (diff2) {
    if (diff2.type === "remove") {
      newCursor = diff2.newStart;
    } else {
      newCursor = diff2.newEnd;
    }
  }
  return range(newCursor);
}
selectionUpdate.exports = calculateUpdate;
function createDiff(currentValue, newValue) {
  var insert;
  var l_str, l_char, l_idx = 0, s_str, s_char, s_idx = 0;
  if (newValue.length > currentValue.length) {
    l_str = newValue;
    s_str = currentValue;
  } else {
    l_str = currentValue;
    s_str = newValue;
  }
  while (l_idx < l_str.length) {
    l_char = l_str.charAt(l_idx);
    s_char = s_str.charAt(s_idx);
    if (l_char !== s_char) {
      if (!insert) {
        insert = {
          l_start: l_idx,
          s_start: s_idx
        };
      }
      l_idx++;
    } else {
      if (insert && !insert.complete) {
        insert.l_end = l_idx;
        insert.s_end = s_idx;
        insert.complete = true;
      }
      s_idx++;
      l_idx++;
    }
  }
  if (insert && !insert.complete) {
    insert.complete = true;
    insert.s_end = s_str.length;
    insert.l_end = l_str.length;
  }
  if (!insert) {
    return;
  }
  if (newValue.length > currentValue.length) {
    return {
      newStart: insert.l_start,
      newEnd: insert.l_end,
      type: "add"
    };
  } else {
    return {
      newStart: insert.s_start,
      newEnd: insert.s_end,
      type: newValue.length < currentValue.length ? "remove" : "replace"
    };
  }
}
function range(start, end) {
  return {
    start,
    end: end === void 0 ? start : end
  };
}
selectionUpdate.exports.range = range;
function mitt(all2) {
  all2 = all2 || /* @__PURE__ */ Object.create(null);
  return {
    on: function on(type, handler) {
      (all2[type] || (all2[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all2[type]) {
        all2[type].splice(all2[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type, evt) {
      (all2[type] || []).slice().map(function(handler) {
        handler(evt);
      });
      (all2["*"] || []).slice().map(function(handler) {
        handler(type, evt);
      });
    }
  };
}
var DEFAULT_OPTIONS = {
  scrollSymbolLeft: "\u2039",
  scrollSymbolRight: "\u203A"
};
function ScrollTabs($el, options) {
  assign$e(this, mitt());
  this.options = options = assign$e({}, DEFAULT_OPTIONS, options);
  this.container = $el;
  this._createScrollButtons($el, options);
  this._bindEvents($el);
}
ScrollTabs.prototype._createButton = function(parentNode, options) {
  var className = options.className, direction = options.direction;
  var button = query("." + className, parentNode);
  if (!button) {
    button = domify$h('<span class="scroll-tabs-button ' + className + '">' + options.label + "</span>");
    parentNode.insertBefore(button, parentNode.childNodes[0]);
  }
  attr$1(button, "data-direction", direction);
  return button;
};
ScrollTabs.prototype._createScrollButtons = function(parentNode, options) {
  this._createButton(parentNode, {
    className: "scroll-tabs-left",
    label: options.scrollSymbolLeft,
    direction: -1
  });
  this._createButton(parentNode, {
    className: "scroll-tabs-right",
    label: options.scrollSymbolRight,
    direction: 1
  });
};
ScrollTabs.prototype.getActiveTabNode = function() {
  return query(this.options.selectors.active, this.container);
};
ScrollTabs.prototype.getTabsContainerNode = function() {
  return query(this.options.selectors.tabsContainer, this.container);
};
ScrollTabs.prototype.getAllTabNodes = function() {
  return all(this.options.selectors.tab, this.container);
};
ScrollTabs.prototype.getVisibleTabs = function() {
  var allTabs = this.getAllTabNodes();
  var ignore = this.options.selectors.ignore;
  return filter$a(allTabs, function(tabNode) {
    return !matchesSelector(tabNode, ignore);
  });
};
ScrollTabs.prototype.getAdjacentTab = function(referenceTabNode, n) {
  var visibleTabs = this.getVisibleTabs();
  var index2 = visibleTabs.indexOf(referenceTabNode);
  return visibleTabs[index2 + n];
};
ScrollTabs.prototype._bindEvents = function(node2) {
  this._bindWheelEvent(node2);
  this._bindTabClickEvents(node2);
  this._bindScrollButtonEvents(node2);
};
ScrollTabs.prototype._bindTabClickEvents = function(node2) {
  var selector2 = this.options.selectors.tab;
  var self2 = this;
  delegate$1.bind(node2, selector2, "click", function onClick(event) {
    self2.scrollToTabNode(event.delegateTarget);
  });
};
ScrollTabs.prototype._bindWheelEvent = function(node2) {
  var self2 = this;
  componentEvent.bind(node2, "wheel", function(e) {
    var direction = Math.sign(e.deltaY);
    var oldActiveTab = self2.getActiveTabNode();
    var newActiveTab = self2.getAdjacentTab(oldActiveTab, direction);
    if (newActiveTab) {
      self2.scrollToTabNode(newActiveTab);
      self2.emit("scroll", newActiveTab, oldActiveTab, direction);
    }
    e.preventDefault();
  });
};
ScrollTabs.prototype._bindScrollButtonEvents = function(node2) {
  var self2 = this;
  delegate$1.bind(node2, ".scroll-tabs-button", "click", function(event) {
    var target = event.delegateTarget;
    var direction = parseInt(attr$1(target, "data-direction"), 10);
    var oldActiveTabNode = self2.getActiveTabNode();
    var newActiveTabNode = self2.getAdjacentTab(oldActiveTabNode, direction);
    if (newActiveTabNode) {
      self2.scrollToTabNode(newActiveTabNode);
      self2.emit("scroll", newActiveTabNode, oldActiveTabNode, direction);
    }
    event.preventDefault();
  });
};
ScrollTabs.prototype.scrollToTabNode = function(tabNode) {
  if (!tabNode) {
    return;
  }
  var tabsContainerNode = tabNode.parentNode;
  var tabWidth = tabNode.offsetWidth, tabOffsetLeft = tabNode.offsetLeft, tabOffsetRight = tabOffsetLeft + tabWidth, containerWidth = tabsContainerNode.offsetWidth, containerScrollLeft = tabsContainerNode.scrollLeft;
  if (containerScrollLeft > tabOffsetLeft) {
    tabsContainerNode.scrollLeft = 0;
  } else if (tabOffsetRight > containerWidth) {
    tabsContainerNode.scrollLeft = tabOffsetRight - containerWidth;
  }
};
ScrollTabs.prototype.update = function() {
  var tabsContainerNode = this.getTabsContainerNode();
  var overflow = tabsContainerNode.scrollWidth > tabsContainerNode.offsetWidth;
  var overflowClass = "scroll-tabs-overflow";
  classes$1(this.container).toggle(overflowClass, overflow);
  if (overflow) {
    this.scrollToTabNode(this.getActiveTabNode());
  }
};
function create($el, options) {
  var scrollTabs2 = get$1($el);
  if (!scrollTabs2) {
    scrollTabs2 = new ScrollTabs($el, options);
    $el.__scrollTabs = scrollTabs2;
  }
  return scrollTabs2;
}
function get$1($el) {
  return $el.__scrollTabs;
}
create.get = get$1;
var scrollTabs$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": create
}, Symbol.toStringTag, { value: "Module" }));
var require$$17 = /* @__PURE__ */ getAugmentedNamespace(scrollTabs$1);
var createDropdown = Utils.createDropdown, escapeHTML$l = Utils.escapeHTML;
var domify$f = require$$6.domify, domQuery$k = require$$6.query, domQueryAll = require$$6.queryAll, domRemove = require$$6.remove, domClasses$7 = require$$6.classes, domClosest$3 = require$$6.closest, domAttr$2 = require$$6.attr, domDelegate = require$$6.delegate, domMatches = require$$6.matches;
var forEach$i = forEach_1, filter$8 = filter_1, get = get_1, keys$7 = keys_1, isEmpty$1 = isEmpty_1, isArray$3 = isArray_1, isFunction$1 = isFunction_1, isObject$5 = isObject_1, xor = xor_1, debounce$1 = debounce_1, flattenDeep$1 = flattenDeep_1, keyBy = keyBy_1, map$4 = map_1, reduce = reduce_1;
var updateSelection$1 = selectionUpdate.exports;
var scrollTabs = require$$17.default;
var getBusinessObject$U = require$$2$2.getBusinessObject;
var HIDE_CLASS = "bpp-hidden";
var DEBOUNCE_DELAY = 300;
var DEFAULT_PRIORITY$2 = 1e3;
function isToggle(node2) {
  return node2.type === "checkbox" || node2.type === "radio";
}
function isSelect(node2) {
  return node2.type === "select-one";
}
function isContentEditable(node2) {
  return domAttr$2(node2, "contenteditable");
}
function getPropertyPlaceholders(node2) {
  var selector2 = "input[name], textarea[name], [data-value], [contenteditable]";
  var placeholders = domQueryAll(selector2, node2);
  if ((!placeholders || !placeholders.length) && domMatches(node2, selector2)) {
    placeholders = [node2];
  }
  return placeholders;
}
function getFormControls(node2, all2) {
  var controls = domQueryAll("input[name], textarea[name], select[name], [contenteditable]", node2);
  if (!controls || !controls.length) {
    controls = domMatches(node2, "option") ? [node2] : controls;
  }
  if (!all2) {
    controls = filter$8(controls, function(node3) {
      return !domClosest$3(node3, "." + HIDE_CLASS);
    });
  }
  return controls;
}
function getFormControlValuesInScope(entryNode) {
  var values2 = {};
  var controlNodes = getFormControls(entryNode);
  forEach$i(controlNodes, function(controlNode) {
    var value = controlNode.value;
    var name2 = domAttr$2(controlNode, "name") || domAttr$2(controlNode, "data-name");
    if (isToggle(controlNode)) {
      if (controlNode.checked) {
        if (!domAttr$2(controlNode, "value")) {
          value = true;
        } else {
          value = controlNode.value;
        }
      } else {
        value = null;
      }
    } else if (isContentEditable(controlNode)) {
      value = controlNode.innerText;
    }
    if (value !== null) {
      values2[name2] = value;
    }
  });
  return values2;
}
function getFormControlValues(entryNode) {
  var values2;
  var listContainer = domQuery$k("[data-list-entry-container]", entryNode);
  if (listContainer) {
    values2 = [];
    var listNodes = listContainer.children || [];
    forEach$i(listNodes, function(listNode) {
      values2.push(getFormControlValuesInScope(listNode));
    });
  } else {
    values2 = getFormControlValuesInScope(entryNode);
  }
  return values2;
}
function valueEqual$1(value, oldValue) {
  if (value && !oldValue) {
    return false;
  }
  var allKeys = keys$7(value).concat(keys$7(oldValue));
  return allKeys.every(function(key) {
    return value[key] === oldValue[key];
  });
}
function valuesEqual(values2, oldValues) {
  if (isArray$3(values2)) {
    if (values2.length !== oldValues.length) {
      return false;
    }
    return values2.every(function(v, idx) {
      return valueEqual$1(v, oldValues[idx]);
    });
  }
  return valueEqual$1(values2, oldValues);
}
function extractEntries(tabs) {
  return keyBy(flattenDeep$1(map$4(flattenDeep$1(map$4(tabs, "groups")), "entries")), "id");
}
function extractGroups(tabs) {
  return keyBy(flattenDeep$1(map$4(tabs, "groups")), "id");
}
function PropertiesPanel(config, injector, eventBus, modeling, commandStack, canvas) {
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._commandStack = commandStack;
  this._canvas = canvas;
  var propertiesProvider = injector.get("propertiesProvider", false);
  if (propertiesProvider) {
    this.registerProvider(propertiesProvider);
  }
  this._init(config);
}
PropertiesPanel.$inject = [
  "config.propertiesPanel",
  "injector",
  "eventBus",
  "modeling",
  "commandStack",
  "canvas"
];
var PropertiesPanel_1 = PropertiesPanel;
PropertiesPanel.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY$2;
  }
  if (typeof provider.getTabs !== "function") {
    console.error("Properties provider does not impement #getTabs(element) API");
    return;
  }
  this._eventBus.on("propertiesPanel.getProviders", priority, function(event) {
    event.providers.push(provider);
  });
  this._eventBus.fire("propertiesPanel.providersChanged");
};
PropertiesPanel.prototype._init = function(config) {
  var canvas = this._canvas, eventBus = this._eventBus;
  var self2 = this;
  eventBus.on("root.added", function(e) {
    var element = e.element;
    if (isImplicitRoot(element)) {
      return;
    }
    self2.update(element);
  });
  eventBus.on("selection.changed", function(e) {
    var newElement = e.newSelection[0];
    var rootElement = canvas.getRootElement();
    if (isImplicitRoot(rootElement)) {
      return;
    }
    self2.update(newElement);
  });
  eventBus.on([
    "propertiesPanel.changed",
    "propertiesPanel.resized"
  ], function(event) {
    var tabBarNode = domQuery$k(".bpp-properties-tab-bar", self2._container);
    if (!tabBarNode) {
      return;
    }
    var scroller = scrollTabs.get(tabBarNode);
    if (!scroller) {
      scroller = scrollTabs(tabBarNode, {
        selectors: {
          tabsContainer: ".bpp-properties-tabs-links",
          tab: ".bpp-properties-tabs-links li",
          ignore: ".bpp-hidden",
          active: ".bpp-active"
        }
      });
      scroller.on("scroll", function(newActiveNode, oldActiveNode, direction) {
        var linkNode = domQuery$k("[data-tab-target]", newActiveNode);
        var tabId = domAttr$2(linkNode, "data-tab-target");
        self2.activateTab(tabId);
      });
    }
    scroller.update();
  });
  eventBus.on("elements.changed", function(e) {
    var current = self2._current;
    var element = current && current.element;
    if (element) {
      if (e.elements.indexOf(element) !== -1) {
        self2.update(element);
      }
    }
  });
  eventBus.on([
    "elementTemplates.changed",
    "propertiesPanel.providersChanged"
  ], function() {
    var current = self2._current;
    var element = current && current.element;
    if (element) {
      self2.update(element);
    }
  });
  eventBus.on("diagram.destroy", function() {
    self2.detach();
  });
  this._container = domify$f('<div class="bpp-properties-panel" input-handle-modified-keys="z,y"></div>');
  this._bindListeners(this._container);
  if (config && config.parent) {
    this.attachTo(config.parent);
  }
};
PropertiesPanel.prototype.attachTo = function(parentNode) {
  if (!parentNode) {
    throw new Error("parentNode required");
  }
  this.detach();
  if (parentNode.get && parentNode.constructor.prototype.jquery) {
    parentNode = parentNode.get(0);
  }
  if (typeof parentNode === "string") {
    parentNode = domQuery$k(parentNode);
  }
  var container = this._container;
  parentNode.appendChild(container);
  this._emit("attach");
};
PropertiesPanel.prototype.detach = function() {
  var container = this._container, parentNode = container.parentNode;
  if (!parentNode) {
    return;
  }
  this._emit("detach");
  parentNode.removeChild(container);
};
PropertiesPanel.prototype.activateTab = function(tabId) {
  if (isObject$5(tabId)) {
    tabId = tabId.id;
  }
  var tabs = domQueryAll(".bpp-properties-tab", this._current.panel), tabLinks = domQueryAll(".bpp-properties-tab-link", this._current.panel);
  forEach$i(tabs, function(tab) {
    domClasses$7(tab).remove("bpp-active");
  });
  forEach$i(tabLinks, function(tabLink) {
    domClasses$7(tabLink).remove("bpp-active");
  });
  var visibleTabs = filter$8(tabs, function(tab) {
    return !domClasses$7(tab).has(HIDE_CLASS);
  });
  var activeTab = reduce(visibleTabs, function(activeTab2, tab) {
    if (domAttr$2(tab, "data-tab") === tabId) {
      return tab;
    }
    return activeTab2;
  }, visibleTabs[0]);
  if (activeTab) {
    domClasses$7(activeTab).add("bpp-active");
  }
  var visibleTabLinks = filter$8(tabLinks, function(tabLink) {
    return !domClasses$7(tabLink).has(HIDE_CLASS);
  });
  var activeTabLink = reduce(visibleTabLinks, function(activeTabLink2, tabLink) {
    if (domAttr$2(domQuery$k("a[data-tab-target]", tabLink), "data-tab-target") === tabId) {
      return tabLink;
    }
    return activeTabLink2;
  }, visibleTabLinks[0]);
  if (activeTabLink) {
    domClasses$7(activeTabLink).add("bpp-active");
  }
};
PropertiesPanel.prototype._getProviders = function() {
  var event = this._eventBus.createEvent({
    type: "propertiesPanel.getProviders",
    providers: []
  });
  this._eventBus.fire(event);
  return event.providers;
};
PropertiesPanel.prototype._getTabs = function(element) {
  var providers = this._getProviders();
  return reduce(providers, function(tabs, provider) {
    var tabsOrUpdater = provider.getTabs(element);
    if (isFunction$1(tabsOrUpdater)) {
      return tabsOrUpdater(tabs);
    } else {
      return tabsOrUpdater;
    }
  }, []);
};
PropertiesPanel.prototype.update = function(element) {
  if (!element) {
    element = this._canvas.getRootElement();
  }
  var tabs = this._getTabs(element);
  var activeTabId, activeTabNode;
  if (this._current) {
    activeTabNode = domQuery$k(".bpp-properties-tab.bpp-active", this._current.panel);
    if (activeTabNode) {
      activeTabId = domAttr$2(activeTabNode, "data-tab");
    }
  }
  if (!this._current || this._current.element !== element || this._entriesChanged(this._current.entries, extractEntries(tabs))) {
    if (this._current) {
      domRemove(this._current.panel);
    }
    this._current = this._create(element, tabs);
  }
  this._updateActivation(this._current);
  if (activeTabId) {
    this.activateTab(activeTabId);
  } else {
    this.activateTab(this._current.tabs[0]);
  }
  this._emit("changed");
};
PropertiesPanel.prototype._entriesChanged = function(prevEntries, entries) {
  var prevEntryIds = keys$7(prevEntries), entryIds = keys$7(entries);
  return !isEmpty$1(xor(prevEntryIds, entryIds));
};
PropertiesPanel.prototype._emit = function(event) {
  this._eventBus.fire("propertiesPanel." + event, { panel: this, current: this._current });
};
PropertiesPanel.prototype._bindListeners = function(container) {
  var self2 = this;
  var handleChange = function handleChange2(event) {
    var inputNode = event.delegateTarget, entryNode = domClosest$3(inputNode, "[data-entry]"), entryId, entry;
    if (!entryNode) {
      return;
    }
    entryId = domAttr$2(entryNode, "data-entry");
    entry = self2.getEntry(entryId);
    var values2 = getFormControlValues(entryNode);
    if (event.type === "change") {
      var onChangeAction = domAttr$2(inputNode, "data-on-change");
      if (onChangeAction) {
        var isEntryDirty = self2.executeAction(entry, entryNode, onChangeAction, event);
        if (!isEntryDirty) {
          return self2.update(self2._current.element);
        }
      }
    }
    self2.applyChanges(entry, values2, entryNode);
    self2.updateState(entry, entryNode);
  };
  domDelegate.bind(container, "input, textarea, [contenteditable]", "input", debounce$1(handleChange, DEBOUNCE_DELAY));
  domDelegate.bind(container, "input, textarea, select, [contenteditable]", "change", handleChange);
  domDelegate.bind(container, "[contenteditable]", "paste", handlePaste);
  function handlePaste(event) {
    var text = (event.clipboardData || window.clipboardData).getData("text");
    text = normalizeEndOfLineSequences(text);
    document.execCommand("insertText", false, text);
    event.preventDefault();
  }
  domDelegate.bind(container, "select", "keydown", function(e) {
    if (e.keyCode === 46) {
      e.stopPropagation();
      e.preventDefault();
    }
  });
  function handleSuggestItems(event) {
    var inputNode = event.delegateTarget;
    var entryNode = domClosest$3(inputNode, "[data-entry]");
    if (!entryNode) {
      return;
    }
    var action = domAttr$2(inputNode, "data-auto-suggest"), entryId = domAttr$2(entryNode, "data-entry");
    var entry = self2.getEntry(entryId);
    self2.executeAction(entry, entryNode, action, event);
  }
  domDelegate.bind(container, "[data-auto-suggest]", "input", handleSuggestItems, true);
  domDelegate.bind(container, "[data-action]", "click", function onClick(event) {
    var inputNode = event.delegateTarget, entryNode = domClosest$3(inputNode, "[data-entry]");
    var actionId = domAttr$2(inputNode, "data-action"), entryId = domAttr$2(entryNode, "data-entry");
    var entry = self2.getEntry(entryId);
    var isEntryDirty = self2.executeAction(entry, entryNode, actionId, event);
    if (!isEntryDirty) {
      return self2.update(self2._current.element);
    }
    var values2 = getFormControlValues(entryNode);
    self2.applyChanges(entry, values2, entryNode);
    self2.updateState(entry, entryNode);
  });
  function handleInput(event, element) {
    var inputNode = event.delegateTarget;
    var entryNode = domClosest$3(inputNode, "[data-entry]");
    if (!entryNode) {
      return;
    }
    var eventHandlerId = domAttr$2(inputNode, "data-blur"), entryId = domAttr$2(entryNode, "data-entry");
    var entry = self2.getEntry(entryId);
    var isEntryDirty = self2.executeAction(entry, entryNode, eventHandlerId, event);
    if (isEntryDirty) {
      var values2 = getFormControlValues(entryNode);
      self2.applyChanges(entry, values2, entryNode);
    }
    self2.updateState(entry, entryNode);
  }
  domDelegate.bind(container, "[data-blur]", "blur", handleInput, true);
  domDelegate.bind(container, ".bpp-properties-tabs-links [data-tab-target]", "click", function(event) {
    event.preventDefault();
    var delegateTarget = event.delegateTarget;
    var tabId = domAttr$2(delegateTarget, "data-tab-target");
    self2.activateTab(tabId);
  });
};
PropertiesPanel.prototype.updateState = function(entry, entryNode) {
  this.updateShow(entry, entryNode);
  this.updateDisable(entry, entryNode);
};
PropertiesPanel.prototype.updateShow = function(entry, node2) {
  var current = this._current;
  if (!current) {
    return;
  }
  var showNodes = domQueryAll("[data-show]", node2) || [];
  forEach$i(showNodes, function(showNode) {
    var expr = domAttr$2(showNode, "data-show");
    var fn = get(entry, expr);
    if (fn) {
      var scope = domClosest$3(showNode, "[data-scope]") || node2;
      var shouldShow = fn(current.element, node2, showNode, scope) || false;
      if (shouldShow) {
        domClasses$7(showNode).remove(HIDE_CLASS);
      } else {
        domClasses$7(showNode).add(HIDE_CLASS);
      }
    }
  });
};
PropertiesPanel.prototype.updateDisable = function(entry, node2) {
  var current = this._current;
  if (!current) {
    return;
  }
  var nodes = domQueryAll("[data-disable]", node2) || [];
  forEach$i(nodes, function(currentNode) {
    var expr = domAttr$2(currentNode, "data-disable");
    var fn = get(entry, expr);
    if (fn) {
      var scope = domClosest$3(currentNode, "[data-scope]") || node2;
      var shouldDisable = fn(current.element, node2, currentNode, scope) || false;
      domAttr$2(currentNode, "disabled", shouldDisable ? "" : null);
    }
  });
};
PropertiesPanel.prototype.executeAction = function(entry, entryNode, actionId, event) {
  var current = this._current;
  if (!current) {
    return;
  }
  var fn = get(entry, actionId);
  if (fn) {
    var scopeNode = domClosest$3(event.target, "[data-scope]") || entryNode;
    return fn.apply(entry, [current.element, entryNode, event, scopeNode]);
  }
};
PropertiesPanel.prototype.applyChanges = function(entry, values2, containerElement) {
  var element = this._current.element;
  if (valuesEqual(values2, entry.oldValues)) {
    return;
  }
  var command = entry.set(element, values2, containerElement);
  var commandToExecute;
  if (isArray$3(command)) {
    if (command.length) {
      commandToExecute = {
        cmd: "properties-panel.multi-command-executor",
        context: flattenDeep$1(command)
      };
    }
  } else {
    commandToExecute = command;
  }
  if (commandToExecute) {
    this._commandStack.execute(commandToExecute.cmd, commandToExecute.context || { element });
  } else {
    this.update(element);
  }
};
PropertiesPanel.prototype.applyValidationErrors = function(validationErrors, entryNode) {
  var valid = true;
  var controlNodes = getFormControls(entryNode, true);
  forEach$i(controlNodes, function(controlNode) {
    var name2 = domAttr$2(controlNode, "name") || domAttr$2(controlNode, "data-name");
    var error2 = validationErrors && validationErrors[name2];
    var errorMessageNode = domQuery$k(".bpp-error-message", controlNode.parentNode);
    if (error2) {
      valid = false;
      if (!errorMessageNode) {
        errorMessageNode = domify$f("<div></div>");
        domClasses$7(errorMessageNode).add("bpp-error-message");
        controlNode.parentNode.insertBefore(errorMessageNode, controlNode.nextSibling);
      }
      errorMessageNode.textContent = error2;
      domClasses$7(controlNode).add("invalid");
    } else {
      domClasses$7(controlNode).remove("invalid");
      if (errorMessageNode) {
        controlNode.parentNode.removeChild(errorMessageNode);
      }
    }
  });
  return valid;
};
PropertiesPanel.prototype.validate = function(entry, values2, entryNode) {
  var self2 = this;
  var current = this._current;
  var valid = true;
  entryNode = entryNode || domQuery$k('[data-entry="' + entry.id + '"]', current.panel);
  if (values2 instanceof Array) {
    var listContainer = domQuery$k("[data-list-entry-container]", entryNode), listEntryNodes = listContainer.children || [];
    for (var i = 0; i < values2.length; i++) {
      var listValue = values2[i];
      if (entry.validateListItem) {
        var validationErrors = entry.validateListItem(current.element, listValue, entryNode, i), listEntryNode = listEntryNodes[i];
        valid = self2.applyValidationErrors(validationErrors, listEntryNode) && valid;
      }
    }
  } else {
    if (entry.validate) {
      this.validationErrors = entry.validate(current.element, values2, entryNode);
      valid = self2.applyValidationErrors(this.validationErrors, entryNode) && valid;
    }
  }
  return valid;
};
PropertiesPanel.prototype.getEntry = function(id2) {
  return this._current && this._current.entries[id2];
};
PropertiesPanel.prototype._create = function(element, tabs) {
  if (!element) {
    return null;
  }
  var containerNode = this._container;
  var panelNode = this._createPanel(element, tabs);
  containerNode.appendChild(panelNode);
  var entries = extractEntries(tabs);
  var groups = extractGroups(tabs);
  return {
    tabs,
    groups,
    entries,
    element,
    panel: panelNode
  };
};
PropertiesPanel.prototype._bindTemplate = function(element, entry, values2, entryNode, idx) {
  var eventBus = this._eventBus;
  function isPropertyEditable(entry2, propertyName) {
    return eventBus.fire("propertiesPanel.isPropertyEditable", {
      entry: entry2,
      propertyName,
      element
    });
  }
  var inputNodes = getPropertyPlaceholders(entryNode);
  forEach$i(inputNodes, function(node2) {
    var name2, newValue, editable;
    if ("value" in node2 || isContentEditable(node2) === "true") {
      name2 = domAttr$2(node2, "name") || domAttr$2(node2, "data-name");
      newValue = values2[name2];
      editable = isPropertyEditable(entry, name2);
      if (editable && entry.editable) {
        editable = entry.editable(element, entryNode, node2, name2, newValue, idx);
      }
      domAttr$2(node2, "readonly", editable ? null : "");
      domAttr$2(node2, "disabled", editable ? null : "");
      if (entry.setControlValue) {
        entry.setControlValue(element, entryNode, node2, name2, newValue, idx);
      } else if (isToggle(node2)) {
        setToggleValue(node2, newValue);
      } else if (isSelect(node2)) {
        setSelectValue(node2, newValue);
      } else {
        setInputValue(node2, newValue);
      }
    } else {
      name2 = domAttr$2(node2, "data-value");
      newValue = values2[name2];
      if (entry.setControlValue) {
        entry.setControlValue(element, entryNode, node2, name2, newValue, idx);
      } else {
        setTextValue(node2, newValue);
      }
    }
  });
};
PropertiesPanel.prototype._updateActivation = function(current) {
  var self2 = this;
  var eventBus = this._eventBus;
  var element = current.element;
  function isEntryVisible2(entry, group, tab) {
    return eventBus.fire("propertiesPanel.isEntryVisible", {
      element,
      entry,
      group,
      tab
    });
  }
  function isGroupVisible(group, element2, groupNode) {
    if (isFunction$1(group.enabled)) {
      return group.enabled(element2, groupNode);
    } else {
      return true;
    }
  }
  function isTabVisible(tab, element2) {
    if (isFunction$1(tab.enabled)) {
      return tab.enabled(element2);
    } else {
      return true;
    }
  }
  function toggleVisible(node2, visible) {
    domClasses$7(node2).toggle(HIDE_CLASS, !visible);
  }
  function updateLabel(element2, selector2, text) {
    var labelNode = domQuery$k(selector2, element2);
    if (!labelNode) {
      return;
    }
    labelNode.textContent = text;
  }
  var panelNode = current.panel;
  forEach$i(current.tabs, function(tab) {
    var tabNode = domQuery$k("[data-tab=" + tab.id + "]", panelNode);
    var tabLinkNode = domQuery$k("[data-tab-target=" + tab.id + "]", panelNode).parentNode;
    var tabVisible = false;
    forEach$i(tab.groups, function(group) {
      var groupVisible = false;
      var groupNode = domQuery$k("[data-group=" + group.id + "]", tabNode);
      forEach$i(group.entries, function(entry) {
        var entryNode = domQuery$k('[data-entry="' + entry.id + '"]', groupNode);
        var entryVisible = isEntryVisible2(entry, group, tab);
        groupVisible = groupVisible || entryVisible;
        toggleVisible(entryNode, entryVisible);
        var values2 = "get" in entry ? entry.get(element, entryNode) : {};
        if (values2 instanceof Array) {
          var listEntryContainer = domQuery$k("[data-list-entry-container]", entryNode);
          var existingElements = listEntryContainer.children || [];
          for (var i = 0; i < values2.length; i++) {
            var listValue = values2[i];
            var listItemNode = existingElements[i];
            if (!listItemNode) {
              listItemNode = domify$f(entry.createListEntryTemplate(listValue, i, listEntryContainer));
              listEntryContainer.appendChild(listItemNode);
            }
            domAttr$2(listItemNode, "data-index", i);
            self2._bindTemplate(element, entry, listValue, listItemNode, i);
          }
          var entriesToRemove = existingElements.length - values2.length;
          for (var j = 0; j < entriesToRemove; j++) {
            listEntryContainer.removeChild(listEntryContainer.lastChild);
          }
        } else {
          self2._bindTemplate(element, entry, values2, entryNode);
        }
        self2.updateState(entry, entryNode);
        self2.validate(entry, values2, entryNode);
        entry.oldValues = getFormControlValues(entryNode);
      });
      if (typeof group.label === "function") {
        updateLabel(groupNode, ".group-label", group.label(element, groupNode));
      }
      groupVisible = groupVisible && isGroupVisible(group, element, groupNode);
      tabVisible = tabVisible || groupVisible;
      toggleVisible(groupNode, groupVisible);
    });
    tabVisible = tabVisible && isTabVisible(tab, element);
    toggleVisible(tabNode, tabVisible);
    toggleVisible(tabLinkNode, tabVisible);
  });
  updateLabel(panelNode, "[data-label-id]", getBusinessObject$U(element).id || "");
};
PropertiesPanel.prototype._createPanel = function(element, tabs) {
  var self2 = this;
  var panelNode = domify$f('<div class="bpp-properties"></div>'), headerNode = domify$f('<div class="bpp-properties-header"><div class="label" data-label-id></div></div>'), tabBarNode = domify$f('<div class="bpp-properties-tab-bar"></div>'), tabLinksNode = domify$f('<ul class="bpp-properties-tabs-links"></ul>'), tabContainerNode = domify$f('<div class="bpp-properties-tabs-container"></div>');
  panelNode.appendChild(headerNode);
  forEach$i(tabs, function(tab, tabIndex) {
    if (!tab.id) {
      throw new Error("tab must have an id");
    }
    var tabNode = domify$f('<div class="bpp-properties-tab" data-tab="' + escapeHTML$l(tab.id) + '"></div>'), tabLinkNode = domify$f('<li class="bpp-properties-tab-link"><a href data-tab-target="' + escapeHTML$l(tab.id) + '">' + escapeHTML$l(tab.label) + "</a></li>");
    var groups = tab.groups;
    forEach$i(groups, function(group) {
      if (!group.id) {
        throw new Error("group must have an id");
      }
      var groupNode = domify$f('<div class="bpp-properties-group" data-group="' + escapeHTML$l(group.id) + '"><span class="group-toggle"></span><div class="group-header"><span class="group-label">' + escapeHTML$l(group.label) + "</span></div></div>");
      if (group.dropdown) {
        domQuery$k(".group-header", groupNode).appendChild(createDropdown(group.dropdown));
      }
      groupNode.querySelector(".group-toggle").addEventListener("click", function(evt) {
        domClasses$7(groupNode).toggle("group-closed");
        evt.preventDefault();
        evt.stopPropagation();
      });
      groupNode.addEventListener("click", function(evt) {
        if (!evt.defaultPrevented && domClasses$7(groupNode).has("group-closed")) {
          domClasses$7(groupNode).remove("group-closed");
        }
      });
      forEach$i(group.entries, function(entry) {
        if (!entry.id) {
          throw new Error("entry must have an id");
        }
        var html = entry.html;
        if (typeof html === "string") {
          html = domify$f(html);
        }
        if (html.get && html.constructor.prototype.jquery) {
          html = html.get(0);
        }
        var entryNode = domify$f('<div class="bpp-properties-entry" data-entry="' + escapeHTML$l(entry.id) + '"></div>');
        forEach$i(entry.cssClasses || [], function(cssClass) {
          domClasses$7(entryNode).add(cssClass);
        });
        entryNode.appendChild(html);
        groupNode.appendChild(entryNode);
        self2.updateState(entry, entryNode);
      });
      tabNode.appendChild(groupNode);
    });
    tabLinksNode.appendChild(tabLinkNode);
    tabContainerNode.appendChild(tabNode);
  });
  tabBarNode.appendChild(tabLinksNode);
  panelNode.appendChild(tabBarNode);
  panelNode.appendChild(tabContainerNode);
  return panelNode;
};
function setInputValue(node2, value) {
  var contentEditable = isContentEditable(node2);
  var oldValue = contentEditable ? node2.innerText : node2.value;
  var selection;
  if (value === void 0) {
    value = "";
  }
  if (oldValue === value) {
    return;
  }
  if (document.activeElement === node2) {
    selection = updateSelection$1(getSelection$1(node2), oldValue, value);
  }
  if (contentEditable) {
    node2.innerText = value;
  } else {
    node2.value = value;
  }
  if (selection) {
    setSelection$1(node2, selection);
  }
}
function setSelectValue(node2, value) {
  if (value !== void 0) {
    node2.value = value;
  }
}
function setToggleValue(node2, value) {
  var nodeValue = node2.value;
  node2.checked = value === nodeValue || !domAttr$2(node2, "value") && value;
}
function setTextValue(node2, value) {
  node2.textContent = value;
}
function getSelection$1(node2) {
  return isContentEditable(node2) ? getContentEditableSelection(node2) : {
    start: node2.selectionStart,
    end: node2.selectionEnd
  };
}
function getContentEditableSelection(node2) {
  var selection = window.getSelection();
  var focusNode = selection.focusNode, focusOffset = selection.focusOffset, anchorOffset = selection.anchorOffset;
  if (!focusNode) {
    throw new Error("not selected");
  }
  if (!node2.contains(focusNode)) {
    throw new Error("not selected");
  }
  return {
    start: Math.min(focusOffset, anchorOffset),
    end: Math.max(focusOffset, anchorOffset)
  };
}
function setSelection$1(node2, selection) {
  if (isContentEditable(node2)) {
    setContentEditableSelection(node2, selection);
  } else {
    node2.selectionStart = selection.start;
    node2.selectionEnd = selection.end;
  }
}
function setContentEditableSelection(node2, selection) {
  var focusNode, domRange, domSelection;
  focusNode = node2.firstChild || node2, domRange = document.createRange();
  domRange.setStart(focusNode, selection.start);
  domRange.setEnd(focusNode, selection.end);
  domSelection = window.getSelection();
  domSelection.removeAllRanges();
  domSelection.addRange(domRange);
}
function isImplicitRoot(element) {
  return element && (element.isImplicit || element.id === "__implicitroot");
}
function normalizeEndOfLineSequences(string) {
  return string.replace(/\r\n|\r|\n/g, "\n");
}
var lib$1 = {
  __depends__: [
    cmd$1,
    require$$1$3.default
  ],
  __init__: ["propertiesPanel"],
  propertiesPanel: ["type", PropertiesPanel_1]
};
var bpmnJsPropertiesPanel = lib$1;
var Helper$1 = {};
var require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(ModelingUtil);
var baseIteratee$2 = _baseIteratee, isArrayLike$2 = isArrayLike_1, keys$6 = keys_1;
function createFind$1(findIndexFunc) {
  return function(collection2, predicate, fromIndex) {
    var iterable = Object(collection2);
    if (!isArrayLike$2(collection2)) {
      var iteratee = baseIteratee$2(predicate);
      collection2 = keys$6(collection2);
      predicate = function(key) {
        return iteratee(iterable[key], key, iterable);
      };
    }
    var index2 = findIndexFunc(collection2, predicate, fromIndex);
    return index2 > -1 ? iterable[iteratee ? collection2[index2] : index2] : void 0;
  };
}
var _createFind = createFind$1;
var toNumber = toNumber_1;
var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign2 = value < 0 ? -1 : 1;
    return sign2 * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_1 = toFinite$1;
var toFinite = toFinite_1;
function toInteger$2(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger$2;
var baseFindIndex = _baseFindIndex, baseIteratee$1 = _baseIteratee, toInteger$1 = toInteger_1;
var nativeMax$3 = Math.max;
function findIndex$3(array, predicate, fromIndex) {
  var length2 = array == null ? 0 : array.length;
  if (!length2) {
    return -1;
  }
  var index2 = fromIndex == null ? 0 : toInteger$1(fromIndex);
  if (index2 < 0) {
    index2 = nativeMax$3(length2 + index2, 0);
  }
  return baseFindIndex(array, baseIteratee$1(predicate), index2);
}
var findIndex_1 = findIndex$3;
var createFind = _createFind, findIndex$2 = findIndex_1;
var find$d = createFind(findIndex$2);
var find_1 = find$d;
var getBusinessObject$T = require$$2$2.getBusinessObject;
var is$K = require$$2$2.is, isAny$a = require$$1$2.isAny;
var find$c = find_1;
var TEMPLATE_ID_ATTR = "camunda:modelerTemplate", TEMPLATE_VERSION_ATTR = "camunda:modelerTemplateVersion";
Helper$1.TEMPLATE_ID_ATTR = TEMPLATE_ID_ATTR;
Helper$1.TEMPLATE_VERSION_ATTR = TEMPLATE_VERSION_ATTR;
function getTemplateId$5(element) {
  var bo = getBusinessObject$T(element);
  if (bo) {
    return bo.get(TEMPLATE_ID_ATTR);
  }
}
Helper$1.getTemplateId = getTemplateId$5;
function getTemplateVersion$1(element) {
  var bo = getBusinessObject$T(element);
  if (bo) {
    return bo.get(TEMPLATE_VERSION_ATTR);
  }
}
Helper$1.getTemplateVersion = getTemplateVersion$1;
function findExtension$4(element, type) {
  var bo = getBusinessObject$T(element);
  var extensionElements2;
  if (is$K(bo, "bpmn:ExtensionElements")) {
    extensionElements2 = bo;
  } else {
    extensionElements2 = bo.extensionElements;
  }
  if (!extensionElements2) {
    return null;
  }
  return find$c(extensionElements2.get("values"), function(e) {
    return is$K(e, type);
  });
}
Helper$1.findExtension = findExtension$4;
function findExtensions$3(element, types2) {
  var extensionElements2 = getExtensionElements$3(element);
  if (!extensionElements2) {
    return [];
  }
  return extensionElements2.get("values").filter(function(e) {
    return isAny$a(e, types2);
  });
}
Helper$1.findExtensions = findExtensions$3;
function findCamundaInOut$1(element, binding) {
  var extensionElements2 = getExtensionElements$3(element);
  if (!extensionElements2) {
    return;
  }
  var matcher;
  if (binding.type === "camunda:in") {
    matcher = function(e) {
      return is$K(e, "camunda:In") && isInOut(e, binding);
    };
  } else if (binding.type === "camunda:out") {
    matcher = function(e) {
      return is$K(e, "camunda:Out") && isInOut(e, binding);
    };
  } else if (binding.type === "camunda:in:businessKey") {
    matcher = function(e) {
      return is$K(e, "camunda:In") && "businessKey" in e;
    };
  }
  return find$c(extensionElements2.get("values"), matcher);
}
Helper$1.findCamundaInOut = findCamundaInOut$1;
function findCamundaProperty$1(camundaProperties, binding) {
  return find$c(camundaProperties.get("values"), function(p) {
    return p.name === binding.name;
  });
}
Helper$1.findCamundaProperty = findCamundaProperty$1;
function findInputParameter$2(inputOutput, binding) {
  var parameters = inputOutput.get("inputParameters");
  return find$c(parameters, function(p) {
    return p.name === binding.name;
  });
}
Helper$1.findInputParameter = findInputParameter$2;
function findOutputParameter$2(inputOutput, binding) {
  var parameters = inputOutput.get("outputParameters");
  return find$c(parameters, function(p) {
    var value = p.value;
    if (!binding.scriptFormat) {
      return value === binding.source;
    }
    var definition = p.definition;
    if (!definition || binding.scriptFormat !== definition.scriptFormat) {
      return false;
    }
    return definition.value === binding.source;
  });
}
Helper$1.findOutputParameter = findOutputParameter$2;
function findCamundaErrorEventDefinition$3(element, bindingErrorRef) {
  var errorEventDefinitions = findExtensions$3(element, ["camunda:ErrorEventDefinition"]), error2;
  return find$c(errorEventDefinitions, function(definition) {
    error2 = definition.errorRef;
    if (error2) {
      return error2.id.indexOf("Error_" + bindingErrorRef) == 0;
    }
  });
}
Helper$1.findCamundaErrorEventDefinition = findCamundaErrorEventDefinition$3;
function getExtensionElements$3(element) {
  var bo = getBusinessObject$T(element);
  if (is$K(bo, "bpmn:ExtensionElements")) {
    return bo;
  } else {
    return bo.extensionElements;
  }
}
function isInOut(element, binding) {
  if (binding.type === "camunda:in") {
    if (binding.target) {
      return element.target === binding.target;
    }
  }
  if (binding.type === "camunda:out") {
    if (binding.source) {
      return element.source === binding.source;
    }
    if (binding.sourceExpression) {
      return element.sourceExpression === binding.sourceExpression;
    }
  }
  if (binding.variables) {
    return element.variables === "all" && (binding.variables !== "local" || element.local);
  }
}
var require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(index_esm$3);
var assign$d = require$$1$1.assign, forEach$h = require$$1$1.forEach, keys$5 = require$$1$1.keys, isObject$4 = require$$1$1.isObject;
var handleLegacyScopes$3 = function handleLegacyScopes2(scopes) {
  var scopesAsArray = [];
  if (!isObject$4(scopes)) {
    return scopes;
  }
  forEach$h(keys$5(scopes), function(scopeName) {
    scopesAsArray.push(assign$d({
      type: scopeName
    }, scopes[scopeName]));
  });
  return scopesAsArray;
};
var CreateHelper = {};
var baseAssignValue$1 = _baseAssignValue, eq$1 = eq_1;
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function assignValue$3(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$3.call(object, key) && eq$1(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$1(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length2 = props.length;
  while (++index2 < length2) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$1;
var eq = eq_1, isArrayLike$1 = isArrayLike_1, isIndex$3 = _isIndex, isObject$3 = isObject_1;
function isIterateeCall$1(value, index2, object) {
  if (!isObject$3(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike$1(object) && isIndex$3(index2, object.length) : type == "string" && index2 in object) {
    return eq(object[index2], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;
var baseRest$1 = _baseRest, isIterateeCall = _isIterateeCall;
function createAssigner$1(assigner) {
  return baseRest$1(function(object, sources) {
    var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length2 < 3 ? void 0 : customizer;
      length2 = 1;
    }
    object = Object(object);
    while (++index2 < length2) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$1;
var assignValue$1 = _assignValue, copyObject = _copyObject, createAssigner = _createAssigner, isArrayLike = isArrayLike_1, isPrototype = _isPrototype, keys$4 = keys_1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
var assign$c = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys$4(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty$2.call(source, key)) {
      assignValue$1(object, key, source[key]);
    }
  }
});
var assign_1 = assign$c;
var assign$b = assign_1;
var nextId = Utils.nextId;
function createInputParameter$3(binding, value, bpmnFactory) {
  var scriptFormat = binding.scriptFormat, parameterValue, parameterDefinition;
  if (scriptFormat) {
    parameterDefinition = bpmnFactory.create("camunda:Script", {
      scriptFormat,
      value
    });
  } else {
    parameterValue = value;
  }
  return bpmnFactory.create("camunda:InputParameter", {
    name: binding.name,
    value: parameterValue,
    definition: parameterDefinition
  });
}
CreateHelper.createInputParameter = createInputParameter$3;
function createOutputParameter$3(binding, value, bpmnFactory) {
  var scriptFormat = binding.scriptFormat, parameterValue, parameterDefinition;
  if (scriptFormat) {
    parameterDefinition = bpmnFactory.create("camunda:Script", {
      scriptFormat,
      value: binding.source
    });
  } else {
    parameterValue = binding.source;
  }
  return bpmnFactory.create("camunda:OutputParameter", {
    name: value,
    value: parameterValue,
    definition: parameterDefinition
  });
}
CreateHelper.createOutputParameter = createOutputParameter$3;
function createCamundaProperty$2(binding, value, bpmnFactory) {
  return bpmnFactory.create("camunda:Property", {
    name: binding.name,
    value: value || ""
  });
}
CreateHelper.createCamundaProperty = createCamundaProperty$2;
function createCamundaIn$2(binding, value, bpmnFactory) {
  var properties2 = createCamundaInOutAttrs(binding, value);
  return bpmnFactory.create("camunda:In", properties2);
}
CreateHelper.createCamundaIn = createCamundaIn$2;
function createCamundaInWithBusinessKey$2(binding, value, bpmnFactory) {
  return bpmnFactory.create("camunda:In", {
    businessKey: value
  });
}
CreateHelper.createCamundaInWithBusinessKey = createCamundaInWithBusinessKey$2;
function createCamundaOut$2(binding, value, bpmnFactory) {
  var properties2 = createCamundaInOutAttrs(binding, value);
  return bpmnFactory.create("camunda:Out", properties2);
}
CreateHelper.createCamundaOut = createCamundaOut$2;
function createCamundaExecutionListenerScript$1(binding, value, bpmnFactory) {
  var scriptFormat = binding.scriptFormat, parameterValue, parameterDefinition;
  if (scriptFormat) {
    parameterDefinition = bpmnFactory.create("camunda:Script", {
      scriptFormat,
      value
    });
  } else {
    parameterValue = value;
  }
  return bpmnFactory.create("camunda:ExecutionListener", {
    event: binding.event,
    value: parameterValue,
    script: parameterDefinition
  });
}
CreateHelper.createCamundaExecutionListenerScript = createCamundaExecutionListenerScript$1;
function createCamundaFieldInjection$2(binding, value, bpmnFactory) {
  var DEFAULT_PROPS2 = {
    "string": void 0,
    "expression": void 0,
    "name": void 0
  };
  var props = assign$b({}, DEFAULT_PROPS2);
  if (!binding.expression) {
    props.string = value;
  } else {
    props.expression = value;
  }
  props.name = binding.name;
  return bpmnFactory.create("camunda:Field", props);
}
CreateHelper.createCamundaFieldInjection = createCamundaFieldInjection$2;
function createCamundaErrorEventDefinition$2(binding, value, error2, parent2, bpmnFactory) {
  var errorRef = error2, expression = value;
  var newErrorEventDefinition = bpmnFactory.create("camunda:ErrorEventDefinition", {
    expression,
    errorRef
  });
  newErrorEventDefinition.$parent = parent2;
  return newErrorEventDefinition;
}
CreateHelper.createCamundaErrorEventDefinition = createCamundaErrorEventDefinition$2;
function createError$2(bindingErrorRef, parent2, bpmnFactory) {
  var error2 = bpmnFactory.create("bpmn:Error", {
    id: nextId("Error_" + bindingErrorRef + "_")
  });
  error2.$parent = parent2;
  return error2;
}
CreateHelper.createError = createError$2;
function createCamundaInOutAttrs(binding, value) {
  var properties2 = {};
  if (binding.type === "camunda:in") {
    if (binding.target && !binding.expression && !binding.variables) {
      properties2.target = binding.target;
      properties2.source = value;
    } else if (binding.target && binding.expression === true && !binding.variables) {
      properties2.target = binding.target;
      properties2.sourceExpression = value;
    } else if (!binding.target && !binding.expression && binding.variables === "local") {
      properties2.local = true;
      properties2.variables = "all";
    } else if (binding.target && !binding.expression && binding.variables === "local") {
      properties2.local = true;
      properties2.source = value;
      properties2.target = binding.target;
    } else if (binding.target && binding.expression && binding.variables === "local") {
      properties2.local = true;
      properties2.sourceExpression = value;
      properties2.target = binding.target;
    } else if (!binding.target && !binding.expression && binding.variables === "all") {
      properties2.variables = "all";
    } else {
      throw new Error("invalid configuration for camunda:in element template binding");
    }
  }
  if (binding.type === "camunda:out") {
    if (binding.source && !binding.sourceExpression && !binding.variables) {
      properties2.target = value;
      properties2.source = binding.source;
    } else if (!binding.source && binding.sourceExpression && !binding.variables) {
      properties2.target = value;
      properties2.sourceExpression = binding.sourceExpression;
    } else if (!binding.source && !binding.sourceExpression && binding.variables === "all") {
      properties2.variables = "all";
    } else if (binding.source && !binding.sourceExpression && binding.variables === "local") {
      properties2.local = true;
      properties2.source = binding.source;
      properties2.target = value;
    } else if (!binding.source && binding.sourceExpression && binding.variables === "local") {
      properties2.local = true;
      properties2.sourceExpression = binding.sourceExpression;
      properties2.target = value;
    } else if (!binding.source && !binding.sourceExpression && binding.variables === "local") {
      properties2.local = true;
      properties2.variables = "all";
    } else {
      throw new Error("invalid configuration for camunda:out element template binding");
    }
  }
  return properties2;
}
var getBusinessObject$S = require$$2$2.getBusinessObject, is$J = require$$2$2.is, forEach$g = forEach_1;
var EventDefinitionHelper$1 = {};
var EventDefinitionHelper_1 = EventDefinitionHelper$1;
EventDefinitionHelper$1.getEventDefinition = function(element, eventType) {
  var bo = getBusinessObject$S(element), eventDefinition = null;
  if (bo.eventDefinitions) {
    forEach$g(bo.eventDefinitions, function(event) {
      if (is$J(event, eventType)) {
        eventDefinition = event;
      }
    });
  }
  return eventDefinition;
};
EventDefinitionHelper$1.getTimerEventDefinition = function(element) {
  return this.getEventDefinition(element, "bpmn:TimerEventDefinition");
};
EventDefinitionHelper$1.getMessageEventDefinition = function(element) {
  return this.getEventDefinition(element, "bpmn:MessageEventDefinition");
};
EventDefinitionHelper$1.getSignalEventDefinition = function(element) {
  return this.getEventDefinition(element, "bpmn:SignalEventDefinition");
};
EventDefinitionHelper$1.getErrorEventDefinition = function(element) {
  return this.getEventDefinition(element, "bpmn:ErrorEventDefinition");
};
EventDefinitionHelper$1.getEscalationEventDefinition = function(element) {
  return this.getEventDefinition(element, "bpmn:EscalationEventDefinition");
};
EventDefinitionHelper$1.getCompensateEventDefinition = function(element) {
  return this.getEventDefinition(element, "bpmn:CompensateEventDefinition");
};
EventDefinitionHelper$1.getLinkEventDefinition = function(element) {
  return this.getEventDefinition(element, "bpmn:LinkEventDefinition");
};
EventDefinitionHelper$1.getConditionalEventDefinition = function(element) {
  return this.getEventDefinition(element, "bpmn:ConditionalEventDefinition");
};
var baseGetTag$1 = _baseGetTag, isArray$2 = isArray_1, isObjectLike$2 = isObjectLike_1;
var stringTag = "[object String]";
function isString$2(value) {
  return typeof value == "string" || !isArray$2(value) && isObjectLike$2(value) && baseGetTag$1(value) == stringTag;
}
var isString_1 = isString$2;
function last$1(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? array[length2 - 1] : void 0;
}
var last_1 = last$1;
function baseSlice$1(array, start, end) {
  var index2 = -1, length2 = array.length;
  if (start < 0) {
    start = -start > length2 ? 0 : length2 + start;
  }
  end = end > length2 ? length2 : end;
  if (end < 0) {
    end += length2;
  }
  length2 = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length2);
  while (++index2 < length2) {
    result[index2] = array[index2 + start];
  }
  return result;
}
var _baseSlice = baseSlice$1;
var baseGet$1 = _baseGet, baseSlice = _baseSlice;
function parent$1(object, path) {
  return path.length < 2 ? object : baseGet$1(object, baseSlice(path, 0, -1));
}
var _parent = parent$1;
var castPath$2 = _castPath, last = last_1, parent = _parent, toKey$1 = _toKey;
function baseUnset$1(object, path) {
  path = castPath$2(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey$1(last(path))];
}
var _baseUnset = baseUnset$1;
var baseUnset = _baseUnset, isIndex$2 = _isIndex;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function basePullAt$1(array, indexes) {
  var length2 = array ? indexes.length : 0, lastIndex = length2 - 1;
  while (length2--) {
    var index2 = indexes[length2];
    if (length2 == lastIndex || index2 !== previous) {
      var previous = index2;
      if (isIndex$2(index2)) {
        splice.call(array, index2, 1);
      } else {
        baseUnset(array, index2);
      }
    }
  }
  return array;
}
var _basePullAt = basePullAt$1;
var baseIteratee = _baseIteratee, basePullAt = _basePullAt;
function remove$2(array, predicate) {
  var result = [];
  if (!(array && array.length)) {
    return result;
  }
  var index2 = -1, indexes = [], length2 = array.length;
  predicate = baseIteratee(predicate);
  while (++index2 < length2) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result.push(value);
      indexes.push(index2);
    }
  }
  basePullAt(array, indexes);
  return result;
}
var remove_1 = remove$2;
var findExtension$3 = Helper$1.findExtension, findExtensions$2 = Helper$1.findExtensions, findCamundaErrorEventDefinition$2 = Helper$1.findCamundaErrorEventDefinition;
var handleLegacyScopes$2 = handleLegacyScopes$3;
var createCamundaExecutionListenerScript = CreateHelper.createCamundaExecutionListenerScript, createCamundaFieldInjection$1 = CreateHelper.createCamundaFieldInjection, createCamundaIn$1 = CreateHelper.createCamundaIn, createCamundaInWithBusinessKey$1 = CreateHelper.createCamundaInWithBusinessKey, createCamundaOut$1 = CreateHelper.createCamundaOut, createCamundaProperty$1 = CreateHelper.createCamundaProperty, createInputParameter$2 = CreateHelper.createInputParameter, createOutputParameter$2 = CreateHelper.createOutputParameter, createCamundaErrorEventDefinition$1 = CreateHelper.createCamundaErrorEventDefinition, createError$1 = CreateHelper.createError;
var EventDefinitionHelper = EventDefinitionHelper_1;
var getRoot$1 = Utils.getRoot;
var getBusinessObject$R = require$$2$2.getBusinessObject;
var is$I = require$$2$2.is, isAny$9 = require$$1$2.isAny;
var find$b = find_1, forEach$f = forEach_1, isString$1 = isString_1, keys$3 = keys_1, remove$1 = remove_1;
var CAMUNDA_SERVICE_TASK_LIKE = [
  "camunda:class",
  "camunda:delegateExpression",
  "camunda:expression"
];
function ChangeElementTemplateHandler$1(bpmnFactory, commandStack, modeling) {
  this._bpmnFactory = bpmnFactory;
  this._commandStack = commandStack;
  this._modeling = modeling;
}
ChangeElementTemplateHandler$1.$inject = [
  "bpmnFactory",
  "commandStack",
  "modeling"
];
var ChangeElementTemplateHandler_1 = ChangeElementTemplateHandler$1;
ChangeElementTemplateHandler$1.prototype.preExecute = function(context) {
  var element = context.element, newTemplate = context.newTemplate, oldTemplate = context.oldTemplate;
  var self2 = this;
  this._updateCamundaModelerTemplate(element, newTemplate);
  if (newTemplate) {
    this._updateProperties(element, oldTemplate, newTemplate);
    this._updateCamundaExecutionListenerProperties(element, newTemplate);
    this._updateCamundaFieldProperties(element, oldTemplate, newTemplate);
    this._updateCamundaInOutProperties(element, oldTemplate, newTemplate);
    this._updateCamundaInputOutputParameterProperties(element, oldTemplate, newTemplate);
    this._updateCamundaPropertyProperties(element, oldTemplate, newTemplate);
    this._updateCamundaErrorEventDefinitionProperties(element, oldTemplate, newTemplate);
    forEach$f(handleLegacyScopes$2(newTemplate.scopes), function(newScopeTemplate) {
      self2._updateScopeProperties(element, oldTemplate, newScopeTemplate, newTemplate);
    });
  }
};
ChangeElementTemplateHandler$1.prototype._getOrCreateExtensionElements = function(element) {
  var bpmnFactory = this._bpmnFactory, modeling = this._modeling;
  var businessObject = getBusinessObject$R(element);
  var extensionElements2 = businessObject.get("extensionElements");
  if (!extensionElements2) {
    extensionElements2 = bpmnFactory.create("bpmn:ExtensionElements", {
      values: []
    });
    extensionElements2.$parent = businessObject;
    modeling.updateProperties(element, {
      extensionElements: extensionElements2
    });
  }
  return extensionElements2;
};
ChangeElementTemplateHandler$1.prototype._updateCamundaErrorEventDefinitionProperties = function(element, oldTemplate, newTemplate) {
  var bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
  var newProperties = newTemplate.properties.filter(function(newProperty) {
    var newBinding = newProperty.binding, newBindingType = newBinding.type;
    return newBindingType === "camunda:errorEventDefinition";
  });
  if (!newProperties.length) {
    return;
  }
  var businessObject = this._getOrCreateExtensionElements(element);
  var oldErrorEventDefinitions = findExtensions$2(element, ["camunda:ErrorEventDefinition"]);
  newProperties.forEach(function(newProperty) {
    var oldProperty = findOldProperty(oldTemplate, newProperty), oldEventDefinition = oldProperty && findOldBusinessObject(businessObject, oldProperty), newBinding = newProperty.binding;
    if (oldProperty && oldEventDefinition) {
      if (!propertyChanged(oldEventDefinition, oldProperty)) {
        commandStack.execute("properties-panel.update-businessobject", {
          element,
          businessObject: oldEventDefinition,
          properties: {
            expression: newProperty.value
          }
        });
      }
      remove$1(oldErrorEventDefinitions, oldEventDefinition);
    } else {
      var rootElement = getRoot$1(getBusinessObject$R(element)), newError = createError$1(newBinding.errorRef, rootElement, bpmnFactory), newEventDefinition = createCamundaErrorEventDefinition$1(newBinding, newProperty.value, newError, businessObject, bpmnFactory);
      commandStack.execute("properties-panel.update-businessobject-list", {
        element,
        currentObject: rootElement,
        propertyName: "rootElements",
        objectsToAdd: [newError],
        objectsToRemove: []
      });
      commandStack.execute("properties-panel.update-businessobject-list", {
        element,
        currentObject: businessObject,
        propertyName: "values",
        objectsToAdd: [newEventDefinition],
        objectsToRemove: []
      });
    }
  });
  if (oldErrorEventDefinitions.length) {
    commandStack.execute("properties-panel.update-businessobject-list", {
      element,
      currentObject: businessObject,
      propertyName: "values",
      objectsToAdd: [],
      objectsToRemove: oldErrorEventDefinitions
    });
  }
};
ChangeElementTemplateHandler$1.prototype._updateCamundaExecutionListenerProperties = function(element, newTemplate) {
  var bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
  var newProperties = newTemplate.properties.filter(function(newProperty) {
    var newBinding = newProperty.binding, newBindingType = newBinding.type;
    return newBindingType === "camunda:executionListener";
  });
  if (!newProperties.length) {
    return;
  }
  var businessObject = this._getOrCreateExtensionElements(element);
  var oldExecutionListeners = findExtensions$2(element, ["camunda:ExecutionListener"]);
  var newExecutionListeners = newProperties.map(function(newProperty) {
    var newBinding = newProperty.binding, propertyValue = newProperty.value;
    return createCamundaExecutionListenerScript(newBinding, propertyValue, bpmnFactory);
  });
  commandStack.execute("properties-panel.update-businessobject-list", {
    element,
    currentObject: businessObject,
    propertyName: "values",
    objectsToAdd: newExecutionListeners,
    objectsToRemove: oldExecutionListeners
  });
};
ChangeElementTemplateHandler$1.prototype._updateCamundaFieldProperties = function(element, oldTemplate, newTemplate, businessObject) {
  var bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
  var newProperties = newTemplate.properties.filter(function(newProperty) {
    var newBinding = newProperty.binding, newBindingType = newBinding.type;
    return newBindingType === "camunda:field";
  });
  if (!newProperties.length) {
    return;
  }
  if (!businessObject) {
    businessObject = this._getOrCreateExtensionElements(element);
  }
  var propertyName = isAny$9(businessObject, ["camunda:ExecutionListener", "camunda:TaskListener"]) ? "fields" : "values";
  var oldFields = findExtensions$2(element, ["camunda:Field"]);
  newProperties.forEach(function(newProperty) {
    var oldProperty = findOldProperty(oldTemplate, newProperty), oldField = oldProperty && findOldBusinessObject(businessObject, oldProperty), newBinding = newProperty.binding;
    if (oldProperty && oldField) {
      if (!propertyChanged(oldField, oldProperty)) {
        commandStack.execute("properties-panel.update-businessobject", {
          element,
          businessObject: oldField,
          properties: {
            string: newProperty.value
          }
        });
      }
      remove$1(oldFields, oldField);
    } else {
      commandStack.execute("properties-panel.update-businessobject-list", {
        element,
        currentObject: businessObject,
        propertyName,
        objectsToAdd: [createCamundaFieldInjection$1(newBinding, newProperty.value, bpmnFactory)],
        objectsToRemove: []
      });
    }
  });
  if (oldFields.length) {
    commandStack.execute("properties-panel.update-businessobject-list", {
      element,
      currentObject: businessObject,
      propertyName,
      objectsToAdd: [],
      objectsToRemove: oldFields
    });
  }
};
ChangeElementTemplateHandler$1.prototype._updateCamundaInOutProperties = function(element, oldTemplate, newTemplate) {
  var bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
  var newProperties = newTemplate.properties.filter(function(newProperty) {
    var newBinding = newProperty.binding, newBindingType = newBinding.type;
    return newBindingType === "camunda:in" || newBindingType === "camunda:in:businessKey" || newBindingType === "camunda:out";
  });
  if (!newProperties.length) {
    return;
  }
  var businessObject = this._getOrCreateExtensionElements(EventDefinitionHelper.getSignalEventDefinition(element) || element);
  var oldInsAndOuts = findExtensions$2(businessObject, ["camunda:In", "camunda:Out"]);
  newProperties.forEach(function(newProperty) {
    var oldProperty = findOldProperty(oldTemplate, newProperty), oldBinding = oldProperty && oldProperty.binding, oldInOurOut = oldProperty && findOldBusinessObject(businessObject, oldProperty), newPropertyValue = newProperty.value, newBinding = newProperty.binding, newBindingType = newBinding.type, newInOrOut, properties2 = {};
    if (oldProperty && oldInOurOut) {
      if (!propertyChanged(oldInOurOut, oldProperty)) {
        if (newBindingType === "camunda:in") {
          if (newBinding.expression) {
            properties2["camunda:sourceExpression"] = newPropertyValue;
          } else {
            properties2["camunda:source"] = newPropertyValue;
          }
        } else if (newBindingType === "camunda:in:businessKey") {
          properties2["camunda:businessKey"] = newPropertyValue;
        } else if (newBindingType === "camunda:out") {
          properties2["camunda:target"] = newPropertyValue;
        }
      }
      if (oldBinding.local && !newBinding.local || !oldBinding.local && newBinding.local) {
        properties2.local = newBinding.local;
      }
      if (keys$3(properties2)) {
        commandStack.execute("properties-panel.update-businessobject", {
          element,
          businessObject: oldInOurOut,
          properties: properties2
        });
      }
      remove$1(oldInsAndOuts, oldInOurOut);
    } else {
      if (newBindingType === "camunda:in") {
        newInOrOut = createCamundaIn$1(newBinding, newPropertyValue, bpmnFactory);
      } else if (newBindingType === "camunda:out") {
        newInOrOut = createCamundaOut$1(newBinding, newPropertyValue, bpmnFactory);
      } else if (newBindingType === "camunda:in:businessKey") {
        newInOrOut = createCamundaInWithBusinessKey$1(newBinding, newPropertyValue, bpmnFactory);
      }
      commandStack.execute("properties-panel.update-businessobject-list", {
        element,
        currentObject: businessObject,
        propertyName: "values",
        objectsToAdd: [newInOrOut],
        objectsToRemove: []
      });
    }
  });
  if (oldInsAndOuts.length) {
    commandStack.execute("properties-panel.update-businessobject-list", {
      element,
      currentObject: businessObject,
      propertyName: "values",
      objectsToAdd: [],
      objectsToRemove: oldInsAndOuts
    });
  }
};
ChangeElementTemplateHandler$1.prototype._updateCamundaInputOutputParameterProperties = function(element, oldTemplate, newTemplate, businessObject) {
  var bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
  var newProperties = newTemplate.properties.filter(function(newProperty) {
    var newBinding = newProperty.binding, newBindingType = newBinding.type;
    return newBindingType === "camunda:inputParameter" || newBindingType === "camunda:outputParameter";
  });
  if (!newProperties.length) {
    return;
  }
  if (!businessObject) {
    businessObject = this._getOrCreateExtensionElements(element);
  }
  var inputOutput;
  if (is$I(businessObject, "camunda:Connector")) {
    inputOutput = businessObject.get("camunda:inputOutput");
    if (!inputOutput) {
      inputOutput = bpmnFactory.create("camunda:InputOutput");
      commandStack.execute("properties-panel.update-businessobject", {
        element,
        businessObject,
        properties: {
          inputOutput
        }
      });
    }
  } else {
    inputOutput = findExtension$3(businessObject, "camunda:InputOutput");
    if (!inputOutput) {
      inputOutput = bpmnFactory.create("camunda:InputOutput");
      commandStack.execute("properties-panel.update-businessobject-list", {
        element,
        currentObject: businessObject,
        propertyName: "values",
        objectsToAdd: [inputOutput],
        objectsToRemove: []
      });
    }
  }
  var oldInputs = inputOutput.get("camunda:inputParameters") ? inputOutput.get("camunda:inputParameters").slice() : [];
  var oldOutputs = inputOutput.get("camunda:outputParameters") ? inputOutput.get("camunda:outputParameters").slice() : [];
  var propertyName;
  newProperties.forEach(function(newProperty) {
    var oldProperty = findOldProperty(oldTemplate, newProperty), oldInputOrOutput = oldProperty && findOldBusinessObject(businessObject, oldProperty), newPropertyValue = newProperty.value, newBinding = newProperty.binding, newBindingType = newBinding.type;
    var newInputOrOutput, properties2;
    if (oldProperty && oldInputOrOutput) {
      if (!propertyChanged(oldInputOrOutput, oldProperty)) {
        if (is$I(oldInputOrOutput, "camunda:InputParameter")) {
          properties2 = {
            value: newPropertyValue
          };
        } else {
          properties2 = {
            name: newPropertyValue
          };
        }
        commandStack.execute("properties-panel.update-businessobject", {
          element,
          businessObject: oldInputOrOutput,
          properties: properties2
        });
      }
      if (is$I(oldInputOrOutput, "camunda:InputParameter")) {
        remove$1(oldInputs, oldInputOrOutput);
      } else {
        remove$1(oldOutputs, oldInputOrOutput);
      }
    } else {
      if (newBindingType === "camunda:inputParameter") {
        propertyName = "inputParameters";
        newInputOrOutput = createInputParameter$2(newBinding, newPropertyValue, bpmnFactory);
      } else {
        propertyName = "outputParameters";
        newInputOrOutput = createOutputParameter$2(newBinding, newPropertyValue, bpmnFactory);
      }
      commandStack.execute("properties-panel.update-businessobject-list", {
        element,
        currentObject: inputOutput,
        propertyName,
        objectsToAdd: [newInputOrOutput],
        objectsToRemove: []
      });
    }
  });
  if (oldInputs.length) {
    commandStack.execute("properties-panel.update-businessobject-list", {
      element,
      currentObject: inputOutput,
      propertyName: "inputParameters",
      objectsToAdd: [],
      objectsToRemove: oldInputs
    });
  }
  if (oldOutputs.length) {
    commandStack.execute("properties-panel.update-businessobject-list", {
      element,
      currentObject: inputOutput,
      propertyName: "outputParameters",
      objectsToAdd: [],
      objectsToRemove: oldOutputs
    });
  }
};
ChangeElementTemplateHandler$1.prototype._updateCamundaModelerTemplate = function(element, newTemplate) {
  var modeling = this._modeling;
  modeling.updateProperties(element, {
    "camunda:modelerTemplate": newTemplate && newTemplate.id,
    "camunda:modelerTemplateVersion": newTemplate && newTemplate.version
  });
};
ChangeElementTemplateHandler$1.prototype._updateCamundaPropertyProperties = function(element, oldTemplate, newTemplate, businessObject) {
  var bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
  var newProperties = newTemplate.properties.filter(function(newProperty) {
    var newBinding = newProperty.binding, newBindingType = newBinding.type;
    return newBindingType === "camunda:property";
  });
  if (!newProperties.length) {
    return;
  }
  if (businessObject) {
    businessObject = this._getOrCreateExtensionElements(businessObject);
  } else {
    businessObject = this._getOrCreateExtensionElements(element);
  }
  var camundaProperties = findExtension$3(businessObject, "camunda:Properties");
  if (!camundaProperties) {
    camundaProperties = bpmnFactory.create("camunda:Properties");
    commandStack.execute("properties-panel.update-businessobject-list", {
      element,
      currentObject: businessObject,
      propertyName: "values",
      objectsToAdd: [camundaProperties],
      objectsToRemove: []
    });
  }
  var oldCamundaProperties = camundaProperties.get("camunda:values") ? camundaProperties.get("camunda:values").slice() : [];
  newProperties.forEach(function(newProperty) {
    var oldProperty = findOldProperty(oldTemplate, newProperty), oldCamundaProperty = oldProperty && findOldBusinessObject(businessObject, oldProperty), newPropertyValue = newProperty.value, newBinding = newProperty.binding;
    if (oldProperty && oldCamundaProperty) {
      if (!propertyChanged(oldCamundaProperty, oldProperty)) {
        commandStack.execute("properties-panel.update-businessobject", {
          element,
          businessObject: oldCamundaProperty,
          properties: {
            value: newPropertyValue
          }
        });
      }
      remove$1(oldCamundaProperties, oldCamundaProperty);
    } else {
      commandStack.execute("properties-panel.update-businessobject-list", {
        element,
        currentObject: camundaProperties,
        propertyName: "values",
        objectsToAdd: [createCamundaProperty$1(newBinding, newPropertyValue, bpmnFactory)],
        objectsToRemove: []
      });
    }
  });
  if (oldCamundaProperties.length) {
    commandStack.execute("properties-panel.update-businessobject-list", {
      element,
      currentObject: camundaProperties,
      propertyName: "values",
      objectsToAdd: [],
      objectsToRemove: oldCamundaProperties
    });
  }
};
ChangeElementTemplateHandler$1.prototype._updateConditionExpression = function(element, oldProperty, newProperty) {
  var bpmnFactory = this._bpmnFactory, commandStack = this._commandStack, modeling = this._modeling;
  var newBinding = newProperty.binding, newPropertyValue = newProperty.value;
  if (!oldProperty) {
    modeling.updateProperties(element, {
      conditionExpression: bpmnFactory.create("bpmn:FormalExpression", {
        body: newPropertyValue,
        language: newBinding.scriptFormat
      })
    });
    return;
  }
  var oldBinding = oldProperty.binding, oldPropertyValue = oldProperty.value;
  var businessObject = getBusinessObject$R(element), conditionExpression = businessObject.get("bpmn:conditionExpression");
  var properties2 = {};
  if (conditionExpression.get("body") === oldPropertyValue) {
    properties2.body = newPropertyValue;
  }
  if (conditionExpression.get("language") === oldBinding.scriptFormat) {
    properties2.language = newBinding.scriptFormat;
  }
  if (!keys$3(properties2).length) {
    return;
  }
  commandStack.execute("properties-panel.update-businessobject", {
    element,
    businessObject: conditionExpression,
    properties: properties2
  });
};
ChangeElementTemplateHandler$1.prototype._updateProperties = function(element, oldTemplate, newTemplate, businessObject) {
  var self2 = this;
  var commandStack = this._commandStack;
  var newProperties = newTemplate.properties.filter(function(newProperty) {
    var newBinding = newProperty.binding, newBindingType = newBinding.type;
    return newBindingType === "property";
  });
  if (!newProperties.length) {
    return;
  }
  if (!businessObject) {
    businessObject = getBusinessObject$R(element);
  }
  newProperties.forEach(function(newProperty) {
    var oldProperty = findOldProperty(oldTemplate, newProperty), newBinding = newProperty.binding, newBindingName = newBinding.name, newPropertyValue = newProperty.value, changedElement, properties2;
    if (newBindingName === "conditionExpression") {
      self2._updateConditionExpression(element, oldProperty, newProperty);
    } else {
      if (is$I(businessObject, "bpmn:Error")) {
        changedElement = businessObject;
      } else {
        changedElement = element;
      }
      if (oldProperty && propertyChanged(changedElement, oldProperty)) {
        return;
      }
      properties2 = {};
      properties2[newBindingName] = newPropertyValue;
      if (CAMUNDA_SERVICE_TASK_LIKE.indexOf(newBindingName) !== -1) {
        CAMUNDA_SERVICE_TASK_LIKE.forEach(function(camundaServiceTaskLikeProperty) {
          if (camundaServiceTaskLikeProperty !== newBindingName) {
            properties2[camundaServiceTaskLikeProperty] = void 0;
          }
        });
      }
      commandStack.execute("properties-panel.update-businessobject", {
        element,
        businessObject,
        properties: properties2
      });
    }
  });
};
ChangeElementTemplateHandler$1.prototype._updateScopeProperties = function(element, oldTemplate, newScopeTemplate, newTemplate) {
  var bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
  var scopeName = newScopeTemplate.type;
  var scopeElement;
  scopeElement = findOldScopeElement(element, newScopeTemplate, newTemplate);
  if (!scopeElement) {
    scopeElement = bpmnFactory.create(scopeName);
  }
  var oldScopeTemplate = findOldScopeTemplate(newScopeTemplate, oldTemplate);
  this._updateProperties(element, oldScopeTemplate, newScopeTemplate, scopeElement);
  this._updateCamundaExecutionListenerProperties(element, newScopeTemplate);
  this._updateCamundaInOutProperties(element, oldScopeTemplate, newScopeTemplate);
  this._updateCamundaInputOutputParameterProperties(element, oldScopeTemplate, newScopeTemplate, scopeElement);
  this._updateCamundaFieldProperties(element, oldScopeTemplate, newScopeTemplate, scopeElement);
  this._updateCamundaPropertyProperties(element, oldScopeTemplate, newScopeTemplate, scopeElement);
  if (isRootElementScope(scopeName)) {
    return;
  }
  var extensionElements2 = this._getOrCreateExtensionElements(element);
  commandStack.execute("properties-panel.update-businessobject-list", {
    element,
    currentObject: extensionElements2,
    propertyName: "values",
    objectsToAdd: [scopeElement],
    objectsToRemove: []
  });
};
function findOldBusinessObject(element, oldProperty) {
  var businessObject = getBusinessObject$R(element), propertyName;
  var oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
  if (oldBindingType === "camunda:field") {
    if (isAny$9(businessObject, ["camunda:ExecutionListener", "camunda:TaskListener"])) {
      propertyName = "camunda:fields";
    } else {
      propertyName = "bpmn:values";
    }
    if (!businessObject || !businessObject.get(propertyName) || !businessObject.get(propertyName).length) {
      return;
    }
    return find$b(businessObject.get(propertyName), function(oldBusinessObject) {
      return oldBusinessObject.get("camunda:name") === oldBinding.name;
    });
  }
  if (oldBindingType === "camunda:in") {
    return find$b(businessObject.get("values"), function(oldBusinessObject) {
      return oldBusinessObject.get("target") === oldBinding.target;
    });
  }
  if (oldBindingType === "camunda:in:businessKey") {
    return find$b(businessObject.get("values"), function(oldBusinessObject) {
      return isString$1(oldBusinessObject.get("businessKey"));
    });
  }
  if (oldBindingType === "camunda:out") {
    return find$b(businessObject.get("values"), function(oldBusinessObject) {
      return oldBusinessObject.get("source") === oldBinding.source || oldBusinessObject.get("sourceExpression") || oldBinding.sourceExpression;
    });
  }
  if (oldBindingType === "camunda:inputParameter" || oldBindingType === "camunda:outputParameter") {
    if (is$I(businessObject, "camunda:Connector")) {
      businessObject = businessObject.get("camunda:inputOutput");
      if (!businessObject) {
        return;
      }
    } else {
      businessObject = findExtension$3(businessObject, "camunda:InputOutput");
      if (!businessObject) {
        return;
      }
    }
    if (oldBindingType === "camunda:inputParameter") {
      return find$b(businessObject.get("camunda:inputParameters"), function(oldBusinessObject) {
        return oldBusinessObject.get("camunda:name") === oldBinding.name;
      });
    } else {
      return find$b(businessObject.get("camunda:outputParameters"), function(oldBusinessObject) {
        var definition;
        if (oldBinding.scriptFormat) {
          definition = oldBusinessObject.get("camunda:definition");
          return definition && definition.get("camunda:value") === oldBinding.source;
        } else {
          return oldBusinessObject.get("camunda:value") === oldBinding.source;
        }
      });
    }
  }
  if (oldBindingType === "camunda:property") {
    if (!businessObject || !businessObject.get("values") || !businessObject.get("values").length) {
      return;
    }
    businessObject = findExtension$3(businessObject, "camunda:Properties");
    if (!businessObject) {
      return;
    }
    return find$b(businessObject.get("values"), function(oldBusinessObject) {
      return oldBusinessObject.get("camunda:name") === oldBinding.name;
    });
  }
  if (oldBindingType === "camunda:errorEventDefinition") {
    return findCamundaErrorEventDefinition$2(element, oldBinding.errorRef);
  }
}
function findOldProperty(oldTemplate, newProperty) {
  if (!oldTemplate) {
    return;
  }
  var oldProperties = oldTemplate.properties, newBinding = newProperty.binding, newBindingName = newBinding.name, newBindingType = newBinding.type;
  if (newBindingType === "property") {
    return find$b(oldProperties, function(oldProperty) {
      var oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      return oldBindingType === "property" && oldBindingName === newBindingName;
    });
  }
  if (newBindingType === "camunda:field") {
    return find$b(oldProperties, function(oldProperty) {
      var oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:field" && oldBindingName === newBindingName;
    });
  }
  if (newBindingType === "camunda:in") {
    return find$b(oldProperties, function(oldProperty) {
      var oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== "camunda:in") {
        return;
      }
      if (oldBinding.expression && !newBinding.expression || !oldBinding.expression && newBinding.expression) {
        return;
      }
      return oldBinding.target === newBinding.target;
    });
  }
  if (newBindingType === "camunda:in:businessKey") {
    return find$b(oldProperties, function(oldProperty) {
      var oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:in:businessKey";
    });
  }
  if (newBindingType === "camunda:out") {
    return find$b(oldProperties, function(oldProperty) {
      var oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:out" && (oldBinding.source === newBinding.source || oldBinding.sourceExpression === newBinding.sourceExpression);
    });
  }
  if (newBindingType === "camunda:inputParameter") {
    return find$b(oldProperties, function(oldProperty) {
      var oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      if (oldBindingType !== "camunda:inputParameter") {
        return;
      }
      return oldBindingName === newBindingName && oldBinding.scriptFormat === newBinding.scriptFormat;
    });
  }
  if (newBindingType === "camunda:outputParameter") {
    return find$b(oldProperties, function(oldProperty) {
      var oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== "camunda:outputParameter") {
        return;
      }
      return oldBinding.source === newBinding.source && oldBinding.scriptFormat === newBinding.scriptFormat;
    });
  }
  if (newBindingType === "camunda:property") {
    return find$b(oldProperties, function(oldProperty) {
      var oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:property" && oldBindingName === newBindingName;
    });
  }
  if (newBindingType === "camunda:errorEventDefinition") {
    return find$b(oldProperties, function(oldProperty) {
      var newBindingRef = newBinding.errorRef, oldBinding = oldProperty.binding, oldBindingRef = oldBinding.errorRef, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:errorEventDefinition" && oldBindingRef === newBindingRef;
    });
  }
}
function findOldScopeElement(element, scopeTemplate, template2) {
  var scopeName = scopeTemplate.type, id2 = scopeTemplate.id;
  if (scopeName === "camunda:Connector") {
    return findExtension$3(element, "camunda:Connector");
  }
  if (scopeName === "bpmn:Error") {
    var errorEventDefinitionBinding = findErrorEventDefinitionBinding(template2, id2);
    if (!errorEventDefinitionBinding) {
      return;
    }
    var errorEventDefinition = findOldBusinessObject(element, errorEventDefinitionBinding);
    if (!errorEventDefinition) {
      return;
    }
    return errorEventDefinition.errorRef;
  }
}
function isRootElementScope(scopeName) {
  return ["bpmn:Error"].includes(scopeName);
}
function findOldScopeTemplate(scopeTemplate, oldTemplate) {
  var scopeName = scopeTemplate.type, scopeId = scopeTemplate.id, scopes = oldTemplate && handleLegacyScopes$2(oldTemplate.scopes);
  return scopes && find$b(scopes, function(scope) {
    if (isRootElementScope(scopeName)) {
      return scope.id === scopeId;
    }
    return scope.type === scopeName;
  });
}
function findErrorEventDefinitionBinding(template2, templateErrorId) {
  return find$b(template2.properties, function(property2) {
    return property2.binding.errorRef === templateErrorId;
  });
}
function propertyChanged(element, oldProperty) {
  var businessObject = getBusinessObject$R(element);
  var oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type, oldPropertyValue = oldProperty.value, conditionExpression, definition;
  if (oldBindingType === "property") {
    if (oldBindingName === "conditionExpression") {
      conditionExpression = businessObject.get("bpmn:conditionExpression");
      return conditionExpression.get("bpmn:body") !== oldPropertyValue;
    }
    return businessObject.get(oldBindingName) !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:field") {
    return businessObject.get("camunda:string") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:in") {
    if (oldBinding.expression) {
      return businessObject.get("sourceExpression") !== oldPropertyValue;
    } else {
      return businessObject.get("camunda:source") !== oldPropertyValue;
    }
  }
  if (oldBindingType === "camunda:in:businessKey") {
    return businessObject.get("camunda:businessKey") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:out") {
    return businessObject.get("camunda:target") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:inputParameter") {
    if (oldBinding.scriptFormat) {
      definition = businessObject.get("camunda:definition");
      return definition && definition.get("camunda:value") !== oldPropertyValue;
    } else {
      return businessObject.get("camunda:value") !== oldPropertyValue;
    }
  }
  if (oldBindingType === "camunda:outputParameter") {
    return businessObject.get("camunda:name") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:property") {
    return businessObject.get("camunda:value") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:errorEventDefinition") {
    return businessObject.get("expression") !== oldPropertyValue;
  }
}
var ChangeElementTemplateHandler = ChangeElementTemplateHandler_1;
function registerHandlers(commandStack, elementTemplates2, eventBus) {
  commandStack.registerHandler("propertiesPanel.camunda.changeTemplate", ChangeElementTemplateHandler);
  eventBus.on(["commandStack.shape.create.postExecuted"], function(context) {
    applyDefaultTemplate(context.context.shape, elementTemplates2, commandStack);
  });
  eventBus.on(["commandStack.connection.create.postExecuted"], function(context) {
    applyDefaultTemplate(context.context.connection, elementTemplates2, commandStack);
  });
}
registerHandlers.$inject = ["commandStack", "elementTemplates", "eventBus"];
var cmd = {
  __init__: [registerHandlers]
};
function applyDefaultTemplate(element, elementTemplates2, commandStack) {
  if (!elementTemplates2.get(element) && elementTemplates2.getDefault(element)) {
    var command = "propertiesPanel.camunda.changeTemplate";
    var commandContext = {
      element,
      newTemplate: elementTemplates2.getDefault(element)
    };
    commandStack.execute(command, commandContext);
  }
}
var baseGetTag = _baseGetTag, isObjectLike$1 = isObjectLike_1;
var boolTag = "[object Boolean]";
function isBoolean$1(value) {
  return value === true || value === false || isObjectLike$1(value) && baseGetTag(value) == boolTag;
}
var isBoolean_1 = isBoolean$1;
var DEFAULT_PRIORITY$1 = 1e3;
function PropertiesActivator$2(eventBus, priority) {
  var self2 = this;
  priority = priority || DEFAULT_PRIORITY$1;
  eventBus.on("propertiesPanel.isEntryVisible", priority, function(context) {
    var element = context.element, entry = context.entry, group = context.group, tab = context.tab;
    return self2.isEntryVisible(element, entry, group, tab);
  });
  eventBus.on("propertiesPanel.isPropertyEditable", priority, function(context) {
    var element = context.element, entry = context.entry, group = context.group, propertyName = context.propertyName, tab = context.tab;
    return self2.isPropertyEditable(propertyName, element, entry, group, tab);
  });
}
PropertiesActivator$2.$inject = ["eventBus"];
var PropertiesActivator_1 = PropertiesActivator$2;
PropertiesActivator$2.prototype.isEntryVisible = function(element, entry, group, tab) {
  return true;
};
PropertiesActivator$2.prototype.isPropertyEditable = function(propertyName, element, entry, group, tab) {
  return true;
};
var inherits$4 = inherits_browser.exports;
var getTemplateId$4 = Helper$1.getTemplateId;
var isBoolean = isBoolean_1;
var find$a = require$$1$1.find, isNumber = require$$1$1.isNumber;
var handleLegacyScopes$1 = handleLegacyScopes$3;
var PropertiesActivator$1 = PropertiesActivator_1;
var HIGHER_PRIORITY = 1100;
function CustomElementsPropertiesActivator(eventBus, elementTemplates2) {
  PropertiesActivator$1.call(this, eventBus, HIGHER_PRIORITY);
  this.isEntryVisible = function(element, entry, group, tab) {
    var template2 = elementTemplates2.get(element), templateId = getTemplateId$4(element);
    if (templateId && !isEntryVisible(entry, tab, template2)) {
      return false;
    }
  };
  this.isPropertyEditable = function(propertyName, element, entry, group, tab) {
    var template2 = elementTemplates2.get(element);
    if (template2 && !isEntryEditable(entry, template2)) {
      return false;
    }
  };
}
CustomElementsPropertiesActivator.$inject = ["eventBus", "elementTemplates"];
inherits$4(CustomElementsPropertiesActivator, PropertiesActivator$1);
var CustomElementsPropertiesActivator_1 = CustomElementsPropertiesActivator;
var CUSTOM_PROPERTIES_PATTERN = /^custom-/;
var DEFAULT_ENTRIES_VISIBLE = {
  _all: false
};
function isCustomEntry(entry) {
  return CUSTOM_PROPERTIES_PATTERN.test(entry.id);
}
function isEntryVisible(entry, tab, template2) {
  var entryId = entry.id;
  if (tab.id === "element-template") {
    return true;
  }
  var entriesVisible = template2 && template2.entriesVisible || DEFAULT_ENTRIES_VISIBLE;
  if (isBoolean(entriesVisible)) {
    return entriesVisible;
  }
  var defaultVisible = entriesVisible._all || false, entryVisible = entriesVisible[entryId];
  if (defaultVisible) {
    return entryVisible !== false;
  } else {
    return entryVisible === true;
  }
}
function isEntryEditable(entry, template2) {
  var property2;
  if (isCustomEntry(entry)) {
    property2 = getProperty$1(template2, entry);
    return property2 && property2.editable !== false;
  }
  return true;
}
function getProperty$1(template2, entry) {
  var idxAsNumber, scope, scopeName;
  var throwError = function() {
    throw new Error("cannot extract property index for entry <" + entry.id + ">");
  };
  var idxOrScope = entry.id.replace("custom-" + template2.id + "-", "");
  if (!idxOrScope.includes("-")) {
    idxAsNumber = parseInt(idxOrScope, 10);
    if (!isNumber(idxAsNumber)) {
      throwError();
    }
    return template2.properties[idxAsNumber];
  }
  var entryParts = idxOrScope.split("-");
  if (entryParts.length == 2) {
    scopeName = entryParts[0].replace(/_/g, ":");
    idxAsNumber = parseInt(entryParts[1], 10);
    if (scopeName && isNumber(idxAsNumber)) {
      scope = findScopeForName(handleLegacyScopes$1(template2.scopes), scopeName);
      return scope.properties[idxAsNumber];
    }
  }
  throwError();
}
function findScopeForName(scopes, scopeName) {
  return find$a(scopes, function(scope) {
    return scope.type === scopeName;
  });
}
var baseFlatten = _baseFlatten;
function flatten$9(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$9;
function isUndefined$5(value) {
  return value === void 0;
}
var isUndefined_1 = isUndefined$5;
var arrayMap = _arrayMap;
function baseValues$1(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}
var _baseValues = baseValues$1;
var baseValues = _baseValues, keys$2 = keys_1;
function values$1(object) {
  return object == null ? [] : baseValues(object, keys$2(object));
}
var values_1 = values$1;
var flatten$8 = flatten_1, find$9 = find_1, isString = isString_1, isUndefined$4 = isUndefined_1, values = values_1;
var getTemplateId$3 = Helper$1.getTemplateId, getTemplateVersion = Helper$1.getTemplateVersion;
var isAny$8 = require$$1$2.isAny;
function ElementTemplates() {
  this._templates = {};
}
ElementTemplates.prototype.get = function(id2, version2) {
  var templates = this._templates, element;
  if (isUndefined$4(id2)) {
    return null;
  } else if (isString(id2)) {
    if (isUndefined$4(version2)) {
      version2 = "_";
    }
    if (templates[id2] && templates[id2][version2]) {
      return templates[id2][version2];
    } else {
      return null;
    }
  } else {
    element = id2;
    return this.get(getTemplateId$3(element), getTemplateVersion(element));
  }
};
ElementTemplates.prototype.getDefault = function(element) {
  return find$9(this.getAll(), function(template2) {
    return isAny$8(element, template2.appliesTo) && template2.isDefault;
  }) || null;
};
ElementTemplates.prototype.getAll = function(id2) {
  if (!isUndefined$4(id2) && this._templates[id2]) {
    return values(this._templates[id2]);
  }
  return flatten$8(values(this._templates).map(values));
};
ElementTemplates.prototype.set = function(templates) {
  var self2 = this;
  this._templates = {};
  templates.forEach(function(template2) {
    var id2 = template2.id, version2 = isUndefined$4(template2.version) ? "_" : template2.version;
    if (!self2._templates[id2]) {
      self2._templates[id2] = {};
    }
    self2._templates[id2][version2] = template2;
  });
};
var ElementTemplates_1 = ElementTemplates;
var semver$1 = { exports: {} };
(function(module, exports) {
  exports = module.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re2 = exports.re = [];
  var src = exports.src = [];
  var t = exports.tokens = {};
  var R = 0;
  function tok(n) {
    t[n] = R++;
  }
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  tok("COERCERTL");
  re2[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re2[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re2[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re2[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug(i, src[i]);
    if (!re2[i]) {
      re2[i] = new RegExp(src[i]);
    }
  }
  exports.parse = parse2;
  function parse2(version2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 !== "string") {
      return null;
    }
    if (version2.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re2[t.LOOSE] : re2[t.FULL];
    if (!r.test(version2)) {
      return null;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      return null;
    }
  }
  exports.valid = valid;
  function valid(version2, options) {
    var v = parse2(version2, options);
    return v ? v.version : null;
  }
  exports.clean = clean;
  function clean(version2, options) {
    var s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports.SemVer = SemVer;
  function SemVer(version2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version2 instanceof SemVer) {
      if (version2.loose === options.loose) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError("Invalid Version: " + version2);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version2, options);
    }
    debug("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version2.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version2);
    }
    this.raw = version2;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id2) {
        if (/^[0-9]+$/.test(id2)) {
          var num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER2) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i2 = 0;
    do {
      var a = this.build[i2];
      var b = other.build[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports.inc = inc;
  function inc(version2, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version2, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports.diff = diff2;
  function diff2(version1, version2) {
    if (eq2(version1, version2)) {
      return null;
    } else {
      var v1 = parse2(version1);
      var v2 = parse2(version2);
      var prefix2 = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix2 = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix2 + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports.compareBuild = compareBuild;
  function compareBuild(a, b, loose) {
    var versionA = new SemVer(a, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }
  exports.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports.compareBuild(a, b, loose);
    });
  }
  exports.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports.compareBuild(b, a, loose);
    });
  }
  exports.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports.eq = eq2;
  function eq2(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq2(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1] !== void 0 ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version2) {
    debug("Comparator.test", version2, this.options.loose);
    if (this.semver === ANY || version2 === ANY) {
      return true;
    }
    if (typeof version2 === "string") {
      try {
        version2 = new SemVer(version2, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version2, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports.Range = Range;
  function Range(range2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range2 instanceof Range) {
      if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
        return range2;
      } else {
        return new Range(range2.raw, options);
      }
    }
    if (range2 instanceof Comparator) {
      return new Range(range2.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range2, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range2;
    this.set = range2.split(/\s*\|\|\s*/).map(function(range3) {
      return this.parseRange(range3.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range2);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range2) {
    var loose = this.options.loose;
    range2 = range2.trim();
    var hr = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
    range2 = range2.replace(hr, hyphenReplace);
    debug("hyphen replace", range2);
    range2 = range2.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range2, re2[t.COMPARATORTRIM]);
    range2 = range2.replace(re2[t.TILDETRIM], tildeTrimReplace);
    range2 = range2.replace(re2[t.CARETTRIM], caretTrimReplace);
    range2 = range2.split(/\s+/).join(" ");
    var compRe = loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
    var set2 = range2.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set2 = set2.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set2 = set2.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set2;
  };
  Range.prototype.intersects = function(range2, options) {
    if (!(range2 instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range2.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  }
  exports.toComparators = toComparators;
  function toComparators(range2, options) {
    return new Range(range2, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  }
  function isX(id2) {
    return !id2 || id2.toLowerCase() === "x" || id2 === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re2[t.STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version2) {
    if (!version2) {
      return false;
    }
    if (typeof version2 === "string") {
      try {
        version2 = new SemVer(version2, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version2, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set2, version2, options) {
    for (var i2 = 0; i2 < set2.length; i2++) {
      if (!set2[i2].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set2.length; i2++) {
        debug(set2[i2].semver);
        if (set2[i2].semver === ANY) {
          continue;
        }
        if (set2[i2].semver.prerelease.length > 0) {
          var allowed = set2[i2].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports.satisfies = satisfies;
  function satisfies(version2, range2, options) {
    try {
      range2 = new Range(range2, options);
    } catch (er) {
      return false;
    }
    return range2.test(version2);
  }
  exports.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range2, options) {
    var max2 = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max2 || maxSV.compare(v) === -1) {
          max2 = v;
          maxSV = new SemVer(max2, options);
        }
      }
    });
    return max2;
  }
  exports.minSatisfying = minSatisfying;
  function minSatisfying(versions, range2, options) {
    var min2 = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min2 || minSV.compare(v) === 1) {
          min2 = v;
          minSV = new SemVer(min2, options);
        }
      }
    });
    return min2;
  }
  exports.minVersion = minVersion;
  function minVersion(range2, loose) {
    range2 = new Range(range2, loose);
    var minver = new SemVer("0.0.0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range2.set.length; ++i2) {
      var comparators = range2.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range2.test(minver)) {
      return minver;
    }
    return null;
  }
  exports.validRange = validRange;
  function validRange(range2, options) {
    try {
      return new Range(range2, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports.ltr = ltr;
  function ltr(version2, range2, options) {
    return outside(version2, range2, "<", options);
  }
  exports.gtr = gtr;
  function gtr(version2, range2, options) {
    return outside(version2, range2, ">", options);
  }
  exports.outside = outside;
  function outside(version2, range2, hilo, options) {
    version2 = new SemVer(version2, options);
    range2 = new Range(range2, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range2, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range2.set.length; ++i2) {
      var comparators = range2.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports.prerelease = prerelease;
  function prerelease(version2, options) {
    var parsed = parse2(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports.coerce = coerce;
  function coerce(version2, options) {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    var match2 = null;
    if (!options.rtl) {
      match2 = version2.match(re2[t.COERCE]);
    } else {
      var next;
      while ((next = re2[t.COERCERTL].exec(version2)) && (!match2 || match2.index + match2[0].length !== version2.length)) {
        if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
          match2 = next;
        }
        re2[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re2[t.COERCERTL].lastIndex = -1;
    }
    if (match2 === null) {
      return null;
    }
    return parse2(match2[2] + "." + (match2[3] || "0") + "." + (match2[4] || "0"), options);
  }
})(semver$1, semver$1.exports);
var escapedChars = {
  "b": "\b",
  "f": "\f",
  "n": "\n",
  "r": "\r",
  "t": "	",
  '"': '"',
  "/": "/",
  "\\": "\\"
};
var A_CODE = "a".charCodeAt();
var parse = function(source, _, options) {
  var pointers = {};
  var line = 0;
  var column = 0;
  var pos = 0;
  var bigint = options && options.bigint && typeof BigInt != "undefined";
  return {
    data: _parse("", true),
    pointers
  };
  function _parse(ptr, topLevel) {
    whitespace();
    var data;
    map2(ptr, "value");
    var char = getChar();
    switch (char) {
      case "t":
        read("rue");
        data = true;
        break;
      case "f":
        read("alse");
        data = false;
        break;
      case "n":
        read("ull");
        data = null;
        break;
      case '"':
        data = parseString();
        break;
      case "[":
        data = parseArray(ptr);
        break;
      case "{":
        data = parseObject(ptr);
        break;
      default:
        backChar();
        if ("-0123456789".indexOf(char) >= 0)
          data = parseNumber();
        else
          unexpectedToken();
    }
    map2(ptr, "valueEnd");
    whitespace();
    if (topLevel && pos < source.length)
      unexpectedToken();
    return data;
  }
  function whitespace() {
    loop:
      while (pos < source.length) {
        switch (source[pos]) {
          case " ":
            column++;
            break;
          case "	":
            column += 4;
            break;
          case "\r":
            column = 0;
            break;
          case "\n":
            column = 0;
            line++;
            break;
          default:
            break loop;
        }
        pos++;
      }
  }
  function parseString() {
    var str = "";
    var char;
    while (true) {
      char = getChar();
      if (char == '"') {
        break;
      } else if (char == "\\") {
        char = getChar();
        if (char in escapedChars)
          str += escapedChars[char];
        else if (char == "u")
          str += getCharCode();
        else
          wasUnexpectedToken();
      } else {
        str += char;
      }
    }
    return str;
  }
  function parseNumber() {
    var numStr = "";
    var integer = true;
    if (source[pos] == "-")
      numStr += getChar();
    numStr += source[pos] == "0" ? getChar() : getDigits();
    if (source[pos] == ".") {
      numStr += getChar() + getDigits();
      integer = false;
    }
    if (source[pos] == "e" || source[pos] == "E") {
      numStr += getChar();
      if (source[pos] == "+" || source[pos] == "-")
        numStr += getChar();
      numStr += getDigits();
      integer = false;
    }
    var result = +numStr;
    return bigint && integer && (result > Number.MAX_SAFE_INTEGER || result < Number.MIN_SAFE_INTEGER) ? BigInt(numStr) : result;
  }
  function parseArray(ptr) {
    whitespace();
    var arr = [];
    var i = 0;
    if (getChar() == "]")
      return arr;
    backChar();
    while (true) {
      var itemPtr = ptr + "/" + i;
      arr.push(_parse(itemPtr));
      whitespace();
      var char = getChar();
      if (char == "]")
        break;
      if (char != ",")
        wasUnexpectedToken();
      whitespace();
      i++;
    }
    return arr;
  }
  function parseObject(ptr) {
    whitespace();
    var obj = {};
    if (getChar() == "}")
      return obj;
    backChar();
    while (true) {
      var loc = getLoc();
      if (getChar() != '"')
        wasUnexpectedToken();
      var key = parseString();
      var propPtr = ptr + "/" + escapeJsonPointer(key);
      mapLoc(propPtr, "key", loc);
      map2(propPtr, "keyEnd");
      whitespace();
      if (getChar() != ":")
        wasUnexpectedToken();
      whitespace();
      obj[key] = _parse(propPtr);
      whitespace();
      var char = getChar();
      if (char == "}")
        break;
      if (char != ",")
        wasUnexpectedToken();
      whitespace();
    }
    return obj;
  }
  function read(str) {
    for (var i = 0; i < str.length; i++)
      if (getChar() !== str[i])
        wasUnexpectedToken();
  }
  function getChar() {
    checkUnexpectedEnd();
    var char = source[pos];
    pos++;
    column++;
    return char;
  }
  function backChar() {
    pos--;
    column--;
  }
  function getCharCode() {
    var count = 4;
    var code = 0;
    while (count--) {
      code <<= 4;
      var char = getChar().toLowerCase();
      if (char >= "a" && char <= "f")
        code += char.charCodeAt() - A_CODE + 10;
      else if (char >= "0" && char <= "9")
        code += +char;
      else
        wasUnexpectedToken();
    }
    return String.fromCharCode(code);
  }
  function getDigits() {
    var digits = "";
    while (source[pos] >= "0" && source[pos] <= "9")
      digits += getChar();
    if (digits.length)
      return digits;
    checkUnexpectedEnd();
    unexpectedToken();
  }
  function map2(ptr, prop) {
    mapLoc(ptr, prop, getLoc());
  }
  function mapLoc(ptr, prop, loc) {
    pointers[ptr] = pointers[ptr] || {};
    pointers[ptr][prop] = loc;
  }
  function getLoc() {
    return {
      line,
      column,
      pos
    };
  }
  function unexpectedToken() {
    throw new SyntaxError("Unexpected token " + source[pos] + " in JSON at position " + pos);
  }
  function wasUnexpectedToken() {
    backChar();
    unexpectedToken();
  }
  function checkUnexpectedEnd() {
    if (pos >= source.length)
      throw new SyntaxError("Unexpected end of JSON input");
  }
};
var stringify = function(data, _, options) {
  if (!validType(data))
    return;
  var wsLine = 0;
  var wsPos, wsColumn;
  var whitespace = typeof options == "object" ? options.space : options;
  switch (typeof whitespace) {
    case "number":
      var len = whitespace > 10 ? 10 : whitespace < 0 ? 0 : Math.floor(whitespace);
      whitespace = len && repeat(len, " ");
      wsPos = len;
      wsColumn = len;
      break;
    case "string":
      whitespace = whitespace.slice(0, 10);
      wsPos = 0;
      wsColumn = 0;
      for (var j = 0; j < whitespace.length; j++) {
        var char = whitespace[j];
        switch (char) {
          case " ":
            wsColumn++;
            break;
          case "	":
            wsColumn += 4;
            break;
          case "\r":
            wsColumn = 0;
            break;
          case "\n":
            wsColumn = 0;
            wsLine++;
            break;
          default:
            throw new Error("whitespace characters not allowed in JSON");
        }
        wsPos++;
      }
      break;
    default:
      whitespace = void 0;
  }
  var json = "";
  var pointers = {};
  var line = 0;
  var column = 0;
  var pos = 0;
  var es6 = options && options.es6 && typeof Map == "function";
  _stringify(data, 0, "");
  return {
    json,
    pointers
  };
  function _stringify(_data, lvl, ptr) {
    map2(ptr, "value");
    switch (typeof _data) {
      case "number":
      case "bigint":
      case "boolean":
        out("" + _data);
        break;
      case "string":
        out(quoted(_data));
        break;
      case "object":
        if (_data === null) {
          out("null");
        } else if (typeof _data.toJSON == "function") {
          out(quoted(_data.toJSON()));
        } else if (Array.isArray(_data)) {
          stringifyArray();
        } else if (es6) {
          if (_data.constructor.BYTES_PER_ELEMENT)
            stringifyArray();
          else if (_data instanceof Map)
            stringifyMapSet();
          else if (_data instanceof Set)
            stringifyMapSet(true);
          else
            stringifyObject();
        } else {
          stringifyObject();
        }
    }
    map2(ptr, "valueEnd");
    function stringifyArray() {
      if (_data.length) {
        out("[");
        var itemLvl = lvl + 1;
        for (var i = 0; i < _data.length; i++) {
          if (i)
            out(",");
          indent(itemLvl);
          var item = validType(_data[i]) ? _data[i] : null;
          var itemPtr = ptr + "/" + i;
          _stringify(item, itemLvl, itemPtr);
        }
        indent(lvl);
        out("]");
      } else {
        out("[]");
      }
    }
    function stringifyObject() {
      var keys2 = Object.keys(_data);
      if (keys2.length) {
        out("{");
        var propLvl = lvl + 1;
        for (var i = 0; i < keys2.length; i++) {
          var key = keys2[i];
          var value = _data[key];
          if (validType(value)) {
            if (i)
              out(",");
            var propPtr = ptr + "/" + escapeJsonPointer(key);
            indent(propLvl);
            map2(propPtr, "key");
            out(quoted(key));
            map2(propPtr, "keyEnd");
            out(":");
            if (whitespace)
              out(" ");
            _stringify(value, propLvl, propPtr);
          }
        }
        indent(lvl);
        out("}");
      } else {
        out("{}");
      }
    }
    function stringifyMapSet(isSet) {
      if (_data.size) {
        out("{");
        var propLvl = lvl + 1;
        var first = true;
        var entries = _data.entries();
        var entry = entries.next();
        while (!entry.done) {
          var item = entry.value;
          var key = item[0];
          var value = isSet ? true : item[1];
          if (validType(value)) {
            if (!first)
              out(",");
            first = false;
            var propPtr = ptr + "/" + escapeJsonPointer(key);
            indent(propLvl);
            map2(propPtr, "key");
            out(quoted(key));
            map2(propPtr, "keyEnd");
            out(":");
            if (whitespace)
              out(" ");
            _stringify(value, propLvl, propPtr);
          }
          entry = entries.next();
        }
        indent(lvl);
        out("}");
      } else {
        out("{}");
      }
    }
  }
  function out(str) {
    column += str.length;
    pos += str.length;
    json += str;
  }
  function indent(lvl) {
    if (whitespace) {
      json += "\n" + repeat(lvl, whitespace);
      line++;
      column = 0;
      while (lvl--) {
        if (wsLine) {
          line += wsLine;
          column = wsColumn;
        } else {
          column += wsColumn;
        }
        pos += wsPos;
      }
      pos += 1;
    }
  }
  function map2(ptr, prop) {
    pointers[ptr] = pointers[ptr] || {};
    pointers[ptr][prop] = {
      line,
      column,
      pos
    };
  }
  function repeat(n, str) {
    return Array(n + 1).join(str);
  }
};
var VALID_TYPES = ["number", "bigint", "boolean", "string", "object"];
function validType(data) {
  return VALID_TYPES.indexOf(typeof data) >= 0;
}
var ESC_QUOTE = /"|\\/g;
var ESC_B = /[\b]/g;
var ESC_F = /\f/g;
var ESC_N = /\n/g;
var ESC_R = /\r/g;
var ESC_T = /\t/g;
function quoted(str) {
  str = str.replace(ESC_QUOTE, "\\$&").replace(ESC_F, "\\f").replace(ESC_B, "\\b").replace(ESC_N, "\\n").replace(ESC_R, "\\r").replace(ESC_T, "\\t");
  return '"' + str + '"';
}
var ESC_0 = /~/g;
var ESC_1 = /\//g;
function escapeJsonPointer(str) {
  return str.replace(ESC_0, "~0").replace(ESC_1, "~1");
}
var jsonSourceMap = {
  parse,
  stringify
};
var version = "0.4.0";
var fastDeepEqual = function equal2(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length2, i, keys2;
    if (Array.isArray(a)) {
      length2 = a.length;
      if (length2 != b.length)
        return false;
      for (i = length2; i-- !== 0; )
        if (!equal2(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys2 = Object.keys(a);
    length2 = keys2.length;
    if (length2 !== Object.keys(b).length)
      return false;
    for (i = length2; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys2[i]))
        return false;
    for (i = length2; i-- !== 0; ) {
      var key = keys2[i];
      if (!equal2(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var equal = fastDeepEqual;
var standaloneValidator = validate14;
var _default = validate14;
const schema17 = { "type": "object", "required": ["name", "id", "appliesTo", "properties"], "properties": { "name": { "$id": "#/name", "type": "string", "title": "element template name", "description": "The name of the element template" }, "id": { "$id": "#/id", "type": "string", "title": "element template id", "description": "The identifier of the element template" }, "description": { "$id": "#/description", "type": "string", "title": "element template description", "description": "The description of the element template" }, "version": { "$id": "#/version", "type": "number", "title": "element template version", "description": "The version of the element template" }, "isDefault": { "$id": "#/isDefault", "type": "boolean", "title": "element template is default", "description": "Indicates whether the element template is a default template" }, "appliesTo": { "$id": "#/appliesTo", "type": "array", "title": "element template applies to", "description": "The definition for which element types the element template can be applied", "default": [], "items": { "$id": "#/appliesTo/items", "type": "string", "pattern": "^(.*?:)", "errorMessage": { "pattern": 'invalid item for "appliesTo", should contain namespaced property, example: "bpmn:Task"' } } }, "properties": { "$ref": "#/definitions/properties", "$id": "#/properties" }, "metadata": { "$id": "#/metadata", "type": "object", "title": "element template metadata", "description": "Some metadata for further configuration" }, "scopes": { "oneOf": [{ "$ref": "#/definitions/scopes_old" }, { "$ref": "#/definitions/scopes" }] }, "entriesVisible": { "$id": "#/entriesVisible", "deprecated": true, "type": ["object", "boolean"], "title": "element template entries visible", "description": "@Deprecated - Select which entries are visible in the properties panel" } }, "errorMessage": { "required": { "name": "missing template name", "id": "missing template id", "appliesTo": "missing appliesTo=[]", "properties": "missing properties=[]" } } };
const schema18 = { "type": "array", "title": "element template properties", "description": "The properties of the element template", "default": [], "items": { "$id": "#/properties/property", "type": "object", "title": "element template property", "description": "A property defined for the element template", "default": {}, "required": ["binding"], "errorMessage": { "required": { "binding": 'missing binding for property "${0#}"' } }, "allOf": [{ "if": { "properties": { "type": { "const": "Dropdown" } }, "required": ["type"] }, "then": { "required": ["choices"], "errorMessage": 'must provide choices=[] with "Dropdown" type' } }, { "if": { "properties": { "binding": { "properties": { "type": { "const": "property" } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown", "Boolean"], "errorMessage": 'invalid property type ${0} for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "const": "camunda:executionListener" } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["Hidden"], "errorMessage": 'invalid property type ${1/type} for binding type "camunda:executionListener"; must be "Hidden"' } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "enum": ["camunda:property", "camunda:outputParameter", "camunda:in", "camunda:in:businessKey", "camunda:out", "camunda:errorEventDefinition"] } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Hidden", "Dropdown"], "errorMessage": "invalid property type ${0} for binding type ${1/binding/type}; must be any of { String, Hidden, Dropdown }" } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "enum": ["camunda:inputParameter", "camunda:field"] } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown"], "errorMessage": "invalid property type ${0} for binding type ${1/binding/type}; must be any of { String, Text, Hidden, Dropdown }" } } } }], "properties": { "value": { "$id": "#/properties/property/value", "type": ["string", "boolean"], "title": "property value", "description": "The value of the control field for the property" }, "description": { "$id": "#/properties/property/description", "type": "string", "title": "property description", "description": "The description of the control field" }, "label": { "$id": "#/properties/property/label", "type": "string", "title": "property label", "description": "The label of the control field for the property" }, "type": { "$id": "#/properties/property/type", "type": "string", "title": "property type", "description": "The type of the control field" }, "editable": { "$id": "#/properties/property/editable", "type": "boolean", "title": "property editable", "description": "Indicates whether the property is editable or not" }, "choices": { "$id": "#/properties/property/choices", "type": "array", "title": "property choices", "description": "The choices for dropdown properties", "items": { "$id": "#/properties/property/choices/item", "type": "object", "properties": { "name": { "$id": "#/properties/property/choices/item/name", "type": "string", "title": "choice name", "description": "The name of the choice" }, "value": { "$id": "#/properties/property/choices/item/value", "type": "string", "title": "choice value", "description": "The value of the choice" } }, "required": ["value", "name"], "errorMessage": '{ name, value } must be specified for "Dropdown" choices' } }, "binding": { "$id": "#/properties/property/binding", "type": "object", "title": "property binding", "description": "A binding to a BPMN 2.0 property", "required": ["type"], "allOf": [{ "if": { "properties": { "type": { "enum": ["property", "camunda:property", "camunda:inputParameter", "camunda:field"] } }, "required": ["type"] }, "then": { "required": ["name"], "errorMessage": "property.binding ${0/type} requires name" } }, { "if": { "properties": { "type": { "const": "camunda:outputParameter" } }, "required": ["type"] }, "then": { "required": ["source"], "errorMessage": "property.binding ${0/type} requires source" } }, { "if": { "properties": { "type": { "const": "camunda:in" } }, "required": ["type"] }, "then": { "anyOf": [{ "required": ["variables"] }, { "required": ["target"] }], "errorMessage": "property.binding ${0/type} requires variables, target, or both" } }, { "if": { "properties": { "type": { "const": "camunda:out" } }, "required": ["type"] }, "then": { "oneOf": [{ "required": ["variables"], "not": { "anyOf": [{ "required": ["source"] }, { "required": ["sourceExpression"] }] } }, { "required": ["source"], "not": { "anyOf": [{ "required": ["variables"] }, { "required": ["sourceExpression"] }] } }, { "required": ["sourceExpression"], "not": { "anyOf": [{ "required": ["variables"] }, { "required": ["source"] }] } }, { "required": ["variables", "sourceExpression"], "not": { "required": ["source"] } }, { "required": ["variables", "source"], "not": { "required": ["sourceExpression"] } }], "errorMessage": "property.binding ${0/type} requires one of the following: variables, sourceExpression, source, (sourceExpression and variables), or (source and variables)" } }, { "if": { "properties": { "type": { "const": "camunda:errorEventDefinition" } }, "required": ["type"] }, "then": { "oneOf": [{ "required": ["errorRef"] }], "errorMessage": "property.binding ${0/type} requires errorRef" } }], "properties": { "type": { "$id": "#/properties/property/binding/type", "type": "string", "title": "property binding type", "enum": ["property", "camunda:property", "camunda:inputParameter", "camunda:outputParameter", "camunda:in", "camunda:out", "camunda:in:businessKey", "camunda:executionListener", "camunda:field", "camunda:errorEventDefinition"], "errorMessage": "invalid property.binding type ${0}; must be any of { property, camunda:property, camunda:inputParameter, camunda:outputParameter, camunda:in, camunda:out, camunda:in:businessKey, camunda:executionListener, camunda:field, camunda:errorEventDefinition }", "description": "The type of the property binding" }, "name": { "$id": "#/properties/property/binding/name", "type": "string", "title": "property binding name", "description": "The name of binding xml property" }, "event": { "$id": "#/properties/property/binding/event", "type": "string", "title": "property binding event", "description": "The event type of an execution listener binding" }, "scriptFormat": { "$id": "#/properties/property/binding/scriptFormat", "type": "string", "title": "property binding script format", "description": "The format of a script property binding (camunda:outputParameter, camunda:inputParameter)" }, "source": { "$id": "#/properties/property/binding/source", "type": "string", "title": "property binding source", "description": "The source value of a property binding (camunda:outputParameter, camunda:out)" }, "target": { "$id": "#/properties/property/binding/target", "type": "string", "title": "property binding target", "description": "The target value to be mapped to (camunda:in)" }, "expression": { "$id": "#/properties/property/binding/expression", "type": "boolean", "title": "property binding expression", "description": "True indicates that the control field value is an expression (camunda:in, camunda:field)" }, "variables": { "$id": "#/properties/property/binding/variables", "type": "string", "title": "property binding variables", "enum": ["all", "local"], "description": "Either all or local indicating the variable mapping (camunda:in)" }, "sourceExpression": { "$id": "#/properties/property/binding/sourceExpression", "type": "string", "title": "property binding source expression", "description": "The string containing the expression for the source attribute (camunda:out)" } } }, "constraints": { "$id": "#/properties/property/constraints", "type": "object", "title": "property constraints", "description": "The validation constraints", "properties": { "notEmpty": { "$id": "#/properties/property/constraints/notEmpty", "type": "boolean", "title": "property constraints not empty", "description": "The control field must not be empty" }, "minLength": { "$id": "#/properties/property/constraints/minLength", "type": "number", "title": "property constraints min length", "description": "The minimal length for the control field value" }, "maxLength": { "$id": "#/properties/property/constraints/maxLength", "type": "number", "title": "property constraints max length", "description": "The maximal length for the control field value" }, "pattern": { "$id": "#/properties/property/constraints/pattern", "title": "property constraints pattern", "description": "A regular expression pattern for the constraints", "oneOf": [{ "type": "object", "properties": { "value": { "$id": "#/properties/property/constraints/pattern/value", "type": "string", "title": "property constraints pattern value", "description": "The regular expression of the pattern constraint" }, "message": { "$id": "#/properties/property/constraints/pattern/message", "type": "string", "title": "property constraints pattern message", "description": "The validation message of the pattern constraint" } } }, { "type": "string" }] } } } } } };
const pattern0 = new RegExp("^(.*?:)", "u");
const obj0 = { "required": "missingProperty", "dependencies": "property", "dependentRequired": "property" };
function validate16(data, { dataPath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors2 = 0;
  if (data && typeof data == "object" && !Array.isArray(data)) {
    for (const key0 in data) {
      if (!(key0 === "camunda:Connector")) {
        const err0 = { keyword: "not", dataPath: dataPath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/additionalProperties/not", params: {}, message: "should NOT be valid" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
        if (errors2 > 0) {
          const emErrs0 = [];
          for (const err1 of vErrors) {
            if (err1.keyword !== "errorMessage" && !err1.emUsed && (err1.dataPath === dataPath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1") || err1.dataPath.indexOf(dataPath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1")) === 0 && err1.dataPath[dataPath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1").length] === "/") && err1.schemaPath.indexOf("#/additionalProperties") === 0 && err1.schemaPath["#/additionalProperties".length] === "/") {
              emErrs0.push(err1);
              err1.emUsed = true;
            }
          }
          if (emErrs0.length) {
            const err2 = { keyword: "errorMessage", dataPath: dataPath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/additionalProperties/errorMessage", params: { errors: emErrs0 }, message: "invalid scope " + JSON.stringify(key0) + ', object descriptor is only supported for "camunda:Connector"' };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
          const emErrs1 = [];
          for (const err3 of vErrors) {
            if (!err3.emUsed) {
              emErrs1.push(err3);
            }
          }
          vErrors = emErrs1;
          errors2 = emErrs1.length;
        }
      }
    }
    if (data["camunda:Connector"] !== void 0) {
      let data1 = data["camunda:Connector"];
      if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
        if (data1.properties !== void 0) {
          let data2 = data1.properties;
          if (Array.isArray(data2)) {
            const len0 = data2.length;
            for (let i0 = 0; i0 < len0; i0++) {
              let data3 = data2[i0];
              const _errs12 = errors2;
              let valid7 = true;
              const _errs13 = errors2;
              if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                if (data3.type === void 0 && "type") {
                  const err4 = {};
                  if (vErrors === null) {
                    vErrors = [err4];
                  } else {
                    vErrors.push(err4);
                  }
                  errors2++;
                } else {
                  if (data3.type !== void 0) {
                    if (!equal(data3.type, "Dropdown")) {
                      const err5 = {};
                      if (vErrors === null) {
                        vErrors = [err5];
                      } else {
                        vErrors.push(err5);
                      }
                      errors2++;
                    }
                  }
                }
              }
              var _valid0 = _errs13 === errors2;
              errors2 = _errs12;
              if (vErrors !== null) {
                if (_errs12) {
                  vErrors.length = _errs12;
                } else {
                  vErrors = null;
                }
              }
              if (_valid0) {
                const _errs15 = errors2;
                if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                  if (data3.choices === void 0) {
                    const err6 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0, schemaPath: "#/definitions/properties/items/allOf/0/then/required", params: { missingProperty: "choices" }, message: "should have required property 'choices'" };
                    if (vErrors === null) {
                      vErrors = [err6];
                    } else {
                      vErrors.push(err6);
                    }
                    errors2++;
                  }
                }
                if (errors2 > 0) {
                  const emErrs2 = [];
                  for (const err7 of vErrors) {
                    if (err7.keyword !== "errorMessage" && !err7.emUsed && (err7.dataPath === dataPath + "/camunda:Connector/properties/" + i0 || err7.dataPath.indexOf(dataPath + "/camunda:Connector/properties/" + i0) === 0 && err7.dataPath[dataPath + "/camunda:Connector/properties/" + i0.length] === "/") && err7.schemaPath.indexOf("#/definitions/properties/items/allOf/0/then") === 0 && err7.schemaPath["#/definitions/properties/items/allOf/0/then".length] === "/") {
                      emErrs2.push(err7);
                      err7.emUsed = true;
                    }
                  }
                  if (emErrs2.length) {
                    const err8 = { keyword: "errorMessage", dataPath: dataPath + "/camunda:Connector/properties/" + i0, schemaPath: "#/definitions/properties/items/allOf/0/then/errorMessage", params: { errors: emErrs2 }, message: 'must provide choices=[] with "Dropdown" type' };
                    if (vErrors === null) {
                      vErrors = [err8];
                    } else {
                      vErrors.push(err8);
                    }
                    errors2++;
                  }
                  const emErrs3 = [];
                  for (const err9 of vErrors) {
                    if (!err9.emUsed) {
                      emErrs3.push(err9);
                    }
                  }
                  vErrors = emErrs3;
                  errors2 = emErrs3.length;
                }
                var _valid0 = _errs15 === errors2;
                valid7 = _valid0;
              }
              if (!valid7) {
                const err10 = { keyword: "if", dataPath: dataPath + "/camunda:Connector/properties/" + i0, schemaPath: "#/definitions/properties/items/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err10];
                } else {
                  vErrors.push(err10);
                }
                errors2++;
              }
              const _errs17 = errors2;
              let valid9 = true;
              const _errs18 = errors2;
              if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                if (data3.binding === void 0 && "binding") {
                  const err11 = {};
                  if (vErrors === null) {
                    vErrors = [err11];
                  } else {
                    vErrors.push(err11);
                  }
                  errors2++;
                } else {
                  if (data3.binding !== void 0) {
                    let data5 = data3.binding;
                    if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
                      if (data5.type === void 0 && "type") {
                        const err12 = {};
                        if (vErrors === null) {
                          vErrors = [err12];
                        } else {
                          vErrors.push(err12);
                        }
                        errors2++;
                      } else {
                        if (data5.type !== void 0) {
                          if (!equal(data5.type, "property")) {
                            const err13 = {};
                            if (vErrors === null) {
                              vErrors = [err13];
                            } else {
                              vErrors.push(err13);
                            }
                            errors2++;
                          }
                        }
                      }
                    }
                  }
                }
              }
              var _valid1 = _errs18 === errors2;
              errors2 = _errs17;
              if (vErrors !== null) {
                if (_errs17) {
                  vErrors.length = _errs17;
                } else {
                  vErrors = null;
                }
              }
              if (_valid1) {
                const _errs21 = errors2;
                if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                  if (data3.type !== void 0) {
                    let data7 = data3.type;
                    if (!(data7 === "String" || data7 === "Text" || data7 === "Hidden" || data7 === "Dropdown" || data7 === "Boolean")) {
                      const err14 = { keyword: "enum", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/type", schemaPath: "#/definitions/properties/items/allOf/1/then/properties/type/enum", params: { allowedValues: schema18.items.allOf[1].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                      if (vErrors === null) {
                        vErrors = [err14];
                      } else {
                        vErrors.push(err14);
                      }
                      errors2++;
                    }
                    if (errors2 > 0) {
                      const emErrs4 = [];
                      for (const err15 of vErrors) {
                        if (err15.keyword !== "errorMessage" && !err15.emUsed && (err15.dataPath === dataPath + "/camunda:Connector/properties/" + i0 + "/type" || err15.dataPath.indexOf(dataPath + "/camunda:Connector/properties/" + i0 + "/type") === 0 && err15.dataPath[dataPath + "/camunda:Connector/properties/" + i0 + "/type".length] === "/") && err15.schemaPath.indexOf("#/definitions/properties/items/allOf/1/then/properties/type") === 0 && err15.schemaPath["#/definitions/properties/items/allOf/1/then/properties/type".length] === "/") {
                          emErrs4.push(err15);
                          err15.emUsed = true;
                        }
                      }
                      if (emErrs4.length) {
                        const err16 = { keyword: "errorMessage", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/type", schemaPath: "#/definitions/properties/items/allOf/1/then/properties/type/errorMessage", params: { errors: emErrs4 }, message: "invalid property type " + JSON.stringify(data7) + ' for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' };
                        if (vErrors === null) {
                          vErrors = [err16];
                        } else {
                          vErrors.push(err16);
                        }
                        errors2++;
                      }
                      const emErrs5 = [];
                      for (const err17 of vErrors) {
                        if (!err17.emUsed) {
                          emErrs5.push(err17);
                        }
                      }
                      vErrors = emErrs5;
                      errors2 = emErrs5.length;
                    }
                  }
                }
                var _valid1 = _errs21 === errors2;
                valid9 = _valid1;
              }
              if (!valid9) {
                const err18 = { keyword: "if", dataPath: dataPath + "/camunda:Connector/properties/" + i0, schemaPath: "#/definitions/properties/items/allOf/1/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err18];
                } else {
                  vErrors.push(err18);
                }
                errors2++;
              }
              const _errs24 = errors2;
              let valid13 = true;
              const _errs25 = errors2;
              if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                if (data3.binding === void 0 && "binding") {
                  const err19 = {};
                  if (vErrors === null) {
                    vErrors = [err19];
                  } else {
                    vErrors.push(err19);
                  }
                  errors2++;
                } else {
                  if (data3.binding !== void 0) {
                    let data8 = data3.binding;
                    if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
                      if (data8.type === void 0 && "type") {
                        const err20 = {};
                        if (vErrors === null) {
                          vErrors = [err20];
                        } else {
                          vErrors.push(err20);
                        }
                        errors2++;
                      } else {
                        if (data8.type !== void 0) {
                          if (!equal(data8.type, "camunda:executionListener")) {
                            const err21 = {};
                            if (vErrors === null) {
                              vErrors = [err21];
                            } else {
                              vErrors.push(err21);
                            }
                            errors2++;
                          }
                        }
                      }
                    }
                  }
                }
              }
              var _valid2 = _errs25 === errors2;
              errors2 = _errs24;
              if (vErrors !== null) {
                if (_errs24) {
                  vErrors.length = _errs24;
                } else {
                  vErrors = null;
                }
              }
              if (_valid2) {
                const _errs28 = errors2;
                if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                  if (data3.type !== void 0) {
                    if (!(data3.type === "Hidden")) {
                      const err22 = { keyword: "enum", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/type", schemaPath: "#/definitions/properties/items/allOf/2/then/properties/type/enum", params: { allowedValues: schema18.items.allOf[2].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                      if (vErrors === null) {
                        vErrors = [err22];
                      } else {
                        vErrors.push(err22);
                      }
                      errors2++;
                    }
                    if (errors2 > 0) {
                      const emErrs6 = [];
                      for (const err23 of vErrors) {
                        if (err23.keyword !== "errorMessage" && !err23.emUsed && (err23.dataPath === dataPath + "/camunda:Connector/properties/" + i0 + "/type" || err23.dataPath.indexOf(dataPath + "/camunda:Connector/properties/" + i0 + "/type") === 0 && err23.dataPath[dataPath + "/camunda:Connector/properties/" + i0 + "/type".length] === "/") && err23.schemaPath.indexOf("#/definitions/properties/items/allOf/2/then/properties/type") === 0 && err23.schemaPath["#/definitions/properties/items/allOf/2/then/properties/type".length] === "/") {
                          emErrs6.push(err23);
                          err23.emUsed = true;
                        }
                      }
                      if (emErrs6.length) {
                        const err24 = { keyword: "errorMessage", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/type", schemaPath: "#/definitions/properties/items/allOf/2/then/properties/type/errorMessage", params: { errors: emErrs6 }, message: "invalid property type " + JSON.stringify(data3 && data3.type) + ' for binding type "camunda:executionListener"; must be "Hidden"' };
                        if (vErrors === null) {
                          vErrors = [err24];
                        } else {
                          vErrors.push(err24);
                        }
                        errors2++;
                      }
                      const emErrs7 = [];
                      for (const err25 of vErrors) {
                        if (!err25.emUsed) {
                          emErrs7.push(err25);
                        }
                      }
                      vErrors = emErrs7;
                      errors2 = emErrs7.length;
                    }
                  }
                }
                var _valid2 = _errs28 === errors2;
                valid13 = _valid2;
              }
              if (!valid13) {
                const err26 = { keyword: "if", dataPath: dataPath + "/camunda:Connector/properties/" + i0, schemaPath: "#/definitions/properties/items/allOf/2/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err26];
                } else {
                  vErrors.push(err26);
                }
                errors2++;
              }
              const _errs31 = errors2;
              let valid17 = true;
              const _errs32 = errors2;
              if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                if (data3.binding === void 0 && "binding") {
                  const err27 = {};
                  if (vErrors === null) {
                    vErrors = [err27];
                  } else {
                    vErrors.push(err27);
                  }
                  errors2++;
                } else {
                  if (data3.binding !== void 0) {
                    let data11 = data3.binding;
                    if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
                      if (data11.type === void 0 && "type") {
                        const err28 = {};
                        if (vErrors === null) {
                          vErrors = [err28];
                        } else {
                          vErrors.push(err28);
                        }
                        errors2++;
                      } else {
                        if (data11.type !== void 0) {
                          let data12 = data11.type;
                          if (!(data12 === "camunda:property" || data12 === "camunda:outputParameter" || data12 === "camunda:in" || data12 === "camunda:in:businessKey" || data12 === "camunda:out" || data12 === "camunda:errorEventDefinition")) {
                            const err29 = {};
                            if (vErrors === null) {
                              vErrors = [err29];
                            } else {
                              vErrors.push(err29);
                            }
                            errors2++;
                          }
                        }
                      }
                    }
                  }
                }
              }
              var _valid3 = _errs32 === errors2;
              errors2 = _errs31;
              if (vErrors !== null) {
                if (_errs31) {
                  vErrors.length = _errs31;
                } else {
                  vErrors = null;
                }
              }
              if (_valid3) {
                const _errs35 = errors2;
                if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                  if (data3.type !== void 0) {
                    let data13 = data3.type;
                    if (!(data13 === "String" || data13 === "Hidden" || data13 === "Dropdown")) {
                      const err30 = { keyword: "enum", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/type", schemaPath: "#/definitions/properties/items/allOf/3/then/properties/type/enum", params: { allowedValues: schema18.items.allOf[3].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                      if (vErrors === null) {
                        vErrors = [err30];
                      } else {
                        vErrors.push(err30);
                      }
                      errors2++;
                    }
                    if (errors2 > 0) {
                      const emErrs8 = [];
                      for (const err31 of vErrors) {
                        if (err31.keyword !== "errorMessage" && !err31.emUsed && (err31.dataPath === dataPath + "/camunda:Connector/properties/" + i0 + "/type" || err31.dataPath.indexOf(dataPath + "/camunda:Connector/properties/" + i0 + "/type") === 0 && err31.dataPath[dataPath + "/camunda:Connector/properties/" + i0 + "/type".length] === "/") && err31.schemaPath.indexOf("#/definitions/properties/items/allOf/3/then/properties/type") === 0 && err31.schemaPath["#/definitions/properties/items/allOf/3/then/properties/type".length] === "/") {
                          emErrs8.push(err31);
                          err31.emUsed = true;
                        }
                      }
                      if (emErrs8.length) {
                        const err32 = { keyword: "errorMessage", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/type", schemaPath: "#/definitions/properties/items/allOf/3/then/properties/type/errorMessage", params: { errors: emErrs8 }, message: "invalid property type " + JSON.stringify(data13) + " for binding type " + JSON.stringify(data3 && data3.binding && data3.binding.type) + "; must be any of { String, Hidden, Dropdown }" };
                        if (vErrors === null) {
                          vErrors = [err32];
                        } else {
                          vErrors.push(err32);
                        }
                        errors2++;
                      }
                      const emErrs9 = [];
                      for (const err33 of vErrors) {
                        if (!err33.emUsed) {
                          emErrs9.push(err33);
                        }
                      }
                      vErrors = emErrs9;
                      errors2 = emErrs9.length;
                    }
                  }
                }
                var _valid3 = _errs35 === errors2;
                valid17 = _valid3;
              }
              if (!valid17) {
                const err34 = { keyword: "if", dataPath: dataPath + "/camunda:Connector/properties/" + i0, schemaPath: "#/definitions/properties/items/allOf/3/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err34];
                } else {
                  vErrors.push(err34);
                }
                errors2++;
              }
              const _errs38 = errors2;
              let valid21 = true;
              const _errs39 = errors2;
              if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                if (data3.binding === void 0 && "binding") {
                  const err35 = {};
                  if (vErrors === null) {
                    vErrors = [err35];
                  } else {
                    vErrors.push(err35);
                  }
                  errors2++;
                } else {
                  if (data3.binding !== void 0) {
                    let data14 = data3.binding;
                    if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
                      if (data14.type === void 0 && "type") {
                        const err36 = {};
                        if (vErrors === null) {
                          vErrors = [err36];
                        } else {
                          vErrors.push(err36);
                        }
                        errors2++;
                      } else {
                        if (data14.type !== void 0) {
                          let data15 = data14.type;
                          if (!(data15 === "camunda:inputParameter" || data15 === "camunda:field")) {
                            const err37 = {};
                            if (vErrors === null) {
                              vErrors = [err37];
                            } else {
                              vErrors.push(err37);
                            }
                            errors2++;
                          }
                        }
                      }
                    }
                  }
                }
              }
              var _valid4 = _errs39 === errors2;
              errors2 = _errs38;
              if (vErrors !== null) {
                if (_errs38) {
                  vErrors.length = _errs38;
                } else {
                  vErrors = null;
                }
              }
              if (_valid4) {
                const _errs42 = errors2;
                if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                  if (data3.type !== void 0) {
                    let data16 = data3.type;
                    if (!(data16 === "String" || data16 === "Text" || data16 === "Hidden" || data16 === "Dropdown")) {
                      const err38 = { keyword: "enum", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/type", schemaPath: "#/definitions/properties/items/allOf/4/then/properties/type/enum", params: { allowedValues: schema18.items.allOf[4].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                      if (vErrors === null) {
                        vErrors = [err38];
                      } else {
                        vErrors.push(err38);
                      }
                      errors2++;
                    }
                    if (errors2 > 0) {
                      const emErrs10 = [];
                      for (const err39 of vErrors) {
                        if (err39.keyword !== "errorMessage" && !err39.emUsed && (err39.dataPath === dataPath + "/camunda:Connector/properties/" + i0 + "/type" || err39.dataPath.indexOf(dataPath + "/camunda:Connector/properties/" + i0 + "/type") === 0 && err39.dataPath[dataPath + "/camunda:Connector/properties/" + i0 + "/type".length] === "/") && err39.schemaPath.indexOf("#/definitions/properties/items/allOf/4/then/properties/type") === 0 && err39.schemaPath["#/definitions/properties/items/allOf/4/then/properties/type".length] === "/") {
                          emErrs10.push(err39);
                          err39.emUsed = true;
                        }
                      }
                      if (emErrs10.length) {
                        const err40 = { keyword: "errorMessage", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/type", schemaPath: "#/definitions/properties/items/allOf/4/then/properties/type/errorMessage", params: { errors: emErrs10 }, message: "invalid property type " + JSON.stringify(data16) + " for binding type " + JSON.stringify(data3 && data3.binding && data3.binding.type) + "; must be any of { String, Text, Hidden, Dropdown }" };
                        if (vErrors === null) {
                          vErrors = [err40];
                        } else {
                          vErrors.push(err40);
                        }
                        errors2++;
                      }
                      const emErrs11 = [];
                      for (const err41 of vErrors) {
                        if (!err41.emUsed) {
                          emErrs11.push(err41);
                        }
                      }
                      vErrors = emErrs11;
                      errors2 = emErrs11.length;
                    }
                  }
                }
                var _valid4 = _errs42 === errors2;
                valid21 = _valid4;
              }
              if (!valid21) {
                const err42 = { keyword: "if", dataPath: dataPath + "/camunda:Connector/properties/" + i0, schemaPath: "#/definitions/properties/items/allOf/4/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err42];
                } else {
                  vErrors.push(err42);
                }
                errors2++;
              }
              if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                if (data3.binding === void 0) {
                  const err43 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0, schemaPath: "#/definitions/properties/items/required", params: { missingProperty: "binding" }, message: "should have required property 'binding'" };
                  if (vErrors === null) {
                    vErrors = [err43];
                  } else {
                    vErrors.push(err43);
                  }
                  errors2++;
                }
                if (data3.value !== void 0) {
                  let data17 = data3.value;
                  if (typeof data17 !== "string" && typeof data17 !== "boolean") {
                    const err44 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/value", schemaPath: "#/definitions/properties/items/properties/value/type", params: { type: schema18.items.properties.value.type }, message: "should be string,boolean" };
                    if (vErrors === null) {
                      vErrors = [err44];
                    } else {
                      vErrors.push(err44);
                    }
                    errors2++;
                  }
                }
                if (data3.description !== void 0) {
                  if (typeof data3.description !== "string") {
                    const err45 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/description", schemaPath: "#/definitions/properties/items/properties/description/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err45];
                    } else {
                      vErrors.push(err45);
                    }
                    errors2++;
                  }
                }
                if (data3.label !== void 0) {
                  if (typeof data3.label !== "string") {
                    const err46 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/label", schemaPath: "#/definitions/properties/items/properties/label/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err46];
                    } else {
                      vErrors.push(err46);
                    }
                    errors2++;
                  }
                }
                if (data3.type !== void 0) {
                  if (typeof data3.type !== "string") {
                    const err47 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/type", schemaPath: "#/definitions/properties/items/properties/type/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err47];
                    } else {
                      vErrors.push(err47);
                    }
                    errors2++;
                  }
                }
                if (data3.editable !== void 0) {
                  if (typeof data3.editable !== "boolean") {
                    const err48 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/editable", schemaPath: "#/definitions/properties/items/properties/editable/type", params: { type: "boolean" }, message: "should be boolean" };
                    if (vErrors === null) {
                      vErrors = [err48];
                    } else {
                      vErrors.push(err48);
                    }
                    errors2++;
                  }
                }
                if (data3.choices !== void 0) {
                  let data22 = data3.choices;
                  if (Array.isArray(data22)) {
                    const len1 = data22.length;
                    for (let i1 = 0; i1 < len1; i1++) {
                      let data23 = data22[i1];
                      if (data23 && typeof data23 == "object" && !Array.isArray(data23)) {
                        if (data23.value === void 0) {
                          const err49 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/choices/" + i1, schemaPath: "#/definitions/properties/items/properties/choices/items/required", params: { missingProperty: "value" }, message: "should have required property 'value'" };
                          if (vErrors === null) {
                            vErrors = [err49];
                          } else {
                            vErrors.push(err49);
                          }
                          errors2++;
                        }
                        if (data23.name === void 0) {
                          const err50 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/choices/" + i1, schemaPath: "#/definitions/properties/items/properties/choices/items/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
                          if (vErrors === null) {
                            vErrors = [err50];
                          } else {
                            vErrors.push(err50);
                          }
                          errors2++;
                        }
                        if (data23.name !== void 0) {
                          if (typeof data23.name !== "string") {
                            const err51 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/choices/" + i1 + "/name", schemaPath: "#/definitions/properties/items/properties/choices/items/properties/name/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err51];
                            } else {
                              vErrors.push(err51);
                            }
                            errors2++;
                          }
                        }
                        if (data23.value !== void 0) {
                          if (typeof data23.value !== "string") {
                            const err52 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/choices/" + i1 + "/value", schemaPath: "#/definitions/properties/items/properties/choices/items/properties/value/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err52];
                            } else {
                              vErrors.push(err52);
                            }
                            errors2++;
                          }
                        }
                      } else {
                        const err53 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/choices/" + i1, schemaPath: "#/definitions/properties/items/properties/choices/items/type", params: { type: "object" }, message: "should be object" };
                        if (vErrors === null) {
                          vErrors = [err53];
                        } else {
                          vErrors.push(err53);
                        }
                        errors2++;
                      }
                      if (errors2 > 0) {
                        const emErrs12 = [];
                        for (const err54 of vErrors) {
                          if (err54.keyword !== "errorMessage" && !err54.emUsed && (err54.dataPath === dataPath + "/camunda:Connector/properties/" + i0 + "/choices/" + i1 || err54.dataPath.indexOf(dataPath + "/camunda:Connector/properties/" + i0 + "/choices/" + i1) === 0 && err54.dataPath[dataPath + "/camunda:Connector/properties/" + i0 + "/choices/" + i1.length] === "/") && err54.schemaPath.indexOf("#/definitions/properties/items/properties/choices/items") === 0 && err54.schemaPath["#/definitions/properties/items/properties/choices/items".length] === "/") {
                            emErrs12.push(err54);
                            err54.emUsed = true;
                          }
                        }
                        if (emErrs12.length) {
                          const err55 = { keyword: "errorMessage", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/choices/" + i1, schemaPath: "#/definitions/properties/items/properties/choices/items/errorMessage", params: { errors: emErrs12 }, message: '{ name, value } must be specified for "Dropdown" choices' };
                          if (vErrors === null) {
                            vErrors = [err55];
                          } else {
                            vErrors.push(err55);
                          }
                          errors2++;
                        }
                        const emErrs13 = [];
                        for (const err56 of vErrors) {
                          if (!err56.emUsed) {
                            emErrs13.push(err56);
                          }
                        }
                        vErrors = emErrs13;
                        errors2 = emErrs13.length;
                      }
                    }
                  } else {
                    const err57 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/choices", schemaPath: "#/definitions/properties/items/properties/choices/type", params: { type: "array" }, message: "should be array" };
                    if (vErrors === null) {
                      vErrors = [err57];
                    } else {
                      vErrors.push(err57);
                    }
                    errors2++;
                  }
                }
                if (data3.binding !== void 0) {
                  let data26 = data3.binding;
                  const _errs65 = errors2;
                  let valid30 = true;
                  const _errs66 = errors2;
                  if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                    if (data26.type === void 0 && "type") {
                      const err58 = {};
                      if (vErrors === null) {
                        vErrors = [err58];
                      } else {
                        vErrors.push(err58);
                      }
                      errors2++;
                    } else {
                      if (data26.type !== void 0) {
                        let data27 = data26.type;
                        if (!(data27 === "property" || data27 === "camunda:property" || data27 === "camunda:inputParameter" || data27 === "camunda:field")) {
                          const err59 = {};
                          if (vErrors === null) {
                            vErrors = [err59];
                          } else {
                            vErrors.push(err59);
                          }
                          errors2++;
                        }
                      }
                    }
                  }
                  var _valid5 = _errs66 === errors2;
                  errors2 = _errs65;
                  if (vErrors !== null) {
                    if (_errs65) {
                      vErrors.length = _errs65;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid5) {
                    const _errs68 = errors2;
                    if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                      if (data26.name === void 0) {
                        const err60 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/0/then/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
                        if (vErrors === null) {
                          vErrors = [err60];
                        } else {
                          vErrors.push(err60);
                        }
                        errors2++;
                      }
                    }
                    if (errors2 > 0) {
                      const emErrs14 = [];
                      for (const err61 of vErrors) {
                        if (err61.keyword !== "errorMessage" && !err61.emUsed && (err61.dataPath === dataPath + "/camunda:Connector/properties/" + i0 + "/binding" || err61.dataPath.indexOf(dataPath + "/camunda:Connector/properties/" + i0 + "/binding") === 0 && err61.dataPath[dataPath + "/camunda:Connector/properties/" + i0 + "/binding".length] === "/") && err61.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/0/then") === 0 && err61.schemaPath["#/definitions/properties/items/properties/binding/allOf/0/then".length] === "/") {
                          emErrs14.push(err61);
                          err61.emUsed = true;
                        }
                      }
                      if (emErrs14.length) {
                        const err62 = { keyword: "errorMessage", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/0/then/errorMessage", params: { errors: emErrs14 }, message: "property.binding " + JSON.stringify(data26 && data26.type) + " requires name" };
                        if (vErrors === null) {
                          vErrors = [err62];
                        } else {
                          vErrors.push(err62);
                        }
                        errors2++;
                      }
                      const emErrs15 = [];
                      for (const err63 of vErrors) {
                        if (!err63.emUsed) {
                          emErrs15.push(err63);
                        }
                      }
                      vErrors = emErrs15;
                      errors2 = emErrs15.length;
                    }
                    var _valid5 = _errs68 === errors2;
                    valid30 = _valid5;
                  }
                  if (!valid30) {
                    const err64 = { keyword: "if", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err64];
                    } else {
                      vErrors.push(err64);
                    }
                    errors2++;
                  }
                  const _errs70 = errors2;
                  let valid32 = true;
                  const _errs71 = errors2;
                  if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                    if (data26.type === void 0 && "type") {
                      const err65 = {};
                      if (vErrors === null) {
                        vErrors = [err65];
                      } else {
                        vErrors.push(err65);
                      }
                      errors2++;
                    } else {
                      if (data26.type !== void 0) {
                        if (!equal(data26.type, "camunda:outputParameter")) {
                          const err66 = {};
                          if (vErrors === null) {
                            vErrors = [err66];
                          } else {
                            vErrors.push(err66);
                          }
                          errors2++;
                        }
                      }
                    }
                  }
                  var _valid6 = _errs71 === errors2;
                  errors2 = _errs70;
                  if (vErrors !== null) {
                    if (_errs70) {
                      vErrors.length = _errs70;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid6) {
                    const _errs73 = errors2;
                    if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                      if (data26.source === void 0) {
                        const err67 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/1/then/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                        if (vErrors === null) {
                          vErrors = [err67];
                        } else {
                          vErrors.push(err67);
                        }
                        errors2++;
                      }
                    }
                    if (errors2 > 0) {
                      const emErrs16 = [];
                      for (const err68 of vErrors) {
                        if (err68.keyword !== "errorMessage" && !err68.emUsed && (err68.dataPath === dataPath + "/camunda:Connector/properties/" + i0 + "/binding" || err68.dataPath.indexOf(dataPath + "/camunda:Connector/properties/" + i0 + "/binding") === 0 && err68.dataPath[dataPath + "/camunda:Connector/properties/" + i0 + "/binding".length] === "/") && err68.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/1/then") === 0 && err68.schemaPath["#/definitions/properties/items/properties/binding/allOf/1/then".length] === "/") {
                          emErrs16.push(err68);
                          err68.emUsed = true;
                        }
                      }
                      if (emErrs16.length) {
                        const err69 = { keyword: "errorMessage", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/1/then/errorMessage", params: { errors: emErrs16 }, message: "property.binding " + JSON.stringify(data26 && data26.type) + " requires source" };
                        if (vErrors === null) {
                          vErrors = [err69];
                        } else {
                          vErrors.push(err69);
                        }
                        errors2++;
                      }
                      const emErrs17 = [];
                      for (const err70 of vErrors) {
                        if (!err70.emUsed) {
                          emErrs17.push(err70);
                        }
                      }
                      vErrors = emErrs17;
                      errors2 = emErrs17.length;
                    }
                    var _valid6 = _errs73 === errors2;
                    valid32 = _valid6;
                  }
                  if (!valid32) {
                    const err71 = { keyword: "if", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/1/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err71];
                    } else {
                      vErrors.push(err71);
                    }
                    errors2++;
                  }
                  const _errs75 = errors2;
                  let valid34 = true;
                  const _errs76 = errors2;
                  if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                    if (data26.type === void 0 && "type") {
                      const err72 = {};
                      if (vErrors === null) {
                        vErrors = [err72];
                      } else {
                        vErrors.push(err72);
                      }
                      errors2++;
                    } else {
                      if (data26.type !== void 0) {
                        if (!equal(data26.type, "camunda:in")) {
                          const err73 = {};
                          if (vErrors === null) {
                            vErrors = [err73];
                          } else {
                            vErrors.push(err73);
                          }
                          errors2++;
                        }
                      }
                    }
                  }
                  var _valid7 = _errs76 === errors2;
                  errors2 = _errs75;
                  if (vErrors !== null) {
                    if (_errs75) {
                      vErrors.length = _errs75;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid7) {
                    const _errs78 = errors2;
                    const _errs79 = errors2;
                    let valid36 = false;
                    const _errs80 = errors2;
                    if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                      if (data26.variables === void 0) {
                        const err74 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/then/anyOf/0/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                        if (vErrors === null) {
                          vErrors = [err74];
                        } else {
                          vErrors.push(err74);
                        }
                        errors2++;
                      }
                    }
                    var _valid8 = _errs80 === errors2;
                    valid36 = valid36 || _valid8;
                    if (!valid36) {
                      const _errs81 = errors2;
                      if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                        if (data26.target === void 0) {
                          const err75 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/then/anyOf/1/required", params: { missingProperty: "target" }, message: "should have required property 'target'" };
                          if (vErrors === null) {
                            vErrors = [err75];
                          } else {
                            vErrors.push(err75);
                          }
                          errors2++;
                        }
                      }
                      var _valid8 = _errs81 === errors2;
                      valid36 = valid36 || _valid8;
                    }
                    if (!valid36) {
                      const err76 = { keyword: "anyOf", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/then/anyOf", params: {}, message: "should match some schema in anyOf" };
                      if (vErrors === null) {
                        vErrors = [err76];
                      } else {
                        vErrors.push(err76);
                      }
                      errors2++;
                    } else {
                      errors2 = _errs79;
                      if (vErrors !== null) {
                        if (_errs79) {
                          vErrors.length = _errs79;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    if (errors2 > 0) {
                      const emErrs18 = [];
                      for (const err77 of vErrors) {
                        if (err77.keyword !== "errorMessage" && !err77.emUsed && (err77.dataPath === dataPath + "/camunda:Connector/properties/" + i0 + "/binding" || err77.dataPath.indexOf(dataPath + "/camunda:Connector/properties/" + i0 + "/binding") === 0 && err77.dataPath[dataPath + "/camunda:Connector/properties/" + i0 + "/binding".length] === "/") && err77.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/2/then") === 0 && err77.schemaPath["#/definitions/properties/items/properties/binding/allOf/2/then".length] === "/") {
                          emErrs18.push(err77);
                          err77.emUsed = true;
                        }
                      }
                      if (emErrs18.length) {
                        const err78 = { keyword: "errorMessage", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/then/errorMessage", params: { errors: emErrs18 }, message: "property.binding " + JSON.stringify(data26 && data26.type) + " requires variables, target, or both" };
                        if (vErrors === null) {
                          vErrors = [err78];
                        } else {
                          vErrors.push(err78);
                        }
                        errors2++;
                      }
                      const emErrs19 = [];
                      for (const err79 of vErrors) {
                        if (!err79.emUsed) {
                          emErrs19.push(err79);
                        }
                      }
                      vErrors = emErrs19;
                      errors2 = emErrs19.length;
                    }
                    var _valid7 = _errs78 === errors2;
                    valid34 = _valid7;
                  }
                  if (!valid34) {
                    const err80 = { keyword: "if", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err80];
                    } else {
                      vErrors.push(err80);
                    }
                    errors2++;
                  }
                  const _errs83 = errors2;
                  let valid37 = true;
                  const _errs84 = errors2;
                  if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                    if (data26.type === void 0 && "type") {
                      const err81 = {};
                      if (vErrors === null) {
                        vErrors = [err81];
                      } else {
                        vErrors.push(err81);
                      }
                      errors2++;
                    } else {
                      if (data26.type !== void 0) {
                        if (!equal(data26.type, "camunda:out")) {
                          const err82 = {};
                          if (vErrors === null) {
                            vErrors = [err82];
                          } else {
                            vErrors.push(err82);
                          }
                          errors2++;
                        }
                      }
                    }
                  }
                  var _valid9 = _errs84 === errors2;
                  errors2 = _errs83;
                  if (vErrors !== null) {
                    if (_errs83) {
                      vErrors.length = _errs83;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid9) {
                    const _errs86 = errors2;
                    const _errs87 = errors2;
                    let valid39 = false;
                    let passing0 = null;
                    const _errs88 = errors2;
                    const _errs89 = errors2;
                    const _errs90 = errors2;
                    const _errs91 = errors2;
                    let valid41 = false;
                    const _errs92 = errors2;
                    if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                      if (data26.source === void 0 && "source") {
                        const err83 = {};
                        if (vErrors === null) {
                          vErrors = [err83];
                        } else {
                          vErrors.push(err83);
                        }
                        errors2++;
                      }
                    }
                    var _valid11 = _errs92 === errors2;
                    valid41 = valid41 || _valid11;
                    if (!valid41) {
                      const _errs93 = errors2;
                      if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                        if (data26.sourceExpression === void 0 && "sourceExpression") {
                          const err84 = {};
                          if (vErrors === null) {
                            vErrors = [err84];
                          } else {
                            vErrors.push(err84);
                          }
                          errors2++;
                        }
                      }
                      var _valid11 = _errs93 === errors2;
                      valid41 = valid41 || _valid11;
                    }
                    if (!valid41) {
                      const err85 = {};
                      if (vErrors === null) {
                        vErrors = [err85];
                      } else {
                        vErrors.push(err85);
                      }
                      errors2++;
                    } else {
                      errors2 = _errs91;
                      if (vErrors !== null) {
                        if (_errs91) {
                          vErrors.length = _errs91;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    var valid40 = _errs90 === errors2;
                    if (!valid40) {
                      errors2 = _errs89;
                      if (vErrors !== null) {
                        if (_errs89) {
                          vErrors.length = _errs89;
                        } else {
                          vErrors = null;
                        }
                      }
                    } else {
                      const err86 = { keyword: "not", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/0/not", params: {}, message: "should NOT be valid" };
                      if (vErrors === null) {
                        vErrors = [err86];
                      } else {
                        vErrors.push(err86);
                      }
                      errors2++;
                    }
                    if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                      if (data26.variables === void 0) {
                        const err87 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/0/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                        if (vErrors === null) {
                          vErrors = [err87];
                        } else {
                          vErrors.push(err87);
                        }
                        errors2++;
                      }
                    }
                    var _valid10 = _errs88 === errors2;
                    if (_valid10) {
                      valid39 = true;
                      passing0 = 0;
                    }
                    const _errs94 = errors2;
                    const _errs95 = errors2;
                    const _errs96 = errors2;
                    const _errs97 = errors2;
                    let valid43 = false;
                    const _errs98 = errors2;
                    if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                      if (data26.variables === void 0 && "variables") {
                        const err88 = {};
                        if (vErrors === null) {
                          vErrors = [err88];
                        } else {
                          vErrors.push(err88);
                        }
                        errors2++;
                      }
                    }
                    var _valid12 = _errs98 === errors2;
                    valid43 = valid43 || _valid12;
                    if (!valid43) {
                      const _errs99 = errors2;
                      if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                        if (data26.sourceExpression === void 0 && "sourceExpression") {
                          const err89 = {};
                          if (vErrors === null) {
                            vErrors = [err89];
                          } else {
                            vErrors.push(err89);
                          }
                          errors2++;
                        }
                      }
                      var _valid12 = _errs99 === errors2;
                      valid43 = valid43 || _valid12;
                    }
                    if (!valid43) {
                      const err90 = {};
                      if (vErrors === null) {
                        vErrors = [err90];
                      } else {
                        vErrors.push(err90);
                      }
                      errors2++;
                    } else {
                      errors2 = _errs97;
                      if (vErrors !== null) {
                        if (_errs97) {
                          vErrors.length = _errs97;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    var valid42 = _errs96 === errors2;
                    if (!valid42) {
                      errors2 = _errs95;
                      if (vErrors !== null) {
                        if (_errs95) {
                          vErrors.length = _errs95;
                        } else {
                          vErrors = null;
                        }
                      }
                    } else {
                      const err91 = { keyword: "not", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/1/not", params: {}, message: "should NOT be valid" };
                      if (vErrors === null) {
                        vErrors = [err91];
                      } else {
                        vErrors.push(err91);
                      }
                      errors2++;
                    }
                    if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                      if (data26.source === void 0) {
                        const err92 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/1/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                        if (vErrors === null) {
                          vErrors = [err92];
                        } else {
                          vErrors.push(err92);
                        }
                        errors2++;
                      }
                    }
                    var _valid10 = _errs94 === errors2;
                    if (_valid10 && valid39) {
                      valid39 = false;
                      passing0 = [passing0, 1];
                    } else {
                      if (_valid10) {
                        valid39 = true;
                        passing0 = 1;
                      }
                      const _errs100 = errors2;
                      const _errs101 = errors2;
                      const _errs102 = errors2;
                      const _errs103 = errors2;
                      let valid45 = false;
                      const _errs104 = errors2;
                      if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                        if (data26.variables === void 0 && "variables") {
                          const err93 = {};
                          if (vErrors === null) {
                            vErrors = [err93];
                          } else {
                            vErrors.push(err93);
                          }
                          errors2++;
                        }
                      }
                      var _valid13 = _errs104 === errors2;
                      valid45 = valid45 || _valid13;
                      if (!valid45) {
                        const _errs105 = errors2;
                        if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                          if (data26.source === void 0 && "source") {
                            const err94 = {};
                            if (vErrors === null) {
                              vErrors = [err94];
                            } else {
                              vErrors.push(err94);
                            }
                            errors2++;
                          }
                        }
                        var _valid13 = _errs105 === errors2;
                        valid45 = valid45 || _valid13;
                      }
                      if (!valid45) {
                        const err95 = {};
                        if (vErrors === null) {
                          vErrors = [err95];
                        } else {
                          vErrors.push(err95);
                        }
                        errors2++;
                      } else {
                        errors2 = _errs103;
                        if (vErrors !== null) {
                          if (_errs103) {
                            vErrors.length = _errs103;
                          } else {
                            vErrors = null;
                          }
                        }
                      }
                      var valid44 = _errs102 === errors2;
                      if (!valid44) {
                        errors2 = _errs101;
                        if (vErrors !== null) {
                          if (_errs101) {
                            vErrors.length = _errs101;
                          } else {
                            vErrors = null;
                          }
                        }
                      } else {
                        const err96 = { keyword: "not", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/2/not", params: {}, message: "should NOT be valid" };
                        if (vErrors === null) {
                          vErrors = [err96];
                        } else {
                          vErrors.push(err96);
                        }
                        errors2++;
                      }
                      if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                        if (data26.sourceExpression === void 0) {
                          const err97 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/2/required", params: { missingProperty: "sourceExpression" }, message: "should have required property 'sourceExpression'" };
                          if (vErrors === null) {
                            vErrors = [err97];
                          } else {
                            vErrors.push(err97);
                          }
                          errors2++;
                        }
                      }
                      var _valid10 = _errs100 === errors2;
                      if (_valid10 && valid39) {
                        valid39 = false;
                        passing0 = [passing0, 2];
                      } else {
                        if (_valid10) {
                          valid39 = true;
                          passing0 = 2;
                        }
                        const _errs106 = errors2;
                        const _errs107 = errors2;
                        const _errs108 = errors2;
                        if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                          if (data26.source === void 0 && "source") {
                            const err98 = {};
                            if (vErrors === null) {
                              vErrors = [err98];
                            } else {
                              vErrors.push(err98);
                            }
                            errors2++;
                          }
                        }
                        var valid46 = _errs108 === errors2;
                        if (!valid46) {
                          errors2 = _errs107;
                          if (vErrors !== null) {
                            if (_errs107) {
                              vErrors.length = _errs107;
                            } else {
                              vErrors = null;
                            }
                          }
                        } else {
                          const err99 = { keyword: "not", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/3/not", params: {}, message: "should NOT be valid" };
                          if (vErrors === null) {
                            vErrors = [err99];
                          } else {
                            vErrors.push(err99);
                          }
                          errors2++;
                        }
                        if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                          if (data26.variables === void 0) {
                            const err100 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/3/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                            if (vErrors === null) {
                              vErrors = [err100];
                            } else {
                              vErrors.push(err100);
                            }
                            errors2++;
                          }
                          if (data26.sourceExpression === void 0) {
                            const err101 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/3/required", params: { missingProperty: "sourceExpression" }, message: "should have required property 'sourceExpression'" };
                            if (vErrors === null) {
                              vErrors = [err101];
                            } else {
                              vErrors.push(err101);
                            }
                            errors2++;
                          }
                        }
                        var _valid10 = _errs106 === errors2;
                        if (_valid10 && valid39) {
                          valid39 = false;
                          passing0 = [passing0, 3];
                        } else {
                          if (_valid10) {
                            valid39 = true;
                            passing0 = 3;
                          }
                          const _errs109 = errors2;
                          const _errs110 = errors2;
                          const _errs111 = errors2;
                          if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                            if (data26.sourceExpression === void 0 && "sourceExpression") {
                              const err102 = {};
                              if (vErrors === null) {
                                vErrors = [err102];
                              } else {
                                vErrors.push(err102);
                              }
                              errors2++;
                            }
                          }
                          var valid47 = _errs111 === errors2;
                          if (!valid47) {
                            errors2 = _errs110;
                            if (vErrors !== null) {
                              if (_errs110) {
                                vErrors.length = _errs110;
                              } else {
                                vErrors = null;
                              }
                            }
                          } else {
                            const err103 = { keyword: "not", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/4/not", params: {}, message: "should NOT be valid" };
                            if (vErrors === null) {
                              vErrors = [err103];
                            } else {
                              vErrors.push(err103);
                            }
                            errors2++;
                          }
                          if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                            if (data26.variables === void 0) {
                              const err104 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/4/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                              if (vErrors === null) {
                                vErrors = [err104];
                              } else {
                                vErrors.push(err104);
                              }
                              errors2++;
                            }
                            if (data26.source === void 0) {
                              const err105 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/4/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                              if (vErrors === null) {
                                vErrors = [err105];
                              } else {
                                vErrors.push(err105);
                              }
                              errors2++;
                            }
                          }
                          var _valid10 = _errs109 === errors2;
                          if (_valid10 && valid39) {
                            valid39 = false;
                            passing0 = [passing0, 4];
                          } else {
                            if (_valid10) {
                              valid39 = true;
                              passing0 = 4;
                            }
                          }
                        }
                      }
                    }
                    if (!valid39) {
                      const err106 = { keyword: "oneOf", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf", params: { passingSchemas: passing0 }, message: "should match exactly one schema in oneOf" };
                      if (vErrors === null) {
                        vErrors = [err106];
                      } else {
                        vErrors.push(err106);
                      }
                      errors2++;
                    } else {
                      errors2 = _errs87;
                      if (vErrors !== null) {
                        if (_errs87) {
                          vErrors.length = _errs87;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    if (errors2 > 0) {
                      const emErrs20 = [];
                      for (const err107 of vErrors) {
                        if (err107.keyword !== "errorMessage" && !err107.emUsed && (err107.dataPath === dataPath + "/camunda:Connector/properties/" + i0 + "/binding" || err107.dataPath.indexOf(dataPath + "/camunda:Connector/properties/" + i0 + "/binding") === 0 && err107.dataPath[dataPath + "/camunda:Connector/properties/" + i0 + "/binding".length] === "/") && err107.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/3/then") === 0 && err107.schemaPath["#/definitions/properties/items/properties/binding/allOf/3/then".length] === "/") {
                          emErrs20.push(err107);
                          err107.emUsed = true;
                        }
                      }
                      if (emErrs20.length) {
                        const err108 = { keyword: "errorMessage", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/errorMessage", params: { errors: emErrs20 }, message: "property.binding " + JSON.stringify(data26 && data26.type) + " requires one of the following: variables, sourceExpression, source, (sourceExpression and variables), or (source and variables)" };
                        if (vErrors === null) {
                          vErrors = [err108];
                        } else {
                          vErrors.push(err108);
                        }
                        errors2++;
                      }
                      const emErrs21 = [];
                      for (const err109 of vErrors) {
                        if (!err109.emUsed) {
                          emErrs21.push(err109);
                        }
                      }
                      vErrors = emErrs21;
                      errors2 = emErrs21.length;
                    }
                    var _valid9 = _errs86 === errors2;
                    valid37 = _valid9;
                  }
                  if (!valid37) {
                    const err110 = { keyword: "if", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err110];
                    } else {
                      vErrors.push(err110);
                    }
                    errors2++;
                  }
                  const _errs113 = errors2;
                  let valid48 = true;
                  const _errs114 = errors2;
                  if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                    if (data26.type === void 0 && "type") {
                      const err111 = {};
                      if (vErrors === null) {
                        vErrors = [err111];
                      } else {
                        vErrors.push(err111);
                      }
                      errors2++;
                    } else {
                      if (data26.type !== void 0) {
                        if (!equal(data26.type, "camunda:errorEventDefinition")) {
                          const err112 = {};
                          if (vErrors === null) {
                            vErrors = [err112];
                          } else {
                            vErrors.push(err112);
                          }
                          errors2++;
                        }
                      }
                    }
                  }
                  var _valid14 = _errs114 === errors2;
                  errors2 = _errs113;
                  if (vErrors !== null) {
                    if (_errs113) {
                      vErrors.length = _errs113;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid14) {
                    const _errs116 = errors2;
                    const _errs117 = errors2;
                    let valid50 = false;
                    let passing1 = null;
                    const _errs118 = errors2;
                    if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                      if (data26.errorRef === void 0) {
                        const err113 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/4/then/oneOf/0/required", params: { missingProperty: "errorRef" }, message: "should have required property 'errorRef'" };
                        if (vErrors === null) {
                          vErrors = [err113];
                        } else {
                          vErrors.push(err113);
                        }
                        errors2++;
                      }
                    }
                    var _valid15 = _errs118 === errors2;
                    if (_valid15) {
                      valid50 = true;
                      passing1 = 0;
                    }
                    if (!valid50) {
                      const err114 = { keyword: "oneOf", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/4/then/oneOf", params: { passingSchemas: passing1 }, message: "should match exactly one schema in oneOf" };
                      if (vErrors === null) {
                        vErrors = [err114];
                      } else {
                        vErrors.push(err114);
                      }
                      errors2++;
                    } else {
                      errors2 = _errs117;
                      if (vErrors !== null) {
                        if (_errs117) {
                          vErrors.length = _errs117;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    if (errors2 > 0) {
                      const emErrs22 = [];
                      for (const err115 of vErrors) {
                        if (err115.keyword !== "errorMessage" && !err115.emUsed && (err115.dataPath === dataPath + "/camunda:Connector/properties/" + i0 + "/binding" || err115.dataPath.indexOf(dataPath + "/camunda:Connector/properties/" + i0 + "/binding") === 0 && err115.dataPath[dataPath + "/camunda:Connector/properties/" + i0 + "/binding".length] === "/") && err115.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/4/then") === 0 && err115.schemaPath["#/definitions/properties/items/properties/binding/allOf/4/then".length] === "/") {
                          emErrs22.push(err115);
                          err115.emUsed = true;
                        }
                      }
                      if (emErrs22.length) {
                        const err116 = { keyword: "errorMessage", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/4/then/errorMessage", params: { errors: emErrs22 }, message: "property.binding " + JSON.stringify(data26 && data26.type) + " requires errorRef" };
                        if (vErrors === null) {
                          vErrors = [err116];
                        } else {
                          vErrors.push(err116);
                        }
                        errors2++;
                      }
                      const emErrs23 = [];
                      for (const err117 of vErrors) {
                        if (!err117.emUsed) {
                          emErrs23.push(err117);
                        }
                      }
                      vErrors = emErrs23;
                      errors2 = emErrs23.length;
                    }
                    var _valid14 = _errs116 === errors2;
                    valid48 = _valid14;
                  }
                  if (!valid48) {
                    const err118 = { keyword: "if", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/4/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err118];
                    } else {
                      vErrors.push(err118);
                    }
                    errors2++;
                  }
                  if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                    if (data26.type === void 0) {
                      const err119 = { keyword: "required", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/required", params: { missingProperty: "type" }, message: "should have required property 'type'" };
                      if (vErrors === null) {
                        vErrors = [err119];
                      } else {
                        vErrors.push(err119);
                      }
                      errors2++;
                    }
                    if (data26.type !== void 0) {
                      let data32 = data26.type;
                      if (typeof data32 !== "string") {
                        const err120 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding/type", schemaPath: "#/definitions/properties/items/properties/binding/properties/type/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err120];
                        } else {
                          vErrors.push(err120);
                        }
                        errors2++;
                      }
                      if (!(data32 === "property" || data32 === "camunda:property" || data32 === "camunda:inputParameter" || data32 === "camunda:outputParameter" || data32 === "camunda:in" || data32 === "camunda:out" || data32 === "camunda:in:businessKey" || data32 === "camunda:executionListener" || data32 === "camunda:field" || data32 === "camunda:errorEventDefinition")) {
                        const err121 = { keyword: "enum", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding/type", schemaPath: "#/definitions/properties/items/properties/binding/properties/type/enum", params: { allowedValues: schema18.items.properties.binding.properties.type.enum }, message: "should be equal to one of the allowed values" };
                        if (vErrors === null) {
                          vErrors = [err121];
                        } else {
                          vErrors.push(err121);
                        }
                        errors2++;
                      }
                      if (errors2 > 0) {
                        const emErrs24 = [];
                        for (const err122 of vErrors) {
                          if (err122.keyword !== "errorMessage" && !err122.emUsed && (err122.dataPath === dataPath + "/camunda:Connector/properties/" + i0 + "/binding/type" || err122.dataPath.indexOf(dataPath + "/camunda:Connector/properties/" + i0 + "/binding/type") === 0 && err122.dataPath[dataPath + "/camunda:Connector/properties/" + i0 + "/binding/type".length] === "/") && err122.schemaPath.indexOf("#/definitions/properties/items/properties/binding/properties/type") === 0 && err122.schemaPath["#/definitions/properties/items/properties/binding/properties/type".length] === "/") {
                            emErrs24.push(err122);
                            err122.emUsed = true;
                          }
                        }
                        if (emErrs24.length) {
                          const err123 = { keyword: "errorMessage", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding/type", schemaPath: "#/definitions/properties/items/properties/binding/properties/type/errorMessage", params: { errors: emErrs24 }, message: "invalid property.binding type " + JSON.stringify(data32) + "; must be any of { property, camunda:property, camunda:inputParameter, camunda:outputParameter, camunda:in, camunda:out, camunda:in:businessKey, camunda:executionListener, camunda:field, camunda:errorEventDefinition }" };
                          if (vErrors === null) {
                            vErrors = [err123];
                          } else {
                            vErrors.push(err123);
                          }
                          errors2++;
                        }
                        const emErrs25 = [];
                        for (const err124 of vErrors) {
                          if (!err124.emUsed) {
                            emErrs25.push(err124);
                          }
                        }
                        vErrors = emErrs25;
                        errors2 = emErrs25.length;
                      }
                    }
                    if (data26.name !== void 0) {
                      if (typeof data26.name !== "string") {
                        const err125 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding/name", schemaPath: "#/definitions/properties/items/properties/binding/properties/name/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err125];
                        } else {
                          vErrors.push(err125);
                        }
                        errors2++;
                      }
                    }
                    if (data26.event !== void 0) {
                      if (typeof data26.event !== "string") {
                        const err126 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding/event", schemaPath: "#/definitions/properties/items/properties/binding/properties/event/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err126];
                        } else {
                          vErrors.push(err126);
                        }
                        errors2++;
                      }
                    }
                    if (data26.scriptFormat !== void 0) {
                      if (typeof data26.scriptFormat !== "string") {
                        const err127 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding/scriptFormat", schemaPath: "#/definitions/properties/items/properties/binding/properties/scriptFormat/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err127];
                        } else {
                          vErrors.push(err127);
                        }
                        errors2++;
                      }
                    }
                    if (data26.source !== void 0) {
                      if (typeof data26.source !== "string") {
                        const err128 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding/source", schemaPath: "#/definitions/properties/items/properties/binding/properties/source/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err128];
                        } else {
                          vErrors.push(err128);
                        }
                        errors2++;
                      }
                    }
                    if (data26.target !== void 0) {
                      if (typeof data26.target !== "string") {
                        const err129 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding/target", schemaPath: "#/definitions/properties/items/properties/binding/properties/target/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err129];
                        } else {
                          vErrors.push(err129);
                        }
                        errors2++;
                      }
                    }
                    if (data26.expression !== void 0) {
                      if (typeof data26.expression !== "boolean") {
                        const err130 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding/expression", schemaPath: "#/definitions/properties/items/properties/binding/properties/expression/type", params: { type: "boolean" }, message: "should be boolean" };
                        if (vErrors === null) {
                          vErrors = [err130];
                        } else {
                          vErrors.push(err130);
                        }
                        errors2++;
                      }
                    }
                    if (data26.variables !== void 0) {
                      let data39 = data26.variables;
                      if (typeof data39 !== "string") {
                        const err131 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding/variables", schemaPath: "#/definitions/properties/items/properties/binding/properties/variables/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err131];
                        } else {
                          vErrors.push(err131);
                        }
                        errors2++;
                      }
                      if (!(data39 === "all" || data39 === "local")) {
                        const err132 = { keyword: "enum", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding/variables", schemaPath: "#/definitions/properties/items/properties/binding/properties/variables/enum", params: { allowedValues: schema18.items.properties.binding.properties.variables.enum }, message: "should be equal to one of the allowed values" };
                        if (vErrors === null) {
                          vErrors = [err132];
                        } else {
                          vErrors.push(err132);
                        }
                        errors2++;
                      }
                    }
                    if (data26.sourceExpression !== void 0) {
                      if (typeof data26.sourceExpression !== "string") {
                        const err133 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding/sourceExpression", schemaPath: "#/definitions/properties/items/properties/binding/properties/sourceExpression/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err133];
                        } else {
                          vErrors.push(err133);
                        }
                        errors2++;
                      }
                    }
                  } else {
                    const err134 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/type", params: { type: "object" }, message: "should be object" };
                    if (vErrors === null) {
                      vErrors = [err134];
                    } else {
                      vErrors.push(err134);
                    }
                    errors2++;
                  }
                }
                if (data3.constraints !== void 0) {
                  let data41 = data3.constraints;
                  if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                    if (data41.notEmpty !== void 0) {
                      if (typeof data41.notEmpty !== "boolean") {
                        const err135 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/constraints/notEmpty", schemaPath: "#/definitions/properties/items/properties/constraints/properties/notEmpty/type", params: { type: "boolean" }, message: "should be boolean" };
                        if (vErrors === null) {
                          vErrors = [err135];
                        } else {
                          vErrors.push(err135);
                        }
                        errors2++;
                      }
                    }
                    if (data41.minLength !== void 0) {
                      if (!(typeof data41.minLength == "number")) {
                        const err136 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/constraints/minLength", schemaPath: "#/definitions/properties/items/properties/constraints/properties/minLength/type", params: { type: "number" }, message: "should be number" };
                        if (vErrors === null) {
                          vErrors = [err136];
                        } else {
                          vErrors.push(err136);
                        }
                        errors2++;
                      }
                    }
                    if (data41.maxLength !== void 0) {
                      if (!(typeof data41.maxLength == "number")) {
                        const err137 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/constraints/maxLength", schemaPath: "#/definitions/properties/items/properties/constraints/properties/maxLength/type", params: { type: "number" }, message: "should be number" };
                        if (vErrors === null) {
                          vErrors = [err137];
                        } else {
                          vErrors.push(err137);
                        }
                        errors2++;
                      }
                    }
                    if (data41.pattern !== void 0) {
                      let data45 = data41.pattern;
                      const _errs146 = errors2;
                      let valid53 = false;
                      let passing2 = null;
                      const _errs147 = errors2;
                      if (data45 && typeof data45 == "object" && !Array.isArray(data45)) {
                        if (data45.value !== void 0) {
                          if (typeof data45.value !== "string") {
                            const err138 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/constraints/pattern/value", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf/0/properties/value/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err138];
                            } else {
                              vErrors.push(err138);
                            }
                            errors2++;
                          }
                        }
                        if (data45.message !== void 0) {
                          if (typeof data45.message !== "string") {
                            const err139 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/constraints/pattern/message", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf/0/properties/message/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err139];
                            } else {
                              vErrors.push(err139);
                            }
                            errors2++;
                          }
                        }
                      } else {
                        const err140 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/constraints/pattern", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf/0/type", params: { type: "object" }, message: "should be object" };
                        if (vErrors === null) {
                          vErrors = [err140];
                        } else {
                          vErrors.push(err140);
                        }
                        errors2++;
                      }
                      var _valid16 = _errs147 === errors2;
                      if (_valid16) {
                        valid53 = true;
                        passing2 = 0;
                      }
                      const _errs153 = errors2;
                      if (typeof data45 !== "string") {
                        const err141 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/constraints/pattern", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf/1/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err141];
                        } else {
                          vErrors.push(err141);
                        }
                        errors2++;
                      }
                      var _valid16 = _errs153 === errors2;
                      if (_valid16 && valid53) {
                        valid53 = false;
                        passing2 = [passing2, 1];
                      } else {
                        if (_valid16) {
                          valid53 = true;
                          passing2 = 1;
                        }
                      }
                      if (!valid53) {
                        const err142 = { keyword: "oneOf", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/constraints/pattern", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf", params: { passingSchemas: passing2 }, message: "should match exactly one schema in oneOf" };
                        if (vErrors === null) {
                          vErrors = [err142];
                        } else {
                          vErrors.push(err142);
                        }
                        errors2++;
                      } else {
                        errors2 = _errs146;
                        if (vErrors !== null) {
                          if (_errs146) {
                            vErrors.length = _errs146;
                          } else {
                            vErrors = null;
                          }
                        }
                      }
                    }
                  } else {
                    const err143 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0 + "/constraints", schemaPath: "#/definitions/properties/items/properties/constraints/type", params: { type: "object" }, message: "should be object" };
                    if (vErrors === null) {
                      vErrors = [err143];
                    } else {
                      vErrors.push(err143);
                    }
                    errors2++;
                  }
                }
              } else {
                const err144 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties/" + i0, schemaPath: "#/definitions/properties/items/type", params: { type: "object" }, message: "should be object" };
                if (vErrors === null) {
                  vErrors = [err144];
                } else {
                  vErrors.push(err144);
                }
                errors2++;
              }
              if (errors2 > 0) {
                const emErrors0 = { "required": { "binding": [] } };
                const templates0 = { required: { binding: function() {
                  return 'missing binding for property "' + JSON.stringify(i0) + '"';
                } } };
                let emPropParams0;
                let emParamsErrors0;
                for (const err145 of vErrors) {
                  if (err145.keyword !== "errorMessage" && !err145.emUsed && err145.dataPath === dataPath + "/camunda:Connector/properties/" + i0 && err145.keyword in emErrors0 && err145.schemaPath.indexOf("#/definitions/properties/items") === 0 && /^\/[^\/]*$/.test(err145.schemaPath.slice(30))) {
                    emPropParams0 = obj0[err145.keyword];
                    emParamsErrors0 = emErrors0[err145.keyword][err145.params[emPropParams0]];
                    if (emParamsErrors0) {
                      emParamsErrors0.push(err145);
                      err145.emUsed = true;
                    }
                  }
                }
                for (const key1 in emErrors0) {
                  for (const keyProp0 in emErrors0[key1]) {
                    emParamsErrors0 = emErrors0[key1][keyProp0];
                    if (emParamsErrors0.length) {
                      const tmpl0 = templates0[key1] && templates0[key1][keyProp0];
                      const err146 = { keyword: "errorMessage", dataPath: dataPath + "/camunda:Connector/properties/" + i0, schemaPath: "#/definitions/properties/items/errorMessage", params: { errors: emParamsErrors0 }, message: tmpl0 ? tmpl0() : schema18.items.errorMessage[key1][keyProp0] };
                      if (vErrors === null) {
                        vErrors = [err146];
                      } else {
                        vErrors.push(err146);
                      }
                      errors2++;
                    }
                  }
                }
                const emErrs26 = [];
                for (const err147 of vErrors) {
                  if (!err147.emUsed) {
                    emErrs26.push(err147);
                  }
                }
                vErrors = emErrs26;
                errors2 = emErrs26.length;
              }
            }
          } else {
            const err148 = { keyword: "type", dataPath: dataPath + "/camunda:Connector/properties", schemaPath: "#/definitions/properties/type", params: { type: "array" }, message: "should be array" };
            if (vErrors === null) {
              vErrors = [err148];
            } else {
              vErrors.push(err148);
            }
            errors2++;
          }
        }
      } else {
        const err149 = { keyword: "type", dataPath: dataPath + "/camunda:Connector", schemaPath: "#/properties/camunda%3AConnector/type", params: { type: "object" }, message: "should be object" };
        if (vErrors === null) {
          vErrors = [err149];
        } else {
          vErrors.push(err149);
        }
        errors2++;
      }
    }
  } else {
    const err150 = { keyword: "type", dataPath, schemaPath: "#/type", params: { type: "object" }, message: "should be object" };
    if (vErrors === null) {
      vErrors = [err150];
    } else {
      vErrors.push(err150);
    }
    errors2++;
  }
  validate16.errors = vErrors;
  return errors2 === 0;
}
const schema21 = { "$id": "#/definitions/scopes", "type": "array", "title": "element template scope", "description": "Special scoped bindings that allow you to configure nested elements", "items": { "$id": "#/scopes/item", "type": "object", "title": "element template scope item", "description": "Scoped binding to configure nested elements", "properties": { "type": { "$id": "#scopes/item/type", "type": "string", "enum": ["camunda:Connector", "bpmn:Error"], "errorMessage": "invalid scope type ${0}; must be any of { camunda:Connector, bpmn:Error }" }, "properties": { "$ref": "#/definitions/properties" } }, "required": ["type", "properties"], "errorMessage": { "required": { "type": "invalid scope, missing type", "properties": "invalid scope ${0/type}, missing properties=[]" } }, "allOf": [{ "if": { "properties": { "type": { "enum": ["bpmn:Error"] } }, "required": ["type"] }, "then": { "required": ["id"], "errorMessage": "invalid scope ${0/type}, missing id" } }] } };
function validate18(data, { dataPath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors2 = 0;
  if (Array.isArray(data)) {
    const len0 = data.length;
    for (let i0 = 0; i0 < len0; i0++) {
      let data0 = data[i0];
      const _errs4 = errors2;
      let valid3 = true;
      const _errs5 = errors2;
      if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
        if (data0.type === void 0 && "type") {
          const err0 = {};
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        } else {
          if (data0.type !== void 0) {
            if (!(data0.type === "bpmn:Error")) {
              const err1 = {};
              if (vErrors === null) {
                vErrors = [err1];
              } else {
                vErrors.push(err1);
              }
              errors2++;
            }
          }
        }
      }
      var _valid0 = _errs5 === errors2;
      errors2 = _errs4;
      if (vErrors !== null) {
        if (_errs4) {
          vErrors.length = _errs4;
        } else {
          vErrors = null;
        }
      }
      if (_valid0) {
        const _errs7 = errors2;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.id === void 0) {
            const err2 = { keyword: "required", dataPath: dataPath + "/" + i0, schemaPath: "#/items/allOf/0/then/required", params: { missingProperty: "id" }, message: "should have required property 'id'" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
        if (errors2 > 0) {
          const emErrs0 = [];
          for (const err3 of vErrors) {
            if (err3.keyword !== "errorMessage" && !err3.emUsed && (err3.dataPath === dataPath + "/" + i0 || err3.dataPath.indexOf(dataPath + "/" + i0) === 0 && err3.dataPath[dataPath + "/" + i0.length] === "/") && err3.schemaPath.indexOf("#/items/allOf/0/then") === 0 && err3.schemaPath["#/items/allOf/0/then".length] === "/") {
              emErrs0.push(err3);
              err3.emUsed = true;
            }
          }
          if (emErrs0.length) {
            const err4 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0, schemaPath: "#/items/allOf/0/then/errorMessage", params: { errors: emErrs0 }, message: "invalid scope " + JSON.stringify(data0 && data0.type) + ", missing id" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
          const emErrs1 = [];
          for (const err5 of vErrors) {
            if (!err5.emUsed) {
              emErrs1.push(err5);
            }
          }
          vErrors = emErrs1;
          errors2 = emErrs1.length;
        }
        var _valid0 = _errs7 === errors2;
        valid3 = _valid0;
      }
      if (!valid3) {
        const err6 = { keyword: "if", dataPath: dataPath + "/" + i0, schemaPath: "#/items/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
        if (vErrors === null) {
          vErrors = [err6];
        } else {
          vErrors.push(err6);
        }
        errors2++;
      }
      if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
        if (data0.type === void 0) {
          const err7 = { keyword: "required", dataPath: dataPath + "/" + i0, schemaPath: "#/items/required", params: { missingProperty: "type" }, message: "should have required property 'type'" };
          if (vErrors === null) {
            vErrors = [err7];
          } else {
            vErrors.push(err7);
          }
          errors2++;
        }
        if (data0.properties === void 0) {
          const err8 = { keyword: "required", dataPath: dataPath + "/" + i0, schemaPath: "#/items/required", params: { missingProperty: "properties" }, message: "should have required property 'properties'" };
          if (vErrors === null) {
            vErrors = [err8];
          } else {
            vErrors.push(err8);
          }
          errors2++;
        }
        if (data0.type !== void 0) {
          let data2 = data0.type;
          if (typeof data2 !== "string") {
            const err9 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/type", schemaPath: "#/items/properties/type/type", params: { type: "string" }, message: "should be string" };
            if (vErrors === null) {
              vErrors = [err9];
            } else {
              vErrors.push(err9);
            }
            errors2++;
          }
          if (!(data2 === "camunda:Connector" || data2 === "bpmn:Error")) {
            const err10 = { keyword: "enum", dataPath: dataPath + "/" + i0 + "/type", schemaPath: "#/items/properties/type/enum", params: { allowedValues: schema21.items.properties.type.enum }, message: "should be equal to one of the allowed values" };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors2++;
          }
          if (errors2 > 0) {
            const emErrs2 = [];
            for (const err11 of vErrors) {
              if (err11.keyword !== "errorMessage" && !err11.emUsed && (err11.dataPath === dataPath + "/" + i0 + "/type" || err11.dataPath.indexOf(dataPath + "/" + i0 + "/type") === 0 && err11.dataPath[dataPath + "/" + i0 + "/type".length] === "/") && err11.schemaPath.indexOf("#/items/properties/type") === 0 && err11.schemaPath["#/items/properties/type".length] === "/") {
                emErrs2.push(err11);
                err11.emUsed = true;
              }
            }
            if (emErrs2.length) {
              const err12 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/type", schemaPath: "#/items/properties/type/errorMessage", params: { errors: emErrs2 }, message: "invalid scope type " + JSON.stringify(data2) + "; must be any of { camunda:Connector, bpmn:Error }" };
              if (vErrors === null) {
                vErrors = [err12];
              } else {
                vErrors.push(err12);
              }
              errors2++;
            }
            const emErrs3 = [];
            for (const err13 of vErrors) {
              if (!err13.emUsed) {
                emErrs3.push(err13);
              }
            }
            vErrors = emErrs3;
            errors2 = emErrs3.length;
          }
        }
        if (data0.properties !== void 0) {
          let data3 = data0.properties;
          if (Array.isArray(data3)) {
            const len1 = data3.length;
            for (let i1 = 0; i1 < len1; i1++) {
              let data4 = data3[i1];
              const _errs16 = errors2;
              let valid10 = true;
              const _errs17 = errors2;
              if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                if (data4.type === void 0 && "type") {
                  const err14 = {};
                  if (vErrors === null) {
                    vErrors = [err14];
                  } else {
                    vErrors.push(err14);
                  }
                  errors2++;
                } else {
                  if (data4.type !== void 0) {
                    if (!equal(data4.type, "Dropdown")) {
                      const err15 = {};
                      if (vErrors === null) {
                        vErrors = [err15];
                      } else {
                        vErrors.push(err15);
                      }
                      errors2++;
                    }
                  }
                }
              }
              var _valid1 = _errs17 === errors2;
              errors2 = _errs16;
              if (vErrors !== null) {
                if (_errs16) {
                  vErrors.length = _errs16;
                } else {
                  vErrors = null;
                }
              }
              if (_valid1) {
                const _errs19 = errors2;
                if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                  if (data4.choices === void 0) {
                    const err16 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/0/then/required", params: { missingProperty: "choices" }, message: "should have required property 'choices'" };
                    if (vErrors === null) {
                      vErrors = [err16];
                    } else {
                      vErrors.push(err16);
                    }
                    errors2++;
                  }
                }
                if (errors2 > 0) {
                  const emErrs4 = [];
                  for (const err17 of vErrors) {
                    if (err17.keyword !== "errorMessage" && !err17.emUsed && (err17.dataPath === dataPath + "/" + i0 + "/properties/" + i1 || err17.dataPath.indexOf(dataPath + "/" + i0 + "/properties/" + i1) === 0 && err17.dataPath[dataPath + "/" + i0 + "/properties/" + i1.length] === "/") && err17.schemaPath.indexOf("#/definitions/properties/items/allOf/0/then") === 0 && err17.schemaPath["#/definitions/properties/items/allOf/0/then".length] === "/") {
                      emErrs4.push(err17);
                      err17.emUsed = true;
                    }
                  }
                  if (emErrs4.length) {
                    const err18 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/0/then/errorMessage", params: { errors: emErrs4 }, message: 'must provide choices=[] with "Dropdown" type' };
                    if (vErrors === null) {
                      vErrors = [err18];
                    } else {
                      vErrors.push(err18);
                    }
                    errors2++;
                  }
                  const emErrs5 = [];
                  for (const err19 of vErrors) {
                    if (!err19.emUsed) {
                      emErrs5.push(err19);
                    }
                  }
                  vErrors = emErrs5;
                  errors2 = emErrs5.length;
                }
                var _valid1 = _errs19 === errors2;
                valid10 = _valid1;
              }
              if (!valid10) {
                const err20 = { keyword: "if", dataPath: dataPath + "/" + i0 + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err20];
                } else {
                  vErrors.push(err20);
                }
                errors2++;
              }
              const _errs21 = errors2;
              let valid12 = true;
              const _errs22 = errors2;
              if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                if (data4.binding === void 0 && "binding") {
                  const err21 = {};
                  if (vErrors === null) {
                    vErrors = [err21];
                  } else {
                    vErrors.push(err21);
                  }
                  errors2++;
                } else {
                  if (data4.binding !== void 0) {
                    let data6 = data4.binding;
                    if (data6 && typeof data6 == "object" && !Array.isArray(data6)) {
                      if (data6.type === void 0 && "type") {
                        const err22 = {};
                        if (vErrors === null) {
                          vErrors = [err22];
                        } else {
                          vErrors.push(err22);
                        }
                        errors2++;
                      } else {
                        if (data6.type !== void 0) {
                          if (!equal(data6.type, "property")) {
                            const err23 = {};
                            if (vErrors === null) {
                              vErrors = [err23];
                            } else {
                              vErrors.push(err23);
                            }
                            errors2++;
                          }
                        }
                      }
                    }
                  }
                }
              }
              var _valid2 = _errs22 === errors2;
              errors2 = _errs21;
              if (vErrors !== null) {
                if (_errs21) {
                  vErrors.length = _errs21;
                } else {
                  vErrors = null;
                }
              }
              if (_valid2) {
                const _errs25 = errors2;
                if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                  if (data4.type !== void 0) {
                    let data8 = data4.type;
                    if (!(data8 === "String" || data8 === "Text" || data8 === "Hidden" || data8 === "Dropdown" || data8 === "Boolean")) {
                      const err24 = { keyword: "enum", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/1/then/properties/type/enum", params: { allowedValues: schema18.items.allOf[1].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                      if (vErrors === null) {
                        vErrors = [err24];
                      } else {
                        vErrors.push(err24);
                      }
                      errors2++;
                    }
                    if (errors2 > 0) {
                      const emErrs6 = [];
                      for (const err25 of vErrors) {
                        if (err25.keyword !== "errorMessage" && !err25.emUsed && (err25.dataPath === dataPath + "/" + i0 + "/properties/" + i1 + "/type" || err25.dataPath.indexOf(dataPath + "/" + i0 + "/properties/" + i1 + "/type") === 0 && err25.dataPath[dataPath + "/" + i0 + "/properties/" + i1 + "/type".length] === "/") && err25.schemaPath.indexOf("#/definitions/properties/items/allOf/1/then/properties/type") === 0 && err25.schemaPath["#/definitions/properties/items/allOf/1/then/properties/type".length] === "/") {
                          emErrs6.push(err25);
                          err25.emUsed = true;
                        }
                      }
                      if (emErrs6.length) {
                        const err26 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/1/then/properties/type/errorMessage", params: { errors: emErrs6 }, message: "invalid property type " + JSON.stringify(data8) + ' for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' };
                        if (vErrors === null) {
                          vErrors = [err26];
                        } else {
                          vErrors.push(err26);
                        }
                        errors2++;
                      }
                      const emErrs7 = [];
                      for (const err27 of vErrors) {
                        if (!err27.emUsed) {
                          emErrs7.push(err27);
                        }
                      }
                      vErrors = emErrs7;
                      errors2 = emErrs7.length;
                    }
                  }
                }
                var _valid2 = _errs25 === errors2;
                valid12 = _valid2;
              }
              if (!valid12) {
                const err28 = { keyword: "if", dataPath: dataPath + "/" + i0 + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/1/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err28];
                } else {
                  vErrors.push(err28);
                }
                errors2++;
              }
              const _errs28 = errors2;
              let valid16 = true;
              const _errs29 = errors2;
              if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                if (data4.binding === void 0 && "binding") {
                  const err29 = {};
                  if (vErrors === null) {
                    vErrors = [err29];
                  } else {
                    vErrors.push(err29);
                  }
                  errors2++;
                } else {
                  if (data4.binding !== void 0) {
                    let data9 = data4.binding;
                    if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
                      if (data9.type === void 0 && "type") {
                        const err30 = {};
                        if (vErrors === null) {
                          vErrors = [err30];
                        } else {
                          vErrors.push(err30);
                        }
                        errors2++;
                      } else {
                        if (data9.type !== void 0) {
                          if (!equal(data9.type, "camunda:executionListener")) {
                            const err31 = {};
                            if (vErrors === null) {
                              vErrors = [err31];
                            } else {
                              vErrors.push(err31);
                            }
                            errors2++;
                          }
                        }
                      }
                    }
                  }
                }
              }
              var _valid3 = _errs29 === errors2;
              errors2 = _errs28;
              if (vErrors !== null) {
                if (_errs28) {
                  vErrors.length = _errs28;
                } else {
                  vErrors = null;
                }
              }
              if (_valid3) {
                const _errs32 = errors2;
                if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                  if (data4.type !== void 0) {
                    if (!(data4.type === "Hidden")) {
                      const err32 = { keyword: "enum", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/2/then/properties/type/enum", params: { allowedValues: schema18.items.allOf[2].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                      if (vErrors === null) {
                        vErrors = [err32];
                      } else {
                        vErrors.push(err32);
                      }
                      errors2++;
                    }
                    if (errors2 > 0) {
                      const emErrs8 = [];
                      for (const err33 of vErrors) {
                        if (err33.keyword !== "errorMessage" && !err33.emUsed && (err33.dataPath === dataPath + "/" + i0 + "/properties/" + i1 + "/type" || err33.dataPath.indexOf(dataPath + "/" + i0 + "/properties/" + i1 + "/type") === 0 && err33.dataPath[dataPath + "/" + i0 + "/properties/" + i1 + "/type".length] === "/") && err33.schemaPath.indexOf("#/definitions/properties/items/allOf/2/then/properties/type") === 0 && err33.schemaPath["#/definitions/properties/items/allOf/2/then/properties/type".length] === "/") {
                          emErrs8.push(err33);
                          err33.emUsed = true;
                        }
                      }
                      if (emErrs8.length) {
                        const err34 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/2/then/properties/type/errorMessage", params: { errors: emErrs8 }, message: "invalid property type " + JSON.stringify(data4 && data4.type) + ' for binding type "camunda:executionListener"; must be "Hidden"' };
                        if (vErrors === null) {
                          vErrors = [err34];
                        } else {
                          vErrors.push(err34);
                        }
                        errors2++;
                      }
                      const emErrs9 = [];
                      for (const err35 of vErrors) {
                        if (!err35.emUsed) {
                          emErrs9.push(err35);
                        }
                      }
                      vErrors = emErrs9;
                      errors2 = emErrs9.length;
                    }
                  }
                }
                var _valid3 = _errs32 === errors2;
                valid16 = _valid3;
              }
              if (!valid16) {
                const err36 = { keyword: "if", dataPath: dataPath + "/" + i0 + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/2/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err36];
                } else {
                  vErrors.push(err36);
                }
                errors2++;
              }
              const _errs35 = errors2;
              let valid20 = true;
              const _errs36 = errors2;
              if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                if (data4.binding === void 0 && "binding") {
                  const err37 = {};
                  if (vErrors === null) {
                    vErrors = [err37];
                  } else {
                    vErrors.push(err37);
                  }
                  errors2++;
                } else {
                  if (data4.binding !== void 0) {
                    let data12 = data4.binding;
                    if (data12 && typeof data12 == "object" && !Array.isArray(data12)) {
                      if (data12.type === void 0 && "type") {
                        const err38 = {};
                        if (vErrors === null) {
                          vErrors = [err38];
                        } else {
                          vErrors.push(err38);
                        }
                        errors2++;
                      } else {
                        if (data12.type !== void 0) {
                          let data13 = data12.type;
                          if (!(data13 === "camunda:property" || data13 === "camunda:outputParameter" || data13 === "camunda:in" || data13 === "camunda:in:businessKey" || data13 === "camunda:out" || data13 === "camunda:errorEventDefinition")) {
                            const err39 = {};
                            if (vErrors === null) {
                              vErrors = [err39];
                            } else {
                              vErrors.push(err39);
                            }
                            errors2++;
                          }
                        }
                      }
                    }
                  }
                }
              }
              var _valid4 = _errs36 === errors2;
              errors2 = _errs35;
              if (vErrors !== null) {
                if (_errs35) {
                  vErrors.length = _errs35;
                } else {
                  vErrors = null;
                }
              }
              if (_valid4) {
                const _errs39 = errors2;
                if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                  if (data4.type !== void 0) {
                    let data14 = data4.type;
                    if (!(data14 === "String" || data14 === "Hidden" || data14 === "Dropdown")) {
                      const err40 = { keyword: "enum", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/3/then/properties/type/enum", params: { allowedValues: schema18.items.allOf[3].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                      if (vErrors === null) {
                        vErrors = [err40];
                      } else {
                        vErrors.push(err40);
                      }
                      errors2++;
                    }
                    if (errors2 > 0) {
                      const emErrs10 = [];
                      for (const err41 of vErrors) {
                        if (err41.keyword !== "errorMessage" && !err41.emUsed && (err41.dataPath === dataPath + "/" + i0 + "/properties/" + i1 + "/type" || err41.dataPath.indexOf(dataPath + "/" + i0 + "/properties/" + i1 + "/type") === 0 && err41.dataPath[dataPath + "/" + i0 + "/properties/" + i1 + "/type".length] === "/") && err41.schemaPath.indexOf("#/definitions/properties/items/allOf/3/then/properties/type") === 0 && err41.schemaPath["#/definitions/properties/items/allOf/3/then/properties/type".length] === "/") {
                          emErrs10.push(err41);
                          err41.emUsed = true;
                        }
                      }
                      if (emErrs10.length) {
                        const err42 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/3/then/properties/type/errorMessage", params: { errors: emErrs10 }, message: "invalid property type " + JSON.stringify(data14) + " for binding type " + JSON.stringify(data4 && data4.binding && data4.binding.type) + "; must be any of { String, Hidden, Dropdown }" };
                        if (vErrors === null) {
                          vErrors = [err42];
                        } else {
                          vErrors.push(err42);
                        }
                        errors2++;
                      }
                      const emErrs11 = [];
                      for (const err43 of vErrors) {
                        if (!err43.emUsed) {
                          emErrs11.push(err43);
                        }
                      }
                      vErrors = emErrs11;
                      errors2 = emErrs11.length;
                    }
                  }
                }
                var _valid4 = _errs39 === errors2;
                valid20 = _valid4;
              }
              if (!valid20) {
                const err44 = { keyword: "if", dataPath: dataPath + "/" + i0 + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/3/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err44];
                } else {
                  vErrors.push(err44);
                }
                errors2++;
              }
              const _errs42 = errors2;
              let valid24 = true;
              const _errs43 = errors2;
              if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                if (data4.binding === void 0 && "binding") {
                  const err45 = {};
                  if (vErrors === null) {
                    vErrors = [err45];
                  } else {
                    vErrors.push(err45);
                  }
                  errors2++;
                } else {
                  if (data4.binding !== void 0) {
                    let data15 = data4.binding;
                    if (data15 && typeof data15 == "object" && !Array.isArray(data15)) {
                      if (data15.type === void 0 && "type") {
                        const err46 = {};
                        if (vErrors === null) {
                          vErrors = [err46];
                        } else {
                          vErrors.push(err46);
                        }
                        errors2++;
                      } else {
                        if (data15.type !== void 0) {
                          let data16 = data15.type;
                          if (!(data16 === "camunda:inputParameter" || data16 === "camunda:field")) {
                            const err47 = {};
                            if (vErrors === null) {
                              vErrors = [err47];
                            } else {
                              vErrors.push(err47);
                            }
                            errors2++;
                          }
                        }
                      }
                    }
                  }
                }
              }
              var _valid5 = _errs43 === errors2;
              errors2 = _errs42;
              if (vErrors !== null) {
                if (_errs42) {
                  vErrors.length = _errs42;
                } else {
                  vErrors = null;
                }
              }
              if (_valid5) {
                const _errs46 = errors2;
                if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                  if (data4.type !== void 0) {
                    let data17 = data4.type;
                    if (!(data17 === "String" || data17 === "Text" || data17 === "Hidden" || data17 === "Dropdown")) {
                      const err48 = { keyword: "enum", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/4/then/properties/type/enum", params: { allowedValues: schema18.items.allOf[4].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                      if (vErrors === null) {
                        vErrors = [err48];
                      } else {
                        vErrors.push(err48);
                      }
                      errors2++;
                    }
                    if (errors2 > 0) {
                      const emErrs12 = [];
                      for (const err49 of vErrors) {
                        if (err49.keyword !== "errorMessage" && !err49.emUsed && (err49.dataPath === dataPath + "/" + i0 + "/properties/" + i1 + "/type" || err49.dataPath.indexOf(dataPath + "/" + i0 + "/properties/" + i1 + "/type") === 0 && err49.dataPath[dataPath + "/" + i0 + "/properties/" + i1 + "/type".length] === "/") && err49.schemaPath.indexOf("#/definitions/properties/items/allOf/4/then/properties/type") === 0 && err49.schemaPath["#/definitions/properties/items/allOf/4/then/properties/type".length] === "/") {
                          emErrs12.push(err49);
                          err49.emUsed = true;
                        }
                      }
                      if (emErrs12.length) {
                        const err50 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/4/then/properties/type/errorMessage", params: { errors: emErrs12 }, message: "invalid property type " + JSON.stringify(data17) + " for binding type " + JSON.stringify(data4 && data4.binding && data4.binding.type) + "; must be any of { String, Text, Hidden, Dropdown }" };
                        if (vErrors === null) {
                          vErrors = [err50];
                        } else {
                          vErrors.push(err50);
                        }
                        errors2++;
                      }
                      const emErrs13 = [];
                      for (const err51 of vErrors) {
                        if (!err51.emUsed) {
                          emErrs13.push(err51);
                        }
                      }
                      vErrors = emErrs13;
                      errors2 = emErrs13.length;
                    }
                  }
                }
                var _valid5 = _errs46 === errors2;
                valid24 = _valid5;
              }
              if (!valid24) {
                const err52 = { keyword: "if", dataPath: dataPath + "/" + i0 + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/4/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err52];
                } else {
                  vErrors.push(err52);
                }
                errors2++;
              }
              if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                if (data4.binding === void 0) {
                  const err53 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1, schemaPath: "#/definitions/properties/items/required", params: { missingProperty: "binding" }, message: "should have required property 'binding'" };
                  if (vErrors === null) {
                    vErrors = [err53];
                  } else {
                    vErrors.push(err53);
                  }
                  errors2++;
                }
                if (data4.value !== void 0) {
                  let data18 = data4.value;
                  if (typeof data18 !== "string" && typeof data18 !== "boolean") {
                    const err54 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/value", schemaPath: "#/definitions/properties/items/properties/value/type", params: { type: schema18.items.properties.value.type }, message: "should be string,boolean" };
                    if (vErrors === null) {
                      vErrors = [err54];
                    } else {
                      vErrors.push(err54);
                    }
                    errors2++;
                  }
                }
                if (data4.description !== void 0) {
                  if (typeof data4.description !== "string") {
                    const err55 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/description", schemaPath: "#/definitions/properties/items/properties/description/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err55];
                    } else {
                      vErrors.push(err55);
                    }
                    errors2++;
                  }
                }
                if (data4.label !== void 0) {
                  if (typeof data4.label !== "string") {
                    const err56 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/label", schemaPath: "#/definitions/properties/items/properties/label/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err56];
                    } else {
                      vErrors.push(err56);
                    }
                    errors2++;
                  }
                }
                if (data4.type !== void 0) {
                  if (typeof data4.type !== "string") {
                    const err57 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/properties/type/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err57];
                    } else {
                      vErrors.push(err57);
                    }
                    errors2++;
                  }
                }
                if (data4.editable !== void 0) {
                  if (typeof data4.editable !== "boolean") {
                    const err58 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/editable", schemaPath: "#/definitions/properties/items/properties/editable/type", params: { type: "boolean" }, message: "should be boolean" };
                    if (vErrors === null) {
                      vErrors = [err58];
                    } else {
                      vErrors.push(err58);
                    }
                    errors2++;
                  }
                }
                if (data4.choices !== void 0) {
                  let data23 = data4.choices;
                  if (Array.isArray(data23)) {
                    const len2 = data23.length;
                    for (let i2 = 0; i2 < len2; i2++) {
                      let data24 = data23[i2];
                      if (data24 && typeof data24 == "object" && !Array.isArray(data24)) {
                        if (data24.value === void 0) {
                          const err59 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/choices/" + i2, schemaPath: "#/definitions/properties/items/properties/choices/items/required", params: { missingProperty: "value" }, message: "should have required property 'value'" };
                          if (vErrors === null) {
                            vErrors = [err59];
                          } else {
                            vErrors.push(err59);
                          }
                          errors2++;
                        }
                        if (data24.name === void 0) {
                          const err60 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/choices/" + i2, schemaPath: "#/definitions/properties/items/properties/choices/items/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
                          if (vErrors === null) {
                            vErrors = [err60];
                          } else {
                            vErrors.push(err60);
                          }
                          errors2++;
                        }
                        if (data24.name !== void 0) {
                          if (typeof data24.name !== "string") {
                            const err61 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/choices/" + i2 + "/name", schemaPath: "#/definitions/properties/items/properties/choices/items/properties/name/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err61];
                            } else {
                              vErrors.push(err61);
                            }
                            errors2++;
                          }
                        }
                        if (data24.value !== void 0) {
                          if (typeof data24.value !== "string") {
                            const err62 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/choices/" + i2 + "/value", schemaPath: "#/definitions/properties/items/properties/choices/items/properties/value/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err62];
                            } else {
                              vErrors.push(err62);
                            }
                            errors2++;
                          }
                        }
                      } else {
                        const err63 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/choices/" + i2, schemaPath: "#/definitions/properties/items/properties/choices/items/type", params: { type: "object" }, message: "should be object" };
                        if (vErrors === null) {
                          vErrors = [err63];
                        } else {
                          vErrors.push(err63);
                        }
                        errors2++;
                      }
                      if (errors2 > 0) {
                        const emErrs14 = [];
                        for (const err64 of vErrors) {
                          if (err64.keyword !== "errorMessage" && !err64.emUsed && (err64.dataPath === dataPath + "/" + i0 + "/properties/" + i1 + "/choices/" + i2 || err64.dataPath.indexOf(dataPath + "/" + i0 + "/properties/" + i1 + "/choices/" + i2) === 0 && err64.dataPath[dataPath + "/" + i0 + "/properties/" + i1 + "/choices/" + i2.length] === "/") && err64.schemaPath.indexOf("#/definitions/properties/items/properties/choices/items") === 0 && err64.schemaPath["#/definitions/properties/items/properties/choices/items".length] === "/") {
                            emErrs14.push(err64);
                            err64.emUsed = true;
                          }
                        }
                        if (emErrs14.length) {
                          const err65 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/choices/" + i2, schemaPath: "#/definitions/properties/items/properties/choices/items/errorMessage", params: { errors: emErrs14 }, message: '{ name, value } must be specified for "Dropdown" choices' };
                          if (vErrors === null) {
                            vErrors = [err65];
                          } else {
                            vErrors.push(err65);
                          }
                          errors2++;
                        }
                        const emErrs15 = [];
                        for (const err66 of vErrors) {
                          if (!err66.emUsed) {
                            emErrs15.push(err66);
                          }
                        }
                        vErrors = emErrs15;
                        errors2 = emErrs15.length;
                      }
                    }
                  } else {
                    const err67 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/choices", schemaPath: "#/definitions/properties/items/properties/choices/type", params: { type: "array" }, message: "should be array" };
                    if (vErrors === null) {
                      vErrors = [err67];
                    } else {
                      vErrors.push(err67);
                    }
                    errors2++;
                  }
                }
                if (data4.binding !== void 0) {
                  let data27 = data4.binding;
                  const _errs69 = errors2;
                  let valid33 = true;
                  const _errs70 = errors2;
                  if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                    if (data27.type === void 0 && "type") {
                      const err68 = {};
                      if (vErrors === null) {
                        vErrors = [err68];
                      } else {
                        vErrors.push(err68);
                      }
                      errors2++;
                    } else {
                      if (data27.type !== void 0) {
                        let data28 = data27.type;
                        if (!(data28 === "property" || data28 === "camunda:property" || data28 === "camunda:inputParameter" || data28 === "camunda:field")) {
                          const err69 = {};
                          if (vErrors === null) {
                            vErrors = [err69];
                          } else {
                            vErrors.push(err69);
                          }
                          errors2++;
                        }
                      }
                    }
                  }
                  var _valid6 = _errs70 === errors2;
                  errors2 = _errs69;
                  if (vErrors !== null) {
                    if (_errs69) {
                      vErrors.length = _errs69;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid6) {
                    const _errs72 = errors2;
                    if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                      if (data27.name === void 0) {
                        const err70 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/0/then/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
                        if (vErrors === null) {
                          vErrors = [err70];
                        } else {
                          vErrors.push(err70);
                        }
                        errors2++;
                      }
                    }
                    if (errors2 > 0) {
                      const emErrs16 = [];
                      for (const err71 of vErrors) {
                        if (err71.keyword !== "errorMessage" && !err71.emUsed && (err71.dataPath === dataPath + "/" + i0 + "/properties/" + i1 + "/binding" || err71.dataPath.indexOf(dataPath + "/" + i0 + "/properties/" + i1 + "/binding") === 0 && err71.dataPath[dataPath + "/" + i0 + "/properties/" + i1 + "/binding".length] === "/") && err71.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/0/then") === 0 && err71.schemaPath["#/definitions/properties/items/properties/binding/allOf/0/then".length] === "/") {
                          emErrs16.push(err71);
                          err71.emUsed = true;
                        }
                      }
                      if (emErrs16.length) {
                        const err72 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/0/then/errorMessage", params: { errors: emErrs16 }, message: "property.binding " + JSON.stringify(data27 && data27.type) + " requires name" };
                        if (vErrors === null) {
                          vErrors = [err72];
                        } else {
                          vErrors.push(err72);
                        }
                        errors2++;
                      }
                      const emErrs17 = [];
                      for (const err73 of vErrors) {
                        if (!err73.emUsed) {
                          emErrs17.push(err73);
                        }
                      }
                      vErrors = emErrs17;
                      errors2 = emErrs17.length;
                    }
                    var _valid6 = _errs72 === errors2;
                    valid33 = _valid6;
                  }
                  if (!valid33) {
                    const err74 = { keyword: "if", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err74];
                    } else {
                      vErrors.push(err74);
                    }
                    errors2++;
                  }
                  const _errs74 = errors2;
                  let valid35 = true;
                  const _errs75 = errors2;
                  if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                    if (data27.type === void 0 && "type") {
                      const err75 = {};
                      if (vErrors === null) {
                        vErrors = [err75];
                      } else {
                        vErrors.push(err75);
                      }
                      errors2++;
                    } else {
                      if (data27.type !== void 0) {
                        if (!equal(data27.type, "camunda:outputParameter")) {
                          const err76 = {};
                          if (vErrors === null) {
                            vErrors = [err76];
                          } else {
                            vErrors.push(err76);
                          }
                          errors2++;
                        }
                      }
                    }
                  }
                  var _valid7 = _errs75 === errors2;
                  errors2 = _errs74;
                  if (vErrors !== null) {
                    if (_errs74) {
                      vErrors.length = _errs74;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid7) {
                    const _errs77 = errors2;
                    if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                      if (data27.source === void 0) {
                        const err77 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/1/then/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                        if (vErrors === null) {
                          vErrors = [err77];
                        } else {
                          vErrors.push(err77);
                        }
                        errors2++;
                      }
                    }
                    if (errors2 > 0) {
                      const emErrs18 = [];
                      for (const err78 of vErrors) {
                        if (err78.keyword !== "errorMessage" && !err78.emUsed && (err78.dataPath === dataPath + "/" + i0 + "/properties/" + i1 + "/binding" || err78.dataPath.indexOf(dataPath + "/" + i0 + "/properties/" + i1 + "/binding") === 0 && err78.dataPath[dataPath + "/" + i0 + "/properties/" + i1 + "/binding".length] === "/") && err78.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/1/then") === 0 && err78.schemaPath["#/definitions/properties/items/properties/binding/allOf/1/then".length] === "/") {
                          emErrs18.push(err78);
                          err78.emUsed = true;
                        }
                      }
                      if (emErrs18.length) {
                        const err79 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/1/then/errorMessage", params: { errors: emErrs18 }, message: "property.binding " + JSON.stringify(data27 && data27.type) + " requires source" };
                        if (vErrors === null) {
                          vErrors = [err79];
                        } else {
                          vErrors.push(err79);
                        }
                        errors2++;
                      }
                      const emErrs19 = [];
                      for (const err80 of vErrors) {
                        if (!err80.emUsed) {
                          emErrs19.push(err80);
                        }
                      }
                      vErrors = emErrs19;
                      errors2 = emErrs19.length;
                    }
                    var _valid7 = _errs77 === errors2;
                    valid35 = _valid7;
                  }
                  if (!valid35) {
                    const err81 = { keyword: "if", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/1/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err81];
                    } else {
                      vErrors.push(err81);
                    }
                    errors2++;
                  }
                  const _errs79 = errors2;
                  let valid37 = true;
                  const _errs80 = errors2;
                  if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                    if (data27.type === void 0 && "type") {
                      const err82 = {};
                      if (vErrors === null) {
                        vErrors = [err82];
                      } else {
                        vErrors.push(err82);
                      }
                      errors2++;
                    } else {
                      if (data27.type !== void 0) {
                        if (!equal(data27.type, "camunda:in")) {
                          const err83 = {};
                          if (vErrors === null) {
                            vErrors = [err83];
                          } else {
                            vErrors.push(err83);
                          }
                          errors2++;
                        }
                      }
                    }
                  }
                  var _valid8 = _errs80 === errors2;
                  errors2 = _errs79;
                  if (vErrors !== null) {
                    if (_errs79) {
                      vErrors.length = _errs79;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid8) {
                    const _errs82 = errors2;
                    const _errs83 = errors2;
                    let valid39 = false;
                    const _errs84 = errors2;
                    if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                      if (data27.variables === void 0) {
                        const err84 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/then/anyOf/0/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                        if (vErrors === null) {
                          vErrors = [err84];
                        } else {
                          vErrors.push(err84);
                        }
                        errors2++;
                      }
                    }
                    var _valid9 = _errs84 === errors2;
                    valid39 = valid39 || _valid9;
                    if (!valid39) {
                      const _errs85 = errors2;
                      if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                        if (data27.target === void 0) {
                          const err85 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/then/anyOf/1/required", params: { missingProperty: "target" }, message: "should have required property 'target'" };
                          if (vErrors === null) {
                            vErrors = [err85];
                          } else {
                            vErrors.push(err85);
                          }
                          errors2++;
                        }
                      }
                      var _valid9 = _errs85 === errors2;
                      valid39 = valid39 || _valid9;
                    }
                    if (!valid39) {
                      const err86 = { keyword: "anyOf", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/then/anyOf", params: {}, message: "should match some schema in anyOf" };
                      if (vErrors === null) {
                        vErrors = [err86];
                      } else {
                        vErrors.push(err86);
                      }
                      errors2++;
                    } else {
                      errors2 = _errs83;
                      if (vErrors !== null) {
                        if (_errs83) {
                          vErrors.length = _errs83;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    if (errors2 > 0) {
                      const emErrs20 = [];
                      for (const err87 of vErrors) {
                        if (err87.keyword !== "errorMessage" && !err87.emUsed && (err87.dataPath === dataPath + "/" + i0 + "/properties/" + i1 + "/binding" || err87.dataPath.indexOf(dataPath + "/" + i0 + "/properties/" + i1 + "/binding") === 0 && err87.dataPath[dataPath + "/" + i0 + "/properties/" + i1 + "/binding".length] === "/") && err87.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/2/then") === 0 && err87.schemaPath["#/definitions/properties/items/properties/binding/allOf/2/then".length] === "/") {
                          emErrs20.push(err87);
                          err87.emUsed = true;
                        }
                      }
                      if (emErrs20.length) {
                        const err88 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/then/errorMessage", params: { errors: emErrs20 }, message: "property.binding " + JSON.stringify(data27 && data27.type) + " requires variables, target, or both" };
                        if (vErrors === null) {
                          vErrors = [err88];
                        } else {
                          vErrors.push(err88);
                        }
                        errors2++;
                      }
                      const emErrs21 = [];
                      for (const err89 of vErrors) {
                        if (!err89.emUsed) {
                          emErrs21.push(err89);
                        }
                      }
                      vErrors = emErrs21;
                      errors2 = emErrs21.length;
                    }
                    var _valid8 = _errs82 === errors2;
                    valid37 = _valid8;
                  }
                  if (!valid37) {
                    const err90 = { keyword: "if", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err90];
                    } else {
                      vErrors.push(err90);
                    }
                    errors2++;
                  }
                  const _errs87 = errors2;
                  let valid40 = true;
                  const _errs88 = errors2;
                  if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                    if (data27.type === void 0 && "type") {
                      const err91 = {};
                      if (vErrors === null) {
                        vErrors = [err91];
                      } else {
                        vErrors.push(err91);
                      }
                      errors2++;
                    } else {
                      if (data27.type !== void 0) {
                        if (!equal(data27.type, "camunda:out")) {
                          const err92 = {};
                          if (vErrors === null) {
                            vErrors = [err92];
                          } else {
                            vErrors.push(err92);
                          }
                          errors2++;
                        }
                      }
                    }
                  }
                  var _valid10 = _errs88 === errors2;
                  errors2 = _errs87;
                  if (vErrors !== null) {
                    if (_errs87) {
                      vErrors.length = _errs87;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid10) {
                    const _errs90 = errors2;
                    const _errs91 = errors2;
                    let valid42 = false;
                    let passing0 = null;
                    const _errs92 = errors2;
                    const _errs93 = errors2;
                    const _errs94 = errors2;
                    const _errs95 = errors2;
                    let valid44 = false;
                    const _errs96 = errors2;
                    if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                      if (data27.source === void 0 && "source") {
                        const err93 = {};
                        if (vErrors === null) {
                          vErrors = [err93];
                        } else {
                          vErrors.push(err93);
                        }
                        errors2++;
                      }
                    }
                    var _valid12 = _errs96 === errors2;
                    valid44 = valid44 || _valid12;
                    if (!valid44) {
                      const _errs97 = errors2;
                      if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                        if (data27.sourceExpression === void 0 && "sourceExpression") {
                          const err94 = {};
                          if (vErrors === null) {
                            vErrors = [err94];
                          } else {
                            vErrors.push(err94);
                          }
                          errors2++;
                        }
                      }
                      var _valid12 = _errs97 === errors2;
                      valid44 = valid44 || _valid12;
                    }
                    if (!valid44) {
                      const err95 = {};
                      if (vErrors === null) {
                        vErrors = [err95];
                      } else {
                        vErrors.push(err95);
                      }
                      errors2++;
                    } else {
                      errors2 = _errs95;
                      if (vErrors !== null) {
                        if (_errs95) {
                          vErrors.length = _errs95;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    var valid43 = _errs94 === errors2;
                    if (!valid43) {
                      errors2 = _errs93;
                      if (vErrors !== null) {
                        if (_errs93) {
                          vErrors.length = _errs93;
                        } else {
                          vErrors = null;
                        }
                      }
                    } else {
                      const err96 = { keyword: "not", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/0/not", params: {}, message: "should NOT be valid" };
                      if (vErrors === null) {
                        vErrors = [err96];
                      } else {
                        vErrors.push(err96);
                      }
                      errors2++;
                    }
                    if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                      if (data27.variables === void 0) {
                        const err97 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/0/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                        if (vErrors === null) {
                          vErrors = [err97];
                        } else {
                          vErrors.push(err97);
                        }
                        errors2++;
                      }
                    }
                    var _valid11 = _errs92 === errors2;
                    if (_valid11) {
                      valid42 = true;
                      passing0 = 0;
                    }
                    const _errs98 = errors2;
                    const _errs99 = errors2;
                    const _errs100 = errors2;
                    const _errs101 = errors2;
                    let valid46 = false;
                    const _errs102 = errors2;
                    if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                      if (data27.variables === void 0 && "variables") {
                        const err98 = {};
                        if (vErrors === null) {
                          vErrors = [err98];
                        } else {
                          vErrors.push(err98);
                        }
                        errors2++;
                      }
                    }
                    var _valid13 = _errs102 === errors2;
                    valid46 = valid46 || _valid13;
                    if (!valid46) {
                      const _errs103 = errors2;
                      if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                        if (data27.sourceExpression === void 0 && "sourceExpression") {
                          const err99 = {};
                          if (vErrors === null) {
                            vErrors = [err99];
                          } else {
                            vErrors.push(err99);
                          }
                          errors2++;
                        }
                      }
                      var _valid13 = _errs103 === errors2;
                      valid46 = valid46 || _valid13;
                    }
                    if (!valid46) {
                      const err100 = {};
                      if (vErrors === null) {
                        vErrors = [err100];
                      } else {
                        vErrors.push(err100);
                      }
                      errors2++;
                    } else {
                      errors2 = _errs101;
                      if (vErrors !== null) {
                        if (_errs101) {
                          vErrors.length = _errs101;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    var valid45 = _errs100 === errors2;
                    if (!valid45) {
                      errors2 = _errs99;
                      if (vErrors !== null) {
                        if (_errs99) {
                          vErrors.length = _errs99;
                        } else {
                          vErrors = null;
                        }
                      }
                    } else {
                      const err101 = { keyword: "not", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/1/not", params: {}, message: "should NOT be valid" };
                      if (vErrors === null) {
                        vErrors = [err101];
                      } else {
                        vErrors.push(err101);
                      }
                      errors2++;
                    }
                    if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                      if (data27.source === void 0) {
                        const err102 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/1/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                        if (vErrors === null) {
                          vErrors = [err102];
                        } else {
                          vErrors.push(err102);
                        }
                        errors2++;
                      }
                    }
                    var _valid11 = _errs98 === errors2;
                    if (_valid11 && valid42) {
                      valid42 = false;
                      passing0 = [passing0, 1];
                    } else {
                      if (_valid11) {
                        valid42 = true;
                        passing0 = 1;
                      }
                      const _errs104 = errors2;
                      const _errs105 = errors2;
                      const _errs106 = errors2;
                      const _errs107 = errors2;
                      let valid48 = false;
                      const _errs108 = errors2;
                      if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                        if (data27.variables === void 0 && "variables") {
                          const err103 = {};
                          if (vErrors === null) {
                            vErrors = [err103];
                          } else {
                            vErrors.push(err103);
                          }
                          errors2++;
                        }
                      }
                      var _valid14 = _errs108 === errors2;
                      valid48 = valid48 || _valid14;
                      if (!valid48) {
                        const _errs109 = errors2;
                        if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                          if (data27.source === void 0 && "source") {
                            const err104 = {};
                            if (vErrors === null) {
                              vErrors = [err104];
                            } else {
                              vErrors.push(err104);
                            }
                            errors2++;
                          }
                        }
                        var _valid14 = _errs109 === errors2;
                        valid48 = valid48 || _valid14;
                      }
                      if (!valid48) {
                        const err105 = {};
                        if (vErrors === null) {
                          vErrors = [err105];
                        } else {
                          vErrors.push(err105);
                        }
                        errors2++;
                      } else {
                        errors2 = _errs107;
                        if (vErrors !== null) {
                          if (_errs107) {
                            vErrors.length = _errs107;
                          } else {
                            vErrors = null;
                          }
                        }
                      }
                      var valid47 = _errs106 === errors2;
                      if (!valid47) {
                        errors2 = _errs105;
                        if (vErrors !== null) {
                          if (_errs105) {
                            vErrors.length = _errs105;
                          } else {
                            vErrors = null;
                          }
                        }
                      } else {
                        const err106 = { keyword: "not", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/2/not", params: {}, message: "should NOT be valid" };
                        if (vErrors === null) {
                          vErrors = [err106];
                        } else {
                          vErrors.push(err106);
                        }
                        errors2++;
                      }
                      if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                        if (data27.sourceExpression === void 0) {
                          const err107 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/2/required", params: { missingProperty: "sourceExpression" }, message: "should have required property 'sourceExpression'" };
                          if (vErrors === null) {
                            vErrors = [err107];
                          } else {
                            vErrors.push(err107);
                          }
                          errors2++;
                        }
                      }
                      var _valid11 = _errs104 === errors2;
                      if (_valid11 && valid42) {
                        valid42 = false;
                        passing0 = [passing0, 2];
                      } else {
                        if (_valid11) {
                          valid42 = true;
                          passing0 = 2;
                        }
                        const _errs110 = errors2;
                        const _errs111 = errors2;
                        const _errs112 = errors2;
                        if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                          if (data27.source === void 0 && "source") {
                            const err108 = {};
                            if (vErrors === null) {
                              vErrors = [err108];
                            } else {
                              vErrors.push(err108);
                            }
                            errors2++;
                          }
                        }
                        var valid49 = _errs112 === errors2;
                        if (!valid49) {
                          errors2 = _errs111;
                          if (vErrors !== null) {
                            if (_errs111) {
                              vErrors.length = _errs111;
                            } else {
                              vErrors = null;
                            }
                          }
                        } else {
                          const err109 = { keyword: "not", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/3/not", params: {}, message: "should NOT be valid" };
                          if (vErrors === null) {
                            vErrors = [err109];
                          } else {
                            vErrors.push(err109);
                          }
                          errors2++;
                        }
                        if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                          if (data27.variables === void 0) {
                            const err110 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/3/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                            if (vErrors === null) {
                              vErrors = [err110];
                            } else {
                              vErrors.push(err110);
                            }
                            errors2++;
                          }
                          if (data27.sourceExpression === void 0) {
                            const err111 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/3/required", params: { missingProperty: "sourceExpression" }, message: "should have required property 'sourceExpression'" };
                            if (vErrors === null) {
                              vErrors = [err111];
                            } else {
                              vErrors.push(err111);
                            }
                            errors2++;
                          }
                        }
                        var _valid11 = _errs110 === errors2;
                        if (_valid11 && valid42) {
                          valid42 = false;
                          passing0 = [passing0, 3];
                        } else {
                          if (_valid11) {
                            valid42 = true;
                            passing0 = 3;
                          }
                          const _errs113 = errors2;
                          const _errs114 = errors2;
                          const _errs115 = errors2;
                          if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                            if (data27.sourceExpression === void 0 && "sourceExpression") {
                              const err112 = {};
                              if (vErrors === null) {
                                vErrors = [err112];
                              } else {
                                vErrors.push(err112);
                              }
                              errors2++;
                            }
                          }
                          var valid50 = _errs115 === errors2;
                          if (!valid50) {
                            errors2 = _errs114;
                            if (vErrors !== null) {
                              if (_errs114) {
                                vErrors.length = _errs114;
                              } else {
                                vErrors = null;
                              }
                            }
                          } else {
                            const err113 = { keyword: "not", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/4/not", params: {}, message: "should NOT be valid" };
                            if (vErrors === null) {
                              vErrors = [err113];
                            } else {
                              vErrors.push(err113);
                            }
                            errors2++;
                          }
                          if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                            if (data27.variables === void 0) {
                              const err114 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/4/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                              if (vErrors === null) {
                                vErrors = [err114];
                              } else {
                                vErrors.push(err114);
                              }
                              errors2++;
                            }
                            if (data27.source === void 0) {
                              const err115 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/4/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                              if (vErrors === null) {
                                vErrors = [err115];
                              } else {
                                vErrors.push(err115);
                              }
                              errors2++;
                            }
                          }
                          var _valid11 = _errs113 === errors2;
                          if (_valid11 && valid42) {
                            valid42 = false;
                            passing0 = [passing0, 4];
                          } else {
                            if (_valid11) {
                              valid42 = true;
                              passing0 = 4;
                            }
                          }
                        }
                      }
                    }
                    if (!valid42) {
                      const err116 = { keyword: "oneOf", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf", params: { passingSchemas: passing0 }, message: "should match exactly one schema in oneOf" };
                      if (vErrors === null) {
                        vErrors = [err116];
                      } else {
                        vErrors.push(err116);
                      }
                      errors2++;
                    } else {
                      errors2 = _errs91;
                      if (vErrors !== null) {
                        if (_errs91) {
                          vErrors.length = _errs91;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    if (errors2 > 0) {
                      const emErrs22 = [];
                      for (const err117 of vErrors) {
                        if (err117.keyword !== "errorMessage" && !err117.emUsed && (err117.dataPath === dataPath + "/" + i0 + "/properties/" + i1 + "/binding" || err117.dataPath.indexOf(dataPath + "/" + i0 + "/properties/" + i1 + "/binding") === 0 && err117.dataPath[dataPath + "/" + i0 + "/properties/" + i1 + "/binding".length] === "/") && err117.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/3/then") === 0 && err117.schemaPath["#/definitions/properties/items/properties/binding/allOf/3/then".length] === "/") {
                          emErrs22.push(err117);
                          err117.emUsed = true;
                        }
                      }
                      if (emErrs22.length) {
                        const err118 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/errorMessage", params: { errors: emErrs22 }, message: "property.binding " + JSON.stringify(data27 && data27.type) + " requires one of the following: variables, sourceExpression, source, (sourceExpression and variables), or (source and variables)" };
                        if (vErrors === null) {
                          vErrors = [err118];
                        } else {
                          vErrors.push(err118);
                        }
                        errors2++;
                      }
                      const emErrs23 = [];
                      for (const err119 of vErrors) {
                        if (!err119.emUsed) {
                          emErrs23.push(err119);
                        }
                      }
                      vErrors = emErrs23;
                      errors2 = emErrs23.length;
                    }
                    var _valid10 = _errs90 === errors2;
                    valid40 = _valid10;
                  }
                  if (!valid40) {
                    const err120 = { keyword: "if", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err120];
                    } else {
                      vErrors.push(err120);
                    }
                    errors2++;
                  }
                  const _errs117 = errors2;
                  let valid51 = true;
                  const _errs118 = errors2;
                  if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                    if (data27.type === void 0 && "type") {
                      const err121 = {};
                      if (vErrors === null) {
                        vErrors = [err121];
                      } else {
                        vErrors.push(err121);
                      }
                      errors2++;
                    } else {
                      if (data27.type !== void 0) {
                        if (!equal(data27.type, "camunda:errorEventDefinition")) {
                          const err122 = {};
                          if (vErrors === null) {
                            vErrors = [err122];
                          } else {
                            vErrors.push(err122);
                          }
                          errors2++;
                        }
                      }
                    }
                  }
                  var _valid15 = _errs118 === errors2;
                  errors2 = _errs117;
                  if (vErrors !== null) {
                    if (_errs117) {
                      vErrors.length = _errs117;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid15) {
                    const _errs120 = errors2;
                    const _errs121 = errors2;
                    let valid53 = false;
                    let passing1 = null;
                    const _errs122 = errors2;
                    if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                      if (data27.errorRef === void 0) {
                        const err123 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/4/then/oneOf/0/required", params: { missingProperty: "errorRef" }, message: "should have required property 'errorRef'" };
                        if (vErrors === null) {
                          vErrors = [err123];
                        } else {
                          vErrors.push(err123);
                        }
                        errors2++;
                      }
                    }
                    var _valid16 = _errs122 === errors2;
                    if (_valid16) {
                      valid53 = true;
                      passing1 = 0;
                    }
                    if (!valid53) {
                      const err124 = { keyword: "oneOf", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/4/then/oneOf", params: { passingSchemas: passing1 }, message: "should match exactly one schema in oneOf" };
                      if (vErrors === null) {
                        vErrors = [err124];
                      } else {
                        vErrors.push(err124);
                      }
                      errors2++;
                    } else {
                      errors2 = _errs121;
                      if (vErrors !== null) {
                        if (_errs121) {
                          vErrors.length = _errs121;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    if (errors2 > 0) {
                      const emErrs24 = [];
                      for (const err125 of vErrors) {
                        if (err125.keyword !== "errorMessage" && !err125.emUsed && (err125.dataPath === dataPath + "/" + i0 + "/properties/" + i1 + "/binding" || err125.dataPath.indexOf(dataPath + "/" + i0 + "/properties/" + i1 + "/binding") === 0 && err125.dataPath[dataPath + "/" + i0 + "/properties/" + i1 + "/binding".length] === "/") && err125.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/4/then") === 0 && err125.schemaPath["#/definitions/properties/items/properties/binding/allOf/4/then".length] === "/") {
                          emErrs24.push(err125);
                          err125.emUsed = true;
                        }
                      }
                      if (emErrs24.length) {
                        const err126 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/4/then/errorMessage", params: { errors: emErrs24 }, message: "property.binding " + JSON.stringify(data27 && data27.type) + " requires errorRef" };
                        if (vErrors === null) {
                          vErrors = [err126];
                        } else {
                          vErrors.push(err126);
                        }
                        errors2++;
                      }
                      const emErrs25 = [];
                      for (const err127 of vErrors) {
                        if (!err127.emUsed) {
                          emErrs25.push(err127);
                        }
                      }
                      vErrors = emErrs25;
                      errors2 = emErrs25.length;
                    }
                    var _valid15 = _errs120 === errors2;
                    valid51 = _valid15;
                  }
                  if (!valid51) {
                    const err128 = { keyword: "if", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/4/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err128];
                    } else {
                      vErrors.push(err128);
                    }
                    errors2++;
                  }
                  if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                    if (data27.type === void 0) {
                      const err129 = { keyword: "required", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/required", params: { missingProperty: "type" }, message: "should have required property 'type'" };
                      if (vErrors === null) {
                        vErrors = [err129];
                      } else {
                        vErrors.push(err129);
                      }
                      errors2++;
                    }
                    if (data27.type !== void 0) {
                      let data33 = data27.type;
                      if (typeof data33 !== "string") {
                        const err130 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding/type", schemaPath: "#/definitions/properties/items/properties/binding/properties/type/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err130];
                        } else {
                          vErrors.push(err130);
                        }
                        errors2++;
                      }
                      if (!(data33 === "property" || data33 === "camunda:property" || data33 === "camunda:inputParameter" || data33 === "camunda:outputParameter" || data33 === "camunda:in" || data33 === "camunda:out" || data33 === "camunda:in:businessKey" || data33 === "camunda:executionListener" || data33 === "camunda:field" || data33 === "camunda:errorEventDefinition")) {
                        const err131 = { keyword: "enum", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding/type", schemaPath: "#/definitions/properties/items/properties/binding/properties/type/enum", params: { allowedValues: schema18.items.properties.binding.properties.type.enum }, message: "should be equal to one of the allowed values" };
                        if (vErrors === null) {
                          vErrors = [err131];
                        } else {
                          vErrors.push(err131);
                        }
                        errors2++;
                      }
                      if (errors2 > 0) {
                        const emErrs26 = [];
                        for (const err132 of vErrors) {
                          if (err132.keyword !== "errorMessage" && !err132.emUsed && (err132.dataPath === dataPath + "/" + i0 + "/properties/" + i1 + "/binding/type" || err132.dataPath.indexOf(dataPath + "/" + i0 + "/properties/" + i1 + "/binding/type") === 0 && err132.dataPath[dataPath + "/" + i0 + "/properties/" + i1 + "/binding/type".length] === "/") && err132.schemaPath.indexOf("#/definitions/properties/items/properties/binding/properties/type") === 0 && err132.schemaPath["#/definitions/properties/items/properties/binding/properties/type".length] === "/") {
                            emErrs26.push(err132);
                            err132.emUsed = true;
                          }
                        }
                        if (emErrs26.length) {
                          const err133 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding/type", schemaPath: "#/definitions/properties/items/properties/binding/properties/type/errorMessage", params: { errors: emErrs26 }, message: "invalid property.binding type " + JSON.stringify(data33) + "; must be any of { property, camunda:property, camunda:inputParameter, camunda:outputParameter, camunda:in, camunda:out, camunda:in:businessKey, camunda:executionListener, camunda:field, camunda:errorEventDefinition }" };
                          if (vErrors === null) {
                            vErrors = [err133];
                          } else {
                            vErrors.push(err133);
                          }
                          errors2++;
                        }
                        const emErrs27 = [];
                        for (const err134 of vErrors) {
                          if (!err134.emUsed) {
                            emErrs27.push(err134);
                          }
                        }
                        vErrors = emErrs27;
                        errors2 = emErrs27.length;
                      }
                    }
                    if (data27.name !== void 0) {
                      if (typeof data27.name !== "string") {
                        const err135 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding/name", schemaPath: "#/definitions/properties/items/properties/binding/properties/name/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err135];
                        } else {
                          vErrors.push(err135);
                        }
                        errors2++;
                      }
                    }
                    if (data27.event !== void 0) {
                      if (typeof data27.event !== "string") {
                        const err136 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding/event", schemaPath: "#/definitions/properties/items/properties/binding/properties/event/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err136];
                        } else {
                          vErrors.push(err136);
                        }
                        errors2++;
                      }
                    }
                    if (data27.scriptFormat !== void 0) {
                      if (typeof data27.scriptFormat !== "string") {
                        const err137 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding/scriptFormat", schemaPath: "#/definitions/properties/items/properties/binding/properties/scriptFormat/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err137];
                        } else {
                          vErrors.push(err137);
                        }
                        errors2++;
                      }
                    }
                    if (data27.source !== void 0) {
                      if (typeof data27.source !== "string") {
                        const err138 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding/source", schemaPath: "#/definitions/properties/items/properties/binding/properties/source/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err138];
                        } else {
                          vErrors.push(err138);
                        }
                        errors2++;
                      }
                    }
                    if (data27.target !== void 0) {
                      if (typeof data27.target !== "string") {
                        const err139 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding/target", schemaPath: "#/definitions/properties/items/properties/binding/properties/target/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err139];
                        } else {
                          vErrors.push(err139);
                        }
                        errors2++;
                      }
                    }
                    if (data27.expression !== void 0) {
                      if (typeof data27.expression !== "boolean") {
                        const err140 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding/expression", schemaPath: "#/definitions/properties/items/properties/binding/properties/expression/type", params: { type: "boolean" }, message: "should be boolean" };
                        if (vErrors === null) {
                          vErrors = [err140];
                        } else {
                          vErrors.push(err140);
                        }
                        errors2++;
                      }
                    }
                    if (data27.variables !== void 0) {
                      let data40 = data27.variables;
                      if (typeof data40 !== "string") {
                        const err141 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding/variables", schemaPath: "#/definitions/properties/items/properties/binding/properties/variables/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err141];
                        } else {
                          vErrors.push(err141);
                        }
                        errors2++;
                      }
                      if (!(data40 === "all" || data40 === "local")) {
                        const err142 = { keyword: "enum", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding/variables", schemaPath: "#/definitions/properties/items/properties/binding/properties/variables/enum", params: { allowedValues: schema18.items.properties.binding.properties.variables.enum }, message: "should be equal to one of the allowed values" };
                        if (vErrors === null) {
                          vErrors = [err142];
                        } else {
                          vErrors.push(err142);
                        }
                        errors2++;
                      }
                    }
                    if (data27.sourceExpression !== void 0) {
                      if (typeof data27.sourceExpression !== "string") {
                        const err143 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding/sourceExpression", schemaPath: "#/definitions/properties/items/properties/binding/properties/sourceExpression/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err143];
                        } else {
                          vErrors.push(err143);
                        }
                        errors2++;
                      }
                    }
                  } else {
                    const err144 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/type", params: { type: "object" }, message: "should be object" };
                    if (vErrors === null) {
                      vErrors = [err144];
                    } else {
                      vErrors.push(err144);
                    }
                    errors2++;
                  }
                }
                if (data4.constraints !== void 0) {
                  let data42 = data4.constraints;
                  if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
                    if (data42.notEmpty !== void 0) {
                      if (typeof data42.notEmpty !== "boolean") {
                        const err145 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/constraints/notEmpty", schemaPath: "#/definitions/properties/items/properties/constraints/properties/notEmpty/type", params: { type: "boolean" }, message: "should be boolean" };
                        if (vErrors === null) {
                          vErrors = [err145];
                        } else {
                          vErrors.push(err145);
                        }
                        errors2++;
                      }
                    }
                    if (data42.minLength !== void 0) {
                      if (!(typeof data42.minLength == "number")) {
                        const err146 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/constraints/minLength", schemaPath: "#/definitions/properties/items/properties/constraints/properties/minLength/type", params: { type: "number" }, message: "should be number" };
                        if (vErrors === null) {
                          vErrors = [err146];
                        } else {
                          vErrors.push(err146);
                        }
                        errors2++;
                      }
                    }
                    if (data42.maxLength !== void 0) {
                      if (!(typeof data42.maxLength == "number")) {
                        const err147 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/constraints/maxLength", schemaPath: "#/definitions/properties/items/properties/constraints/properties/maxLength/type", params: { type: "number" }, message: "should be number" };
                        if (vErrors === null) {
                          vErrors = [err147];
                        } else {
                          vErrors.push(err147);
                        }
                        errors2++;
                      }
                    }
                    if (data42.pattern !== void 0) {
                      let data46 = data42.pattern;
                      const _errs150 = errors2;
                      let valid56 = false;
                      let passing2 = null;
                      const _errs151 = errors2;
                      if (data46 && typeof data46 == "object" && !Array.isArray(data46)) {
                        if (data46.value !== void 0) {
                          if (typeof data46.value !== "string") {
                            const err148 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/constraints/pattern/value", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf/0/properties/value/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err148];
                            } else {
                              vErrors.push(err148);
                            }
                            errors2++;
                          }
                        }
                        if (data46.message !== void 0) {
                          if (typeof data46.message !== "string") {
                            const err149 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/constraints/pattern/message", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf/0/properties/message/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err149];
                            } else {
                              vErrors.push(err149);
                            }
                            errors2++;
                          }
                        }
                      } else {
                        const err150 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/constraints/pattern", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf/0/type", params: { type: "object" }, message: "should be object" };
                        if (vErrors === null) {
                          vErrors = [err150];
                        } else {
                          vErrors.push(err150);
                        }
                        errors2++;
                      }
                      var _valid17 = _errs151 === errors2;
                      if (_valid17) {
                        valid56 = true;
                        passing2 = 0;
                      }
                      const _errs157 = errors2;
                      if (typeof data46 !== "string") {
                        const err151 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/constraints/pattern", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf/1/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err151];
                        } else {
                          vErrors.push(err151);
                        }
                        errors2++;
                      }
                      var _valid17 = _errs157 === errors2;
                      if (_valid17 && valid56) {
                        valid56 = false;
                        passing2 = [passing2, 1];
                      } else {
                        if (_valid17) {
                          valid56 = true;
                          passing2 = 1;
                        }
                      }
                      if (!valid56) {
                        const err152 = { keyword: "oneOf", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/constraints/pattern", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf", params: { passingSchemas: passing2 }, message: "should match exactly one schema in oneOf" };
                        if (vErrors === null) {
                          vErrors = [err152];
                        } else {
                          vErrors.push(err152);
                        }
                        errors2++;
                      } else {
                        errors2 = _errs150;
                        if (vErrors !== null) {
                          if (_errs150) {
                            vErrors.length = _errs150;
                          } else {
                            vErrors = null;
                          }
                        }
                      }
                    }
                  } else {
                    const err153 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1 + "/constraints", schemaPath: "#/definitions/properties/items/properties/constraints/type", params: { type: "object" }, message: "should be object" };
                    if (vErrors === null) {
                      vErrors = [err153];
                    } else {
                      vErrors.push(err153);
                    }
                    errors2++;
                  }
                }
              } else {
                const err154 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties/" + i1, schemaPath: "#/definitions/properties/items/type", params: { type: "object" }, message: "should be object" };
                if (vErrors === null) {
                  vErrors = [err154];
                } else {
                  vErrors.push(err154);
                }
                errors2++;
              }
              if (errors2 > 0) {
                const emErrors0 = { "required": { "binding": [] } };
                const templates0 = { required: { binding: function() {
                  return 'missing binding for property "' + JSON.stringify(i1) + '"';
                } } };
                let emPropParams0;
                let emParamsErrors0;
                for (const err155 of vErrors) {
                  if (err155.keyword !== "errorMessage" && !err155.emUsed && err155.dataPath === dataPath + "/" + i0 + "/properties/" + i1 && err155.keyword in emErrors0 && err155.schemaPath.indexOf("#/definitions/properties/items") === 0 && /^\/[^\/]*$/.test(err155.schemaPath.slice(30))) {
                    emPropParams0 = obj0[err155.keyword];
                    emParamsErrors0 = emErrors0[err155.keyword][err155.params[emPropParams0]];
                    if (emParamsErrors0) {
                      emParamsErrors0.push(err155);
                      err155.emUsed = true;
                    }
                  }
                }
                for (const key0 in emErrors0) {
                  for (const keyProp0 in emErrors0[key0]) {
                    emParamsErrors0 = emErrors0[key0][keyProp0];
                    if (emParamsErrors0.length) {
                      const tmpl0 = templates0[key0] && templates0[key0][keyProp0];
                      const err156 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0 + "/properties/" + i1, schemaPath: "#/definitions/properties/items/errorMessage", params: { errors: emParamsErrors0 }, message: tmpl0 ? tmpl0() : schema18.items.errorMessage[key0][keyProp0] };
                      if (vErrors === null) {
                        vErrors = [err156];
                      } else {
                        vErrors.push(err156);
                      }
                      errors2++;
                    }
                  }
                }
                const emErrs28 = [];
                for (const err157 of vErrors) {
                  if (!err157.emUsed) {
                    emErrs28.push(err157);
                  }
                }
                vErrors = emErrs28;
                errors2 = emErrs28.length;
              }
            }
          } else {
            const err158 = { keyword: "type", dataPath: dataPath + "/" + i0 + "/properties", schemaPath: "#/definitions/properties/type", params: { type: "array" }, message: "should be array" };
            if (vErrors === null) {
              vErrors = [err158];
            } else {
              vErrors.push(err158);
            }
            errors2++;
          }
        }
      } else {
        const err159 = { keyword: "type", dataPath: dataPath + "/" + i0, schemaPath: "#/items/type", params: { type: "object" }, message: "should be object" };
        if (vErrors === null) {
          vErrors = [err159];
        } else {
          vErrors.push(err159);
        }
        errors2++;
      }
      if (errors2 > 0) {
        const emErrors1 = { "required": { "type": [], "properties": [] } };
        const templates1 = { required: { properties: function() {
          return "invalid scope " + JSON.stringify(data0 && data0.type) + ", missing properties=[]";
        } } };
        let emPropParams1;
        let emParamsErrors1;
        for (const err160 of vErrors) {
          if (err160.keyword !== "errorMessage" && !err160.emUsed && err160.dataPath === dataPath + "/" + i0 && err160.keyword in emErrors1 && err160.schemaPath.indexOf("#/items") === 0 && /^\/[^\/]*$/.test(err160.schemaPath.slice(7))) {
            emPropParams1 = obj0[err160.keyword];
            emParamsErrors1 = emErrors1[err160.keyword][err160.params[emPropParams1]];
            if (emParamsErrors1) {
              emParamsErrors1.push(err160);
              err160.emUsed = true;
            }
          }
        }
        for (const key1 in emErrors1) {
          for (const keyProp1 in emErrors1[key1]) {
            emParamsErrors1 = emErrors1[key1][keyProp1];
            if (emParamsErrors1.length) {
              const tmpl1 = templates1[key1] && templates1[key1][keyProp1];
              const err161 = { keyword: "errorMessage", dataPath: dataPath + "/" + i0, schemaPath: "#/items/errorMessage", params: { errors: emParamsErrors1 }, message: tmpl1 ? tmpl1() : schema21.items.errorMessage[key1][keyProp1] };
              if (vErrors === null) {
                vErrors = [err161];
              } else {
                vErrors.push(err161);
              }
              errors2++;
            }
          }
        }
        const emErrs29 = [];
        for (const err162 of vErrors) {
          if (!err162.emUsed) {
            emErrs29.push(err162);
          }
        }
        vErrors = emErrs29;
        errors2 = emErrs29.length;
      }
    }
  } else {
    const err163 = { keyword: "type", dataPath, schemaPath: "#/type", params: { type: "array" }, message: "should be array" };
    if (vErrors === null) {
      vErrors = [err163];
    } else {
      vErrors.push(err163);
    }
    errors2++;
  }
  validate18.errors = vErrors;
  return errors2 === 0;
}
function validate15(data, { dataPath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors2 = 0;
  if (data && typeof data == "object" && !Array.isArray(data)) {
    if (data.name === void 0) {
      const err0 = { keyword: "required", dataPath, schemaPath: "#/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }
      errors2++;
    }
    if (data.id === void 0) {
      const err1 = { keyword: "required", dataPath, schemaPath: "#/required", params: { missingProperty: "id" }, message: "should have required property 'id'" };
      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }
      errors2++;
    }
    if (data.appliesTo === void 0) {
      const err2 = { keyword: "required", dataPath, schemaPath: "#/required", params: { missingProperty: "appliesTo" }, message: "should have required property 'appliesTo'" };
      if (vErrors === null) {
        vErrors = [err2];
      } else {
        vErrors.push(err2);
      }
      errors2++;
    }
    if (data.properties === void 0) {
      const err3 = { keyword: "required", dataPath, schemaPath: "#/required", params: { missingProperty: "properties" }, message: "should have required property 'properties'" };
      if (vErrors === null) {
        vErrors = [err3];
      } else {
        vErrors.push(err3);
      }
      errors2++;
    }
    if (data.name !== void 0) {
      if (typeof data.name !== "string") {
        const err4 = { keyword: "type", dataPath: dataPath + "/name", schemaPath: "#/properties/name/type", params: { type: "string" }, message: "should be string" };
        if (vErrors === null) {
          vErrors = [err4];
        } else {
          vErrors.push(err4);
        }
        errors2++;
      }
    }
    if (data.id !== void 0) {
      if (typeof data.id !== "string") {
        const err5 = { keyword: "type", dataPath: dataPath + "/id", schemaPath: "#/properties/id/type", params: { type: "string" }, message: "should be string" };
        if (vErrors === null) {
          vErrors = [err5];
        } else {
          vErrors.push(err5);
        }
        errors2++;
      }
    }
    if (data.description !== void 0) {
      if (typeof data.description !== "string") {
        const err6 = { keyword: "type", dataPath: dataPath + "/description", schemaPath: "#/properties/description/type", params: { type: "string" }, message: "should be string" };
        if (vErrors === null) {
          vErrors = [err6];
        } else {
          vErrors.push(err6);
        }
        errors2++;
      }
    }
    if (data.version !== void 0) {
      if (!(typeof data.version == "number")) {
        const err7 = { keyword: "type", dataPath: dataPath + "/version", schemaPath: "#/properties/version/type", params: { type: "number" }, message: "should be number" };
        if (vErrors === null) {
          vErrors = [err7];
        } else {
          vErrors.push(err7);
        }
        errors2++;
      }
    }
    if (data.isDefault !== void 0) {
      if (typeof data.isDefault !== "boolean") {
        const err8 = { keyword: "type", dataPath: dataPath + "/isDefault", schemaPath: "#/properties/isDefault/type", params: { type: "boolean" }, message: "should be boolean" };
        if (vErrors === null) {
          vErrors = [err8];
        } else {
          vErrors.push(err8);
        }
        errors2++;
      }
    }
    if (data.appliesTo !== void 0) {
      let data5 = data.appliesTo;
      if (Array.isArray(data5)) {
        const len0 = data5.length;
        for (let i0 = 0; i0 < len0; i0++) {
          let data6 = data5[i0];
          if (typeof data6 === "string") {
            if (!pattern0.test(data6)) {
              const err9 = { keyword: "pattern", dataPath: dataPath + "/appliesTo/" + i0, schemaPath: "#/properties/appliesTo/items/pattern", params: { pattern: "^(.*?:)" }, message: 'should match pattern "^(.*?:)"' };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors2++;
            }
          } else {
            const err10 = { keyword: "type", dataPath: dataPath + "/appliesTo/" + i0, schemaPath: "#/properties/appliesTo/items/type", params: { type: "string" }, message: "should be string" };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors2++;
          }
          if (errors2 > 0) {
            const emErrors0 = { "pattern": [] };
            const templates0 = {};
            for (const err11 of vErrors) {
              if (err11.keyword !== "errorMessage" && !err11.emUsed && err11.dataPath === dataPath + "/appliesTo/" + i0 && err11.keyword in emErrors0 && err11.schemaPath.indexOf("#/properties/appliesTo/items") === 0 && /^\/[^\/]*$/.test(err11.schemaPath.slice(28))) {
                emErrors0[err11.keyword].push(err11);
                err11.emUsed = true;
              }
            }
            for (const key0 in emErrors0) {
              if (emErrors0[key0].length) {
                const err12 = { keyword: "errorMessage", dataPath: dataPath + "/appliesTo/" + i0, schemaPath: "#/properties/appliesTo/items/errorMessage", params: { errors: emErrors0[key0] }, message: key0 in templates0 ? templates0[key0]() : schema17.properties.appliesTo.items.errorMessage[key0] };
                if (vErrors === null) {
                  vErrors = [err12];
                } else {
                  vErrors.push(err12);
                }
                errors2++;
              }
            }
            const emErrs0 = [];
            for (const err13 of vErrors) {
              if (!err13.emUsed) {
                emErrs0.push(err13);
              }
            }
            vErrors = emErrs0;
            errors2 = emErrs0.length;
          }
        }
      } else {
        const err14 = { keyword: "type", dataPath: dataPath + "/appliesTo", schemaPath: "#/properties/appliesTo/type", params: { type: "array" }, message: "should be array" };
        if (vErrors === null) {
          vErrors = [err14];
        } else {
          vErrors.push(err14);
        }
        errors2++;
      }
    }
    if (data.properties !== void 0) {
      let data7 = data.properties;
      if (Array.isArray(data7)) {
        const len1 = data7.length;
        for (let i1 = 0; i1 < len1; i1++) {
          let data8 = data7[i1];
          const _errs21 = errors2;
          let valid7 = true;
          const _errs22 = errors2;
          if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
            if (data8.type === void 0 && "type") {
              const err15 = {};
              if (vErrors === null) {
                vErrors = [err15];
              } else {
                vErrors.push(err15);
              }
              errors2++;
            } else {
              if (data8.type !== void 0) {
                if (!equal(data8.type, "Dropdown")) {
                  const err16 = {};
                  if (vErrors === null) {
                    vErrors = [err16];
                  } else {
                    vErrors.push(err16);
                  }
                  errors2++;
                }
              }
            }
          }
          var _valid0 = _errs22 === errors2;
          errors2 = _errs21;
          if (vErrors !== null) {
            if (_errs21) {
              vErrors.length = _errs21;
            } else {
              vErrors = null;
            }
          }
          if (_valid0) {
            const _errs24 = errors2;
            if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
              if (data8.choices === void 0) {
                const err17 = { keyword: "required", dataPath: dataPath + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/0/then/required", params: { missingProperty: "choices" }, message: "should have required property 'choices'" };
                if (vErrors === null) {
                  vErrors = [err17];
                } else {
                  vErrors.push(err17);
                }
                errors2++;
              }
            }
            if (errors2 > 0) {
              const emErrs1 = [];
              for (const err18 of vErrors) {
                if (err18.keyword !== "errorMessage" && !err18.emUsed && (err18.dataPath === dataPath + "/properties/" + i1 || err18.dataPath.indexOf(dataPath + "/properties/" + i1) === 0 && err18.dataPath[dataPath + "/properties/" + i1.length] === "/") && err18.schemaPath.indexOf("#/definitions/properties/items/allOf/0/then") === 0 && err18.schemaPath["#/definitions/properties/items/allOf/0/then".length] === "/") {
                  emErrs1.push(err18);
                  err18.emUsed = true;
                }
              }
              if (emErrs1.length) {
                const err19 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/0/then/errorMessage", params: { errors: emErrs1 }, message: 'must provide choices=[] with "Dropdown" type' };
                if (vErrors === null) {
                  vErrors = [err19];
                } else {
                  vErrors.push(err19);
                }
                errors2++;
              }
              const emErrs2 = [];
              for (const err20 of vErrors) {
                if (!err20.emUsed) {
                  emErrs2.push(err20);
                }
              }
              vErrors = emErrs2;
              errors2 = emErrs2.length;
            }
            var _valid0 = _errs24 === errors2;
            valid7 = _valid0;
          }
          if (!valid7) {
            const err21 = { keyword: "if", dataPath: dataPath + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err21];
            } else {
              vErrors.push(err21);
            }
            errors2++;
          }
          const _errs26 = errors2;
          let valid9 = true;
          const _errs27 = errors2;
          if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
            if (data8.binding === void 0 && "binding") {
              const err22 = {};
              if (vErrors === null) {
                vErrors = [err22];
              } else {
                vErrors.push(err22);
              }
              errors2++;
            } else {
              if (data8.binding !== void 0) {
                let data10 = data8.binding;
                if (data10 && typeof data10 == "object" && !Array.isArray(data10)) {
                  if (data10.type === void 0 && "type") {
                    const err23 = {};
                    if (vErrors === null) {
                      vErrors = [err23];
                    } else {
                      vErrors.push(err23);
                    }
                    errors2++;
                  } else {
                    if (data10.type !== void 0) {
                      if (!equal(data10.type, "property")) {
                        const err24 = {};
                        if (vErrors === null) {
                          vErrors = [err24];
                        } else {
                          vErrors.push(err24);
                        }
                        errors2++;
                      }
                    }
                  }
                }
              }
            }
          }
          var _valid1 = _errs27 === errors2;
          errors2 = _errs26;
          if (vErrors !== null) {
            if (_errs26) {
              vErrors.length = _errs26;
            } else {
              vErrors = null;
            }
          }
          if (_valid1) {
            const _errs30 = errors2;
            if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
              if (data8.type !== void 0) {
                let data12 = data8.type;
                if (!(data12 === "String" || data12 === "Text" || data12 === "Hidden" || data12 === "Dropdown" || data12 === "Boolean")) {
                  const err25 = { keyword: "enum", dataPath: dataPath + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/1/then/properties/type/enum", params: { allowedValues: schema18.items.allOf[1].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err25];
                  } else {
                    vErrors.push(err25);
                  }
                  errors2++;
                }
                if (errors2 > 0) {
                  const emErrs3 = [];
                  for (const err26 of vErrors) {
                    if (err26.keyword !== "errorMessage" && !err26.emUsed && (err26.dataPath === dataPath + "/properties/" + i1 + "/type" || err26.dataPath.indexOf(dataPath + "/properties/" + i1 + "/type") === 0 && err26.dataPath[dataPath + "/properties/" + i1 + "/type".length] === "/") && err26.schemaPath.indexOf("#/definitions/properties/items/allOf/1/then/properties/type") === 0 && err26.schemaPath["#/definitions/properties/items/allOf/1/then/properties/type".length] === "/") {
                      emErrs3.push(err26);
                      err26.emUsed = true;
                    }
                  }
                  if (emErrs3.length) {
                    const err27 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/1/then/properties/type/errorMessage", params: { errors: emErrs3 }, message: "invalid property type " + JSON.stringify(data12) + ' for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' };
                    if (vErrors === null) {
                      vErrors = [err27];
                    } else {
                      vErrors.push(err27);
                    }
                    errors2++;
                  }
                  const emErrs4 = [];
                  for (const err28 of vErrors) {
                    if (!err28.emUsed) {
                      emErrs4.push(err28);
                    }
                  }
                  vErrors = emErrs4;
                  errors2 = emErrs4.length;
                }
              }
            }
            var _valid1 = _errs30 === errors2;
            valid9 = _valid1;
          }
          if (!valid9) {
            const err29 = { keyword: "if", dataPath: dataPath + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/1/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err29];
            } else {
              vErrors.push(err29);
            }
            errors2++;
          }
          const _errs33 = errors2;
          let valid13 = true;
          const _errs34 = errors2;
          if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
            if (data8.binding === void 0 && "binding") {
              const err30 = {};
              if (vErrors === null) {
                vErrors = [err30];
              } else {
                vErrors.push(err30);
              }
              errors2++;
            } else {
              if (data8.binding !== void 0) {
                let data13 = data8.binding;
                if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                  if (data13.type === void 0 && "type") {
                    const err31 = {};
                    if (vErrors === null) {
                      vErrors = [err31];
                    } else {
                      vErrors.push(err31);
                    }
                    errors2++;
                  } else {
                    if (data13.type !== void 0) {
                      if (!equal(data13.type, "camunda:executionListener")) {
                        const err32 = {};
                        if (vErrors === null) {
                          vErrors = [err32];
                        } else {
                          vErrors.push(err32);
                        }
                        errors2++;
                      }
                    }
                  }
                }
              }
            }
          }
          var _valid2 = _errs34 === errors2;
          errors2 = _errs33;
          if (vErrors !== null) {
            if (_errs33) {
              vErrors.length = _errs33;
            } else {
              vErrors = null;
            }
          }
          if (_valid2) {
            const _errs37 = errors2;
            if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
              if (data8.type !== void 0) {
                if (!(data8.type === "Hidden")) {
                  const err33 = { keyword: "enum", dataPath: dataPath + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/2/then/properties/type/enum", params: { allowedValues: schema18.items.allOf[2].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err33];
                  } else {
                    vErrors.push(err33);
                  }
                  errors2++;
                }
                if (errors2 > 0) {
                  const emErrs5 = [];
                  for (const err34 of vErrors) {
                    if (err34.keyword !== "errorMessage" && !err34.emUsed && (err34.dataPath === dataPath + "/properties/" + i1 + "/type" || err34.dataPath.indexOf(dataPath + "/properties/" + i1 + "/type") === 0 && err34.dataPath[dataPath + "/properties/" + i1 + "/type".length] === "/") && err34.schemaPath.indexOf("#/definitions/properties/items/allOf/2/then/properties/type") === 0 && err34.schemaPath["#/definitions/properties/items/allOf/2/then/properties/type".length] === "/") {
                      emErrs5.push(err34);
                      err34.emUsed = true;
                    }
                  }
                  if (emErrs5.length) {
                    const err35 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/2/then/properties/type/errorMessage", params: { errors: emErrs5 }, message: "invalid property type " + JSON.stringify(data8 && data8.type) + ' for binding type "camunda:executionListener"; must be "Hidden"' };
                    if (vErrors === null) {
                      vErrors = [err35];
                    } else {
                      vErrors.push(err35);
                    }
                    errors2++;
                  }
                  const emErrs6 = [];
                  for (const err36 of vErrors) {
                    if (!err36.emUsed) {
                      emErrs6.push(err36);
                    }
                  }
                  vErrors = emErrs6;
                  errors2 = emErrs6.length;
                }
              }
            }
            var _valid2 = _errs37 === errors2;
            valid13 = _valid2;
          }
          if (!valid13) {
            const err37 = { keyword: "if", dataPath: dataPath + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/2/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err37];
            } else {
              vErrors.push(err37);
            }
            errors2++;
          }
          const _errs40 = errors2;
          let valid17 = true;
          const _errs41 = errors2;
          if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
            if (data8.binding === void 0 && "binding") {
              const err38 = {};
              if (vErrors === null) {
                vErrors = [err38];
              } else {
                vErrors.push(err38);
              }
              errors2++;
            } else {
              if (data8.binding !== void 0) {
                let data16 = data8.binding;
                if (data16 && typeof data16 == "object" && !Array.isArray(data16)) {
                  if (data16.type === void 0 && "type") {
                    const err39 = {};
                    if (vErrors === null) {
                      vErrors = [err39];
                    } else {
                      vErrors.push(err39);
                    }
                    errors2++;
                  } else {
                    if (data16.type !== void 0) {
                      let data17 = data16.type;
                      if (!(data17 === "camunda:property" || data17 === "camunda:outputParameter" || data17 === "camunda:in" || data17 === "camunda:in:businessKey" || data17 === "camunda:out" || data17 === "camunda:errorEventDefinition")) {
                        const err40 = {};
                        if (vErrors === null) {
                          vErrors = [err40];
                        } else {
                          vErrors.push(err40);
                        }
                        errors2++;
                      }
                    }
                  }
                }
              }
            }
          }
          var _valid3 = _errs41 === errors2;
          errors2 = _errs40;
          if (vErrors !== null) {
            if (_errs40) {
              vErrors.length = _errs40;
            } else {
              vErrors = null;
            }
          }
          if (_valid3) {
            const _errs44 = errors2;
            if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
              if (data8.type !== void 0) {
                let data18 = data8.type;
                if (!(data18 === "String" || data18 === "Hidden" || data18 === "Dropdown")) {
                  const err41 = { keyword: "enum", dataPath: dataPath + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/3/then/properties/type/enum", params: { allowedValues: schema18.items.allOf[3].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err41];
                  } else {
                    vErrors.push(err41);
                  }
                  errors2++;
                }
                if (errors2 > 0) {
                  const emErrs7 = [];
                  for (const err42 of vErrors) {
                    if (err42.keyword !== "errorMessage" && !err42.emUsed && (err42.dataPath === dataPath + "/properties/" + i1 + "/type" || err42.dataPath.indexOf(dataPath + "/properties/" + i1 + "/type") === 0 && err42.dataPath[dataPath + "/properties/" + i1 + "/type".length] === "/") && err42.schemaPath.indexOf("#/definitions/properties/items/allOf/3/then/properties/type") === 0 && err42.schemaPath["#/definitions/properties/items/allOf/3/then/properties/type".length] === "/") {
                      emErrs7.push(err42);
                      err42.emUsed = true;
                    }
                  }
                  if (emErrs7.length) {
                    const err43 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/3/then/properties/type/errorMessage", params: { errors: emErrs7 }, message: "invalid property type " + JSON.stringify(data18) + " for binding type " + JSON.stringify(data8 && data8.binding && data8.binding.type) + "; must be any of { String, Hidden, Dropdown }" };
                    if (vErrors === null) {
                      vErrors = [err43];
                    } else {
                      vErrors.push(err43);
                    }
                    errors2++;
                  }
                  const emErrs8 = [];
                  for (const err44 of vErrors) {
                    if (!err44.emUsed) {
                      emErrs8.push(err44);
                    }
                  }
                  vErrors = emErrs8;
                  errors2 = emErrs8.length;
                }
              }
            }
            var _valid3 = _errs44 === errors2;
            valid17 = _valid3;
          }
          if (!valid17) {
            const err45 = { keyword: "if", dataPath: dataPath + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/3/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err45];
            } else {
              vErrors.push(err45);
            }
            errors2++;
          }
          const _errs47 = errors2;
          let valid21 = true;
          const _errs48 = errors2;
          if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
            if (data8.binding === void 0 && "binding") {
              const err46 = {};
              if (vErrors === null) {
                vErrors = [err46];
              } else {
                vErrors.push(err46);
              }
              errors2++;
            } else {
              if (data8.binding !== void 0) {
                let data19 = data8.binding;
                if (data19 && typeof data19 == "object" && !Array.isArray(data19)) {
                  if (data19.type === void 0 && "type") {
                    const err47 = {};
                    if (vErrors === null) {
                      vErrors = [err47];
                    } else {
                      vErrors.push(err47);
                    }
                    errors2++;
                  } else {
                    if (data19.type !== void 0) {
                      let data20 = data19.type;
                      if (!(data20 === "camunda:inputParameter" || data20 === "camunda:field")) {
                        const err48 = {};
                        if (vErrors === null) {
                          vErrors = [err48];
                        } else {
                          vErrors.push(err48);
                        }
                        errors2++;
                      }
                    }
                  }
                }
              }
            }
          }
          var _valid4 = _errs48 === errors2;
          errors2 = _errs47;
          if (vErrors !== null) {
            if (_errs47) {
              vErrors.length = _errs47;
            } else {
              vErrors = null;
            }
          }
          if (_valid4) {
            const _errs51 = errors2;
            if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
              if (data8.type !== void 0) {
                let data21 = data8.type;
                if (!(data21 === "String" || data21 === "Text" || data21 === "Hidden" || data21 === "Dropdown")) {
                  const err49 = { keyword: "enum", dataPath: dataPath + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/4/then/properties/type/enum", params: { allowedValues: schema18.items.allOf[4].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err49];
                  } else {
                    vErrors.push(err49);
                  }
                  errors2++;
                }
                if (errors2 > 0) {
                  const emErrs9 = [];
                  for (const err50 of vErrors) {
                    if (err50.keyword !== "errorMessage" && !err50.emUsed && (err50.dataPath === dataPath + "/properties/" + i1 + "/type" || err50.dataPath.indexOf(dataPath + "/properties/" + i1 + "/type") === 0 && err50.dataPath[dataPath + "/properties/" + i1 + "/type".length] === "/") && err50.schemaPath.indexOf("#/definitions/properties/items/allOf/4/then/properties/type") === 0 && err50.schemaPath["#/definitions/properties/items/allOf/4/then/properties/type".length] === "/") {
                      emErrs9.push(err50);
                      err50.emUsed = true;
                    }
                  }
                  if (emErrs9.length) {
                    const err51 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/allOf/4/then/properties/type/errorMessage", params: { errors: emErrs9 }, message: "invalid property type " + JSON.stringify(data21) + " for binding type " + JSON.stringify(data8 && data8.binding && data8.binding.type) + "; must be any of { String, Text, Hidden, Dropdown }" };
                    if (vErrors === null) {
                      vErrors = [err51];
                    } else {
                      vErrors.push(err51);
                    }
                    errors2++;
                  }
                  const emErrs10 = [];
                  for (const err52 of vErrors) {
                    if (!err52.emUsed) {
                      emErrs10.push(err52);
                    }
                  }
                  vErrors = emErrs10;
                  errors2 = emErrs10.length;
                }
              }
            }
            var _valid4 = _errs51 === errors2;
            valid21 = _valid4;
          }
          if (!valid21) {
            const err53 = { keyword: "if", dataPath: dataPath + "/properties/" + i1, schemaPath: "#/definitions/properties/items/allOf/4/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err53];
            } else {
              vErrors.push(err53);
            }
            errors2++;
          }
          if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
            if (data8.binding === void 0) {
              const err54 = { keyword: "required", dataPath: dataPath + "/properties/" + i1, schemaPath: "#/definitions/properties/items/required", params: { missingProperty: "binding" }, message: "should have required property 'binding'" };
              if (vErrors === null) {
                vErrors = [err54];
              } else {
                vErrors.push(err54);
              }
              errors2++;
            }
            if (data8.value !== void 0) {
              let data22 = data8.value;
              if (typeof data22 !== "string" && typeof data22 !== "boolean") {
                const err55 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/value", schemaPath: "#/definitions/properties/items/properties/value/type", params: { type: schema18.items.properties.value.type }, message: "should be string,boolean" };
                if (vErrors === null) {
                  vErrors = [err55];
                } else {
                  vErrors.push(err55);
                }
                errors2++;
              }
            }
            if (data8.description !== void 0) {
              if (typeof data8.description !== "string") {
                const err56 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/description", schemaPath: "#/definitions/properties/items/properties/description/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err56];
                } else {
                  vErrors.push(err56);
                }
                errors2++;
              }
            }
            if (data8.label !== void 0) {
              if (typeof data8.label !== "string") {
                const err57 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/label", schemaPath: "#/definitions/properties/items/properties/label/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err57];
                } else {
                  vErrors.push(err57);
                }
                errors2++;
              }
            }
            if (data8.type !== void 0) {
              if (typeof data8.type !== "string") {
                const err58 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/type", schemaPath: "#/definitions/properties/items/properties/type/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err58];
                } else {
                  vErrors.push(err58);
                }
                errors2++;
              }
            }
            if (data8.editable !== void 0) {
              if (typeof data8.editable !== "boolean") {
                const err59 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/editable", schemaPath: "#/definitions/properties/items/properties/editable/type", params: { type: "boolean" }, message: "should be boolean" };
                if (vErrors === null) {
                  vErrors = [err59];
                } else {
                  vErrors.push(err59);
                }
                errors2++;
              }
            }
            if (data8.choices !== void 0) {
              let data27 = data8.choices;
              if (Array.isArray(data27)) {
                const len2 = data27.length;
                for (let i2 = 0; i2 < len2; i2++) {
                  let data28 = data27[i2];
                  if (data28 && typeof data28 == "object" && !Array.isArray(data28)) {
                    if (data28.value === void 0) {
                      const err60 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/choices/" + i2, schemaPath: "#/definitions/properties/items/properties/choices/items/required", params: { missingProperty: "value" }, message: "should have required property 'value'" };
                      if (vErrors === null) {
                        vErrors = [err60];
                      } else {
                        vErrors.push(err60);
                      }
                      errors2++;
                    }
                    if (data28.name === void 0) {
                      const err61 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/choices/" + i2, schemaPath: "#/definitions/properties/items/properties/choices/items/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
                      if (vErrors === null) {
                        vErrors = [err61];
                      } else {
                        vErrors.push(err61);
                      }
                      errors2++;
                    }
                    if (data28.name !== void 0) {
                      if (typeof data28.name !== "string") {
                        const err62 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/choices/" + i2 + "/name", schemaPath: "#/definitions/properties/items/properties/choices/items/properties/name/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err62];
                        } else {
                          vErrors.push(err62);
                        }
                        errors2++;
                      }
                    }
                    if (data28.value !== void 0) {
                      if (typeof data28.value !== "string") {
                        const err63 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/choices/" + i2 + "/value", schemaPath: "#/definitions/properties/items/properties/choices/items/properties/value/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err63];
                        } else {
                          vErrors.push(err63);
                        }
                        errors2++;
                      }
                    }
                  } else {
                    const err64 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/choices/" + i2, schemaPath: "#/definitions/properties/items/properties/choices/items/type", params: { type: "object" }, message: "should be object" };
                    if (vErrors === null) {
                      vErrors = [err64];
                    } else {
                      vErrors.push(err64);
                    }
                    errors2++;
                  }
                  if (errors2 > 0) {
                    const emErrs11 = [];
                    for (const err65 of vErrors) {
                      if (err65.keyword !== "errorMessage" && !err65.emUsed && (err65.dataPath === dataPath + "/properties/" + i1 + "/choices/" + i2 || err65.dataPath.indexOf(dataPath + "/properties/" + i1 + "/choices/" + i2) === 0 && err65.dataPath[dataPath + "/properties/" + i1 + "/choices/" + i2.length] === "/") && err65.schemaPath.indexOf("#/definitions/properties/items/properties/choices/items") === 0 && err65.schemaPath["#/definitions/properties/items/properties/choices/items".length] === "/") {
                        emErrs11.push(err65);
                        err65.emUsed = true;
                      }
                    }
                    if (emErrs11.length) {
                      const err66 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i1 + "/choices/" + i2, schemaPath: "#/definitions/properties/items/properties/choices/items/errorMessage", params: { errors: emErrs11 }, message: '{ name, value } must be specified for "Dropdown" choices' };
                      if (vErrors === null) {
                        vErrors = [err66];
                      } else {
                        vErrors.push(err66);
                      }
                      errors2++;
                    }
                    const emErrs12 = [];
                    for (const err67 of vErrors) {
                      if (!err67.emUsed) {
                        emErrs12.push(err67);
                      }
                    }
                    vErrors = emErrs12;
                    errors2 = emErrs12.length;
                  }
                }
              } else {
                const err68 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/choices", schemaPath: "#/definitions/properties/items/properties/choices/type", params: { type: "array" }, message: "should be array" };
                if (vErrors === null) {
                  vErrors = [err68];
                } else {
                  vErrors.push(err68);
                }
                errors2++;
              }
            }
            if (data8.binding !== void 0) {
              let data31 = data8.binding;
              const _errs74 = errors2;
              let valid30 = true;
              const _errs75 = errors2;
              if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                if (data31.type === void 0 && "type") {
                  const err69 = {};
                  if (vErrors === null) {
                    vErrors = [err69];
                  } else {
                    vErrors.push(err69);
                  }
                  errors2++;
                } else {
                  if (data31.type !== void 0) {
                    let data32 = data31.type;
                    if (!(data32 === "property" || data32 === "camunda:property" || data32 === "camunda:inputParameter" || data32 === "camunda:field")) {
                      const err70 = {};
                      if (vErrors === null) {
                        vErrors = [err70];
                      } else {
                        vErrors.push(err70);
                      }
                      errors2++;
                    }
                  }
                }
              }
              var _valid5 = _errs75 === errors2;
              errors2 = _errs74;
              if (vErrors !== null) {
                if (_errs74) {
                  vErrors.length = _errs74;
                } else {
                  vErrors = null;
                }
              }
              if (_valid5) {
                const _errs77 = errors2;
                if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                  if (data31.name === void 0) {
                    const err71 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/0/then/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
                    if (vErrors === null) {
                      vErrors = [err71];
                    } else {
                      vErrors.push(err71);
                    }
                    errors2++;
                  }
                }
                if (errors2 > 0) {
                  const emErrs13 = [];
                  for (const err72 of vErrors) {
                    if (err72.keyword !== "errorMessage" && !err72.emUsed && (err72.dataPath === dataPath + "/properties/" + i1 + "/binding" || err72.dataPath.indexOf(dataPath + "/properties/" + i1 + "/binding") === 0 && err72.dataPath[dataPath + "/properties/" + i1 + "/binding".length] === "/") && err72.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/0/then") === 0 && err72.schemaPath["#/definitions/properties/items/properties/binding/allOf/0/then".length] === "/") {
                      emErrs13.push(err72);
                      err72.emUsed = true;
                    }
                  }
                  if (emErrs13.length) {
                    const err73 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/0/then/errorMessage", params: { errors: emErrs13 }, message: "property.binding " + JSON.stringify(data31 && data31.type) + " requires name" };
                    if (vErrors === null) {
                      vErrors = [err73];
                    } else {
                      vErrors.push(err73);
                    }
                    errors2++;
                  }
                  const emErrs14 = [];
                  for (const err74 of vErrors) {
                    if (!err74.emUsed) {
                      emErrs14.push(err74);
                    }
                  }
                  vErrors = emErrs14;
                  errors2 = emErrs14.length;
                }
                var _valid5 = _errs77 === errors2;
                valid30 = _valid5;
              }
              if (!valid30) {
                const err75 = { keyword: "if", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err75];
                } else {
                  vErrors.push(err75);
                }
                errors2++;
              }
              const _errs79 = errors2;
              let valid32 = true;
              const _errs80 = errors2;
              if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                if (data31.type === void 0 && "type") {
                  const err76 = {};
                  if (vErrors === null) {
                    vErrors = [err76];
                  } else {
                    vErrors.push(err76);
                  }
                  errors2++;
                } else {
                  if (data31.type !== void 0) {
                    if (!equal(data31.type, "camunda:outputParameter")) {
                      const err77 = {};
                      if (vErrors === null) {
                        vErrors = [err77];
                      } else {
                        vErrors.push(err77);
                      }
                      errors2++;
                    }
                  }
                }
              }
              var _valid6 = _errs80 === errors2;
              errors2 = _errs79;
              if (vErrors !== null) {
                if (_errs79) {
                  vErrors.length = _errs79;
                } else {
                  vErrors = null;
                }
              }
              if (_valid6) {
                const _errs82 = errors2;
                if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                  if (data31.source === void 0) {
                    const err78 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/1/then/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                    if (vErrors === null) {
                      vErrors = [err78];
                    } else {
                      vErrors.push(err78);
                    }
                    errors2++;
                  }
                }
                if (errors2 > 0) {
                  const emErrs15 = [];
                  for (const err79 of vErrors) {
                    if (err79.keyword !== "errorMessage" && !err79.emUsed && (err79.dataPath === dataPath + "/properties/" + i1 + "/binding" || err79.dataPath.indexOf(dataPath + "/properties/" + i1 + "/binding") === 0 && err79.dataPath[dataPath + "/properties/" + i1 + "/binding".length] === "/") && err79.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/1/then") === 0 && err79.schemaPath["#/definitions/properties/items/properties/binding/allOf/1/then".length] === "/") {
                      emErrs15.push(err79);
                      err79.emUsed = true;
                    }
                  }
                  if (emErrs15.length) {
                    const err80 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/1/then/errorMessage", params: { errors: emErrs15 }, message: "property.binding " + JSON.stringify(data31 && data31.type) + " requires source" };
                    if (vErrors === null) {
                      vErrors = [err80];
                    } else {
                      vErrors.push(err80);
                    }
                    errors2++;
                  }
                  const emErrs16 = [];
                  for (const err81 of vErrors) {
                    if (!err81.emUsed) {
                      emErrs16.push(err81);
                    }
                  }
                  vErrors = emErrs16;
                  errors2 = emErrs16.length;
                }
                var _valid6 = _errs82 === errors2;
                valid32 = _valid6;
              }
              if (!valid32) {
                const err82 = { keyword: "if", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/1/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err82];
                } else {
                  vErrors.push(err82);
                }
                errors2++;
              }
              const _errs84 = errors2;
              let valid34 = true;
              const _errs85 = errors2;
              if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                if (data31.type === void 0 && "type") {
                  const err83 = {};
                  if (vErrors === null) {
                    vErrors = [err83];
                  } else {
                    vErrors.push(err83);
                  }
                  errors2++;
                } else {
                  if (data31.type !== void 0) {
                    if (!equal(data31.type, "camunda:in")) {
                      const err84 = {};
                      if (vErrors === null) {
                        vErrors = [err84];
                      } else {
                        vErrors.push(err84);
                      }
                      errors2++;
                    }
                  }
                }
              }
              var _valid7 = _errs85 === errors2;
              errors2 = _errs84;
              if (vErrors !== null) {
                if (_errs84) {
                  vErrors.length = _errs84;
                } else {
                  vErrors = null;
                }
              }
              if (_valid7) {
                const _errs87 = errors2;
                const _errs88 = errors2;
                let valid36 = false;
                const _errs89 = errors2;
                if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                  if (data31.variables === void 0) {
                    const err85 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/then/anyOf/0/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                    if (vErrors === null) {
                      vErrors = [err85];
                    } else {
                      vErrors.push(err85);
                    }
                    errors2++;
                  }
                }
                var _valid8 = _errs89 === errors2;
                valid36 = valid36 || _valid8;
                if (!valid36) {
                  const _errs90 = errors2;
                  if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                    if (data31.target === void 0) {
                      const err86 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/then/anyOf/1/required", params: { missingProperty: "target" }, message: "should have required property 'target'" };
                      if (vErrors === null) {
                        vErrors = [err86];
                      } else {
                        vErrors.push(err86);
                      }
                      errors2++;
                    }
                  }
                  var _valid8 = _errs90 === errors2;
                  valid36 = valid36 || _valid8;
                }
                if (!valid36) {
                  const err87 = { keyword: "anyOf", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/then/anyOf", params: {}, message: "should match some schema in anyOf" };
                  if (vErrors === null) {
                    vErrors = [err87];
                  } else {
                    vErrors.push(err87);
                  }
                  errors2++;
                } else {
                  errors2 = _errs88;
                  if (vErrors !== null) {
                    if (_errs88) {
                      vErrors.length = _errs88;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                if (errors2 > 0) {
                  const emErrs17 = [];
                  for (const err88 of vErrors) {
                    if (err88.keyword !== "errorMessage" && !err88.emUsed && (err88.dataPath === dataPath + "/properties/" + i1 + "/binding" || err88.dataPath.indexOf(dataPath + "/properties/" + i1 + "/binding") === 0 && err88.dataPath[dataPath + "/properties/" + i1 + "/binding".length] === "/") && err88.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/2/then") === 0 && err88.schemaPath["#/definitions/properties/items/properties/binding/allOf/2/then".length] === "/") {
                      emErrs17.push(err88);
                      err88.emUsed = true;
                    }
                  }
                  if (emErrs17.length) {
                    const err89 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/then/errorMessage", params: { errors: emErrs17 }, message: "property.binding " + JSON.stringify(data31 && data31.type) + " requires variables, target, or both" };
                    if (vErrors === null) {
                      vErrors = [err89];
                    } else {
                      vErrors.push(err89);
                    }
                    errors2++;
                  }
                  const emErrs18 = [];
                  for (const err90 of vErrors) {
                    if (!err90.emUsed) {
                      emErrs18.push(err90);
                    }
                  }
                  vErrors = emErrs18;
                  errors2 = emErrs18.length;
                }
                var _valid7 = _errs87 === errors2;
                valid34 = _valid7;
              }
              if (!valid34) {
                const err91 = { keyword: "if", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/2/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err91];
                } else {
                  vErrors.push(err91);
                }
                errors2++;
              }
              const _errs92 = errors2;
              let valid37 = true;
              const _errs93 = errors2;
              if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                if (data31.type === void 0 && "type") {
                  const err92 = {};
                  if (vErrors === null) {
                    vErrors = [err92];
                  } else {
                    vErrors.push(err92);
                  }
                  errors2++;
                } else {
                  if (data31.type !== void 0) {
                    if (!equal(data31.type, "camunda:out")) {
                      const err93 = {};
                      if (vErrors === null) {
                        vErrors = [err93];
                      } else {
                        vErrors.push(err93);
                      }
                      errors2++;
                    }
                  }
                }
              }
              var _valid9 = _errs93 === errors2;
              errors2 = _errs92;
              if (vErrors !== null) {
                if (_errs92) {
                  vErrors.length = _errs92;
                } else {
                  vErrors = null;
                }
              }
              if (_valid9) {
                const _errs95 = errors2;
                const _errs96 = errors2;
                let valid39 = false;
                let passing0 = null;
                const _errs97 = errors2;
                const _errs98 = errors2;
                const _errs99 = errors2;
                const _errs100 = errors2;
                let valid41 = false;
                const _errs101 = errors2;
                if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                  if (data31.source === void 0 && "source") {
                    const err94 = {};
                    if (vErrors === null) {
                      vErrors = [err94];
                    } else {
                      vErrors.push(err94);
                    }
                    errors2++;
                  }
                }
                var _valid11 = _errs101 === errors2;
                valid41 = valid41 || _valid11;
                if (!valid41) {
                  const _errs102 = errors2;
                  if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                    if (data31.sourceExpression === void 0 && "sourceExpression") {
                      const err95 = {};
                      if (vErrors === null) {
                        vErrors = [err95];
                      } else {
                        vErrors.push(err95);
                      }
                      errors2++;
                    }
                  }
                  var _valid11 = _errs102 === errors2;
                  valid41 = valid41 || _valid11;
                }
                if (!valid41) {
                  const err96 = {};
                  if (vErrors === null) {
                    vErrors = [err96];
                  } else {
                    vErrors.push(err96);
                  }
                  errors2++;
                } else {
                  errors2 = _errs100;
                  if (vErrors !== null) {
                    if (_errs100) {
                      vErrors.length = _errs100;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                var valid40 = _errs99 === errors2;
                if (!valid40) {
                  errors2 = _errs98;
                  if (vErrors !== null) {
                    if (_errs98) {
                      vErrors.length = _errs98;
                    } else {
                      vErrors = null;
                    }
                  }
                } else {
                  const err97 = { keyword: "not", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/0/not", params: {}, message: "should NOT be valid" };
                  if (vErrors === null) {
                    vErrors = [err97];
                  } else {
                    vErrors.push(err97);
                  }
                  errors2++;
                }
                if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                  if (data31.variables === void 0) {
                    const err98 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/0/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                    if (vErrors === null) {
                      vErrors = [err98];
                    } else {
                      vErrors.push(err98);
                    }
                    errors2++;
                  }
                }
                var _valid10 = _errs97 === errors2;
                if (_valid10) {
                  valid39 = true;
                  passing0 = 0;
                }
                const _errs103 = errors2;
                const _errs104 = errors2;
                const _errs105 = errors2;
                const _errs106 = errors2;
                let valid43 = false;
                const _errs107 = errors2;
                if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                  if (data31.variables === void 0 && "variables") {
                    const err99 = {};
                    if (vErrors === null) {
                      vErrors = [err99];
                    } else {
                      vErrors.push(err99);
                    }
                    errors2++;
                  }
                }
                var _valid12 = _errs107 === errors2;
                valid43 = valid43 || _valid12;
                if (!valid43) {
                  const _errs108 = errors2;
                  if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                    if (data31.sourceExpression === void 0 && "sourceExpression") {
                      const err100 = {};
                      if (vErrors === null) {
                        vErrors = [err100];
                      } else {
                        vErrors.push(err100);
                      }
                      errors2++;
                    }
                  }
                  var _valid12 = _errs108 === errors2;
                  valid43 = valid43 || _valid12;
                }
                if (!valid43) {
                  const err101 = {};
                  if (vErrors === null) {
                    vErrors = [err101];
                  } else {
                    vErrors.push(err101);
                  }
                  errors2++;
                } else {
                  errors2 = _errs106;
                  if (vErrors !== null) {
                    if (_errs106) {
                      vErrors.length = _errs106;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                var valid42 = _errs105 === errors2;
                if (!valid42) {
                  errors2 = _errs104;
                  if (vErrors !== null) {
                    if (_errs104) {
                      vErrors.length = _errs104;
                    } else {
                      vErrors = null;
                    }
                  }
                } else {
                  const err102 = { keyword: "not", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/1/not", params: {}, message: "should NOT be valid" };
                  if (vErrors === null) {
                    vErrors = [err102];
                  } else {
                    vErrors.push(err102);
                  }
                  errors2++;
                }
                if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                  if (data31.source === void 0) {
                    const err103 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/1/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                    if (vErrors === null) {
                      vErrors = [err103];
                    } else {
                      vErrors.push(err103);
                    }
                    errors2++;
                  }
                }
                var _valid10 = _errs103 === errors2;
                if (_valid10 && valid39) {
                  valid39 = false;
                  passing0 = [passing0, 1];
                } else {
                  if (_valid10) {
                    valid39 = true;
                    passing0 = 1;
                  }
                  const _errs109 = errors2;
                  const _errs110 = errors2;
                  const _errs111 = errors2;
                  const _errs112 = errors2;
                  let valid45 = false;
                  const _errs113 = errors2;
                  if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                    if (data31.variables === void 0 && "variables") {
                      const err104 = {};
                      if (vErrors === null) {
                        vErrors = [err104];
                      } else {
                        vErrors.push(err104);
                      }
                      errors2++;
                    }
                  }
                  var _valid13 = _errs113 === errors2;
                  valid45 = valid45 || _valid13;
                  if (!valid45) {
                    const _errs114 = errors2;
                    if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                      if (data31.source === void 0 && "source") {
                        const err105 = {};
                        if (vErrors === null) {
                          vErrors = [err105];
                        } else {
                          vErrors.push(err105);
                        }
                        errors2++;
                      }
                    }
                    var _valid13 = _errs114 === errors2;
                    valid45 = valid45 || _valid13;
                  }
                  if (!valid45) {
                    const err106 = {};
                    if (vErrors === null) {
                      vErrors = [err106];
                    } else {
                      vErrors.push(err106);
                    }
                    errors2++;
                  } else {
                    errors2 = _errs112;
                    if (vErrors !== null) {
                      if (_errs112) {
                        vErrors.length = _errs112;
                      } else {
                        vErrors = null;
                      }
                    }
                  }
                  var valid44 = _errs111 === errors2;
                  if (!valid44) {
                    errors2 = _errs110;
                    if (vErrors !== null) {
                      if (_errs110) {
                        vErrors.length = _errs110;
                      } else {
                        vErrors = null;
                      }
                    }
                  } else {
                    const err107 = { keyword: "not", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/2/not", params: {}, message: "should NOT be valid" };
                    if (vErrors === null) {
                      vErrors = [err107];
                    } else {
                      vErrors.push(err107);
                    }
                    errors2++;
                  }
                  if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                    if (data31.sourceExpression === void 0) {
                      const err108 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/2/required", params: { missingProperty: "sourceExpression" }, message: "should have required property 'sourceExpression'" };
                      if (vErrors === null) {
                        vErrors = [err108];
                      } else {
                        vErrors.push(err108);
                      }
                      errors2++;
                    }
                  }
                  var _valid10 = _errs109 === errors2;
                  if (_valid10 && valid39) {
                    valid39 = false;
                    passing0 = [passing0, 2];
                  } else {
                    if (_valid10) {
                      valid39 = true;
                      passing0 = 2;
                    }
                    const _errs115 = errors2;
                    const _errs116 = errors2;
                    const _errs117 = errors2;
                    if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                      if (data31.source === void 0 && "source") {
                        const err109 = {};
                        if (vErrors === null) {
                          vErrors = [err109];
                        } else {
                          vErrors.push(err109);
                        }
                        errors2++;
                      }
                    }
                    var valid46 = _errs117 === errors2;
                    if (!valid46) {
                      errors2 = _errs116;
                      if (vErrors !== null) {
                        if (_errs116) {
                          vErrors.length = _errs116;
                        } else {
                          vErrors = null;
                        }
                      }
                    } else {
                      const err110 = { keyword: "not", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/3/not", params: {}, message: "should NOT be valid" };
                      if (vErrors === null) {
                        vErrors = [err110];
                      } else {
                        vErrors.push(err110);
                      }
                      errors2++;
                    }
                    if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                      if (data31.variables === void 0) {
                        const err111 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/3/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                        if (vErrors === null) {
                          vErrors = [err111];
                        } else {
                          vErrors.push(err111);
                        }
                        errors2++;
                      }
                      if (data31.sourceExpression === void 0) {
                        const err112 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/3/required", params: { missingProperty: "sourceExpression" }, message: "should have required property 'sourceExpression'" };
                        if (vErrors === null) {
                          vErrors = [err112];
                        } else {
                          vErrors.push(err112);
                        }
                        errors2++;
                      }
                    }
                    var _valid10 = _errs115 === errors2;
                    if (_valid10 && valid39) {
                      valid39 = false;
                      passing0 = [passing0, 3];
                    } else {
                      if (_valid10) {
                        valid39 = true;
                        passing0 = 3;
                      }
                      const _errs118 = errors2;
                      const _errs119 = errors2;
                      const _errs120 = errors2;
                      if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                        if (data31.sourceExpression === void 0 && "sourceExpression") {
                          const err113 = {};
                          if (vErrors === null) {
                            vErrors = [err113];
                          } else {
                            vErrors.push(err113);
                          }
                          errors2++;
                        }
                      }
                      var valid47 = _errs120 === errors2;
                      if (!valid47) {
                        errors2 = _errs119;
                        if (vErrors !== null) {
                          if (_errs119) {
                            vErrors.length = _errs119;
                          } else {
                            vErrors = null;
                          }
                        }
                      } else {
                        const err114 = { keyword: "not", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/4/not", params: {}, message: "should NOT be valid" };
                        if (vErrors === null) {
                          vErrors = [err114];
                        } else {
                          vErrors.push(err114);
                        }
                        errors2++;
                      }
                      if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                        if (data31.variables === void 0) {
                          const err115 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/4/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                          if (vErrors === null) {
                            vErrors = [err115];
                          } else {
                            vErrors.push(err115);
                          }
                          errors2++;
                        }
                        if (data31.source === void 0) {
                          const err116 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf/4/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                          if (vErrors === null) {
                            vErrors = [err116];
                          } else {
                            vErrors.push(err116);
                          }
                          errors2++;
                        }
                      }
                      var _valid10 = _errs118 === errors2;
                      if (_valid10 && valid39) {
                        valid39 = false;
                        passing0 = [passing0, 4];
                      } else {
                        if (_valid10) {
                          valid39 = true;
                          passing0 = 4;
                        }
                      }
                    }
                  }
                }
                if (!valid39) {
                  const err117 = { keyword: "oneOf", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/oneOf", params: { passingSchemas: passing0 }, message: "should match exactly one schema in oneOf" };
                  if (vErrors === null) {
                    vErrors = [err117];
                  } else {
                    vErrors.push(err117);
                  }
                  errors2++;
                } else {
                  errors2 = _errs96;
                  if (vErrors !== null) {
                    if (_errs96) {
                      vErrors.length = _errs96;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                if (errors2 > 0) {
                  const emErrs19 = [];
                  for (const err118 of vErrors) {
                    if (err118.keyword !== "errorMessage" && !err118.emUsed && (err118.dataPath === dataPath + "/properties/" + i1 + "/binding" || err118.dataPath.indexOf(dataPath + "/properties/" + i1 + "/binding") === 0 && err118.dataPath[dataPath + "/properties/" + i1 + "/binding".length] === "/") && err118.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/3/then") === 0 && err118.schemaPath["#/definitions/properties/items/properties/binding/allOf/3/then".length] === "/") {
                      emErrs19.push(err118);
                      err118.emUsed = true;
                    }
                  }
                  if (emErrs19.length) {
                    const err119 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/then/errorMessage", params: { errors: emErrs19 }, message: "property.binding " + JSON.stringify(data31 && data31.type) + " requires one of the following: variables, sourceExpression, source, (sourceExpression and variables), or (source and variables)" };
                    if (vErrors === null) {
                      vErrors = [err119];
                    } else {
                      vErrors.push(err119);
                    }
                    errors2++;
                  }
                  const emErrs20 = [];
                  for (const err120 of vErrors) {
                    if (!err120.emUsed) {
                      emErrs20.push(err120);
                    }
                  }
                  vErrors = emErrs20;
                  errors2 = emErrs20.length;
                }
                var _valid9 = _errs95 === errors2;
                valid37 = _valid9;
              }
              if (!valid37) {
                const err121 = { keyword: "if", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/3/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err121];
                } else {
                  vErrors.push(err121);
                }
                errors2++;
              }
              const _errs122 = errors2;
              let valid48 = true;
              const _errs123 = errors2;
              if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                if (data31.type === void 0 && "type") {
                  const err122 = {};
                  if (vErrors === null) {
                    vErrors = [err122];
                  } else {
                    vErrors.push(err122);
                  }
                  errors2++;
                } else {
                  if (data31.type !== void 0) {
                    if (!equal(data31.type, "camunda:errorEventDefinition")) {
                      const err123 = {};
                      if (vErrors === null) {
                        vErrors = [err123];
                      } else {
                        vErrors.push(err123);
                      }
                      errors2++;
                    }
                  }
                }
              }
              var _valid14 = _errs123 === errors2;
              errors2 = _errs122;
              if (vErrors !== null) {
                if (_errs122) {
                  vErrors.length = _errs122;
                } else {
                  vErrors = null;
                }
              }
              if (_valid14) {
                const _errs125 = errors2;
                const _errs126 = errors2;
                let valid50 = false;
                let passing1 = null;
                const _errs127 = errors2;
                if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                  if (data31.errorRef === void 0) {
                    const err124 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/4/then/oneOf/0/required", params: { missingProperty: "errorRef" }, message: "should have required property 'errorRef'" };
                    if (vErrors === null) {
                      vErrors = [err124];
                    } else {
                      vErrors.push(err124);
                    }
                    errors2++;
                  }
                }
                var _valid15 = _errs127 === errors2;
                if (_valid15) {
                  valid50 = true;
                  passing1 = 0;
                }
                if (!valid50) {
                  const err125 = { keyword: "oneOf", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/4/then/oneOf", params: { passingSchemas: passing1 }, message: "should match exactly one schema in oneOf" };
                  if (vErrors === null) {
                    vErrors = [err125];
                  } else {
                    vErrors.push(err125);
                  }
                  errors2++;
                } else {
                  errors2 = _errs126;
                  if (vErrors !== null) {
                    if (_errs126) {
                      vErrors.length = _errs126;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                if (errors2 > 0) {
                  const emErrs21 = [];
                  for (const err126 of vErrors) {
                    if (err126.keyword !== "errorMessage" && !err126.emUsed && (err126.dataPath === dataPath + "/properties/" + i1 + "/binding" || err126.dataPath.indexOf(dataPath + "/properties/" + i1 + "/binding") === 0 && err126.dataPath[dataPath + "/properties/" + i1 + "/binding".length] === "/") && err126.schemaPath.indexOf("#/definitions/properties/items/properties/binding/allOf/4/then") === 0 && err126.schemaPath["#/definitions/properties/items/properties/binding/allOf/4/then".length] === "/") {
                      emErrs21.push(err126);
                      err126.emUsed = true;
                    }
                  }
                  if (emErrs21.length) {
                    const err127 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/4/then/errorMessage", params: { errors: emErrs21 }, message: "property.binding " + JSON.stringify(data31 && data31.type) + " requires errorRef" };
                    if (vErrors === null) {
                      vErrors = [err127];
                    } else {
                      vErrors.push(err127);
                    }
                    errors2++;
                  }
                  const emErrs22 = [];
                  for (const err128 of vErrors) {
                    if (!err128.emUsed) {
                      emErrs22.push(err128);
                    }
                  }
                  vErrors = emErrs22;
                  errors2 = emErrs22.length;
                }
                var _valid14 = _errs125 === errors2;
                valid48 = _valid14;
              }
              if (!valid48) {
                const err129 = { keyword: "if", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/allOf/4/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err129];
                } else {
                  vErrors.push(err129);
                }
                errors2++;
              }
              if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                if (data31.type === void 0) {
                  const err130 = { keyword: "required", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/required", params: { missingProperty: "type" }, message: "should have required property 'type'" };
                  if (vErrors === null) {
                    vErrors = [err130];
                  } else {
                    vErrors.push(err130);
                  }
                  errors2++;
                }
                if (data31.type !== void 0) {
                  let data37 = data31.type;
                  if (typeof data37 !== "string") {
                    const err131 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/binding/type", schemaPath: "#/definitions/properties/items/properties/binding/properties/type/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err131];
                    } else {
                      vErrors.push(err131);
                    }
                    errors2++;
                  }
                  if (!(data37 === "property" || data37 === "camunda:property" || data37 === "camunda:inputParameter" || data37 === "camunda:outputParameter" || data37 === "camunda:in" || data37 === "camunda:out" || data37 === "camunda:in:businessKey" || data37 === "camunda:executionListener" || data37 === "camunda:field" || data37 === "camunda:errorEventDefinition")) {
                    const err132 = { keyword: "enum", dataPath: dataPath + "/properties/" + i1 + "/binding/type", schemaPath: "#/definitions/properties/items/properties/binding/properties/type/enum", params: { allowedValues: schema18.items.properties.binding.properties.type.enum }, message: "should be equal to one of the allowed values" };
                    if (vErrors === null) {
                      vErrors = [err132];
                    } else {
                      vErrors.push(err132);
                    }
                    errors2++;
                  }
                  if (errors2 > 0) {
                    const emErrs23 = [];
                    for (const err133 of vErrors) {
                      if (err133.keyword !== "errorMessage" && !err133.emUsed && (err133.dataPath === dataPath + "/properties/" + i1 + "/binding/type" || err133.dataPath.indexOf(dataPath + "/properties/" + i1 + "/binding/type") === 0 && err133.dataPath[dataPath + "/properties/" + i1 + "/binding/type".length] === "/") && err133.schemaPath.indexOf("#/definitions/properties/items/properties/binding/properties/type") === 0 && err133.schemaPath["#/definitions/properties/items/properties/binding/properties/type".length] === "/") {
                        emErrs23.push(err133);
                        err133.emUsed = true;
                      }
                    }
                    if (emErrs23.length) {
                      const err134 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i1 + "/binding/type", schemaPath: "#/definitions/properties/items/properties/binding/properties/type/errorMessage", params: { errors: emErrs23 }, message: "invalid property.binding type " + JSON.stringify(data37) + "; must be any of { property, camunda:property, camunda:inputParameter, camunda:outputParameter, camunda:in, camunda:out, camunda:in:businessKey, camunda:executionListener, camunda:field, camunda:errorEventDefinition }" };
                      if (vErrors === null) {
                        vErrors = [err134];
                      } else {
                        vErrors.push(err134);
                      }
                      errors2++;
                    }
                    const emErrs24 = [];
                    for (const err135 of vErrors) {
                      if (!err135.emUsed) {
                        emErrs24.push(err135);
                      }
                    }
                    vErrors = emErrs24;
                    errors2 = emErrs24.length;
                  }
                }
                if (data31.name !== void 0) {
                  if (typeof data31.name !== "string") {
                    const err136 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/binding/name", schemaPath: "#/definitions/properties/items/properties/binding/properties/name/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err136];
                    } else {
                      vErrors.push(err136);
                    }
                    errors2++;
                  }
                }
                if (data31.event !== void 0) {
                  if (typeof data31.event !== "string") {
                    const err137 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/binding/event", schemaPath: "#/definitions/properties/items/properties/binding/properties/event/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err137];
                    } else {
                      vErrors.push(err137);
                    }
                    errors2++;
                  }
                }
                if (data31.scriptFormat !== void 0) {
                  if (typeof data31.scriptFormat !== "string") {
                    const err138 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/binding/scriptFormat", schemaPath: "#/definitions/properties/items/properties/binding/properties/scriptFormat/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err138];
                    } else {
                      vErrors.push(err138);
                    }
                    errors2++;
                  }
                }
                if (data31.source !== void 0) {
                  if (typeof data31.source !== "string") {
                    const err139 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/binding/source", schemaPath: "#/definitions/properties/items/properties/binding/properties/source/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err139];
                    } else {
                      vErrors.push(err139);
                    }
                    errors2++;
                  }
                }
                if (data31.target !== void 0) {
                  if (typeof data31.target !== "string") {
                    const err140 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/binding/target", schemaPath: "#/definitions/properties/items/properties/binding/properties/target/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err140];
                    } else {
                      vErrors.push(err140);
                    }
                    errors2++;
                  }
                }
                if (data31.expression !== void 0) {
                  if (typeof data31.expression !== "boolean") {
                    const err141 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/binding/expression", schemaPath: "#/definitions/properties/items/properties/binding/properties/expression/type", params: { type: "boolean" }, message: "should be boolean" };
                    if (vErrors === null) {
                      vErrors = [err141];
                    } else {
                      vErrors.push(err141);
                    }
                    errors2++;
                  }
                }
                if (data31.variables !== void 0) {
                  let data44 = data31.variables;
                  if (typeof data44 !== "string") {
                    const err142 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/binding/variables", schemaPath: "#/definitions/properties/items/properties/binding/properties/variables/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err142];
                    } else {
                      vErrors.push(err142);
                    }
                    errors2++;
                  }
                  if (!(data44 === "all" || data44 === "local")) {
                    const err143 = { keyword: "enum", dataPath: dataPath + "/properties/" + i1 + "/binding/variables", schemaPath: "#/definitions/properties/items/properties/binding/properties/variables/enum", params: { allowedValues: schema18.items.properties.binding.properties.variables.enum }, message: "should be equal to one of the allowed values" };
                    if (vErrors === null) {
                      vErrors = [err143];
                    } else {
                      vErrors.push(err143);
                    }
                    errors2++;
                  }
                }
                if (data31.sourceExpression !== void 0) {
                  if (typeof data31.sourceExpression !== "string") {
                    const err144 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/binding/sourceExpression", schemaPath: "#/definitions/properties/items/properties/binding/properties/sourceExpression/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err144];
                    } else {
                      vErrors.push(err144);
                    }
                    errors2++;
                  }
                }
              } else {
                const err145 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/binding", schemaPath: "#/definitions/properties/items/properties/binding/type", params: { type: "object" }, message: "should be object" };
                if (vErrors === null) {
                  vErrors = [err145];
                } else {
                  vErrors.push(err145);
                }
                errors2++;
              }
            }
            if (data8.constraints !== void 0) {
              let data46 = data8.constraints;
              if (data46 && typeof data46 == "object" && !Array.isArray(data46)) {
                if (data46.notEmpty !== void 0) {
                  if (typeof data46.notEmpty !== "boolean") {
                    const err146 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/constraints/notEmpty", schemaPath: "#/definitions/properties/items/properties/constraints/properties/notEmpty/type", params: { type: "boolean" }, message: "should be boolean" };
                    if (vErrors === null) {
                      vErrors = [err146];
                    } else {
                      vErrors.push(err146);
                    }
                    errors2++;
                  }
                }
                if (data46.minLength !== void 0) {
                  if (!(typeof data46.minLength == "number")) {
                    const err147 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/constraints/minLength", schemaPath: "#/definitions/properties/items/properties/constraints/properties/minLength/type", params: { type: "number" }, message: "should be number" };
                    if (vErrors === null) {
                      vErrors = [err147];
                    } else {
                      vErrors.push(err147);
                    }
                    errors2++;
                  }
                }
                if (data46.maxLength !== void 0) {
                  if (!(typeof data46.maxLength == "number")) {
                    const err148 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/constraints/maxLength", schemaPath: "#/definitions/properties/items/properties/constraints/properties/maxLength/type", params: { type: "number" }, message: "should be number" };
                    if (vErrors === null) {
                      vErrors = [err148];
                    } else {
                      vErrors.push(err148);
                    }
                    errors2++;
                  }
                }
                if (data46.pattern !== void 0) {
                  let data50 = data46.pattern;
                  const _errs155 = errors2;
                  let valid53 = false;
                  let passing2 = null;
                  const _errs156 = errors2;
                  if (data50 && typeof data50 == "object" && !Array.isArray(data50)) {
                    if (data50.value !== void 0) {
                      if (typeof data50.value !== "string") {
                        const err149 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/constraints/pattern/value", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf/0/properties/value/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err149];
                        } else {
                          vErrors.push(err149);
                        }
                        errors2++;
                      }
                    }
                    if (data50.message !== void 0) {
                      if (typeof data50.message !== "string") {
                        const err150 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/constraints/pattern/message", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf/0/properties/message/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err150];
                        } else {
                          vErrors.push(err150);
                        }
                        errors2++;
                      }
                    }
                  } else {
                    const err151 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/constraints/pattern", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf/0/type", params: { type: "object" }, message: "should be object" };
                    if (vErrors === null) {
                      vErrors = [err151];
                    } else {
                      vErrors.push(err151);
                    }
                    errors2++;
                  }
                  var _valid16 = _errs156 === errors2;
                  if (_valid16) {
                    valid53 = true;
                    passing2 = 0;
                  }
                  const _errs162 = errors2;
                  if (typeof data50 !== "string") {
                    const err152 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/constraints/pattern", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf/1/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err152];
                    } else {
                      vErrors.push(err152);
                    }
                    errors2++;
                  }
                  var _valid16 = _errs162 === errors2;
                  if (_valid16 && valid53) {
                    valid53 = false;
                    passing2 = [passing2, 1];
                  } else {
                    if (_valid16) {
                      valid53 = true;
                      passing2 = 1;
                    }
                  }
                  if (!valid53) {
                    const err153 = { keyword: "oneOf", dataPath: dataPath + "/properties/" + i1 + "/constraints/pattern", schemaPath: "#/definitions/properties/items/properties/constraints/properties/pattern/oneOf", params: { passingSchemas: passing2 }, message: "should match exactly one schema in oneOf" };
                    if (vErrors === null) {
                      vErrors = [err153];
                    } else {
                      vErrors.push(err153);
                    }
                    errors2++;
                  } else {
                    errors2 = _errs155;
                    if (vErrors !== null) {
                      if (_errs155) {
                        vErrors.length = _errs155;
                      } else {
                        vErrors = null;
                      }
                    }
                  }
                }
              } else {
                const err154 = { keyword: "type", dataPath: dataPath + "/properties/" + i1 + "/constraints", schemaPath: "#/definitions/properties/items/properties/constraints/type", params: { type: "object" }, message: "should be object" };
                if (vErrors === null) {
                  vErrors = [err154];
                } else {
                  vErrors.push(err154);
                }
                errors2++;
              }
            }
          } else {
            const err155 = { keyword: "type", dataPath: dataPath + "/properties/" + i1, schemaPath: "#/definitions/properties/items/type", params: { type: "object" }, message: "should be object" };
            if (vErrors === null) {
              vErrors = [err155];
            } else {
              vErrors.push(err155);
            }
            errors2++;
          }
          if (errors2 > 0) {
            const emErrors1 = { "required": { "binding": [] } };
            const templates1 = { required: { binding: function() {
              return 'missing binding for property "' + JSON.stringify(i1) + '"';
            } } };
            let emPropParams0;
            let emParamsErrors0;
            for (const err156 of vErrors) {
              if (err156.keyword !== "errorMessage" && !err156.emUsed && err156.dataPath === dataPath + "/properties/" + i1 && err156.keyword in emErrors1 && err156.schemaPath.indexOf("#/definitions/properties/items") === 0 && /^\/[^\/]*$/.test(err156.schemaPath.slice(30))) {
                emPropParams0 = obj0[err156.keyword];
                emParamsErrors0 = emErrors1[err156.keyword][err156.params[emPropParams0]];
                if (emParamsErrors0) {
                  emParamsErrors0.push(err156);
                  err156.emUsed = true;
                }
              }
            }
            for (const key1 in emErrors1) {
              for (const keyProp0 in emErrors1[key1]) {
                emParamsErrors0 = emErrors1[key1][keyProp0];
                if (emParamsErrors0.length) {
                  const tmpl0 = templates1[key1] && templates1[key1][keyProp0];
                  const err157 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i1, schemaPath: "#/definitions/properties/items/errorMessage", params: { errors: emParamsErrors0 }, message: tmpl0 ? tmpl0() : schema18.items.errorMessage[key1][keyProp0] };
                  if (vErrors === null) {
                    vErrors = [err157];
                  } else {
                    vErrors.push(err157);
                  }
                  errors2++;
                }
              }
            }
            const emErrs25 = [];
            for (const err158 of vErrors) {
              if (!err158.emUsed) {
                emErrs25.push(err158);
              }
            }
            vErrors = emErrs25;
            errors2 = emErrs25.length;
          }
        }
      } else {
        const err159 = { keyword: "type", dataPath: dataPath + "/properties", schemaPath: "#/definitions/properties/type", params: { type: "array" }, message: "should be array" };
        if (vErrors === null) {
          vErrors = [err159];
        } else {
          vErrors.push(err159);
        }
        errors2++;
      }
    }
    if (data.metadata !== void 0) {
      let data53 = data.metadata;
      if (!(data53 && typeof data53 == "object" && !Array.isArray(data53))) {
        const err160 = { keyword: "type", dataPath: dataPath + "/metadata", schemaPath: "#/properties/metadata/type", params: { type: "object" }, message: "should be object" };
        if (vErrors === null) {
          vErrors = [err160];
        } else {
          vErrors.push(err160);
        }
        errors2++;
      }
    }
    if (data.scopes !== void 0) {
      let data54 = data.scopes;
      const _errs167 = errors2;
      let valid55 = false;
      let passing3 = null;
      const _errs168 = errors2;
      if (!validate16(data54, { dataPath: dataPath + "/scopes", parentData: data, parentDataProperty: "scopes", rootData })) {
        vErrors = vErrors === null ? validate16.errors : vErrors.concat(validate16.errors);
        errors2 = vErrors.length;
      }
      var _valid17 = _errs168 === errors2;
      if (_valid17) {
        valid55 = true;
        passing3 = 0;
      }
      const _errs169 = errors2;
      if (!validate18(data54, { dataPath: dataPath + "/scopes", parentData: data, parentDataProperty: "scopes", rootData })) {
        vErrors = vErrors === null ? validate18.errors : vErrors.concat(validate18.errors);
        errors2 = vErrors.length;
      }
      var _valid17 = _errs169 === errors2;
      if (_valid17 && valid55) {
        valid55 = false;
        passing3 = [passing3, 1];
      } else {
        if (_valid17) {
          valid55 = true;
          passing3 = 1;
        }
      }
      if (!valid55) {
        const err161 = { keyword: "oneOf", dataPath: dataPath + "/scopes", schemaPath: "#/properties/scopes/oneOf", params: { passingSchemas: passing3 }, message: "should match exactly one schema in oneOf" };
        if (vErrors === null) {
          vErrors = [err161];
        } else {
          vErrors.push(err161);
        }
        errors2++;
      } else {
        errors2 = _errs167;
        if (vErrors !== null) {
          if (_errs167) {
            vErrors.length = _errs167;
          } else {
            vErrors = null;
          }
        }
      }
    }
    if (data.entriesVisible !== void 0) {
      let data55 = data.entriesVisible;
      if (!(data55 && typeof data55 == "object" && !Array.isArray(data55)) && typeof data55 !== "boolean") {
        const err162 = { keyword: "type", dataPath: dataPath + "/entriesVisible", schemaPath: "#/properties/entriesVisible/type", params: { type: schema17.properties.entriesVisible.type }, message: "should be object,boolean" };
        if (vErrors === null) {
          vErrors = [err162];
        } else {
          vErrors.push(err162);
        }
        errors2++;
      }
    }
  } else {
    const err163 = { keyword: "type", dataPath, schemaPath: "#/type", params: { type: "object" }, message: "should be object" };
    if (vErrors === null) {
      vErrors = [err163];
    } else {
      vErrors.push(err163);
    }
    errors2++;
  }
  if (errors2 > 0) {
    const emErrors2 = { "required": { "name": [], "id": [], "appliesTo": [], "properties": [] } };
    const templates2 = { required: {} };
    let emPropParams1;
    let emParamsErrors1;
    for (const err164 of vErrors) {
      if (err164.keyword !== "errorMessage" && !err164.emUsed && err164.dataPath === dataPath && err164.keyword in emErrors2 && err164.schemaPath.indexOf("#") === 0 && /^\/[^\/]*$/.test(err164.schemaPath.slice(1))) {
        emPropParams1 = obj0[err164.keyword];
        emParamsErrors1 = emErrors2[err164.keyword][err164.params[emPropParams1]];
        if (emParamsErrors1) {
          emParamsErrors1.push(err164);
          err164.emUsed = true;
        }
      }
    }
    for (const key2 in emErrors2) {
      for (const keyProp1 in emErrors2[key2]) {
        emParamsErrors1 = emErrors2[key2][keyProp1];
        if (emParamsErrors1.length) {
          const tmpl1 = templates2[key2] && templates2[key2][keyProp1];
          const err165 = { keyword: "errorMessage", dataPath, schemaPath: "#/errorMessage", params: { errors: emParamsErrors1 }, message: tmpl1 ? tmpl1() : schema17.errorMessage[key2][keyProp1] };
          if (vErrors === null) {
            vErrors = [err165];
          } else {
            vErrors.push(err165);
          }
          errors2++;
        }
      }
    }
    const emErrs26 = [];
    for (const err166 of vErrors) {
      if (!err166.emUsed) {
        emErrs26.push(err166);
      }
    }
    vErrors = emErrs26;
    errors2 = emErrs26.length;
  }
  validate15.errors = vErrors;
  return errors2 === 0;
}
function validate14(data, { dataPath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors2 = 0;
  const _errs0 = errors2;
  let valid0 = false;
  let passing0 = null;
  const _errs1 = errors2;
  if (!validate15(data, { dataPath, parentData, parentDataProperty, rootData })) {
    vErrors = vErrors === null ? validate15.errors : vErrors.concat(validate15.errors);
    errors2 = vErrors.length;
  }
  var _valid0 = _errs1 === errors2;
  if (_valid0) {
    valid0 = true;
    passing0 = 0;
  }
  const _errs2 = errors2;
  if (Array.isArray(data)) {
    const len0 = data.length;
    for (let i0 = 0; i0 < len0; i0++) {
      if (!validate15(data[i0], { dataPath: dataPath + "/" + i0, parentData: data, parentDataProperty: i0, rootData })) {
        vErrors = vErrors === null ? validate15.errors : vErrors.concat(validate15.errors);
        errors2 = vErrors.length;
      }
    }
  } else {
    const err0 = { keyword: "type", dataPath, schemaPath: "#/oneOf/1/type", params: { type: "array" }, message: "should be array" };
    if (vErrors === null) {
      vErrors = [err0];
    } else {
      vErrors.push(err0);
    }
    errors2++;
  }
  var _valid0 = _errs2 === errors2;
  if (_valid0 && valid0) {
    valid0 = false;
    passing0 = [passing0, 1];
  } else {
    if (_valid0) {
      valid0 = true;
      passing0 = 1;
    }
  }
  if (!valid0) {
    const err1 = { keyword: "oneOf", dataPath, schemaPath: "#/oneOf", params: { passingSchemas: passing0 }, message: "should match exactly one schema in oneOf" };
    if (vErrors === null) {
      vErrors = [err1];
    } else {
      vErrors.push(err1);
    }
    errors2++;
  } else {
    errors2 = _errs0;
    if (vErrors !== null) {
      if (_errs0) {
        vErrors.length = _errs0;
      } else {
        vErrors = null;
      }
    }
  }
  validate14.errors = vErrors;
  return errors2 === 0;
}
standaloneValidator.default = _default;
function getSchemaVersion$1() {
  return version;
}
function validate(object) {
  const dataPointerMap = generateDataPointerMap(object);
  const valid = standaloneValidator(object);
  let errors2 = standaloneValidator.errors;
  if (errors2 && errors2.length) {
    forEach$q(errors2, wrapRawErrors);
    errors2 = ignoreSupportiveErrors(errors2);
    forEach$q(errors2, function(error2) {
      setDataPointer(error2, dataPointerMap);
    });
  }
  return {
    valid,
    object,
    errors: errors2
  };
}
function validateAll(objects) {
  const results = [];
  let allValid = true;
  forEach$q(objects, function(object) {
    const result = validate(object);
    if (!result.valid) {
      allValid = false;
    }
    results.push(result);
  });
  return {
    valid: allValid,
    results
  };
}
function wrapRawErrors(error2) {
  const params = error2.params;
  if (params && params.errors) {
    params.rawErrors = params.errors;
    delete params.errors;
  }
}
function setDataPointer(error2, dataPointerMap) {
  const dataPath = error2.dataPath;
  const pointer = dataPointerMap[dataPath];
  error2.dataPointer = pointer;
}
function ignoreSupportiveErrors(errors2) {
  return filter$a(errors2, function(error2) {
    return error2.keyword !== "if";
  });
}
function generateDataPointerMap(object) {
  return jsonSourceMap.stringify(object, null, 2).pointers;
}
var index_esm$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getSchemaVersion: getSchemaVersion$1,
  validate,
  validateAll
}, Symbol.toStringTag, { value: "Module" }));
var require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(index_esm$1);
var isArray$1 = require$$1$1.isArray, filter$7 = require$$1$1.filter;
var semver = semver$1.exports;
var validateAgainstSchema = require$$2$1.validate, getTemplateSchemaVersion = require$$2$1.getSchemaVersion;
var SUPPORTED_SCHEMA_VERSION = getTemplateSchemaVersion();
function Validator$1() {
  this._templatesById = {};
  this._validTemplates = [];
  this._errors = [];
  this.addAll = function(templates) {
    if (!isArray$1(templates)) {
      this._logError("templates must be []");
    } else {
      templates.forEach(this.add, this);
    }
    return this;
  };
  this.add = function(template2) {
    var err = this._validateTemplate(template2);
    var id2, version2;
    if (!err) {
      id2 = template2.id;
      version2 = template2.version || "_";
      if (!this._templatesById[id2]) {
        this._templatesById[id2] = {};
      }
      this._templatesById[id2][version2] = template2;
      this._validTemplates.push(template2);
    }
    return this;
  };
  this._validateTemplate = function(template2) {
    var err, id2 = template2.id, version2 = template2.version || "_", schemaVersion = template2.$schema && getSchemaVersion(template2.$schema), self2 = this;
    if (schemaVersion && semver.compare(SUPPORTED_SCHEMA_VERSION, schemaVersion) < 0) {
      return this._logError("unsupported element template schema version <" + schemaVersion + ">. Your installation only supports up to version <" + SUPPORTED_SCHEMA_VERSION + ">. Please update your installation", template2);
    }
    if (this._templatesById[id2] && this._templatesById[id2][version2]) {
      if (version2 === "_") {
        return this._logError("template id <" + id2 + "> already used", template2);
      } else {
        return this._logError("template id <" + id2 + "> and version <" + version2 + "> already used", template2);
      }
    }
    var validationResult = validateAgainstSchema(template2), valid = validationResult.valid, errors2 = validationResult.errors;
    if (!valid) {
      err = new Error("invalid template");
      filteredSchemaErrors(errors2).forEach(function(error2) {
        self2._logError(error2.message, template2);
      });
    }
    return err;
  };
  this._logError = function(err, template2) {
    if (typeof err === "string") {
      if (template2) {
        err = "template(id: <" + template2.id + ">, name: <" + template2.name + ">): " + err;
      }
      err = new Error(err);
    }
    this._errors.push(err);
    return err;
  };
  this.getErrors = function() {
    return this._errors;
  };
  this.getValidTemplates = function() {
    return this._validTemplates;
  };
}
var Validator_1 = Validator$1;
function getSchemaVersion(schemaUri) {
  var re2 = /\d+\.\d+\.\d+/g;
  var match2 = schemaUri.match(re2);
  return match2 === null ? void 0 : match2[0];
}
function filteredSchemaErrors(schemaErrors) {
  return filter$7(schemaErrors, function(err) {
    if (err.keyword === "errorMessage") {
      return true;
    }
    if (err.keyword === "type" && err.dataPath && err.dataPath !== "/scopes") {
      return true;
    }
    return false;
  });
}
var Validator = Validator_1;
function ElementTemplatesLoader(loadTemplates, eventBus, elementTemplates2) {
  this._loadTemplates = loadTemplates;
  this._eventBus = eventBus;
  this._elementTemplates = elementTemplates2;
  var self2 = this;
  eventBus.on("diagram.init", function() {
    self2.reload();
  });
}
var ElementTemplatesLoader_1 = ElementTemplatesLoader;
ElementTemplatesLoader.$inject = [
  "config.elementTemplates",
  "eventBus",
  "elementTemplates"
];
ElementTemplatesLoader.prototype.reload = function() {
  var self2 = this;
  var loadTemplates = this._loadTemplates;
  if (typeof loadTemplates === "undefined") {
    return;
  }
  if (typeof loadTemplates === "function") {
    return loadTemplates(function(err, templates) {
      if (err) {
        return self2.templateErrors([err]);
      }
      self2.setTemplates(templates);
    });
  }
  if (loadTemplates.length) {
    return this.setTemplates(loadTemplates);
  }
};
ElementTemplatesLoader.prototype.setTemplates = function(templates) {
  var elementTemplates2 = this._elementTemplates;
  var validator = new Validator().addAll(templates);
  var errors2 = validator.getErrors(), validTemplates = validator.getValidTemplates();
  elementTemplates2.set(validTemplates);
  if (errors2.length) {
    this.templateErrors(errors2);
  }
  this.templatesChanged();
};
ElementTemplatesLoader.prototype.templatesChanged = function() {
  this._eventBus.fire("elementTemplates.changed");
};
ElementTemplatesLoader.prototype.templateErrors = function(errors2) {
  this._eventBus.fire("elementTemplates.errors", {
    errors: errors2
  });
};
var is$H = require$$2$2.is;
function ReplaceBehavior(elementTemplates2, eventBus) {
  eventBus.on("moddleCopy.canCopyProperty", function(context) {
    var parent2 = context.parent;
    var property2 = context.property;
    var propertyName = context.propertyName;
    if (propertyName !== "modelerTemplate") {
      return;
    }
    var elementTemplate = elementTemplates2.get(property2);
    if (!elementTemplate) {
      return false;
    }
    var appliesTo = elementTemplate.appliesTo;
    var allowed = appliesTo.reduce(function(allowed2, type) {
      return allowed2 || is$H(parent2, type);
    }, false);
    if (!allowed) {
      return false;
    }
  });
}
ReplaceBehavior.$inject = ["elementTemplates", "eventBus"];
var ReplaceBehavior_1 = ReplaceBehavior;
var elementTemplates = {
  __depends__: [
    cmd,
    require$$1$3.default
  ],
  __init__: [
    "customElementsPropertiesActivator",
    "elementTemplatesLoader",
    "replaceBehavior"
  ],
  customElementsPropertiesActivator: ["type", CustomElementsPropertiesActivator_1],
  elementTemplates: ["type", ElementTemplates_1],
  elementTemplatesLoader: ["type", ElementTemplatesLoader_1],
  replaceBehavior: ["type", ReplaceBehavior_1]
};
var AsyncCapableHelper = {};
var CmdHelper = {};
var CmdHelper_1 = CmdHelper;
CmdHelper.updateProperties = function(element, properties2) {
  return {
    cmd: "element.updateProperties",
    context: { element, properties: properties2 }
  };
};
CmdHelper.updateBusinessObject = function(element, businessObject, newProperties) {
  return {
    cmd: "properties-panel.update-businessobject",
    context: {
      element,
      businessObject,
      properties: newProperties
    }
  };
};
CmdHelper.addElementsTolist = function(element, businessObject, listPropertyName, objectsToAdd, objectsToPrepend) {
  return {
    cmd: "properties-panel.update-businessobject-list",
    context: {
      element,
      currentObject: businessObject,
      propertyName: listPropertyName,
      objectsToPrepend,
      objectsToAdd
    }
  };
};
CmdHelper.removeElementsFromList = function(element, businessObject, listPropertyName, referencePropertyName, objectsToRemove) {
  return {
    cmd: "properties-panel.update-businessobject-list",
    context: {
      element,
      currentObject: businessObject,
      propertyName: listPropertyName,
      referencePropertyName,
      objectsToRemove
    }
  };
};
CmdHelper.addAndRemoveElementsFromList = function(element, businessObject, listPropertyName, referencePropertyName, objectsToAdd, objectsToRemove) {
  return {
    cmd: "properties-panel.update-businessobject-list",
    context: {
      element,
      currentObject: businessObject,
      propertyName: listPropertyName,
      referencePropertyName,
      objectsToAdd,
      objectsToRemove
    }
  };
};
CmdHelper.setList = function(element, businessObject, listPropertyName, updatedObjectList) {
  return {
    cmd: "properties-panel.update-businessobject-list",
    context: {
      element,
      currentObject: businessObject,
      propertyName: listPropertyName,
      updatedObjectList
    }
  };
};
var cmdHelper$N = CmdHelper_1, elementHelper$l = ElementHelper_1;
var is$G = require$$2$2.is;
var ExtensionElementsHelper = {};
ExtensionElementsHelper.getExtensionElements = function(bo, type) {
  var elements = [];
  var extensionElements2 = bo.get("extensionElements");
  if (typeof extensionElements2 !== "undefined") {
    var extensionValues = extensionElements2.get("values");
    if (typeof extensionValues !== "undefined") {
      elements = extensionValues.filter(function(value) {
        return is$G(value, type);
      });
    }
  }
  return elements;
};
ExtensionElementsHelper.addEntry = function(bo, element, entry, bpmnFactory) {
  var extensionElements2 = bo.get("extensionElements");
  if (!extensionElements2) {
    extensionElements2 = elementHelper$l.createElement("bpmn:ExtensionElements", { values: [entry] }, bo, bpmnFactory);
    return { extensionElements: extensionElements2 };
  } else {
    return cmdHelper$N.addElementsTolist(element, extensionElements2, "values", [entry]);
  }
};
ExtensionElementsHelper.removeEntry = function(bo, element, entry) {
  var extensionElements2 = bo.get("extensionElements");
  if (!extensionElements2) {
    return {};
  }
  return cmdHelper$N.removeElementsFromList(element, extensionElements2, "values", "extensionElements", [entry]);
};
var ExtensionElementsHelper_1 = ExtensionElementsHelper;
var map$3 = map_1;
var extensionElementsHelper$a = ExtensionElementsHelper_1;
function isAsyncBefore$2(bo) {
  return !!(bo.get("camunda:asyncBefore") || bo.get("camunda:async"));
}
AsyncCapableHelper.isAsyncBefore = isAsyncBefore$2;
function isAsyncAfter$2(bo) {
  return !!bo.get("camunda:asyncAfter");
}
AsyncCapableHelper.isAsyncAfter = isAsyncAfter$2;
function isExclusive$1(bo) {
  return !!bo.get("camunda:exclusive");
}
AsyncCapableHelper.isExclusive = isExclusive$1;
function getFailedJobRetryTimeCycle$1(bo) {
  return extensionElementsHelper$a.getExtensionElements(bo, "camunda:FailedJobRetryTimeCycle")[0];
}
AsyncCapableHelper.getFailedJobRetryTimeCycle = getFailedJobRetryTimeCycle$1;
function removeFailedJobRetryTimeCycle$2(bo, element) {
  var retryTimeCycles = extensionElementsHelper$a.getExtensionElements(bo, "camunda:FailedJobRetryTimeCycle");
  return map$3(retryTimeCycles, function(cycle) {
    return extensionElementsHelper$a.removeEntry(bo, element, cycle);
  });
}
AsyncCapableHelper.removeFailedJobRetryTimeCycle = removeFailedJobRetryTimeCycle$2;
var ModelUtil$3 = require$$2$2, is$F = ModelUtil$3.is, getBusinessObject$Q = ModelUtil$3.getBusinessObject;
var eventDefinitionHelper$8 = EventDefinitionHelper_1;
var extensionsElementHelper = ExtensionElementsHelper_1;
var ImplementationTypeHelper$7 = {};
var ImplementationTypeHelper_1 = ImplementationTypeHelper$7;
ImplementationTypeHelper$7.isServiceTaskLike = function(element) {
  return is$F(element, "camunda:ServiceTaskLike");
};
ImplementationTypeHelper$7.isDmnCapable = function(element) {
  return is$F(element, "camunda:DmnCapable");
};
ImplementationTypeHelper$7.isExternalCapable = function(element) {
  return is$F(element, "camunda:ExternalCapable");
};
ImplementationTypeHelper$7.isTaskListener = function(element) {
  return is$F(element, "camunda:TaskListener");
};
ImplementationTypeHelper$7.isExecutionListener = function(element) {
  return is$F(element, "camunda:ExecutionListener");
};
ImplementationTypeHelper$7.isListener = function(element) {
  return this.isTaskListener(element) || this.isExecutionListener(element);
};
ImplementationTypeHelper$7.isSequenceFlow = function(element) {
  return is$F(element, "bpmn:SequenceFlow");
};
ImplementationTypeHelper$7.getServiceTaskLikeBusinessObject = function(element) {
  if (is$F(element, "bpmn:IntermediateThrowEvent") || is$F(element, "bpmn:EndEvent")) {
    var messageEventDefinition = eventDefinitionHelper$8.getMessageEventDefinition(element);
    if (messageEventDefinition) {
      element = messageEventDefinition;
    }
  }
  return this.isServiceTaskLike(element) && getBusinessObject$Q(element);
};
ImplementationTypeHelper$7.getImplementationType = function(element) {
  var bo = this.getServiceTaskLikeBusinessObject(element);
  if (!bo) {
    if (this.isListener(element)) {
      bo = element;
    } else {
      return;
    }
  }
  if (this.isDmnCapable(bo)) {
    var decisionRef = bo.get("camunda:decisionRef");
    if (typeof decisionRef !== "undefined") {
      return "dmn";
    }
  }
  if (this.isServiceTaskLike(bo)) {
    var connectors = extensionsElementHelper.getExtensionElements(bo, "camunda:Connector");
    if (connectors.length) {
      return "connector";
    }
  }
  if (this.isExternalCapable(bo)) {
    var type = bo.get("camunda:type");
    if (type === "external") {
      return "external";
    }
  }
  var cls = bo.get("camunda:class");
  if (typeof cls !== "undefined") {
    return "class";
  }
  var expression = bo.get("camunda:expression");
  if (typeof expression !== "undefined") {
    return "expression";
  }
  var delegateExpression = bo.get("camunda:delegateExpression");
  if (typeof delegateExpression !== "undefined") {
    return "delegateExpression";
  }
  if (this.isListener(bo)) {
    var script = bo.get("script");
    if (typeof script !== "undefined") {
      return "script";
    }
  }
};
var domify$e = require$$6.domify, domClasses$6 = require$$6.classes, domEvent$3 = require$$6.event;
var escapeHTML$k = Utils.escapeHTML;
var MAX_DESCRIPTION_LENGTH$3 = 200;
var EntryFieldDescription = function entryFieldDescription2(translate2, description, options) {
  var show = options && options.show;
  var escaped = [];
  var pattern = /(?:\[([^\]]+)\]\((https?:\/\/[^)]+)\))|(?:<a href="(https?:\/\/[^"]+)">(.+?(?=<\/))<\/a>)/gi;
  var index2 = 0;
  var match2;
  var link2, text;
  while (match2 = pattern.exec(description)) {
    if (match2.index > index2) {
      escaped.push(escapeText(description.substring(index2, match2.index)));
    }
    link2 = match2[2] && encodeURI(match2[2]) || match2[3];
    text = match2[1] || match2[4];
    escaped.push('<a href="' + link2 + '" target="_blank">' + escapeText(text) + "</a>");
    index2 = match2.index + match2[0].length;
  }
  if (index2 < description.length) {
    escaped.push(escapeText(description.substring(index2)));
  }
  description = escaped.join("");
  var html = domify$e('<div class="bpp-field-description description description--expanded"' + (show ? 'data-show="' + show + '">' : ">") + "</div>");
  var descriptionText = domify$e('<span class="description__text">' + description + "</span>");
  html.appendChild(descriptionText);
  function toggleExpanded(expanded2) {
    if (expanded2) {
      domClasses$6(html).add("description--expanded");
      descriptionText.textContent = description + " ";
      expand.textContent = translate2("Less");
    } else {
      domClasses$6(html).remove("description--expanded");
      descriptionText.textContent = descriptionShortened + " ... ";
      expand.textContent = translate2("More");
    }
  }
  var descriptionShortened, expand, expanded = false;
  if (description.length > MAX_DESCRIPTION_LENGTH$3) {
    descriptionShortened = description.slice(0, MAX_DESCRIPTION_LENGTH$3);
    expand = domify$e('<span class="bpp-entry-link description__expand">' + translate2("More") + "</span>");
    domEvent$3.bind(expand, "click", function() {
      expanded = !expanded;
      toggleExpanded(expanded);
    });
    html.appendChild(expand);
    toggleExpanded(expanded);
  }
  return html;
};
function escapeText(text) {
  var match2, index2 = 0, escaped = [];
  var pattern = /<br\s*\/?>/gi;
  while (match2 = pattern.exec(text)) {
    if (match2.index > index2) {
      escaped.push(escapeHTML$k(text.substring(index2, match2.index)));
    }
    escaped.push("<br />");
    index2 = match2.index + match2[0].length;
  }
  if (index2 < text.length) {
    escaped.push(escapeHTML$k(text.substring(index2)));
  }
  return escaped.join("");
}
var escapeHTML$j = Utils.escapeHTML;
var domify$d = require$$6.domify, domQuery$j = require$$6.query;
var entryFieldDescription$c = EntryFieldDescription;
var textField$1 = function(translate2, options, defaultParameters) {
  var defaultButtonAction = function(element, inputNode) {
    var input = domQuery$j('input[name="' + options.modelProperty + '"]', inputNode);
    input.value = "";
    return true;
  };
  var defaultButtonShow = function(element, inputNode) {
    var input = domQuery$j('input[name="' + options.modelProperty + '"]', inputNode);
    return input.value !== "";
  };
  var resource = defaultParameters, label2 = options.label || resource.id, dataValueLabel = options.dataValueLabel, buttonLabel = options.buttonLabel || "X", actionName = typeof options.buttonAction != "undefined" ? options.buttonAction.name : "clear", actionMethod = typeof options.buttonAction != "undefined" ? options.buttonAction.method : defaultButtonAction, showName = typeof options.buttonShow != "undefined" ? options.buttonShow.name : "canClear", showMethod = typeof options.buttonShow != "undefined" ? options.buttonShow.method : defaultButtonShow, canBeDisabled = !!options.disabled && typeof options.disabled === "function", canBeHidden = !!options.hidden && typeof options.hidden === "function", description = options.description;
  resource.html = domify$d('<label for="camunda-' + escapeHTML$j(resource.id) + '" ' + (canBeDisabled ? 'data-disable="isDisabled" ' : "") + (canBeHidden ? 'data-show="isHidden" ' : "") + (dataValueLabel ? 'data-value="' + escapeHTML$j(dataValueLabel) + '"' : "") + ">" + escapeHTML$j(label2) + '</label><div class="bpp-field-wrapper" ' + (canBeDisabled ? 'data-disable="isDisabled"' : "") + (canBeHidden ? 'data-show="isHidden"' : "") + '><input id="camunda-' + escapeHTML$j(resource.id) + '" type="text" name="' + escapeHTML$j(options.modelProperty) + '" ' + (canBeDisabled ? 'data-disable="isDisabled"' : "") + (canBeHidden ? 'data-show="isHidden"' : "") + ' /><button class="action-button ' + escapeHTML$j(actionName) + '" data-action="' + escapeHTML$j(actionName) + '" data-show="' + escapeHTML$j(showName) + '" ' + (canBeDisabled ? 'data-disable="isDisabled"' : "") + (canBeHidden ? ' data-show="isHidden"' : "") + "><span>" + escapeHTML$j(buttonLabel) + "</span></button></div>");
  if (description) {
    resource.html.appendChild(entryFieldDescription$c(translate2, description, { show: canBeHidden && "isHidden" }));
  }
  resource[actionName] = actionMethod;
  resource[showName] = showMethod;
  if (canBeDisabled) {
    resource.isDisabled = function() {
      return options.disabled.apply(resource, arguments);
    };
  }
  if (canBeHidden) {
    resource.isHidden = function() {
      return !options.hidden.apply(resource, arguments);
    };
  }
  resource.cssClasses = ["bpp-textfield"];
  return resource;
};
var TextInputEntryFactory = textField$1;
var domify$c = require$$6.domify;
var getBusinessObject$P = require$$2$2.getBusinessObject, cmdHelper$M = CmdHelper_1, escapeHTML$i = Utils.escapeHTML;
var entryFieldDescription$b = EntryFieldDescription;
var checkbox = function(translate2, options, defaultParameters) {
  var resource = defaultParameters, id2 = resource.id, label2 = options.label || id2, canBeDisabled = !!options.disabled && typeof options.disabled === "function", canBeHidden = !!options.hidden && typeof options.hidden === "function", description = options.description;
  resource.html = domify$c('<input id="camunda-' + escapeHTML$i(id2) + '" type="checkbox" name="' + escapeHTML$i(options.modelProperty) + '" ' + (canBeDisabled ? 'data-disable="isDisabled"' : "") + (canBeHidden ? 'data-show="isHidden"' : "") + ' /><label for="camunda-' + escapeHTML$i(id2) + '" ' + (canBeDisabled ? 'data-disable="isDisabled"' : "") + (canBeHidden ? 'data-show="isHidden"' : "") + ">" + escapeHTML$i(label2) + "</label>");
  if (description) {
    resource.html.appendChild(entryFieldDescription$b(translate2, description, { show: canBeHidden && "isHidden" }));
  }
  resource.get = function(element) {
    var bo = getBusinessObject$P(element), res = {};
    res[options.modelProperty] = bo.get(options.modelProperty);
    return res;
  };
  resource.set = function(element, values2) {
    var res = {};
    res[options.modelProperty] = !!values2[options.modelProperty];
    return cmdHelper$M.updateProperties(element, res);
  };
  if (typeof options.set === "function") {
    resource.set = options.set;
  }
  if (typeof options.get === "function") {
    resource.get = options.get;
  }
  if (canBeDisabled) {
    resource.isDisabled = function() {
      return options.disabled.apply(resource, arguments);
    };
  }
  if (canBeHidden) {
    resource.isHidden = function() {
      return !options.hidden.apply(resource, arguments);
    };
  }
  resource.cssClasses = ["bpp-checkbox"];
  return resource;
};
var CheckboxEntryFactory = checkbox;
var escapeHTML$h = Utils.escapeHTML;
var domify$b = require$$6.domify, domQuery$i = require$$6.query;
var forEach$e = forEach_1;
var entryFieldDescription$a = EntryFieldDescription;
var isList$1 = function(list) {
  return !(!list || Object.prototype.toString.call(list) !== "[object Array]");
};
var addEmptyParameter = function(list) {
  return list.concat([{ name: "", value: "" }]);
};
var createOption = function(option2) {
  return '<option value="' + option2.value + '">' + option2.name + "</option>";
};
var selectbox = function(translate2, options, defaultParameters) {
  var resource = defaultParameters, label2 = options.label || resource.id, selectOptions = options.selectOptions || [{ name: "", value: "" }], modelProperty = options.modelProperty, emptyParameter = options.emptyParameter, canBeDisabled = !!options.disabled && typeof options.disabled === "function", canBeHidden = !!options.hidden && typeof options.hidden === "function", description = options.description;
  if (emptyParameter) {
    selectOptions = addEmptyParameter(selectOptions);
  }
  resource.html = domify$b('<label for="camunda-' + escapeHTML$h(resource.id) + '"' + (canBeDisabled ? 'data-disable="isDisabled" ' : "") + (canBeHidden ? 'data-show="isHidden" ' : "") + ">" + escapeHTML$h(label2) + '</label><select id="camunda-' + escapeHTML$h(resource.id) + '-select" name="' + escapeHTML$h(modelProperty) + '"' + (canBeDisabled ? 'data-disable="isDisabled" ' : "") + (canBeHidden ? 'data-show="isHidden" ' : "") + " data-value></select>");
  var select = domQuery$i("select", resource.html);
  if (isList$1(selectOptions)) {
    forEach$e(selectOptions, function(option2) {
      select.appendChild(domify$b('<option value="' + escapeHTML$h(option2.value) + (option2.title ? '" title="' + escapeHTML$h(option2.title) : "") + '">' + (option2.name ? escapeHTML$h(option2.name) : "") + "</option>"));
    });
  }
  if (description && typeof options.showCustomInput !== "function") {
    resource.html.appendChild(entryFieldDescription$a(translate2, description, { show: canBeHidden && "isHidden" }));
  }
  resource.setControlValue = function(element, entryNode, inputNode, inputName, newValue) {
    if (typeof selectOptions === "function") {
      var options2 = selectOptions(element, inputNode);
      if (options2) {
        while (inputNode.firstChild) {
          inputNode.removeChild(inputNode.firstChild);
        }
        forEach$e(options2, function(option2) {
          var template2 = domify$b(createOption(option2));
          inputNode.appendChild(template2);
        });
      }
    }
    if (newValue !== void 0) {
      inputNode.value = newValue;
    }
  };
  if (canBeDisabled) {
    resource.isDisabled = function() {
      return options.disabled.apply(resource, arguments);
    };
  }
  if (canBeHidden) {
    resource.isHidden = function() {
      return !options.hidden.apply(resource, arguments);
    };
  }
  resource.cssClasses = ["bpp-dropdown"];
  return resource;
};
var SelectEntryFactory = selectbox;
var assign$a = assign_1, find$8 = find_1;
var domify$a = require$$6.domify, domQuery$h = require$$6.query;
var escapeHTML$g = Utils.escapeHTML;
var selectEntryFactory = SelectEntryFactory, entryFieldDescription$9 = EntryFieldDescription;
var comboBox = function(translate2, options) {
  var selectOptions = options.selectOptions, modelProperty = options.modelProperty, customValue = options.customValue || "custom", customName = options.customName || "custom " + modelProperty, description = options.description;
  var isCustomValue = function(value) {
    if (typeof value[modelProperty] === "undefined") {
      return false;
    }
    var isCustom = !find$8(selectOptions, function(option2) {
      return value[modelProperty] === option2.value;
    });
    return isCustom;
  };
  var comboOptions = assign$a({}, options);
  comboOptions.showCustomInput = function(element, node2) {
    var selectBox = domQuery$h('[data-entry="' + options.id + '"] select', node2.parentNode);
    if (selectBox) {
      return selectBox.value === customValue;
    }
    return false;
  };
  comboOptions.get = function(element, node2) {
    var value = options.get(element, node2);
    var modifiedValues = {};
    if (!isCustomValue(value)) {
      modifiedValues[modelProperty] = value[modelProperty] || "";
      return modifiedValues;
    }
    modifiedValues[modelProperty] = customValue;
    modifiedValues["custom-" + modelProperty] = value[modelProperty];
    return modifiedValues;
  };
  comboOptions.set = function(element, values2, node2) {
    var modifiedValues = {};
    if (values2[modelProperty] === customValue) {
      modifiedValues[modelProperty] = values2["custom-" + modelProperty] || "";
    } else if (options.emptyParameter && values2[modelProperty] === "") {
      modifiedValues[modelProperty] = void 0;
    } else {
      modifiedValues[modelProperty] = values2[modelProperty];
    }
    return options.set(element, modifiedValues, node2);
  };
  comboOptions.selectOptions.push({ name: customName, value: customValue });
  var comboBoxEntry = assign$a({}, selectEntryFactory(translate2, comboOptions, comboOptions));
  var fragment = document.createDocumentFragment();
  fragment.appendChild(comboBoxEntry.html);
  comboBoxEntry.html = fragment;
  comboBoxEntry.html.appendChild(domify$a('<div class="bpp-field-wrapper bpp-combo-input" data-show="showCustomInput"><input id="camunda-' + escapeHTML$g(options.id) + '-input" type="text" name="custom-' + escapeHTML$g(modelProperty) + '"  /></div>'));
  if (description) {
    comboBoxEntry.html.appendChild(entryFieldDescription$9(translate2, description, { show: "showCustomInput" }));
  }
  return comboBoxEntry;
};
var ComboEntryFactory = comboBox;
var domify$9 = require$$6.domify;
var escapeHTML$f = Utils.escapeHTML;
var entryFieldDescription$8 = EntryFieldDescription;
var textBox = function(translate2, options, defaultParameters) {
  var resource = defaultParameters, label2 = options.label || resource.id, canBeShown = !!options.show && typeof options.show === "function", description = options.description;
  resource.html = domify$9('<label for="camunda-' + escapeHTML$f(resource.id) + '" ' + (canBeShown ? 'data-show="isShown"' : "") + ">" + label2 + '</label><div class="bpp-field-wrapper" ' + (canBeShown ? 'data-show="isShown"' : "") + '><div contenteditable="true" id="camunda-' + escapeHTML$f(resource.id) + '" name="' + escapeHTML$f(options.modelProperty) + '" /></div>');
  if (description) {
    resource.html.appendChild(entryFieldDescription$8(translate2, description, { show: canBeShown && "isShown" }));
  }
  if (canBeShown) {
    resource.isShown = function() {
      return options.show.apply(resource, arguments);
    };
  }
  resource.cssClasses = ["bpp-textbox"];
  return resource;
};
var TextBoxEntryFactory = textBox;
var textField = TextInputEntryFactory;
var validationAwareTextField = function(translate2, options, defaultParameters) {
  var modelProperty = options.modelProperty;
  defaultParameters.get = function(element, node2) {
    var value = this.__lastInvalidValue;
    delete this.__lastInvalidValue;
    var properties2 = {};
    properties2[modelProperty] = value !== void 0 ? value : options.getProperty(element, node2);
    return properties2;
  };
  defaultParameters.set = function(element, values2, node2) {
    var validationErrors = validate2.apply(this, [element, values2, node2]), propertyValue = values2[modelProperty];
    if (validationErrors && validationErrors[modelProperty]) {
      this.__lastInvalidValue = propertyValue;
      return options.setProperty(element, {}, node2);
    } else {
      var properties2 = {};
      properties2[modelProperty] = propertyValue;
      return options.setProperty(element, properties2, node2);
    }
  };
  var validate2 = defaultParameters.validate = function(element, values2, node2) {
    var value = values2[modelProperty] || this.__lastInvalidValue;
    var property2 = {};
    property2[modelProperty] = value;
    return options.validate(element, property2, node2);
  };
  return textField(translate2, options, defaultParameters);
};
var ValidationAwareTextInput = validationAwareTextField;
var escapeHTML$e = Utils.escapeHTML;
var cmdHelper$L = CmdHelper_1;
var domQuery$g = require$$6.query, domAttr$1 = require$$6.attr, domClosest$2 = require$$6.closest;
var filter$6 = filter_1, forEach$d = forEach_1, keys$1 = keys_1;
var domify$8 = require$$6.domify;
var entryFieldDescription$7 = EntryFieldDescription;
var updateSelection = selectionUpdate.exports;
var TABLE_ROW_DIV_SNIPPET = '<div class="bpp-field-wrapper bpp-table-row">';
var DELETE_ROW_BUTTON_SNIPPET = '<button class="action-button clear" data-action="deleteElement"><span>X</span></button>';
function createInputRowTemplate(properties2, canRemove) {
  var template2 = TABLE_ROW_DIV_SNIPPET;
  template2 += createInputTemplate(properties2, canRemove);
  template2 += canRemove ? DELETE_ROW_BUTTON_SNIPPET : "";
  template2 += "</div>";
  return template2;
}
function createInputTemplate(properties2, canRemove) {
  var columns = properties2.length;
  var template2 = "";
  forEach$d(properties2, function(prop, idx) {
    template2 += '<input class="bpp-table-row-columns-' + columns + " " + (canRemove ? "bpp-table-row-removable" : "") + '" id="camunda-table-row-cell-input-value-' + idx + '"type="text" name="' + escapeHTML$e(prop) + '" />';
  });
  return template2;
}
function createLabelRowTemplate(labels) {
  var template2 = TABLE_ROW_DIV_SNIPPET;
  template2 += createLabelTemplate(labels);
  template2 += "</div>";
  return template2;
}
function createLabelTemplate(labels) {
  var columns = labels.length;
  var template2 = "";
  forEach$d(labels, function(label2) {
    template2 += '<label class="bpp-table-row-columns-' + columns + '">' + escapeHTML$e(label2) + "</label>";
  });
  return template2;
}
function pick$2(elements, properties2) {
  return (elements || []).map(function(elem) {
    var newElement = {};
    forEach$d(properties2, function(prop) {
      newElement[prop] = elem[prop] || "";
    });
    return newElement;
  });
}
function diff(element, node2, values2, oldValues, editable) {
  return filter$6(values2, function(value, idx) {
    return !valueEqual(element, node2, value, oldValues[idx], editable, idx);
  });
}
function valueEqual(element, node2, value, oldValue, editable, idx) {
  if (value && !oldValue) {
    return false;
  }
  var allKeys = keys$1(value).concat(keys$1(oldValue));
  return allKeys.every(function(key) {
    var n = value[key] || void 0;
    var o = oldValue[key] || void 0;
    return !editable(element, node2, key, idx) || n === o;
  });
}
function getEntryNode(node2) {
  return domClosest$2(node2, "[data-entry]", true);
}
function getContainer(node2) {
  return domQuery$g("div[data-list-entry-container]", node2);
}
function getSelection(node2) {
  return {
    start: node2.selectionStart,
    end: node2.selectionEnd
  };
}
function setSelection(node2, selection) {
  node2.selectionStart = selection.start;
  node2.selectionEnd = selection.end;
}
var TableEntryFactory = function(translate2, options) {
  var id2 = options.id, modelProperties = options.modelProperties, labels = options.labels, description = options.description;
  var labelRow = createLabelRowTemplate(labels);
  var getElements2 = options.getElements;
  var removeElement2 = options.removeElement, canRemove = typeof removeElement2 === "function";
  var addElement = options.addElement, canAdd = typeof addElement === "function", addLabel = options.addLabel || "Add Value";
  var updateElement = options.updateElement, canUpdate = typeof updateElement === "function";
  var editable = options.editable || function() {
    return true;
  }, setControlValue = options.setControlValue;
  var show = options.show, canBeShown = typeof show === "function";
  var elements = function(element, node2) {
    return pick$2(getElements2(element, node2), modelProperties);
  };
  var html = domify$8((canAdd ? '<div class="bpp-table-add-row" ' + (canBeShown ? 'data-show="show"' : "") + "><label>" + escapeHTML$e(addLabel) + '</label><button class="action-button add" data-action="addElement"><span>+</span></button></div>' : "") + '<div class="bpp-table" data-show="showTable"><div class="bpp-field-wrapper bpp-table-row">' + labelRow + "</div><div data-list-entry-container></div></div>");
  if (description) {
    html.appendChild(entryFieldDescription$7(translate2, description, { show: "showTable" }));
  }
  var factory2 = {
    id: id2,
    html,
    get: function(element, node2) {
      var boElements = elements(element, node2, this.__invalidValues);
      var invalidValues = this.__invalidValues;
      delete this.__invalidValues;
      forEach$d(invalidValues, function(value, idx) {
        var element2 = boElements[idx];
        forEach$d(modelProperties, function(prop) {
          element2[prop] = value[prop];
        });
      });
      return boElements;
    },
    set: function(element, values2, node2) {
      var action = this.__action || {};
      delete this.__action;
      if (action.id === "delete-element") {
        return removeElement2(element, node2, action.idx);
      } else if (action.id === "add-element") {
        return addElement(element, node2);
      } else if (canUpdate) {
        var commands = [], valuesToValidate = values2;
        if (typeof options.validate !== "function") {
          valuesToValidate = diff(element, node2, values2, elements(element, node2), editable);
        }
        var self2 = this;
        forEach$d(valuesToValidate, function(value) {
          var validationError, idx = values2.indexOf(value);
          if (typeof options.validate === "function") {
            validationError = options.validate(element, value, node2, idx);
          }
          if (!validationError) {
            var cmd2 = updateElement(element, value, node2, idx);
            if (cmd2) {
              commands.push(cmd2);
            }
          } else {
            self2.__invalidValues = self2.__invalidValues || {};
            self2.__invalidValues[idx] = value;
            commands.push(cmdHelper$L.updateProperties(element, {}));
          }
        });
        return commands;
      }
    },
    createListEntryTemplate: function(value, index2, selectBox) {
      return createInputRowTemplate(modelProperties, canRemove);
    },
    addElement: function(element, node2, event, scopeNode) {
      var template2 = domify$8(createInputRowTemplate(modelProperties, canRemove));
      var container = getContainer(node2);
      container.appendChild(template2);
      this.__action = {
        id: "add-element"
      };
      return true;
    },
    deleteElement: function(element, node2, event, scopeNode) {
      var container = getContainer(node2);
      var rowToDelete = event.delegateTarget.parentNode;
      var idx = parseInt(domAttr$1(rowToDelete, "data-index"), 10);
      container.removeChild(rowToDelete);
      this.__action = {
        id: "delete-element",
        idx
      };
      return true;
    },
    editable: function(element, rowNode, input, prop, value, idx) {
      var entryNode = domClosest$2(rowNode, "[data-entry]");
      return editable(element, entryNode, prop, idx);
    },
    show: function(element, entryNode, node2, scopeNode) {
      entryNode = getEntryNode(entryNode);
      return show(element, entryNode, node2, scopeNode);
    },
    showTable: function(element, entryNode, node2, scopeNode) {
      entryNode = getEntryNode(entryNode);
      var elems = elements(element, entryNode);
      return elems && elems.length && (!canBeShown || show(element, entryNode, node2, scopeNode));
    },
    validateListItem: function(element, value, node2, idx) {
      if (typeof options.validate === "function") {
        return options.validate(element, value, node2, idx);
      }
    }
  };
  if (setControlValue) {
    factory2.setControlValue = function(element, rowNode, input, prop, value, idx) {
      var entryNode = getEntryNode(rowNode);
      var isReadOnly = domAttr$1(input, "readonly");
      var oldValue = input.value;
      var selection;
      if (value === void 0) {
        value = "";
      }
      if (!!isReadOnly && oldValue === value) {
        return;
      }
      if (document.activeElement === input) {
        selection = updateSelection(getSelection(input), oldValue, value);
      }
      setControlValue(element, entryNode, input, prop, value, idx);
      if (selection) {
        setSelection(input, selection);
      }
    };
  }
  return factory2;
};
var label = function(options) {
  return {
    id: options.id,
    html: '<label data-value="label" data-show="showLabel" class="entry-label' + (options.divider ? " divider" : "") + '"></label>',
    get: function(element, node2) {
      if (typeof options.get === "function") {
        return options.get(element, node2);
      }
      return { label: options.labelText };
    },
    showLabel: function(element, node2) {
      if (typeof options.showLabel === "function") {
        return options.showLabel(element, node2);
      }
      return true;
    }
  };
};
var LabelFactory = label;
var WeakMap = _WeakMap;
var metaMap$2 = WeakMap && new WeakMap();
var _metaMap = metaMap$2;
var identity = identity_1, metaMap$1 = _metaMap;
var baseSetData$2 = !metaMap$1 ? identity : function(func, data) {
  metaMap$1.set(func, data);
  return func;
};
var _baseSetData = baseSetData$2;
var baseCreate$2 = _baseCreate, isObject$2 = isObject_1;
function createCtor$4(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate$2(Ctor.prototype), result = Ctor.apply(thisBinding, args);
    return isObject$2(result) ? result : thisBinding;
  };
}
var _createCtor = createCtor$4;
var createCtor$3 = _createCtor, root$3 = _root;
var WRAP_BIND_FLAG$7 = 1;
function createBind$1(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG$7, Ctor = createCtor$3(func);
  function wrapper() {
    var fn = this && this !== root$3 && this instanceof wrapper ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
var _createBind = createBind$1;
var nativeMax$2 = Math.max;
function composeArgs$2(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax$2(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}
var _composeArgs = composeArgs$2;
var nativeMax$1 = Math.max;
function composeArgsRight$2(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax$1(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset2 = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset2 + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset2 + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result;
}
var _composeArgsRight = composeArgsRight$2;
function countHolders$1(array, placeholder) {
  var length2 = array.length, result = 0;
  while (length2--) {
    if (array[length2] === placeholder) {
      ++result;
    }
  }
  return result;
}
var _countHolders = countHolders$1;
function baseLodash$3() {
}
var _baseLodash = baseLodash$3;
var baseCreate$1 = _baseCreate, baseLodash$2 = _baseLodash;
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper$3(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper$3.prototype = baseCreate$1(baseLodash$2.prototype);
LazyWrapper$3.prototype.constructor = LazyWrapper$3;
var _LazyWrapper = LazyWrapper$3;
var metaMap = _metaMap, noop$2 = noop_1;
var getData$2 = !metaMap ? noop$2 : function(func) {
  return metaMap.get(func);
};
var _getData = getData$2;
var realNames$1 = {};
var _realNames = realNames$1;
var realNames = _realNames;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function getFuncName$1(func) {
  var result = func.name + "", array = realNames[result], length2 = hasOwnProperty$1.call(realNames, result) ? array.length : 0;
  while (length2--) {
    var data = array[length2], otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result;
}
var _getFuncName = getFuncName$1;
var baseCreate = _baseCreate, baseLodash$1 = _baseLodash;
function LodashWrapper$2(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper$2.prototype = baseCreate(baseLodash$1.prototype);
LodashWrapper$2.prototype.constructor = LodashWrapper$2;
var _LodashWrapper = LodashWrapper$2;
function copyArray$2(source, array) {
  var index2 = -1, length2 = source.length;
  array || (array = Array(length2));
  while (++index2 < length2) {
    array[index2] = source[index2];
  }
  return array;
}
var _copyArray = copyArray$2;
var LazyWrapper$2 = _LazyWrapper, LodashWrapper$1 = _LodashWrapper, copyArray$1 = _copyArray;
function wrapperClone$1(wrapper) {
  if (wrapper instanceof LazyWrapper$2) {
    return wrapper.clone();
  }
  var result = new LodashWrapper$1(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray$1(wrapper.__actions__);
  result.__index__ = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}
var _wrapperClone = wrapperClone$1;
var LazyWrapper$1 = _LazyWrapper, LodashWrapper = _LodashWrapper, baseLodash = _baseLodash, isArray = isArray_1, isObjectLike = isObjectLike_1, wrapperClone = _wrapperClone;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function lodash$1(value) {
  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper$1)) {
    if (value instanceof LodashWrapper) {
      return value;
    }
    if (hasOwnProperty.call(value, "__wrapped__")) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper(value);
}
lodash$1.prototype = baseLodash.prototype;
lodash$1.prototype.constructor = lodash$1;
var wrapperLodash = lodash$1;
var LazyWrapper = _LazyWrapper, getData$1 = _getData, getFuncName = _getFuncName, lodash = wrapperLodash;
function isLaziable$1(func) {
  var funcName = getFuncName(func), other = lodash[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData$1(other);
  return !!data && func === data[0];
}
var _isLaziable = isLaziable$1;
var baseSetData$1 = _baseSetData, shortOut = _shortOut;
var setData$2 = shortOut(baseSetData$1);
var _setData = setData$2;
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
function getWrapDetails$1(source) {
  var match2 = source.match(reWrapDetails);
  return match2 ? match2[1].split(reSplitDetails) : [];
}
var _getWrapDetails = getWrapDetails$1;
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails$1(source, details) {
  var length2 = details.length;
  if (!length2) {
    return source;
  }
  var lastIndex = length2 - 1;
  details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length2 > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
var _insertWrapDetails = insertWrapDetails$1;
var arrayEach = _arrayEach, arrayIncludes = _arrayIncludes;
var WRAP_BIND_FLAG$6 = 1, WRAP_BIND_KEY_FLAG$4 = 2, WRAP_CURRY_FLAG$4 = 8, WRAP_CURRY_RIGHT_FLAG$2 = 16, WRAP_PARTIAL_FLAG$3 = 32, WRAP_PARTIAL_RIGHT_FLAG$2 = 64, WRAP_ARY_FLAG$2 = 128, WRAP_REARG_FLAG$1 = 256, WRAP_FLIP_FLAG$1 = 512;
var wrapFlags = [
  ["ary", WRAP_ARY_FLAG$2],
  ["bind", WRAP_BIND_FLAG$6],
  ["bindKey", WRAP_BIND_KEY_FLAG$4],
  ["curry", WRAP_CURRY_FLAG$4],
  ["curryRight", WRAP_CURRY_RIGHT_FLAG$2],
  ["flip", WRAP_FLIP_FLAG$1],
  ["partial", WRAP_PARTIAL_FLAG$3],
  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG$2],
  ["rearg", WRAP_REARG_FLAG$1]
];
function updateWrapDetails$1(details, bitmask) {
  arrayEach(wrapFlags, function(pair) {
    var value = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}
var _updateWrapDetails = updateWrapDetails$1;
var getWrapDetails = _getWrapDetails, insertWrapDetails = _insertWrapDetails, setToString$1 = _setToString, updateWrapDetails = _updateWrapDetails;
function setWrapToString$2(wrapper, reference, bitmask) {
  var source = reference + "";
  return setToString$1(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
}
var _setWrapToString = setWrapToString$2;
var isLaziable = _isLaziable, setData$1 = _setData, setWrapToString$1 = _setWrapToString;
var WRAP_BIND_FLAG$5 = 1, WRAP_BIND_KEY_FLAG$3 = 2, WRAP_CURRY_BOUND_FLAG$1 = 4, WRAP_CURRY_FLAG$3 = 8, WRAP_PARTIAL_FLAG$2 = 32, WRAP_PARTIAL_RIGHT_FLAG$1 = 64;
function createRecurry$2(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG$3, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG$2 : WRAP_PARTIAL_RIGHT_FLAG$1;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$1 : WRAP_PARTIAL_FLAG$2);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG$1)) {
    bitmask &= ~(WRAP_BIND_FLAG$5 | WRAP_BIND_KEY_FLAG$3);
  }
  var newData = [
    func,
    bitmask,
    thisArg,
    newPartials,
    newHolders,
    newPartialsRight,
    newHoldersRight,
    argPos,
    ary,
    arity
  ];
  var result = wrapFunc.apply(void 0, newData);
  if (isLaziable(func)) {
    setData$1(result, newData);
  }
  result.placeholder = placeholder;
  return setWrapToString$1(result, func, bitmask);
}
var _createRecurry = createRecurry$2;
function getHolder$3(func) {
  var object = func;
  return object.placeholder;
}
var _getHolder = getHolder$3;
var copyArray = _copyArray, isIndex$1 = _isIndex;
var nativeMin$1 = Math.min;
function reorder$1(array, indexes) {
  var arrLength = array.length, length2 = nativeMin$1(indexes.length, arrLength), oldArray = copyArray(array);
  while (length2--) {
    var index2 = indexes[length2];
    array[length2] = isIndex$1(index2, arrLength) ? oldArray[index2] : void 0;
  }
  return array;
}
var _reorder = reorder$1;
var PLACEHOLDER$1 = "__lodash_placeholder__";
function replaceHolders$4(array, placeholder) {
  var index2 = -1, length2 = array.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array[index2];
    if (value === placeholder || value === PLACEHOLDER$1) {
      array[index2] = PLACEHOLDER$1;
      result[resIndex++] = index2;
    }
  }
  return result;
}
var _replaceHolders = replaceHolders$4;
var composeArgs$1 = _composeArgs, composeArgsRight$1 = _composeArgsRight, countHolders = _countHolders, createCtor$2 = _createCtor, createRecurry$1 = _createRecurry, getHolder$2 = _getHolder, reorder = _reorder, replaceHolders$3 = _replaceHolders, root$2 = _root;
var WRAP_BIND_FLAG$4 = 1, WRAP_BIND_KEY_FLAG$2 = 2, WRAP_CURRY_FLAG$2 = 8, WRAP_CURRY_RIGHT_FLAG$1 = 16, WRAP_ARY_FLAG$1 = 128, WRAP_FLIP_FLAG = 512;
function createHybrid$2(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG$1, isBind = bitmask & WRAP_BIND_FLAG$4, isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2, isCurried = bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? void 0 : createCtor$2(func);
  function wrapper() {
    var length2 = arguments.length, args = Array(length2), index2 = length2;
    while (index2--) {
      args[index2] = arguments[index2];
    }
    if (isCurried) {
      var placeholder = getHolder$2(wrapper), holdersCount = countHolders(args, placeholder);
    }
    if (partials) {
      args = composeArgs$1(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight$1(args, partialsRight, holdersRight, isCurried);
    }
    length2 -= holdersCount;
    if (isCurried && length2 < arity) {
      var newHolders = replaceHolders$3(args, placeholder);
      return createRecurry$1(func, bitmask, createHybrid$2, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length2);
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
    length2 = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length2 > 1) {
      args.reverse();
    }
    if (isAry && ary < length2) {
      args.length = ary;
    }
    if (this && this !== root$2 && this instanceof wrapper) {
      fn = Ctor || createCtor$2(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
var _createHybrid = createHybrid$2;
var apply$1 = _apply, createCtor$1 = _createCtor, createHybrid$1 = _createHybrid, createRecurry = _createRecurry, getHolder$1 = _getHolder, replaceHolders$2 = _replaceHolders, root$1 = _root;
function createCurry$1(func, bitmask, arity) {
  var Ctor = createCtor$1(func);
  function wrapper() {
    var length2 = arguments.length, args = Array(length2), index2 = length2, placeholder = getHolder$1(wrapper);
    while (index2--) {
      args[index2] = arguments[index2];
    }
    var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders$2(args, placeholder);
    length2 -= holders.length;
    if (length2 < arity) {
      return createRecurry(func, bitmask, createHybrid$1, wrapper.placeholder, void 0, args, holders, void 0, void 0, arity - length2);
    }
    var fn = this && this !== root$1 && this instanceof wrapper ? Ctor : func;
    return apply$1(fn, this, args);
  }
  return wrapper;
}
var _createCurry = createCurry$1;
var apply = _apply, createCtor = _createCtor, root = _root;
var WRAP_BIND_FLAG$3 = 1;
function createPartial$1(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG$3, Ctor = createCtor(func);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var _createPartial = createPartial$1;
var composeArgs = _composeArgs, composeArgsRight = _composeArgsRight, replaceHolders$1 = _replaceHolders;
var PLACEHOLDER = "__lodash_placeholder__";
var WRAP_BIND_FLAG$2 = 1, WRAP_BIND_KEY_FLAG$1 = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG$1 = 8, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256;
var nativeMin = Math.min;
function mergeData$1(data, source) {
  var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG$2 | WRAP_BIND_KEY_FLAG$1 | WRAP_ARY_FLAG);
  var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG$1 || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG$1;
  if (!(isCommon || isCombo)) {
    return data;
  }
  if (srcBitmask & WRAP_BIND_FLAG$2) {
    data[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG$2 ? 0 : WRAP_CURRY_BOUND_FLAG;
  }
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders$1(data[3], PLACEHOLDER) : source[4];
  }
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders$1(data[5], PLACEHOLDER) : source[6];
  }
  value = source[7];
  if (value) {
    data[7] = value;
  }
  if (srcBitmask & WRAP_ARY_FLAG) {
    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
  }
  if (data[9] == null) {
    data[9] = source[9];
  }
  data[0] = source[0];
  data[1] = newBitmask;
  return data;
}
var _mergeData = mergeData$1;
var baseSetData = _baseSetData, createBind = _createBind, createCurry = _createCurry, createHybrid = _createHybrid, createPartial = _createPartial, getData = _getData, mergeData = _mergeData, setData = _setData, setWrapToString = _setWrapToString, toInteger = toInteger_1;
var FUNC_ERROR_TEXT = "Expected a function";
var WRAP_BIND_FLAG$1 = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG$1 = 32, WRAP_PARTIAL_RIGHT_FLAG = 64;
var nativeMax = Math.max;
function createWrap$1(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
  if (!isBindKey && typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var length2 = partials ? partials.length : 0;
  if (!length2) {
    bitmask &= ~(WRAP_PARTIAL_FLAG$1 | WRAP_PARTIAL_RIGHT_FLAG);
    partials = holders = void 0;
  }
  ary = ary === void 0 ? ary : nativeMax(toInteger(ary), 0);
  arity = arity === void 0 ? arity : toInteger(arity);
  length2 -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data = isBindKey ? void 0 : getData(func);
  var newData = [
    func,
    bitmask,
    thisArg,
    partials,
    holders,
    partialsRight,
    holdersRight,
    argPos,
    ary,
    arity
  ];
  if (data) {
    mergeData(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
    bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG$1) {
    var result = createBind(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
    result = createCurry(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG$1 || bitmask == (WRAP_BIND_FLAG$1 | WRAP_PARTIAL_FLAG$1)) && !holders.length) {
    result = createPartial(func, bitmask, thisArg, partials);
  } else {
    result = createHybrid.apply(void 0, newData);
  }
  var setter = data ? baseSetData : setData;
  return setWrapToString(setter(result, newData), func, bitmask);
}
var _createWrap = createWrap$1;
var baseRest = _baseRest, createWrap = _createWrap, getHolder = _getHolder, replaceHolders = _replaceHolders;
var WRAP_BIND_FLAG = 1, WRAP_PARTIAL_FLAG = 32;
var bind$1 = baseRest(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG;
  if (partials.length) {
    var holders = replaceHolders(partials, getHolder(bind$1));
    bitmask |= WRAP_PARTIAL_FLAG;
  }
  return createWrap(func, bitmask, thisArg, partials, holders);
});
bind$1.placeholder = {};
var bind_1 = bind$1;
var domify$7 = require$$6.domify;
var escapeHTML$d = Utils.escapeHTML;
var entryFieldDescription$6 = EntryFieldDescription;
var bind = bind_1;
function link$1(translate2, options) {
  var id2 = options.id, buttonLabel = options.buttonLabel || id2, showLink = options.showLink, handleClick = options.handleClick, description = options.description, label2 = options.label;
  if (showLink && typeof showLink !== "function") {
    throw new Error("options.showLink must be a function");
  }
  if (typeof handleClick !== "function") {
    throw new Error("options.handleClick must be a function");
  }
  var resource = {
    id: id2,
    html: document.createDocumentFragment()
  };
  if (label2) {
    resource.html.appendChild(domify$7('<label for="camunda-' + escapeHTML$d(id2) + '" ' + (showLink ? 'data-show="showLink" ' : "") + ">" + escapeHTML$d(label2) + "</label>"));
  }
  resource.html.appendChild(domify$7('<div class="bpp-field-wrapper"><a data-action="handleClick" ' + (showLink ? 'data-show="showLink" ' : "") + 'class="bpp-entry-link' + (options.cssClasses ? " " + escapeHTML$d(options.cssClasses) : "") + '">' + escapeHTML$d(buttonLabel) + "</a></div>"));
  if (description) {
    resource.html.appendChild(entryFieldDescription$6(translate2, description, { show: "showLink" }));
  }
  resource.handleClick = bind(handleClick, resource);
  if (typeof showLink === "function") {
    resource.showLink = function() {
      return showLink.apply(resource, arguments);
    };
  }
  return resource;
}
var LinkEntryFactory = link$1;
var domClasses$5 = require$$6.classes, domify$6 = require$$6.domify, domQuery$f = require$$6.query;
var assign$9 = require$$1$1.assign, find$7 = require$$1$1.find, forEach$c = require$$1$1.forEach, debounce = require$$1$1.debounce;
var escapeHTML$c = Utils.escapeHTML;
var entryFieldDescription$5 = EntryFieldDescription;
var CLASS_ACTIVE = "active";
var FOCUS_LEAVE_DELAY = "150";
var TEXT_NODE_NAME = "#text";
var SUGGESTION_LIST_BOX_THRESHOLD = 15;
var noop$1 = function() {
};
var autoSuggestTextBox = function(translate2, options, defaultParameters) {
  var resource = defaultParameters, label2 = options.label || resource.id, canBeShown = !!options.show && typeof options.show === "function", description = options.description;
  resource.html = domify$6('<label for="camunda-' + escapeHTML$c(resource.id) + '" ' + (canBeShown ? 'data-show="isShown"' : "") + ">" + label2 + '</label><div class="bpp-field-wrapper" ' + (canBeShown ? 'data-show="isShown"' : "") + '><div contenteditable="true"id="camunda-' + escapeHTML$c(resource.id) + '" name="' + escapeHTML$c(options.modelProperty) + '" data-auto-suggest="suggestItems"data-blur="handleFocusLeave"></div><div class="bpp-autosuggest-list"></div></div>');
  if (description) {
    domQuery$f(".bpp-field-wrapper", resource.html).appendChild(entryFieldDescription$5(translate2, description));
  }
  if (canBeShown) {
    resource.isShown = function() {
      return options.show.apply(resource, arguments);
    };
  }
  resource.handleFocusLeave = debounce(function(element, entryNode) {
    clearSuggestionList(entryNode);
    hideSuggestionList(entryNode);
  }, FOCUS_LEAVE_DELAY);
  resource.suggestItems = function(element, entryNode, event) {
    var editorNode = event.delegateTarget, range2 = getSelectionRange(), focusNode = range2.focusNode, caretPosition = getCaretPosition(range2.range), canSuggest = options.canSuggest || noop$1, getItems = options.getItems;
    function updateSuggestionList(items2) {
      var listNode = domQuery$f(".bpp-autosuggest-list", entryNode);
      clearSuggestionList(entryNode);
      if (!items2.length) {
        return;
      }
      domClasses$5(listNode).add(CLASS_ACTIVE);
      forEach$c(items2, function(item) {
        createSuggestionItem(listNode, item);
      });
      var position = getSuggestionListPosition(listNode, document.body).position;
      setPosition(listNode, position.x, position.y);
    }
    function createSuggestionItem(parentNode, value2) {
      var itemNode = domify$6('<div class="bpp-autosuggest-item"></div>');
      itemNode.innerText = escapeHTML$c(value2);
      parentNode.appendChild(itemNode);
      itemNode.addEventListener("click", handleItemClick);
    }
    function handleItemClick(event2) {
      var value2 = event2.target.innerText, wordIndex = currentWord.index, start = wordIndex, end = wordIndex + currentWord[0].length;
      selectRange(focusNode, start, end);
      document.execCommand("insertText", false, value2);
      clearSuggestionList(entryNode);
      hideSuggestionList(entryNode);
    }
    hideSuggestionList(entryNode);
    var currentWord = getWordUnderCursor(focusNode, caretPosition) || [];
    if (currentWord && canSuggest(currentWord, editorNode, focusNode)) {
      var items = getItems(element, entryNode), results = [], value = currentWord[0];
      forEach$c(items, function(item) {
        var itemLowerCase = item.toLowerCase(), valueLowerCase = value && value.toLowerCase();
        if (itemLowerCase.indexOf(valueLowerCase) === 0) {
          results.push(item);
        }
      });
      forEach$c(items, function(item) {
        var itemLowerCase = item.toLowerCase(item), valueLowerCase = value && value.toLowerCase();
        if (itemLowerCase.indexOf(valueLowerCase) >= 1) {
          results.push(item);
        }
      });
      updateSuggestionList(results);
    }
  };
  function getSuggestionListPosition(listNode, container) {
    var range2 = getSelectionRange().range, cursorBounds = range2.getBoundingClientRect(), clientBounds = container.getBoundingClientRect(), listBounds = listNode.getBoundingClientRect();
    var coordinates = {
      "top-left": {
        x: cursorBounds.right - listBounds.width,
        y: cursorBounds.top - listBounds.height
      },
      "top-right": {
        x: cursorBounds.right,
        y: cursorBounds.top - listBounds.height
      },
      "bottom-left": {
        x: cursorBounds.right - listBounds.width,
        y: cursorBounds.top + SUGGESTION_LIST_BOX_THRESHOLD
      },
      "bottom-right": {
        x: cursorBounds.right,
        y: cursorBounds.top + SUGGESTION_LIST_BOX_THRESHOLD
      }
    };
    var orientation = "";
    if (cursorBounds.top + SUGGESTION_LIST_BOX_THRESHOLD + listBounds.height > clientBounds.height + clientBounds.top) {
      orientation = "top-";
    } else {
      orientation = "bottom-";
    }
    if (cursorBounds.right + listBounds.width > clientBounds.width + clientBounds.left) {
      orientation += "left";
    } else {
      orientation += "right";
    }
    return { orientation, position: coordinates[orientation] };
  }
  resource.getSuggestionListPosition = getSuggestionListPosition;
  resource.cssClasses = ["bpp-autosuggest-textbox"];
  return resource;
};
var AutoSuggestTextBoxFactory = autoSuggestTextBox;
function getSelectionRange() {
  var selection = document.getSelection();
  return {
    range: selection.getRangeAt(0),
    focusNode: selection.focusNode
  };
}
function getCaretPosition(range2) {
  return range2.startOffset;
}
function selectRange(focusNode, start, end) {
  var range2 = document.createRange(), selection = window.getSelection();
  range2.setStart(focusNode, start);
  range2.setEnd(focusNode, end);
  selection.removeAllRanges();
  selection.addRange(range2);
}
function hideSuggestionList(entryNode) {
  var listNode = domQuery$f(".bpp-autosuggest-list", entryNode);
  domClasses$5(listNode).remove(CLASS_ACTIVE);
}
function clearSuggestionList(entryNode) {
  var listNode = domQuery$f(".bpp-autosuggest-list", entryNode);
  while (listNode.firstChild) {
    listNode.removeChild(listNode.firstChild);
  }
}
function getWordUnderCursor(node2, currentCursorPositon) {
  var value = node2.nodeName === TEXT_NODE_NAME ? node2.wholeText : node2.innerText, allWords = findWords(value);
  return find$7(allWords, function(word) {
    var matchValue = word[0], wordStart = word.index, wordEnd = wordStart + matchValue.length - 1;
    return wordStart <= currentCursorPositon - 1 && wordEnd >= currentCursorPositon - 1;
  });
}
function findWords(value) {
  return matchAll(value, /[^\s\r\(\)\,\+\-\*\/\{\}]+/g);
}
function matchAll(value, regex) {
  var regexp = RegExp(regex), match2, matches = [];
  while ((match2 = regexp.exec(value)) !== null) {
    matches.push(match2);
  }
  return matches;
}
function setPosition(el, x, y) {
  assign$9(el.style, { left: x + "px", top: y + "px" });
}
var escapeHTML$b = Utils.escapeHTML;
var domQuery$e = require$$6.query;
function Collapsible(options) {
  var id2 = options.id, title = options.title || "", description = options.description || "", open3 = !!options.open || false, onToggle = options.onToggle || noop, onRemove = options.onRemove, cssClasses = options.cssClasses || [];
  var collapsibleEntry = {
    id: id2,
    toggle: toggle2,
    isOpen,
    set: set2,
    setOpen,
    get: get2
  };
  if (typeof onRemove === "function") {
    collapsibleEntry.onRemove = function(entry, entryNode, actionId, event) {
      var commands = onRemove(entry, entryNode, actionId, event);
      if (commands) {
        scheduleCommands(commands, entryNode);
        return true;
      }
    };
  }
  function get2(element, entryNode) {
    if (options.get) {
      return options.get(element, entryNode);
    }
    return {
      title: title || "",
      description: description || ""
    };
  }
  function set2() {
    var commands = this._commands;
    if (commands) {
      delete this._commands;
      return commands;
    }
  }
  function toggle2(element, entryNode, event, scope) {
    var value = !open3;
    setOpen(value, entryNode);
    onToggle(value, entryNode);
  }
  function setOpen(value, entryNode) {
    open3 = value;
    entryNode.classList.toggle("bpp-collapsible--collapsed", !value);
  }
  function isOpen() {
    return open3;
  }
  function scheduleCommands(commands, entryNode) {
    collapsibleEntry._commands = commands;
    var input = domQuery$e('input[type="hidden"]', entryNode);
    input.value = 1;
  }
  collapsibleEntry.html = '<div class="bpp-field-wrapper" data-action="toggle"><input name="hidden" type="hidden"><span class="bpp-collapsible__icon"></span><label class="bpp-collapsible__title" data-value="title">' + escapeHTML$b(title) + '</label><label class="bpp-collapsible__description" data-value="description">' + escapeHTML$b(description) + "</label>" + (onRemove ? '<button class="bpp-collapsible__remove action-button clear" data-action="onRemove"></button>' : "") + "</div>";
  collapsibleEntry.cssClasses = cssClasses.concat(open3 ? ["bpp-collapsible"] : ["bpp-collapsible", "bpp-collapsible--collapsed"]);
  return collapsibleEntry;
}
var CollapsibleEntryFactory = Collapsible;
function noop() {
}
var getBusinessObject$O = require$$2$2.getBusinessObject, cmdHelper$K = CmdHelper_1, escapeHTML$a = Utils.escapeHTML;
var entryFieldDescription$4 = EntryFieldDescription;
var domify$5 = require$$6.domify;
var toggleSwitch$1 = function(translate2, options, defaultParameters) {
  var resource = defaultParameters, id2 = resource.id, label2 = options.label || id2, canBeHidden = !!options.hidden && typeof options.hidden === "function", isOn = options.isOn, descriptionOn = options.descriptionOn, descriptionOff = options.descriptionOff, labelOn = options.labelOn, labelOff = options.labelOff;
  resource.html = document.createDocumentFragment();
  resource.html.appendChild(domify$5('<label for="' + escapeHTML$a(id2) + '" ' + (canBeHidden ? 'data-show="shouldShow"' : "") + ">" + escapeHTML$a(label2) + '</label><div class="bpp-field-wrapper"' + (canBeHidden ? 'data-show="shouldShow"' : "") + '><label class="bpp-toggle-switch__switcher"><input id="' + escapeHTML$a(id2) + '" type="checkbox" name="' + escapeHTML$a(options.modelProperty) + '" /><span class="bpp-toggle-switch__slider"></span></label><p class="bpp-toggle-switch__label" data-show="isOn">' + escapeHTML$a(labelOn) + '</p><p class="bpp-toggle-switch__label" data-show="isOff">' + escapeHTML$a(labelOff) + "</p></div>"));
  if (descriptionOn) {
    resource.html.appendChild(entryFieldDescription$4(translate2, descriptionOn, { show: "isOn" }));
  }
  if (descriptionOff) {
    resource.html.appendChild(entryFieldDescription$4(translate2, descriptionOff, { show: "isOff" }));
  }
  resource.get = function(element) {
    var bo = getBusinessObject$O(element), res = {};
    res[options.modelProperty] = bo.get(options.modelProperty);
    return res;
  };
  resource.set = function(element, values2) {
    var res = {};
    res[options.modelProperty] = !!values2[options.modelProperty];
    return cmdHelper$K.updateProperties(element, res);
  };
  if (typeof options.set === "function") {
    resource.set = options.set;
  }
  if (typeof options.get === "function") {
    resource.get = options.get;
  }
  if (canBeHidden) {
    resource.shouldShow = function() {
      return !options.hidden.apply(resource, arguments);
    };
  }
  resource.isOn = function() {
    if (canBeHidden && !resource.shouldShow()) {
      return false;
    }
    return isOn.apply(resource, arguments);
  };
  resource.isOff = function() {
    if (canBeHidden && !resource.shouldShow()) {
      return false;
    }
    return !resource.isOn();
  };
  resource.cssClasses = ["bpp-toggle-switch"];
  return resource;
};
var ToggleSwitchEntryFactory = toggleSwitch$1;
var getBusinessObject$N = require$$2$2.getBusinessObject;
var textInputField = TextInputEntryFactory, checkboxField = CheckboxEntryFactory, selectBoxField = SelectEntryFactory, comboBoxField = ComboEntryFactory, textBoxField = TextBoxEntryFactory, validationAwareTextInputField = ValidationAwareTextInput, tableField = TableEntryFactory, labelEntry = LabelFactory, link = LinkEntryFactory, autoSuggestTextBoxField = AutoSuggestTextBoxFactory, collapsible = CollapsibleEntryFactory, toggleSwitch = ToggleSwitchEntryFactory;
var cmdHelper$J = CmdHelper_1;
function ensureNotNull(prop) {
  if (!prop) {
    throw new Error(prop + " must be set.");
  }
  return prop;
}
var setDefaultParameters = function(options) {
  var defaultGet = function(element) {
    var bo = getBusinessObject$N(element), res = {}, prop = ensureNotNull(options.modelProperty);
    res[prop] = bo.get(prop);
    return res;
  };
  var defaultSet = function(element, values2) {
    var res = {}, prop = ensureNotNull(options.modelProperty);
    if (values2[prop] !== "") {
      res[prop] = values2[prop];
    } else {
      res[prop] = void 0;
    }
    return cmdHelper$J.updateProperties(element, res);
  };
  var defaultValidate = function() {
    return {};
  };
  return {
    id: options.id,
    description: options.description || "",
    get: options.get || defaultGet,
    set: options.set || defaultSet,
    validate: options.validate || defaultValidate,
    html: ""
  };
};
function EntryFactory() {
}
EntryFactory.textField = function(translate2, options) {
  return textInputField(translate2, options, setDefaultParameters(options));
};
EntryFactory.validationAwareTextField = function(translate2, options) {
  return validationAwareTextInputField(translate2, options, setDefaultParameters(options));
};
EntryFactory.checkbox = function(translate2, options) {
  return checkboxField(translate2, options, setDefaultParameters(options));
};
EntryFactory.textBox = function(translate2, options) {
  return textBoxField(translate2, options, setDefaultParameters(options));
};
EntryFactory.selectBox = function(translate2, options) {
  return selectBoxField(translate2, options, setDefaultParameters(options));
};
EntryFactory.comboBox = function(translate2, options) {
  return comboBoxField(translate2, options);
};
EntryFactory.table = function(translate2, options) {
  return tableField(translate2, options);
};
EntryFactory.label = function(options) {
  return labelEntry(options);
};
EntryFactory.link = function(translate2, options) {
  return link(translate2, options);
};
EntryFactory.autoSuggest = function(translate2, options) {
  return autoSuggestTextBoxField(translate2, options, setDefaultParameters(options));
};
EntryFactory.collapsible = function(options) {
  return collapsible(options);
};
EntryFactory.toggleSwitch = function(translate2, options) {
  return toggleSwitch(translate2, options, setDefaultParameters(options));
};
var EntryFactory_1 = EntryFactory;
var is$E = require$$2$2.is, getBusinessObject$M = require$$2$2.getBusinessObject, cmdHelper$I = CmdHelper_1;
var ParticipantHelper = {};
var ParticipantHelper_1 = ParticipantHelper;
ParticipantHelper.modifyProcessBusinessObject = function(element, property2, values2) {
  if (!is$E(element, "bpmn:Participant")) {
    return {};
  }
  var bo = getBusinessObject$M(element).get("processRef"), properties2 = {};
  properties2[property2] = values2[property2];
  return cmdHelper$I.updateBusinessObject(element, bo, properties2);
};
ParticipantHelper.getProcessBusinessObject = function(element, propertyName) {
  if (!is$E(element, "bpmn:Participant")) {
    return {};
  }
  var bo = getBusinessObject$M(element).get("processRef"), properties2 = {};
  properties2[propertyName] = bo.get(propertyName);
  return properties2;
};
var entryFactory$G = EntryFactory_1;
var Name = function(element, options, translate2) {
  options = options || {};
  var id2 = options.id || "name", label2 = options.label || translate2("Name"), modelProperty = options.modelProperty || "name";
  var nameEntry = entryFactory$G.textBox(translate2, {
    id: id2,
    label: label2,
    modelProperty,
    get: options.get,
    set: options.set
  });
  return [nameEntry];
};
var is$D = require$$2$2.is, entryFactory$F = EntryFactory_1, participantHelper$1 = ParticipantHelper_1, getBusinessObject$L = require$$2$2.getBusinessObject, nameEntryFactory$1 = Name, utils$f = Utils;
var ProcessProps = function(group, element, translate2, options) {
  var businessObject = getBusinessObject$L(element);
  var processIdDescription = options && options.processIdDescription;
  if (is$D(element, "bpmn:Process") || is$D(element, "bpmn:Participant") && businessObject.get("processRef")) {
    if (is$D(element, "bpmn:Participant")) {
      var idEntry = entryFactory$F.validationAwareTextField(translate2, {
        id: "process-id",
        label: translate2("Process Id"),
        description: processIdDescription && translate2(processIdDescription),
        modelProperty: "processId"
      });
      idEntry.get = function(element2) {
        var properties2 = participantHelper$1.getProcessBusinessObject(element2, "id");
        return { processId: properties2.id };
      };
      idEntry.set = function(element2, values2) {
        return participantHelper$1.modifyProcessBusinessObject(element2, "id", { id: values2.processId });
      };
      idEntry.validate = function(element2, values2) {
        var idValue = values2.processId;
        var bo = getBusinessObject$L(element2);
        var processIdError = utils$f.isIdValid(bo.processRef, idValue, translate2);
        return processIdError ? { processId: processIdError } : {};
      };
      group.entries.push(idEntry);
      var processNameEntry = nameEntryFactory$1(element, {
        id: "process-name",
        label: translate2("Process Name")
      })[0];
      processNameEntry.get = function(element2) {
        return participantHelper$1.getProcessBusinessObject(element2, "name");
      };
      processNameEntry.set = function(element2, values2) {
        return participantHelper$1.modifyProcessBusinessObject(element2, "name", values2);
      };
      group.entries.push(processNameEntry);
    }
  }
};
var cmdHelper$H = CmdHelper_1;
var domQuery$d = require$$6.query, domify$4 = require$$6.domify, domAttr = require$$6.attr;
var forEach$b = forEach_1, find$6 = find_1;
var elementHelper$k = ElementHelper_1;
var utils$e = Utils, escapeHTML$9 = utils$e.escapeHTML;
var selector = "select[name=selectedElement]";
function getSelectBox$1(node2) {
  return domQuery$d(selector, node2);
}
function findElementById(eventDefinition, type, id2) {
  var elements = utils$e.findRootElementsByType(eventDefinition, type);
  return find$6(elements, function(element) {
    return element.id === id2;
  });
}
var EventDefinitionReference = function(element, definition, bpmnFactory, options) {
  var elementName = options.elementName || "", elementType = options.elementType, referenceProperty = options.referenceProperty;
  var newElementIdPrefix = options.newElementIdPrefix || "elem_";
  var label2 = options.label || "", description = options.description || "";
  var entries = [];
  var canBeHidden = !!options.hidden && typeof options.hidden === "function";
  entries.push({
    id: options.id || "event-definitions-" + elementName,
    description,
    isShown: function() {
      if (canBeHidden) {
        return !options.hidden.apply(definition, arguments);
      }
      return !options.hidden;
    },
    html: '<div class="bpp-row bpp-select" data-show="isShown"><label for="camunda-' + escapeHTML$9(elementName) + '">' + escapeHTML$9(label2) + '</label><div class="bpp-field-wrapper"><select id="camunda-' + escapeHTML$9(elementName) + '" name="selectedElement" data-value></select><button class="action-button add" id="addElement" data-action="addElement"><span>+</span></button></div></div>',
    get: function(element2, entryNode) {
      utils$e.updateOptionsDropDown(selector, definition, elementType, entryNode);
      var reference = definition.get(referenceProperty);
      return {
        selectedElement: reference && reference.id || ""
      };
    },
    set: function(element2, values2) {
      var selection = values2.selectedElement;
      var props = {};
      if (!selection || typeof selection === "undefined") {
        props[referenceProperty] = void 0;
        return cmdHelper$H.updateBusinessObject(element2, definition, props);
      }
      var commands = [];
      var selectedElement = findElementById(definition, elementType, selection);
      if (!selectedElement) {
        var root2 = utils$e.getRoot(definition);
        selectedElement = elementHelper$k.createElement(elementType, { name: selection }, root2, bpmnFactory);
        commands.push(cmdHelper$H.addAndRemoveElementsFromList(element2, root2, "rootElements", null, [selectedElement]));
      }
      props[referenceProperty] = selectedElement;
      commands.push(cmdHelper$H.updateBusinessObject(element2, definition, props));
      return commands;
    },
    addElement: function(element2, inputNode) {
      var id2 = utils$e.nextId(newElementIdPrefix);
      var optionTemplate = domify$4('<option value="' + escapeHTML$9(id2) + '"> (id=' + escapeHTML$9(id2) + ")</option>");
      var selectBox = getSelectBox$1(inputNode);
      selectBox.insertBefore(optionTemplate, selectBox.firstChild);
      forEach$b(selectBox, function(option2) {
        if (option2.value === id2) {
          domAttr(option2, "selected", "selected");
        } else {
          domAttr(option2, "selected", null);
        }
      });
      return true;
    }
  });
  return entries;
};
var entryFactory$E = EntryFactory_1;
var cmdHelper$G = CmdHelper_1;
var ElementReferenceProperty = function(element, definition, bpmnFactory, translate2, options) {
  var id2 = options.id || "element-property";
  var label2 = options.label;
  var referenceProperty = options.referenceProperty;
  var modelProperty = options.modelProperty || "name";
  var shouldValidate = options.shouldValidate || false;
  var description = options.description;
  var canBeHidden = !!options.hidden && typeof options.hidden === "function";
  var entry = entryFactory$E.textField(translate2, {
    id: id2,
    label: label2,
    modelProperty,
    description,
    get: function(element2, node2) {
      var reference = definition.get(referenceProperty);
      var props = {};
      props[modelProperty] = reference && reference.get(modelProperty);
      return props;
    },
    set: function(element2, values2, node2) {
      var reference = definition.get(referenceProperty);
      var props = {};
      props[modelProperty] = values2[modelProperty] || void 0;
      return cmdHelper$G.updateBusinessObject(element2, reference, props);
    },
    hidden: function(element2, node2) {
      if (canBeHidden) {
        return options.hidden.apply(definition, arguments) || !definition.get(referenceProperty);
      }
      return !definition.get(referenceProperty);
    }
  });
  if (shouldValidate) {
    entry.validate = function(element2, values2, node2) {
      var reference = definition.get(referenceProperty);
      if (reference && !values2[modelProperty]) {
        var validationErrors = {};
        validationErrors[modelProperty] = "Must provide a value";
        return validationErrors;
      }
    };
  }
  return [entry];
};
var eventDefinitionReference$4 = EventDefinitionReference, elementReferenceProperty$5 = ElementReferenceProperty;
var MessageEventDefinition = function(group, element, bpmnFactory, messageEventDefinition, translate2) {
  group.entries = group.entries.concat(eventDefinitionReference$4(element, messageEventDefinition, bpmnFactory, {
    label: translate2("Global Message referenced"),
    elementName: "message",
    elementType: "bpmn:Message",
    referenceProperty: "messageRef",
    newElementIdPrefix: "Message_"
  }));
  group.entries = group.entries.concat(elementReferenceProperty$5(element, messageEventDefinition, bpmnFactory, translate2, {
    id: "message-element-name",
    label: translate2("Global Message Name"),
    referenceProperty: "messageRef",
    modelProperty: "name",
    shouldValidate: true
  }));
};
var eventDefinitionReference$3 = EventDefinitionReference, elementReferenceProperty$4 = ElementReferenceProperty;
var SignalEventDefinition = function(group, element, bpmnFactory, signalEventDefinition, translate2) {
  group.entries = group.entries.concat(eventDefinitionReference$3(element, signalEventDefinition, bpmnFactory, {
    label: translate2("Global Signal referenced"),
    elementName: "signal",
    elementType: "bpmn:Signal",
    referenceProperty: "signalRef",
    newElementIdPrefix: "Signal_"
  }));
  group.entries = group.entries.concat(elementReferenceProperty$4(element, signalEventDefinition, bpmnFactory, translate2, {
    id: "signal-element-name",
    label: translate2("Global Signal Name"),
    referenceProperty: "signalRef",
    modelProperty: "name",
    shouldValidate: true
  }));
};
var eventDefinitionReference$2 = EventDefinitionReference, elementReferenceProperty$3 = ElementReferenceProperty;
var ErrorEventDefinition$1 = function(group, element, bpmnFactory, errorEventDefinition, translate2) {
  group.entries = group.entries.concat(eventDefinitionReference$2(element, errorEventDefinition, bpmnFactory, {
    label: translate2("Global Error referenced"),
    elementName: "error",
    elementType: "bpmn:Error",
    referenceProperty: "errorRef",
    newElementIdPrefix: "Error_"
  }));
  group.entries = group.entries.concat(elementReferenceProperty$3(element, errorEventDefinition, bpmnFactory, translate2, {
    id: "error-element-name",
    label: translate2("Name"),
    referenceProperty: "errorRef",
    modelProperty: "name",
    shouldValidate: true
  }));
  group.entries = group.entries.concat(elementReferenceProperty$3(element, errorEventDefinition, bpmnFactory, translate2, {
    id: "error-element-code",
    label: translate2("Code"),
    referenceProperty: "errorRef",
    modelProperty: "errorCode"
  }));
};
var entryFactory$D = EntryFactory_1, cmdHelper$F = CmdHelper_1, utils$d = Utils;
var eventDefinitionReference$1 = EventDefinitionReference, elementReferenceProperty$2 = ElementReferenceProperty;
var EscalationEventDefinition = function(group, element, bpmnFactory, escalationEventDefinition, showEscalationCodeVariable, translate2) {
  group.entries = group.entries.concat(eventDefinitionReference$1(element, escalationEventDefinition, bpmnFactory, {
    label: translate2("Global Escalation referenced"),
    elementName: "escalation",
    elementType: "bpmn:Escalation",
    referenceProperty: "escalationRef",
    newElementIdPrefix: "Escalation_"
  }));
  group.entries = group.entries.concat(elementReferenceProperty$2(element, escalationEventDefinition, bpmnFactory, translate2, {
    id: "escalation-element-name",
    label: translate2("Global Escalation Name"),
    referenceProperty: "escalationRef",
    modelProperty: "name",
    shouldValidate: true
  }));
  group.entries = group.entries.concat(elementReferenceProperty$2(element, escalationEventDefinition, bpmnFactory, translate2, {
    id: "escalation-element-code",
    label: translate2("Global Escalation Code"),
    referenceProperty: "escalationRef",
    modelProperty: "escalationCode"
  }));
  if (showEscalationCodeVariable) {
    group.entries.push(entryFactory$D.validationAwareTextField(translate2, {
      id: "escalationCodeVariable",
      label: translate2("Escalation Code Variable"),
      modelProperty: "escalationCodeVariable",
      description: translate2("Define the name of the variable that will contain the escalation code"),
      getProperty: function(element2) {
        var codeVariable = escalationEventDefinition.get("camunda:escalationCodeVariable");
        return codeVariable;
      },
      setProperty: function(element2, values2) {
        if (values2.escalationCodeVariable === "")
          values2.escalationCodeVariable = void 0;
        return cmdHelper$F.updateBusinessObject(element2, escalationEventDefinition, values2);
      },
      validate: function(element2, values2) {
        var validation = {}, targetValue = values2.escalationCodeVariable;
        if (utils$d.containsSpace(targetValue)) {
          validation.escalationCodeVariable = translate2("Escalation code variable must not contain spaces.");
        }
        return validation;
      }
    }));
  }
};
var elementHelper$j = ElementHelper_1, cmdHelper$E = CmdHelper_1;
var entryFactory$C = EntryFactory_1;
function getTimerDefinitionType(timer2) {
  if (!timer2) {
    return;
  }
  var timeDate = timer2.get("timeDate");
  if (typeof timeDate !== "undefined") {
    return "timeDate";
  }
  var timeCycle = timer2.get("timeCycle");
  if (typeof timeCycle !== "undefined") {
    return "timeCycle";
  }
  var timeDuration = timer2.get("timeDuration");
  if (typeof timeDuration !== "undefined") {
    return "timeDuration";
  }
}
function getTimerDefinition(timerOrFunction, element, node2) {
  if (typeof timerOrFunction === "function") {
    return timerOrFunction(element, node2);
  }
  return timerOrFunction;
}
function createFormalExpression$1(parent2, body, bpmnFactory) {
  body = body || void 0;
  return elementHelper$j.createElement("bpmn:FormalExpression", { body }, parent2, bpmnFactory);
}
function TimerEventDefinition(group, element, bpmnFactory, timerEventDefinition, translate2, options) {
  var selectOptions = [
    { value: "timeDate", name: translate2("Date") },
    { value: "timeDuration", name: translate2("Duration") },
    { value: "timeCycle", name: translate2("Cycle") }
  ];
  var prefix2 = options && options.idPrefix, createTimerEventDefinition = options && options.createTimerEventDefinition;
  group.entries.push(entryFactory$C.selectBox(translate2, {
    id: prefix2 + "timer-event-definition-type",
    label: translate2("Timer Definition Type"),
    selectOptions,
    emptyParameter: true,
    modelProperty: "timerDefinitionType",
    get: function(element2, node2) {
      var timerDefinition = getTimerDefinition(timerEventDefinition, element2, node2);
      return {
        timerDefinitionType: getTimerDefinitionType(timerDefinition) || ""
      };
    },
    set: function(element2, values2, node2) {
      var props = {
        timeDuration: void 0,
        timeDate: void 0,
        timeCycle: void 0
      };
      var timerDefinition = getTimerDefinition(timerEventDefinition, element2, node2), newType = values2.timerDefinitionType;
      if (!timerDefinition && typeof createTimerEventDefinition === "function") {
        timerDefinition = createTimerEventDefinition(element2, node2);
      }
      if (values2.timerDefinitionType) {
        var oldType = getTimerDefinitionType(timerDefinition);
        var value;
        if (oldType) {
          var definition = timerDefinition.get(oldType);
          value = definition.get("body");
        }
        props[newType] = createFormalExpression$1(timerDefinition, value, bpmnFactory);
      }
      return cmdHelper$E.updateBusinessObject(element2, timerDefinition, props);
    },
    hidden: function(element2, node2) {
      return getTimerDefinition(timerEventDefinition, element2, node2) === void 0;
    }
  }));
  group.entries.push(entryFactory$C.textField(translate2, {
    id: prefix2 + "timer-event-definition",
    label: translate2("Timer Definition"),
    modelProperty: "timerDefinition",
    get: function(element2, node2) {
      var timerDefinition = getTimerDefinition(timerEventDefinition, element2, node2), type = getTimerDefinitionType(timerDefinition), definition = type && timerDefinition.get(type), value = definition && definition.get("body");
      return {
        timerDefinition: value
      };
    },
    set: function(element2, values2, node2) {
      var timerDefinition = getTimerDefinition(timerEventDefinition, element2, node2), type = getTimerDefinitionType(timerDefinition), definition = type && timerDefinition.get(type);
      if (definition) {
        return cmdHelper$E.updateBusinessObject(element2, definition, {
          body: values2.timerDefinition || void 0
        });
      }
    },
    validate: function(element2, node2) {
      var timerDefinition = getTimerDefinition(timerEventDefinition, element2, node2), type = getTimerDefinitionType(timerDefinition), definition = type && timerDefinition.get(type);
      if (definition) {
        var value = definition.get("body");
        if (!value) {
          return {
            timerDefinition: translate2("Must provide a value")
          };
        }
      }
    },
    hidden: function(element2, node2) {
      var timerDefinition = getTimerDefinition(timerEventDefinition, element2, node2);
      return !getTimerDefinitionType(timerDefinition);
    }
  }));
}
var TimerEventDefinition_1 = TimerEventDefinition;
var entryFactory$B = EntryFactory_1;
var cmdHelper$D = CmdHelper_1, eventDefinitionHelper$7 = EventDefinitionHelper_1, utils$c = Utils;
var getBusinessObject$K = require$$2$2.getBusinessObject, is$C = require$$2$2.is;
var forEach$a = forEach_1, find$5 = find_1, filter$5 = filter_1;
function getContainedActivities(element) {
  return getFlowElements(element, "bpmn:Activity");
}
function getContainedBoundaryEvents(element) {
  return getFlowElements(element, "bpmn:BoundaryEvent");
}
function getFlowElements(element, type) {
  return utils$c.filterElementsByType(element.flowElements, type);
}
function isCompensationEventAttachedToActivity(activity, boundaryEvents) {
  var activityId = activity.id;
  var boundaryEvent = find$5(boundaryEvents, function(boundaryEvent2) {
    var compensateEventDefinition = eventDefinitionHelper$7.getCompensateEventDefinition(boundaryEvent2);
    var attachedToRef = boundaryEvent2.attachedToRef;
    return compensateEventDefinition && attachedToRef && attachedToRef.id === activityId;
  });
  return !!boundaryEvent;
}
function canActivityBeCompensated(activity, boundaryEvents) {
  return is$C(activity, "bpmn:SubProcess") && !activity.triggeredByEvent || is$C(activity, "bpmn:CallActivity") || isCompensationEventAttachedToActivity(activity, boundaryEvents);
}
function getActivitiesForCompensation(element) {
  var boundaryEvents = getContainedBoundaryEvents(element);
  return filter$5(getContainedActivities(element), function(activity) {
    return canActivityBeCompensated(activity, boundaryEvents);
  });
}
function getActivitiesForActivityRef(element) {
  var bo = getBusinessObject$K(element);
  var parent2 = bo.$parent;
  var activitiesForActivityRef = getActivitiesForCompensation(parent2);
  if (is$C(parent2, "bpmn:SubProcess") && parent2.triggeredByEvent) {
    parent2 = parent2.$parent;
    if (parent2) {
      activitiesForActivityRef = activitiesForActivityRef.concat(getActivitiesForCompensation(parent2));
    }
  }
  return activitiesForActivityRef;
}
function createActivityRefOptions(element) {
  var options = [{ value: "" }];
  var activities = getActivitiesForActivityRef(element);
  forEach$a(activities, function(activity) {
    var activityId = activity.id;
    var name2 = (activity.name ? activity.name + " " : "") + "(id=" + activityId + ")";
    options.push({ value: activityId, name: name2 });
  });
  return options;
}
var CompensateEventDefinition = function(group, element, bpmnFactory, compensateEventDefinition, elementRegistry, translate2) {
  group.entries.push(entryFactory$B.checkbox(translate2, {
    id: "wait-for-completion",
    label: translate2("Wait for Completion"),
    modelProperty: "waitForCompletion",
    get: function(element2, node2) {
      return {
        waitForCompletion: compensateEventDefinition.waitForCompletion
      };
    },
    set: function(element2, values2) {
      values2.waitForCompletion = values2.waitForCompletion || false;
      return cmdHelper$D.updateBusinessObject(element2, compensateEventDefinition, values2);
    }
  }));
  group.entries.push(entryFactory$B.selectBox(translate2, {
    id: "activity-ref",
    label: translate2("Activity Ref"),
    selectOptions: createActivityRefOptions(element),
    modelProperty: "activityRef",
    get: function(element2, node2) {
      var activityRef = compensateEventDefinition.activityRef;
      activityRef = activityRef && activityRef.id;
      return {
        activityRef: activityRef || ""
      };
    },
    set: function(element2, values2) {
      var activityRef = values2.activityRef || void 0;
      activityRef = activityRef && getBusinessObject$K(elementRegistry.get(activityRef));
      return cmdHelper$D.updateBusinessObject(element2, compensateEventDefinition, {
        activityRef
      });
    }
  }));
};
var require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(DiUtil);
var entryFactory$A = EntryFactory_1, cmdHelper$C = CmdHelper_1;
var is$B = require$$2$2.is, isEventSubProcess = require$$3$1.isEventSubProcess;
var ConditionalEventDefinition = function(group, element, bpmnFactory, conditionalEventDefinition, elementRegistry, translate2) {
  var getValue2 = function(modelProperty) {
    return function(element2) {
      var modelPropertyValue = conditionalEventDefinition.get("camunda:" + modelProperty);
      var value = {};
      value[modelProperty] = modelPropertyValue;
      return value;
    };
  };
  var setValue = function(modelProperty) {
    return function(element2, values2) {
      var props = {};
      props["camunda:" + modelProperty] = values2[modelProperty] || void 0;
      return cmdHelper$C.updateBusinessObject(element2, conditionalEventDefinition, props);
    };
  };
  group.entries.push(entryFactory$A.textField(translate2, {
    id: "variableName",
    label: translate2("Variable Name"),
    modelProperty: "variableName",
    get: getValue2("variableName"),
    set: setValue("variableName")
  }));
  var isConditionalStartEvent = is$B(element, "bpmn:StartEvent") && !isEventSubProcess(element.parent);
  if (!isConditionalStartEvent) {
    group.entries.push(entryFactory$A.textField(translate2, {
      id: "variableEvents",
      label: translate2("Variable Events"),
      description: translate2("Specify more than one variable change event as a comma separated list."),
      modelProperty: "variableEvents",
      get: getValue2("variableEvents"),
      set: setValue("variableEvents")
    }));
  }
};
var is$A = require$$2$2.is, isAny$7 = require$$1$2.isAny, getBusinessObject$J = require$$2$2.getBusinessObject, eventDefinitionHelper$6 = EventDefinitionHelper_1;
var forEach$9 = forEach_1;
var message = MessageEventDefinition, signal = SignalEventDefinition, error$1 = ErrorEventDefinition$1, escalation = EscalationEventDefinition, timer = TimerEventDefinition_1, compensation = CompensateEventDefinition, condition = ConditionalEventDefinition;
var EventProps = function(group, element, bpmnFactory, elementRegistry, translate2) {
  var events = [
    "bpmn:StartEvent",
    "bpmn:EndEvent",
    "bpmn:IntermediateThrowEvent",
    "bpmn:BoundaryEvent",
    "bpmn:IntermediateCatchEvent"
  ];
  forEach$9(events, function(event) {
    if (is$A(element, event)) {
      var messageEventDefinition = eventDefinitionHelper$6.getMessageEventDefinition(element), signalEventDefinition = eventDefinitionHelper$6.getSignalEventDefinition(element);
      if (messageEventDefinition) {
        message(group, element, bpmnFactory, messageEventDefinition, translate2);
      }
      if (signalEventDefinition) {
        signal(group, element, bpmnFactory, signalEventDefinition, translate2);
      }
    }
  });
  if (is$A(element, "bpmn:ReceiveTask")) {
    message(group, element, bpmnFactory, getBusinessObject$J(element), translate2);
  }
  var errorEvents = [
    "bpmn:StartEvent",
    "bpmn:BoundaryEvent",
    "bpmn:EndEvent"
  ];
  forEach$9(errorEvents, function(event) {
    if (is$A(element, event)) {
      var errorEventDefinition = eventDefinitionHelper$6.getErrorEventDefinition(element);
      if (errorEventDefinition) {
        error$1(group, element, bpmnFactory, errorEventDefinition, translate2);
      }
    }
  });
  var escalationEvents = [
    "bpmn:StartEvent",
    "bpmn:BoundaryEvent",
    "bpmn:IntermediateThrowEvent",
    "bpmn:EndEvent"
  ];
  forEach$9(escalationEvents, function(event) {
    if (is$A(element, event)) {
      var showEscalationCodeVariable = is$A(element, "bpmn:StartEvent") || is$A(element, "bpmn:BoundaryEvent");
      var escalationEventDefinition = eventDefinitionHelper$6.getEscalationEventDefinition(element);
      if (escalationEventDefinition) {
        escalation(group, element, bpmnFactory, escalationEventDefinition, showEscalationCodeVariable, translate2);
      }
    }
  });
  var timerEvents = [
    "bpmn:StartEvent",
    "bpmn:BoundaryEvent",
    "bpmn:IntermediateCatchEvent"
  ];
  forEach$9(timerEvents, function(event) {
    if (is$A(element, event)) {
      var timerEventDefinition = eventDefinitionHelper$6.getTimerEventDefinition(element);
      if (timerEventDefinition) {
        timer(group, element, bpmnFactory, timerEventDefinition, translate2);
      }
    }
  });
  var compensationEvents = [
    "bpmn:EndEvent",
    "bpmn:IntermediateThrowEvent"
  ];
  forEach$9(compensationEvents, function(event) {
    if (is$A(element, event)) {
      var compensateEventDefinition = eventDefinitionHelper$6.getCompensateEventDefinition(element);
      if (compensateEventDefinition) {
        compensation(group, element, bpmnFactory, compensateEventDefinition, elementRegistry, translate2);
      }
    }
  });
  var conditionalEvents = [
    "bpmn:StartEvent",
    "bpmn:BoundaryEvent",
    "bpmn:IntermediateThrowEvent",
    "bpmn:IntermediateCatchEvent"
  ];
  if (isAny$7(element, conditionalEvents)) {
    var conditionalEventDefinition = eventDefinitionHelper$6.getConditionalEventDefinition(element);
    if (conditionalEventDefinition) {
      condition(group, element, bpmnFactory, conditionalEventDefinition, elementRegistry, translate2);
    }
  }
};
var is$z = require$$2$2.is, getBusinessObject$I = require$$2$2.getBusinessObject, entryFactory$z = EntryFactory_1, cmdHelper$B = CmdHelper_1;
var forEach$8 = forEach_1;
function getLinkEventDefinition(element) {
  var bo = getBusinessObject$I(element);
  var linkEventDefinition = null;
  if (bo.eventDefinitions) {
    forEach$8(bo.eventDefinitions, function(eventDefinition) {
      if (is$z(eventDefinition, "bpmn:LinkEventDefinition")) {
        linkEventDefinition = eventDefinition;
      }
    });
  }
  return linkEventDefinition;
}
var LinkProps = function(group, element, translate2) {
  var linkEvents = ["bpmn:IntermediateThrowEvent", "bpmn:IntermediateCatchEvent"];
  forEach$8(linkEvents, function(event) {
    if (is$z(element, event)) {
      var linkEventDefinition = getLinkEventDefinition(element);
      if (linkEventDefinition) {
        var entry = entryFactory$z.textField(translate2, {
          id: "link-event",
          label: translate2("Link Name"),
          modelProperty: "link-name"
        });
        entry.get = function() {
          return { "link-name": linkEventDefinition.get("name") };
        };
        entry.set = function(element2, values2) {
          var newProperties = {
            name: values2["link-name"]
          };
          return cmdHelper$B.updateBusinessObject(element2, linkEventDefinition, newProperties);
        };
        group.entries.push(entry);
      }
    }
  });
};
var entryFactory$y = EntryFactory_1, cmdHelper$A = CmdHelper_1;
var ModelUtil$2 = require$$2$2, is$y = ModelUtil$2.is, getBusinessObject$H = ModelUtil$2.getBusinessObject;
var DOCUMENTATION_TEXT_FORMAT = "text/plain";
var DocumentationProps = function(group, element, bpmnFactory, translate2) {
  var findDocumentation = function(docs) {
    return docs.find(function(d) {
      return (d.textFormat || DOCUMENTATION_TEXT_FORMAT) === DOCUMENTATION_TEXT_FORMAT;
    });
  };
  var getValue2 = function(businessObject) {
    return function(element2) {
      var documentation = findDocumentation(businessObject && businessObject.get("documentation"));
      var text = documentation && documentation.text || "";
      return { documentation: text };
    };
  };
  var setValue = function(businessObject) {
    return function(element2, values2) {
      var text = values2.documentation;
      var documentation = findDocumentation(businessObject && businessObject.get("documentation"));
      if (documentation) {
        if (text) {
          return cmdHelper$A.updateBusinessObject(element2, documentation, { text: values2.documentation });
        } else {
          return cmdHelper$A.removeElementsFromList(element2, businessObject, "documentation", null, [documentation]);
        }
      }
      if (text) {
        return cmdHelper$A.addElementsTolist(element2, businessObject, "documentation", [
          bpmnFactory.create("bpmn:Documentation", {
            text: values2.documentation
          })
        ]);
      }
    };
  };
  var elementDocuEntry = entryFactory$y.textBox(translate2, {
    id: "documentation",
    label: translate2("Element Documentation"),
    modelProperty: "documentation"
  });
  elementDocuEntry.set = setValue(getBusinessObject$H(element));
  elementDocuEntry.get = getValue2(getBusinessObject$H(element));
  group.entries.push(elementDocuEntry);
  var processRef;
  if (is$y(element, "bpmn:Participant")) {
    processRef = getBusinessObject$H(element).processRef;
    if (processRef) {
      var processDocuEntry = entryFactory$y.textBox(translate2, {
        id: "process-documentation",
        label: translate2("Process Documentation"),
        modelProperty: "documentation"
      });
      processDocuEntry.set = setValue(processRef);
      processDocuEntry.get = getValue2(processRef);
      group.entries.push(processDocuEntry);
    }
  }
};
var entryFactory$x = EntryFactory_1, getBusinessObject$G = require$$2$2.getBusinessObject, utils$b = Utils, cmdHelper$z = CmdHelper_1;
var IdProps = function(group, element, translate2, options) {
  if (!options) {
    options = {};
  }
  group.entries.push(entryFactory$x.validationAwareTextField(translate2, {
    id: options.id || "id",
    label: translate2(options.label || "Id"),
    description: options.description && translate2(options.description),
    modelProperty: "id",
    getProperty: function(element2) {
      return getBusinessObject$G(element2).id;
    },
    setProperty: function(element2, properties2) {
      element2 = element2.labelTarget || element2;
      return cmdHelper$z.updateProperties(element2, properties2);
    },
    validate: function(element2, values2) {
      var idValue = values2.id;
      var bo = getBusinessObject$G(element2);
      var idError = utils$b.isIdValid(bo, idValue, translate2);
      return idError ? { id: idError } : {};
    }
  }));
};
function remove(collection2, element) {
  if (!collection2 || !element) {
    return -1;
  }
  var idx = collection2.indexOf(element);
  if (idx !== -1) {
    collection2.splice(idx, 1);
  }
  return idx;
}
function add$1(collection2, element, idx) {
  if (!collection2 || !element) {
    return;
  }
  if (typeof idx !== "number") {
    idx = -1;
  }
  var currentIdx = collection2.indexOf(element);
  if (currentIdx !== -1) {
    if (currentIdx === idx) {
      return;
    } else {
      if (idx !== -1) {
        collection2.splice(currentIdx, 1);
      } else {
        return;
      }
    }
  }
  if (idx !== -1) {
    collection2.splice(idx, 0, element);
  } else {
    collection2.push(element);
  }
}
function indexOf(collection2, element) {
  if (!collection2 || !element) {
    return -1;
  }
  return collection2.indexOf(element);
}
var Collections = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  remove,
  add: add$1,
  indexOf
}, Symbol.toStringTag, { value: "Module" }));
var require$$3 = /* @__PURE__ */ getAugmentedNamespace(Collections);
var collectionAdd$1 = require$$3.add, getBusinessObject$F = require$$2$2.getBusinessObject;
var CategoryHelper = {};
var CategoryHelper_1 = CategoryHelper;
CategoryHelper.createCategoryValue = function(definitions, bpmnFactory) {
  var categoryValue = bpmnFactory.create("bpmn:CategoryValue"), category = bpmnFactory.create("bpmn:Category", {
    categoryValue: [categoryValue]
  });
  collectionAdd$1(definitions.get("rootElements"), category);
  getBusinessObject$F(category).$parent = definitions;
  getBusinessObject$F(categoryValue).$parent = category;
  return categoryValue;
};
var nameEntryFactory = Name, createCategoryValue = CategoryHelper_1.createCategoryValue, is$x = require$$2$2.is, getBusinessObject$E = require$$2$2.getBusinessObject;
var NameProps = function(group, element, bpmnFactory, canvas, translate2, options) {
  if (!options) {
    options = {};
  }
  function initializeCategory(semantic) {
    var rootElement = canvas.getRootElement(), definitions = getBusinessObject$E(rootElement).$parent, categoryValue = createCategoryValue(definitions, bpmnFactory);
    semantic.categoryValueRef = categoryValue;
  }
  function setGroupName(element2, values2) {
    var bo = getBusinessObject$E(element2), categoryValueRef = bo.categoryValueRef;
    if (!categoryValueRef) {
      initializeCategory(bo);
    }
    return {
      cmd: "element.updateLabel",
      context: {
        element: element2,
        newLabel: values2.categoryValue
      }
    };
  }
  function getGroupName(element2) {
    var bo = getBusinessObject$E(element2), value = (bo.categoryValueRef || {}).value;
    return { categoryValue: value };
  }
  if (!is$x(element, "bpmn:Collaboration")) {
    var nameOptions = {
      id: options.id,
      label: options.label && translate2(options.label)
    };
    if (is$x(element, "bpmn:TextAnnotation")) {
      nameOptions.modelProperty = "text";
      nameOptions.label = translate2("Text");
    } else if (is$x(element, "bpmn:Group")) {
      nameOptions.modelProperty = "categoryValue";
      nameOptions.label = translate2("Category Value");
      nameOptions.get = getGroupName;
      nameOptions.set = setGroupName;
    }
    group.entries = group.entries.concat(nameEntryFactory(element, nameOptions, translate2));
  }
};
var is$w = require$$2$2.is, getBusinessObject$D = require$$2$2.getBusinessObject;
var entryFactory$w = EntryFactory_1;
var participantHelper = ParticipantHelper_1;
var ExecutableProps = function(group, element, translate2) {
  var bo = getBusinessObject$D(element);
  if (!bo) {
    return;
  }
  if (is$w(element, "bpmn:Process") || is$w(element, "bpmn:Participant") && bo.get("processRef")) {
    var executableEntry = entryFactory$w.checkbox(translate2, {
      id: "process-is-executable",
      label: translate2("Executable"),
      modelProperty: "isExecutable"
    });
    if (is$w(element, "bpmn:Participant")) {
      executableEntry.get = function(element2) {
        return participantHelper.getProcessBusinessObject(element2, "isExecutable");
      };
      executableEntry.set = function(element2, values2) {
        return participantHelper.modifyProcessBusinessObject(element2, "isExecutable", values2);
      };
    }
    group.entries.push(executableEntry);
  }
};
var ModelUtil$1 = require$$2$2, is$v = ModelUtil$1.is, getBusinessObject$C = ModelUtil$1.getBusinessObject;
var extensionElementsHelper$9 = ExtensionElementsHelper_1, implementationTypeHelper$1 = ImplementationTypeHelper_1;
var InputOutputHelper$2 = {};
var InputOutputHelper_1 = InputOutputHelper$2;
function getElements$1(bo, type, prop) {
  var elems = extensionElementsHelper$9.getExtensionElements(bo, type);
  return !prop ? elems : (elems[0] || {})[prop] || [];
}
function getParameters$1(element, prop, insideConnector) {
  var inputOutput = InputOutputHelper$2.getInputOutput(element, insideConnector);
  return inputOutput && inputOutput.get(prop) || [];
}
InputOutputHelper$2.getInputOutput = function(element, insideConnector) {
  if (!insideConnector) {
    var bo = getBusinessObject$C(element);
    return (getElements$1(bo, "camunda:InputOutput") || [])[0];
  }
  var connector = this.getConnector(element);
  return connector && connector.get("inputOutput");
};
InputOutputHelper$2.getConnector = function(element) {
  var bo = implementationTypeHelper$1.getServiceTaskLikeBusinessObject(element);
  return bo && (getElements$1(bo, "camunda:Connector") || [])[0];
};
InputOutputHelper$2.getInputParameters = function(element, insideConnector) {
  return getParameters$1.apply(this, [element, "inputParameters", insideConnector]);
};
InputOutputHelper$2.getOutputParameters = function(element, insideConnector) {
  return getParameters$1.apply(this, [element, "outputParameters", insideConnector]);
};
InputOutputHelper$2.getInputParameter = function(element, insideConnector, idx) {
  return this.getInputParameters(element, insideConnector)[idx];
};
InputOutputHelper$2.getOutputParameter = function(element, insideConnector, idx) {
  return this.getOutputParameters(element, insideConnector)[idx];
};
InputOutputHelper$2.isInputOutputSupported = function(element, insideConnector) {
  if (insideConnector) {
    return true;
  }
  var bo = getBusinessObject$C(element);
  return is$v(bo, "bpmn:FlowNode") && !(is$v(bo, "bpmn:StartEvent") || is$v(bo, "bpmn:Gateway") || is$v(bo, "bpmn:BoundaryEvent") || is$v(bo, "bpmn:SubProcess") && bo.get("triggeredByEvent"));
};
InputOutputHelper$2.areOutputParametersSupported = function(element, insideConnector) {
  var bo = getBusinessObject$C(element);
  return insideConnector || !is$v(bo, "bpmn:EndEvent") && !bo.loopCharacteristics;
};
var entryFactory$v = EntryFactory_1, cmdHelper$y = CmdHelper_1, extensionElementsHelper$8 = ExtensionElementsHelper_1, elementHelper$i = ElementHelper_1;
var assign$8 = assign_1;
var map$2 = map_1;
var DEFAULT_DELEGATE_PROPS = ["class", "expression", "delegateExpression"];
var DELEGATE_PROPS = {
  "camunda:class": void 0,
  "camunda:expression": void 0,
  "camunda:delegateExpression": void 0,
  "camunda:resultVariable": void 0
};
var DMN_CAPABLE_PROPS = {
  "camunda:decisionRef": void 0,
  "camunda:decisionRefBinding": "latest",
  "camunda:decisionRefVersion": void 0,
  "camunda:mapDecisionResult": "resultList",
  "camunda:decisionRefTenantId": void 0
};
var EXTERNAL_CAPABLE_PROPS = {
  "camunda:type": void 0,
  "camunda:topic": void 0
};
var ImplementationType = function(element, bpmnFactory, options, translate2) {
  var DEFAULT_OPTIONS2 = [
    { value: "class", name: translate2("Java Class") },
    { value: "expression", name: translate2("Expression") },
    { value: "delegateExpression", name: translate2("Delegate Expression") }
  ];
  var DMN_OPTION = [
    { value: "dmn", name: translate2("DMN") }
  ];
  var EXTERNAL_OPTION = [
    { value: "external", name: translate2("External") }
  ];
  var CONNECTOR_OPTION = [
    { value: "connector", name: translate2("Connector") }
  ];
  var SCRIPT_OPTION = [
    { value: "script", name: translate2("Script") }
  ];
  var getType2 = options.getImplementationType, getBusinessObject2 = options.getBusinessObject;
  var hasDmnSupport = options.hasDmnSupport, hasExternalSupport = options.hasExternalSupport, hasServiceTaskLikeSupport = options.hasServiceTaskLikeSupport, hasScriptSupport = options.hasScriptSupport;
  var entries = [];
  var selectOptions = DEFAULT_OPTIONS2.concat([]);
  if (hasDmnSupport) {
    selectOptions = selectOptions.concat(DMN_OPTION);
  }
  if (hasExternalSupport) {
    selectOptions = selectOptions.concat(EXTERNAL_OPTION);
  }
  if (hasServiceTaskLikeSupport) {
    selectOptions = selectOptions.concat(CONNECTOR_OPTION);
  }
  if (hasScriptSupport) {
    selectOptions = selectOptions.concat(SCRIPT_OPTION);
  }
  selectOptions.push({ value: "" });
  entries.push(entryFactory$v.selectBox(translate2, {
    id: "implementation",
    label: translate2("Implementation"),
    selectOptions,
    modelProperty: "implType",
    get: function(element2, node2) {
      return {
        implType: getType2(element2) || ""
      };
    },
    set: function(element2, values2, node2) {
      var bo = getBusinessObject2(element2);
      var oldType = getType2(element2);
      var newType = values2.implType;
      var props = assign$8({}, DELEGATE_PROPS);
      if (DEFAULT_DELEGATE_PROPS.indexOf(newType) !== -1) {
        var newValue = "";
        if (DEFAULT_DELEGATE_PROPS.indexOf(oldType) !== -1) {
          newValue = bo.get("camunda:" + oldType);
        }
        props["camunda:" + newType] = newValue;
      }
      if (hasDmnSupport) {
        props = assign$8(props, DMN_CAPABLE_PROPS);
        if (newType === "dmn") {
          props["camunda:decisionRef"] = "";
        }
      }
      if (hasExternalSupport) {
        props = assign$8(props, EXTERNAL_CAPABLE_PROPS);
        if (newType === "external") {
          props["camunda:type"] = "external";
          props["camunda:topic"] = "";
        }
      }
      if (hasScriptSupport) {
        props["camunda:script"] = void 0;
        if (newType === "script") {
          props["camunda:script"] = elementHelper$i.createElement("camunda:Script", {}, bo, bpmnFactory);
        }
      }
      var commands = [];
      commands.push(cmdHelper$y.updateBusinessObject(element2, bo, props));
      if (oldType === "external" && newType !== "external") {
        var errorEventDefinitions = extensionElementsHelper$8.getExtensionElements(bo, "camunda:ErrorEventDefinition");
        commands.push(map$2(errorEventDefinitions, function(errorEventDefinition) {
          return extensionElementsHelper$8.removeEntry(bo, element2, errorEventDefinition);
        }));
      }
      if (hasServiceTaskLikeSupport) {
        var connectors = extensionElementsHelper$8.getExtensionElements(bo, "camunda:Connector");
        commands.push(map$2(connectors, function(connector2) {
          return extensionElementsHelper$8.removeEntry(bo, element2, connector2);
        }));
        if (newType === "connector") {
          var extensionElements2 = bo.get("extensionElements");
          if (!extensionElements2) {
            extensionElements2 = elementHelper$i.createElement("bpmn:ExtensionElements", { values: [] }, bo, bpmnFactory);
            commands.push(cmdHelper$y.updateBusinessObject(element2, bo, { extensionElements: extensionElements2 }));
          }
          var connector = elementHelper$i.createElement("camunda:Connector", {}, extensionElements2, bpmnFactory);
          commands.push(cmdHelper$y.addAndRemoveElementsFromList(element2, extensionElements2, "values", "extensionElements", [connector], []));
        }
      }
      return commands;
    }
  }));
  return entries;
};
var entryFactory$u = EntryFactory_1, cmdHelper$x = CmdHelper_1;
var DELEGATE_TYPES = [
  "class",
  "expression",
  "delegateExpression"
];
var PROPERTIES = {
  class: "camunda:class",
  expression: "camunda:expression",
  delegateExpression: "camunda:delegateExpression"
};
function isDelegate(type) {
  return DELEGATE_TYPES.indexOf(type) !== -1;
}
function getAttribute(type) {
  return PROPERTIES[type];
}
var Delegate = function(element, bpmnFactory, options, translate2) {
  var getImplementationType2 = options.getImplementationType, getBusinessObject2 = options.getBusinessObject;
  function getDelegationLabel(type) {
    switch (type) {
      case "class":
        return translate2("Java Class");
      case "expression":
        return translate2("Expression");
      case "delegateExpression":
        return translate2("Delegate Expression");
      default:
        return "";
    }
  }
  var delegateEntry = entryFactory$u.textField(translate2, {
    id: "delegate",
    label: translate2("Value"),
    dataValueLabel: "delegationLabel",
    modelProperty: "delegate",
    get: function(element2, node2) {
      var bo = getBusinessObject2(element2);
      var type = getImplementationType2(element2);
      var attr2 = getAttribute(type);
      var label2 = getDelegationLabel(type);
      return {
        delegate: bo.get(attr2),
        delegationLabel: label2
      };
    },
    set: function(element2, values2, node2) {
      var bo = getBusinessObject2(element2);
      var type = getImplementationType2(element2);
      var attr2 = getAttribute(type);
      var prop = {};
      prop[attr2] = values2.delegate || "";
      return cmdHelper$x.updateBusinessObject(element2, bo, prop);
    },
    validate: function(element2, values2, node2) {
      return isDelegate(getImplementationType2(element2)) && !values2.delegate ? { delegate: translate2("Must provide a value") } : {};
    },
    hidden: function(element2, node2) {
      return !isDelegate(getImplementationType2(element2));
    }
  });
  return [delegateEntry];
};
var entryFactory$t = EntryFactory_1, cmdHelper$w = CmdHelper_1;
var External = function(element, bpmnFactory, options, translate2) {
  var getImplementationType2 = options.getImplementationType, getBusinessObject2 = options.getBusinessObject;
  function isExternal(element2) {
    return getImplementationType2(element2) === "external";
  }
  var topicEntry = entryFactory$t.textField(translate2, {
    id: "externalTopic",
    label: translate2("Topic"),
    modelProperty: "externalTopic",
    get: function(element2, node2) {
      var bo = getBusinessObject2(element2);
      return { externalTopic: bo.get("camunda:topic") };
    },
    set: function(element2, values2, node2) {
      var bo = getBusinessObject2(element2);
      return cmdHelper$w.updateBusinessObject(element2, bo, {
        "camunda:topic": values2.externalTopic
      });
    },
    validate: function(element2, values2, node2) {
      return isExternal(element2) && !values2.externalTopic ? { externalTopic: translate2("Must provide a value") } : {};
    },
    hidden: function(element2, node2) {
      return !isExternal(element2);
    }
  });
  return [topicEntry];
};
var is$u = require$$2$2.is;
var assign$7 = assign_1;
var entryFactory$s = EntryFactory_1, cmdHelper$v = CmdHelper_1;
var ResultVariable = function(element, bpmnFactory, options, translate2) {
  var getBusinessObject2 = options.getBusinessObject, hideResultVariable = options.hideResultVariable, id2 = options.id || "resultVariable";
  var resultVariableEntry = entryFactory$s.textField(translate2, {
    id: id2,
    label: translate2("Result Variable"),
    modelProperty: "resultVariable",
    get: function(element2, node2) {
      var bo = getBusinessObject2(element2);
      return { resultVariable: bo.get("camunda:resultVariable") };
    },
    set: function(element2, values2, node2) {
      var bo = getBusinessObject2(element2);
      var resultVariable2 = values2.resultVariable || void 0;
      var props = {
        "camunda:resultVariable": resultVariable2
      };
      if (is$u(bo, "camunda:DmnCapable") && !resultVariable2) {
        props = assign$7({ "camunda:mapDecisionResult": "resultList" }, props);
      }
      return cmdHelper$v.updateBusinessObject(element2, bo, props);
    },
    hidden: function(element2, node2) {
      if (typeof hideResultVariable === "function") {
        return hideResultVariable.apply(resultVariableEntry, arguments);
      }
    }
  });
  return [resultVariableEntry];
};
var cmdHelper$u = CmdHelper_1, entryFactory$r = EntryFactory_1, elementHelper$h = ElementHelper_1, extensionElementsHelper$7 = ExtensionElementsHelper_1;
var resultVariable$1 = ResultVariable;
var getBusinessObject$B = require$$2$2.getBusinessObject;
var is$t = require$$2$2.is;
var forEach$7 = forEach_1;
var attributeInfo = {
  bpmn: {
    element: "calledElement",
    binding: "camunda:calledElementBinding",
    version: "camunda:calledElementVersion",
    versionTag: "camunda:calledElementVersionTag",
    tenantId: "camunda:calledElementTenantId"
  },
  cmmn: {
    element: "camunda:caseRef",
    binding: "camunda:caseBinding",
    version: "camunda:caseVersion",
    tenantId: "camunda:caseTenantId"
  },
  dmn: {
    element: "camunda:decisionRef",
    binding: "camunda:decisionRefBinding",
    version: "camunda:decisionRefVersion",
    versionTag: "camunda:decisionRefVersionTag",
    tenantId: "camunda:decisionRefTenantId"
  }
};
var mapDecisionResultOptions = [
  {
    name: "singleEntry (TypedValue)",
    value: "singleEntry"
  },
  {
    name: "singleResult (Map<String, Object>)",
    value: "singleResult"
  },
  {
    name: "collectEntries (List<Object>)",
    value: "collectEntries"
  },
  {
    name: "resultList (List<Map<String, Object>>)",
    value: "resultList"
  }
];
var delegateVariableMappingOptions = [
  {
    name: "variableMappingClass",
    value: "variableMappingClass"
  },
  {
    name: "variableMappingDelegateExpression",
    value: "variableMappingDelegateExpression"
  }
];
function getCamundaInWithBusinessKey(element) {
  var camundaIn = [], bo = getBusinessObject$B(element);
  var camundaInParams = extensionElementsHelper$7.getExtensionElements(bo, "camunda:In");
  forEach$7(camundaInParams, function(param) {
    if (param.businessKey !== void 0) {
      camundaIn.push(param);
    }
  });
  return camundaIn;
}
function setBusinessKey(element, text, bpmnFactory) {
  var commands = [];
  var camundaInWithBusinessKey = getCamundaInWithBusinessKey(element);
  if (camundaInWithBusinessKey.length) {
    commands.push(cmdHelper$u.updateBusinessObject(element, camundaInWithBusinessKey[0], {
      businessKey: text
    }));
  } else {
    var bo = getBusinessObject$B(element), extensionElements2 = bo.extensionElements;
    if (!extensionElements2) {
      extensionElements2 = elementHelper$h.createElement("bpmn:ExtensionElements", { values: [] }, bo, bpmnFactory);
      commands.push(cmdHelper$u.updateProperties(element, { extensionElements: extensionElements2 }));
    }
    var camundaIn = elementHelper$h.createElement("camunda:In", { "businessKey": text }, extensionElements2, bpmnFactory);
    commands.push(cmdHelper$u.addAndRemoveElementsFromList(element, extensionElements2, "values", "extensionElements", [camundaIn], []));
  }
  return commands;
}
function deleteBusinessKey(element) {
  var camundaInExtensions = getCamundaInWithBusinessKey(element);
  var commands = [];
  forEach$7(camundaInExtensions, function(elem) {
    commands.push(extensionElementsHelper$7.removeEntry(getBusinessObject$B(element), element, elem));
  });
  return commands;
}
function isSupportedCallableType(type) {
  return ["bpmn", "cmmn", "dmn"].indexOf(type) !== -1;
}
var Callable = function(element, bpmnFactory, options, translate2) {
  var bindingOptions = [
    {
      name: translate2("latest"),
      value: "latest"
    },
    {
      name: translate2("deployment"),
      value: "deployment"
    },
    {
      name: translate2("version"),
      value: "version"
    },
    {
      name: translate2("versionTag"),
      value: "versionTag"
    }
  ];
  var getCallableType2 = options.getCallableType;
  var entries = [];
  function getAttribute2(element2, prop) {
    var type = getCallableType2(element2);
    return (attributeInfo[type] || {})[prop];
  }
  function getCallActivityBindingValue(element2) {
    var type = getCallableType2(element2);
    var bo = getBusinessObject$B(element2);
    var attr2 = (attributeInfo[type] || {}).binding;
    return bo.get(attr2);
  }
  function getDelegateVariableMappingType(element2) {
    var bo = getBusinessObject$B(element2);
    var boVariableMappingClass = bo.get("camunda:variableMappingClass"), boVariableMappingDelegateExpression = bo.get("camunda:variableMappingDelegateExpression");
    var delegateVariableMappingType = "";
    if (typeof boVariableMappingClass !== "undefined") {
      delegateVariableMappingType = "variableMappingClass";
    } else if (typeof boVariableMappingDelegateExpression !== "undefined") {
      delegateVariableMappingType = "variableMappingDelegateExpression";
    }
    return delegateVariableMappingType;
  }
  entries.push(entryFactory$r.textField(translate2, {
    id: "callable-element-ref",
    dataValueLabel: "callableElementLabel",
    modelProperty: "callableElementRef",
    get: function(element2, node2) {
      var callableElementRef;
      var attr2 = getAttribute2(element2, "element");
      if (attr2) {
        var bo = getBusinessObject$B(element2);
        callableElementRef = bo.get(attr2);
      }
      var label2 = "";
      var type = getCallableType2(element2);
      if (type === "bpmn") {
        label2 = translate2("Called Element");
      } else if (type === "cmmn") {
        label2 = translate2("Case Ref");
      } else if (type === "dmn") {
        label2 = translate2("Decision Ref");
      }
      return {
        callableElementRef,
        callableElementLabel: label2
      };
    },
    set: function(element2, values2, node2) {
      var newCallableElementRef = values2.callableElementRef;
      var attr2 = getAttribute2(element2, "element");
      var props = {};
      props[attr2] = newCallableElementRef || "";
      return cmdHelper$u.updateProperties(element2, props);
    },
    validate: function(element2, values2, node2) {
      var elementRef = values2.callableElementRef;
      var type = getCallableType2(element2);
      return isSupportedCallableType(type) && !elementRef ? { callableElementRef: translate2("Must provide a value") } : {};
    },
    hidden: function(element2, node2) {
      return !isSupportedCallableType(getCallableType2(element2));
    }
  }));
  entries.push(entryFactory$r.selectBox(translate2, {
    id: "callable-binding",
    label: translate2("Binding"),
    selectOptions: function(element2) {
      var type = getCallableType2(element2);
      var options2;
      if (type === "cmmn") {
        options2 = bindingOptions.filter(function(bindingOption) {
          return bindingOption.value !== "versionTag";
        });
      } else {
        options2 = bindingOptions;
      }
      return options2;
    },
    modelProperty: "callableBinding",
    get: function(element2, node2) {
      var callableBinding;
      var attr2 = getAttribute2(element2, "binding");
      if (attr2) {
        var bo = getBusinessObject$B(element2);
        callableBinding = bo.get(attr2) || "latest";
      }
      return {
        callableBinding
      };
    },
    set: function(element2, values2, node2) {
      var binding = values2.callableBinding;
      var attr2 = getAttribute2(element2, "binding"), attrVer = getAttribute2(element2, "version"), attrVerTag = getAttribute2(element2, "versionTag");
      var props = {};
      props[attr2] = binding;
      props[attrVer] = void 0;
      props[attrVerTag] = void 0;
      return cmdHelper$u.updateProperties(element2, props);
    },
    hidden: function(element2, node2) {
      return !isSupportedCallableType(getCallableType2(element2));
    }
  }));
  entries.push(entryFactory$r.textField(translate2, {
    id: "callable-version",
    label: translate2("Version"),
    modelProperty: "callableVersion",
    get: function(element2, node2) {
      var callableVersion;
      var attr2 = getAttribute2(element2, "version");
      if (attr2) {
        var bo = getBusinessObject$B(element2);
        callableVersion = bo.get(attr2);
      }
      return {
        callableVersion
      };
    },
    set: function(element2, values2, node2) {
      var version2 = values2.callableVersion;
      var attr2 = getAttribute2(element2, "version");
      var props = {};
      props[attr2] = version2 || void 0;
      return cmdHelper$u.updateProperties(element2, props);
    },
    validate: function(element2, values2, node2) {
      var version2 = values2.callableVersion;
      var type = getCallableType2(element2);
      return isSupportedCallableType(type) && getCallActivityBindingValue(element2) === "version" && (!version2 ? { callableVersion: translate2("Must provide a value") } : {});
    },
    hidden: function(element2, node2) {
      var type = getCallableType2(element2);
      return !isSupportedCallableType(type) || getCallActivityBindingValue(element2) !== "version";
    }
  }));
  entries.push(entryFactory$r.textField(translate2, {
    id: "callable-version-tag",
    label: translate2("Version Tag"),
    modelProperty: "versionTag",
    get: function(element2, node2) {
      var versionTag2;
      var attr2 = getAttribute2(element2, "versionTag");
      if (attr2) {
        var bo = getBusinessObject$B(element2);
        versionTag2 = bo.get(attr2);
      }
      return {
        versionTag: versionTag2
      };
    },
    set: function(element2, values2, node2) {
      var versionTag2 = values2.versionTag;
      var attr2 = getAttribute2(element2, "versionTag");
      var props = {};
      props[attr2] = versionTag2 || void 0;
      return cmdHelper$u.updateProperties(element2, props);
    },
    validate: function(element2, values2, node2) {
      var versionTag2 = values2.versionTag;
      var type = getCallableType2(element2);
      return isSupportedCallableType(type) && getCallActivityBindingValue(element2) === "versionTag" && (!versionTag2 ? { versionTag: translate2("Must provide a value") } : {});
    },
    hidden: function(element2, node2) {
      var type = getCallableType2(element2);
      return !isSupportedCallableType(type) || getCallActivityBindingValue(element2) !== "versionTag";
    }
  }));
  entries.push(entryFactory$r.textField(translate2, {
    id: "tenant-id",
    label: translate2("Tenant Id"),
    modelProperty: "tenantId",
    get: function(element2, node2) {
      var tenantId;
      var attr2 = getAttribute2(element2, "tenantId");
      if (attr2) {
        var bo = getBusinessObject$B(element2);
        tenantId = bo.get(attr2);
      }
      return {
        tenantId
      };
    },
    set: function(element2, values2, node2) {
      var tenantId = values2.tenantId;
      var attr2 = getAttribute2(element2, "tenantId");
      var props = {};
      props[attr2] = tenantId || void 0;
      return cmdHelper$u.updateProperties(element2, props);
    },
    hidden: function(element2, node2) {
      var type = getCallableType2(element2);
      return !isSupportedCallableType(type);
    }
  }));
  if (is$t(getBusinessObject$B(element), "bpmn:CallActivity")) {
    entries.push(entryFactory$r.checkbox(translate2, {
      id: "callable-business-key",
      label: translate2("Business Key"),
      modelProperty: "callableBusinessKey",
      get: function(element2, node2) {
        var camundaIn = getCamundaInWithBusinessKey(element2);
        return {
          callableBusinessKey: !!(camundaIn && camundaIn.length > 0)
        };
      },
      set: function(element2, values2, node2) {
        if (values2.callableBusinessKey) {
          return setBusinessKey(element2, "#{execution.processBusinessKey}", bpmnFactory);
        } else {
          return deleteBusinessKey(element2);
        }
      }
    }));
  }
  entries.push(entryFactory$r.textField(translate2, {
    id: "business-key-expression",
    label: translate2("Business Key Expression"),
    modelProperty: "businessKey",
    get: function(element2, node2) {
      var camundaInWithBusinessKey = getCamundaInWithBusinessKey(element2);
      return {
        businessKey: camundaInWithBusinessKey.length ? camundaInWithBusinessKey[0].get("camunda:businessKey") : void 0
      };
    },
    set: function(element2, values2, node2) {
      var businessKey = values2.businessKey;
      return setBusinessKey(element2, businessKey, bpmnFactory);
    },
    validate: function(element2, values2, node2) {
      var businessKey = values2.businessKey;
      return businessKey === "" ? { businessKey: translate2("Must provide a value") } : {};
    },
    hidden: function(element2, node2) {
      return !getCamundaInWithBusinessKey(element2).length;
    }
  }));
  entries = entries.concat(resultVariable$1(element, bpmnFactory, {
    id: "dmn-resultVariable",
    getBusinessObject: getBusinessObject$B,
    getImplementationType: getCallableType2,
    hideResultVariable: function(element2, node2) {
      return getCallableType2(element2) !== "dmn";
    }
  }, translate2));
  entries.push(entryFactory$r.selectBox(translate2, {
    id: "dmn-map-decision-result",
    label: translate2("Map Decision Result"),
    selectOptions: mapDecisionResultOptions,
    modelProperty: "mapDecisionResult",
    get: function(element2, node2) {
      var bo = getBusinessObject$B(element2);
      return {
        mapDecisionResult: bo.get("camunda:mapDecisionResult") || "resultList"
      };
    },
    set: function(element2, values2, node2) {
      return cmdHelper$u.updateProperties(element2, {
        "camunda:mapDecisionResult": values2.mapDecisionResult || "resultList"
      });
    },
    hidden: function(element2, node2) {
      var bo = getBusinessObject$B(element2);
      var resultVariable2 = bo.get("camunda:resultVariable");
      return !(getCallableType2(element2) === "dmn" && typeof resultVariable2 !== "undefined");
    }
  }));
  entries.push(entryFactory$r.selectBox(translate2, {
    id: "delegateVariableMappingType",
    label: translate2("Delegate Variable Mapping"),
    selectOptions: delegateVariableMappingOptions,
    emptyParameter: true,
    modelProperty: "delegateVariableMappingType",
    get: function(element2, node2) {
      return {
        delegateVariableMappingType: getDelegateVariableMappingType(element2)
      };
    },
    set: function(element2, values2, node2) {
      var delegateVariableMappingType = values2.delegateVariableMappingType;
      var props = {
        "camunda:variableMappingClass": void 0,
        "camunda:variableMappingDelegateExpression": void 0
      };
      if (delegateVariableMappingType === "variableMappingClass") {
        props["camunda:variableMappingClass"] = "";
      } else if (delegateVariableMappingType === "variableMappingDelegateExpression") {
        props["camunda:variableMappingDelegateExpression"] = "";
      }
      return cmdHelper$u.updateProperties(element2, props);
    },
    hidden: function(element2, node2) {
      return getCallableType2(element2) !== "bpmn";
    }
  }));
  entries.push(entryFactory$r.textField(translate2, {
    id: "delegateVariableMapping",
    dataValueLabel: "delegateVariableMappingLabel",
    modelProperty: "delegateVariableMapping",
    get: function(element2, node2) {
      var bo = getBusinessObject$B(element2);
      var label2 = "";
      var delegateVariableMapping = void 0;
      var type = getDelegateVariableMappingType(element2);
      if (type === "variableMappingClass") {
        label2 = translate2("Class");
        delegateVariableMapping = bo.get("camunda:variableMappingClass");
      } else if (type === "variableMappingDelegateExpression") {
        label2 = translate2("Delegate Expression");
        delegateVariableMapping = bo.get("camunda:variableMappingDelegateExpression");
      }
      return {
        delegateVariableMapping,
        delegateVariableMappingLabel: label2
      };
    },
    set: function(element2, values2, node2) {
      var delegateVariableMapping = values2.delegateVariableMapping;
      var attr2 = "camunda:" + getDelegateVariableMappingType(element2);
      var props = {};
      props[attr2] = delegateVariableMapping || void 0;
      return cmdHelper$u.updateProperties(element2, props);
    },
    validate: function(element2, values2, node2) {
      var delegateVariableMapping = values2.delegateVariableMapping;
      return getCallableType2(element2) === "bpmn" && (!delegateVariableMapping ? { delegateVariableMapping: translate2("Must provide a value") } : {});
    },
    hidden: function(element2, node2) {
      return !(getCallableType2(element2) === "bpmn" && getDelegateVariableMappingType(element2) !== "");
    }
  }));
  return entries;
};
var ImplementationTypeHelper$6 = ImplementationTypeHelper_1, InputOutputHelper$1 = InputOutputHelper_1;
var utils$a = Utils, escapeHTML$8 = utils$a.escapeHTML, triggerClickEvent = utils$a.triggerClickEvent;
var implementationType = ImplementationType, delegate = Delegate, external = External, callable$1 = Callable, resultVariable = ResultVariable;
var entryFactory$q = EntryFactory_1;
var domQuery$c = require$$6.query, domClosest$1 = require$$6.closest, domClasses$4 = require$$6.classes;
function getImplementationType$1(element) {
  return ImplementationTypeHelper$6.getImplementationType(element);
}
function getBusinessObject$A(element) {
  return ImplementationTypeHelper$6.getServiceTaskLikeBusinessObject(element);
}
function isDmnCapable(element) {
  return ImplementationTypeHelper$6.isDmnCapable(element);
}
function isExternalCapable(element) {
  return ImplementationTypeHelper$6.isExternalCapable(element);
}
function isServiceTaskLike(element) {
  return ImplementationTypeHelper$6.isServiceTaskLike(element);
}
var ServiceTaskDelegateProps = function(group, element, bpmnFactory, translate2) {
  if (!isServiceTaskLike(getBusinessObject$A(element))) {
    return;
  }
  var hasDmnSupport = isDmnCapable(element);
  var hasExternalSupport = isExternalCapable(getBusinessObject$A(element));
  group.entries = group.entries.concat(implementationType(element, bpmnFactory, {
    getBusinessObject: getBusinessObject$A,
    getImplementationType: getImplementationType$1,
    hasDmnSupport,
    hasExternalSupport,
    hasServiceTaskLikeSupport: true
  }, translate2));
  group.entries = group.entries.concat(delegate(element, bpmnFactory, {
    getBusinessObject: getBusinessObject$A,
    getImplementationType: getImplementationType$1
  }, translate2));
  group.entries = group.entries.concat(resultVariable(element, bpmnFactory, {
    getBusinessObject: getBusinessObject$A,
    getImplementationType: getImplementationType$1,
    hideResultVariable: function(element2, node2) {
      return getImplementationType$1(element2) !== "expression";
    }
  }, translate2));
  if (hasExternalSupport) {
    group.entries = group.entries.concat(external(element, bpmnFactory, {
      getBusinessObject: getBusinessObject$A,
      getImplementationType: getImplementationType$1
    }, translate2));
  }
  if (hasDmnSupport) {
    group.entries = group.entries.concat(callable$1(element, bpmnFactory, {
      getCallableType: getImplementationType$1
    }, translate2));
  }
  var isConnector2 = function(element2) {
    return getImplementationType$1(element2) === "connector";
  };
  group.entries.push(entryFactory$q.link(translate2, {
    id: "configureConnectorLink",
    buttonLabel: translate2("Configure Connector"),
    handleClick: function(element2, node2, event) {
      var connectorTabEl = getTabNode(node2, "connector");
      if (connectorTabEl) {
        triggerClickEvent(connectorTabEl);
      }
      return false;
    },
    showLink: function(element2, node2) {
      var link2 = domQuery$c("a", node2);
      link2.textContent = "";
      domClasses$4(link2).remove("bpp-error-message");
      if (isConnector2(element2)) {
        var connectorId = InputOutputHelper$1.getConnector(element2).get("connectorId");
        if (connectorId) {
          link2.textContent = translate2("Configure Connector");
        } else {
          link2.innerHTML = '<span class="bpp-icon-warning"></span> ' + escapeHTML$8(translate2("Must configure Connector"));
          domClasses$4(link2).add("bpp-error-message");
        }
        return true;
      }
      return false;
    }
  }));
};
function getTabNode(el, id2) {
  var containerEl = domClosest$1(el, ".bpp-properties-panel");
  return domQuery$c('a[data-tab-target="' + id2 + '"]', containerEl);
}
var is$s = require$$2$2.is, entryFactory$p = EntryFactory_1;
var UserTaskProps = function(group, element, translate2) {
  if (is$s(element, "camunda:Assignable")) {
    group.entries.push(entryFactory$p.textField(translate2, {
      id: "assignee",
      label: translate2("Assignee"),
      modelProperty: "assignee"
    }));
    group.entries.push(entryFactory$p.textField(translate2, {
      id: "candidateUsers",
      label: translate2("Candidate Users"),
      modelProperty: "candidateUsers"
    }));
    group.entries.push(entryFactory$p.textField(translate2, {
      id: "candidateGroups",
      label: translate2("Candidate Groups"),
      modelProperty: "candidateGroups"
    }));
    group.entries.push(entryFactory$p.textField(translate2, {
      id: "dueDate",
      description: translate2("The due date as an EL expression (e.g. ${someDate} or an ISO date (e.g. 2015-06-26T09:54:00)"),
      label: translate2("Due Date"),
      modelProperty: "dueDate"
    }));
    group.entries.push(entryFactory$p.textField(translate2, {
      id: "followUpDate",
      description: translate2("The follow up date as an EL expression (e.g. ${someDate} or an ISO date (e.g. 2015-06-26T09:54:00)"),
      label: translate2("Follow Up Date"),
      modelProperty: "followUpDate"
    }));
    group.entries.push(entryFactory$p.textField(translate2, {
      id: "priority",
      label: translate2("Priority"),
      modelProperty: "priority"
    }));
  }
};
var assign$6 = assign_1;
var entryFactory$o = EntryFactory_1;
var asyncCapableHelper$2 = AsyncCapableHelper, eventDefinitionHelper$5 = EventDefinitionHelper_1, cmdHelper$t = CmdHelper_1;
function isAsyncBefore$1(bo) {
  return asyncCapableHelper$2.isAsyncBefore(bo);
}
function isAsyncAfter$1(bo) {
  return asyncCapableHelper$2.isAsyncAfter(bo);
}
function isExclusive(bo) {
  return asyncCapableHelper$2.isExclusive(bo);
}
function removeFailedJobRetryTimeCycle$1(bo, element) {
  return asyncCapableHelper$2.removeFailedJobRetryTimeCycle(bo, element);
}
function canRemoveFailedJobRetryTimeCycle(element) {
  return !eventDefinitionHelper$5.getTimerEventDefinition(element);
}
var AsyncContinuation = function(element, bpmnFactory, options, translate2) {
  var getBusinessObject2 = options.getBusinessObject;
  var idPrefix = options.idPrefix || "", labelPrefix = options.labelPrefix || "";
  var asyncBeforeEntry = entryFactory$o.checkbox(translate2, {
    id: idPrefix + "asyncBefore",
    label: labelPrefix + translate2("Asynchronous Before"),
    modelProperty: "asyncBefore",
    get: function(element2, node2) {
      var bo = getBusinessObject2(element2);
      return {
        asyncBefore: isAsyncBefore$1(bo)
      };
    },
    set: function(element2, values2) {
      var bo = getBusinessObject2(element2);
      var asyncBefore = !!values2.asyncBefore;
      var props = {
        "camunda:asyncBefore": asyncBefore,
        "camunda:async": false
      };
      var commands = [];
      if (!isAsyncAfter$1(bo) && !asyncBefore) {
        props = assign$6({ "camunda:exclusive": true }, props);
        if (canRemoveFailedJobRetryTimeCycle(element2)) {
          commands.push(removeFailedJobRetryTimeCycle$1(bo, element2));
        }
      }
      commands.push(cmdHelper$t.updateBusinessObject(element2, bo, props));
      return commands;
    }
  });
  var asyncAfterEntry = entryFactory$o.checkbox(translate2, {
    id: idPrefix + "asyncAfter",
    label: labelPrefix + translate2("Asynchronous After"),
    modelProperty: "asyncAfter",
    get: function(element2, node2) {
      var bo = getBusinessObject2(element2);
      return {
        asyncAfter: isAsyncAfter$1(bo)
      };
    },
    set: function(element2, values2) {
      var bo = getBusinessObject2(element2);
      var asyncAfter = !!values2.asyncAfter;
      var props = {
        "camunda:asyncAfter": asyncAfter
      };
      var commands = [];
      if (!isAsyncBefore$1(bo) && !asyncAfter) {
        props = assign$6({ "camunda:exclusive": true }, props);
        if (canRemoveFailedJobRetryTimeCycle(element2)) {
          commands.push(removeFailedJobRetryTimeCycle$1(bo, element2));
        }
      }
      commands.push(cmdHelper$t.updateBusinessObject(element2, bo, props));
      return commands;
    }
  });
  var exclusiveEntry = entryFactory$o.checkbox(translate2, {
    id: idPrefix + "exclusive",
    label: labelPrefix + translate2("Exclusive"),
    modelProperty: "exclusive",
    get: function(element2, node2) {
      var bo = getBusinessObject2(element2);
      return { exclusive: isExclusive(bo) };
    },
    set: function(element2, values2) {
      var bo = getBusinessObject2(element2);
      return cmdHelper$t.updateBusinessObject(element2, bo, { "camunda:exclusive": !!values2.exclusive });
    },
    hidden: function(element2) {
      var bo = getBusinessObject2(element2);
      return bo && !isAsyncAfter$1(bo) && !isAsyncBefore$1(bo);
    }
  });
  return [asyncBeforeEntry, asyncAfterEntry, exclusiveEntry];
};
var getBusinessObject$z = require$$2$2.getBusinessObject, is$r = require$$2$2.is, asyncContinuation$1 = AsyncContinuation;
var AsynchronousContinuationProps = function(group, element, bpmnFactory, translate2) {
  if (is$r(element, "camunda:AsyncCapable")) {
    group.entries = group.entries.concat(asyncContinuation$1(element, bpmnFactory, {
      getBusinessObject: getBusinessObject$z
    }, translate2));
  }
};
var getBusinessObject$y = require$$2$2.getBusinessObject, is$q = require$$2$2.is;
var entryFactory$n = EntryFactory_1;
var callable = Callable;
var cmdHelper$s = CmdHelper_1;
var flattenDeep = flattenDeep_1;
var assign$5 = assign_1;
function getCallableType(element) {
  var bo = getBusinessObject$y(element);
  var boCalledElement = bo.get("calledElement"), boCaseRef = bo.get("camunda:caseRef");
  var callActivityType = "";
  if (typeof boCalledElement !== "undefined") {
    callActivityType = "bpmn";
  } else if (typeof boCaseRef !== "undefined") {
    callActivityType = "cmmn";
  }
  return callActivityType;
}
var DEFAULT_PROPS$1 = {
  calledElement: void 0,
  "camunda:calledElementBinding": "latest",
  "camunda:calledElementVersion": void 0,
  "camunda:calledElementTenantId": void 0,
  "camunda:variableMappingClass": void 0,
  "camunda:variableMappingDelegateExpression": void 0,
  "camunda:caseRef": void 0,
  "camunda:caseBinding": "latest",
  "camunda:caseVersion": void 0,
  "camunda:caseTenantId": void 0
};
var CallActivityProps = function(group, element, bpmnFactory, translate2) {
  if (!is$q(element, "camunda:CallActivity")) {
    return;
  }
  group.entries.push(entryFactory$n.selectBox(translate2, {
    id: "callActivity",
    label: translate2("CallActivity Type"),
    selectOptions: [
      { name: "BPMN", value: "bpmn" },
      { name: "CMMN", value: "cmmn" }
    ],
    emptyParameter: true,
    modelProperty: "callActivityType",
    get: function(element2, node2) {
      return {
        callActivityType: getCallableType(element2)
      };
    },
    set: function(element2, values2, node2) {
      var type = values2.callActivityType;
      var props = assign$5({}, DEFAULT_PROPS$1);
      if (type === "bpmn") {
        props.calledElement = "";
      } else if (type === "cmmn") {
        props["camunda:caseRef"] = "";
      }
      return cmdHelper$s.updateProperties(element2, props);
    }
  }));
  group.entries.push(callable(element, bpmnFactory, {
    getCallableType
  }, translate2));
  group.entries = flattenDeep(group.entries);
};
var getBusinessObject$x = require$$2$2.getBusinessObject, escapeHTML$7 = Utils.escapeHTML;
var entryFactory$m = EntryFactory_1;
var elementHelper$g = ElementHelper_1, cmdHelper$r = CmdHelper_1;
var domClasses$3 = require$$6.classes;
function getProperty(element, propertyName) {
  var loopCharacteristics = getLoopCharacteristics$1(element);
  return loopCharacteristics && loopCharacteristics.get(propertyName);
}
function getBody(expression) {
  return expression && expression.get("body");
}
function getLoopCharacteristics$1(element) {
  var bo = getBusinessObject$x(element);
  return bo.loopCharacteristics;
}
function getLoopCardinality(element) {
  return getProperty(element, "loopCardinality");
}
function getLoopCardinalityValue(element) {
  var loopCardinality = getLoopCardinality(element);
  return getBody(loopCardinality);
}
function getCompletionCondition(element) {
  return getProperty(element, "completionCondition");
}
function getCompletionConditionValue(element) {
  var completionCondition = getCompletionCondition(element);
  return getBody(completionCondition);
}
function getCollection(element) {
  return getProperty(element, "camunda:collection");
}
function getElementVariable(element) {
  return getProperty(element, "camunda:elementVariable");
}
function createFormalExpression(parent2, body, bpmnFactory) {
  return elementHelper$g.createElement("bpmn:FormalExpression", { body }, parent2, bpmnFactory);
}
function updateFormalExpression(element, propertyName, newValue, bpmnFactory) {
  var loopCharacteristics = getLoopCharacteristics$1(element);
  var expressionProps = {};
  if (!newValue) {
    expressionProps[propertyName] = void 0;
    return cmdHelper$r.updateBusinessObject(element, loopCharacteristics, expressionProps);
  }
  var existingExpression = loopCharacteristics.get(propertyName);
  if (!existingExpression) {
    expressionProps[propertyName] = createFormalExpression(loopCharacteristics, newValue, bpmnFactory);
    return cmdHelper$r.updateBusinessObject(element, loopCharacteristics, expressionProps);
  }
  return cmdHelper$r.updateBusinessObject(element, existingExpression, {
    body: newValue
  });
}
var MultiInstanceLoopCharacteristics = function(element, bpmnFactory, translate2) {
  var entries = [];
  entries.push({
    id: "multiInstance-errorMessage",
    html: '<div data-show="isValid"><span class="bpp-icon-warning"></span> ' + escapeHTML$7(translate2("Must provide either loop cardinality or collection")) + "</div>",
    isValid: function(element2, node2, notification, scope) {
      var loopCharacteristics = getLoopCharacteristics$1(element2);
      var isValid = true;
      if (loopCharacteristics) {
        var loopCardinality = getLoopCardinalityValue(element2);
        var collection2 = getCollection(element2);
        isValid = !loopCardinality && !collection2;
      }
      domClasses$3(node2).toggle("bpp-hidden", !isValid);
      domClasses$3(notification).toggle("bpp-error-message", isValid);
      return isValid;
    }
  });
  entries.push(entryFactory$m.textField(translate2, {
    id: "multiInstance-loopCardinality",
    label: translate2("Loop Cardinality"),
    modelProperty: "loopCardinality",
    get: function(element2, node2) {
      return {
        loopCardinality: getLoopCardinalityValue(element2)
      };
    },
    set: function(element2, values2) {
      return updateFormalExpression(element2, "loopCardinality", values2.loopCardinality, bpmnFactory);
    }
  }));
  entries.push(entryFactory$m.textField(translate2, {
    id: "multiInstance-collection",
    label: translate2("Collection"),
    modelProperty: "collection",
    get: function(element2, node2) {
      return {
        collection: getCollection(element2)
      };
    },
    set: function(element2, values2) {
      var loopCharacteristics = getLoopCharacteristics$1(element2);
      return cmdHelper$r.updateBusinessObject(element2, loopCharacteristics, {
        "camunda:collection": values2.collection || void 0
      });
    },
    validate: function(element2, values2, node2) {
      var collection2 = getCollection(element2);
      var elementVariable = getElementVariable(element2);
      if (!collection2 && elementVariable) {
        return { collection: "Must provide a value" };
      }
    }
  }));
  entries.push(entryFactory$m.textField(translate2, {
    id: "multiInstance-elementVariable",
    label: translate2("Element Variable"),
    modelProperty: "elementVariable",
    get: function(element2, node2) {
      return {
        elementVariable: getElementVariable(element2)
      };
    },
    set: function(element2, values2) {
      var loopCharacteristics = getLoopCharacteristics$1(element2);
      return cmdHelper$r.updateBusinessObject(element2, loopCharacteristics, {
        "camunda:elementVariable": values2.elementVariable || void 0
      });
    }
  }));
  entries.push(entryFactory$m.textField(translate2, {
    id: "multiInstance-completionCondition",
    label: translate2("Completion Condition"),
    modelProperty: "completionCondition",
    get: function(element2) {
      return {
        completionCondition: getCompletionConditionValue(element2)
      };
    },
    set: function(element2, values2) {
      return updateFormalExpression(element2, "completionCondition", values2.completionCondition, bpmnFactory);
    }
  }));
  return entries;
};
var is$p = require$$2$2.is;
var entryFactory$l = EntryFactory_1;
var asyncCapableHelper$1 = AsyncCapableHelper;
var elementHelper$f = ElementHelper_1, eventDefinitionHelper$4 = EventDefinitionHelper_1, cmdHelper$q = CmdHelper_1;
function isAsyncBefore(bo) {
  return asyncCapableHelper$1.isAsyncBefore(bo);
}
function isAsyncAfter(bo) {
  return asyncCapableHelper$1.isAsyncAfter(bo);
}
function getFailedJobRetryTimeCycle(bo) {
  return asyncCapableHelper$1.getFailedJobRetryTimeCycle(bo);
}
function removeFailedJobRetryTimeCycle(bo, element) {
  return asyncCapableHelper$1.removeFailedJobRetryTimeCycle(bo, element);
}
function createExtensionElements(parent2, bpmnFactory) {
  return elementHelper$f.createElement("bpmn:ExtensionElements", { values: [] }, parent2, bpmnFactory);
}
function createFailedJobRetryTimeCycle(parent2, bpmnFactory, cycle) {
  return elementHelper$f.createElement("camunda:FailedJobRetryTimeCycle", { body: cycle }, parent2, bpmnFactory);
}
var JobRetryTimeCycle = function(element, bpmnFactory, options, translate2) {
  var getBusinessObject2 = options.getBusinessObject;
  var idPrefix = options.idPrefix || "", labelPrefix = options.labelPrefix || "";
  var retryTimeCycleEntry = entryFactory$l.textField(translate2, {
    id: idPrefix + "retryTimeCycle",
    label: labelPrefix + translate2("Retry Time Cycle"),
    modelProperty: "cycle",
    get: function(element2, node2) {
      var retryTimeCycle = getFailedJobRetryTimeCycle(getBusinessObject2(element2));
      var value = retryTimeCycle && retryTimeCycle.get("body");
      return {
        cycle: value
      };
    },
    set: function(element2, values2, node2) {
      var newCycle = values2.cycle;
      var bo = getBusinessObject2(element2);
      if (newCycle === "" || typeof newCycle === "undefined") {
        return removeFailedJobRetryTimeCycle(bo, element2);
      }
      var retryTimeCycle = getFailedJobRetryTimeCycle(bo);
      if (!retryTimeCycle) {
        var commands = [];
        var extensionElements2 = bo.get("extensionElements");
        if (!extensionElements2) {
          extensionElements2 = createExtensionElements(bo, bpmnFactory);
          commands.push(cmdHelper$q.updateBusinessObject(element2, bo, { extensionElements: extensionElements2 }));
        }
        retryTimeCycle = createFailedJobRetryTimeCycle(extensionElements2, bpmnFactory, newCycle);
        commands.push(cmdHelper$q.addAndRemoveElementsFromList(element2, extensionElements2, "values", "extensionElements", [retryTimeCycle], []));
        return commands;
      }
      return cmdHelper$q.updateBusinessObject(element2, retryTimeCycle, { body: newCycle });
    },
    hidden: function(element2) {
      var bo = getBusinessObject2(element2);
      if (bo && (isAsyncBefore(bo) || isAsyncAfter(bo))) {
        return false;
      }
      if (is$p(element2, "bpmn:Event")) {
        return !eventDefinitionHelper$4.getTimerEventDefinition(element2);
      }
      return true;
    }
  });
  return [retryTimeCycleEntry];
};
var getBusinessObject$w = require$$2$2.getBusinessObject, is$o = require$$2$2.is;
var multiInstanceLoopCharacteristics = MultiInstanceLoopCharacteristics;
var jobRetryTimeCycle$1 = JobRetryTimeCycle, asyncContinuation = AsyncContinuation;
function getLoopCharacteristics(element) {
  var bo = getBusinessObject$w(element);
  return bo.loopCharacteristics;
}
function ensureMultiInstanceSupported(element) {
  var loopCharacteristics = getLoopCharacteristics(element);
  return !!loopCharacteristics && is$o(loopCharacteristics, "camunda:Collectable");
}
var MultiInstanceLoopProps = function(group, element, bpmnFactory, translate2) {
  if (!ensureMultiInstanceSupported(element)) {
    return;
  }
  group.entries = group.entries.concat(multiInstanceLoopCharacteristics(element, bpmnFactory, translate2));
  group.entries = group.entries.concat(asyncContinuation(element, bpmnFactory, {
    getBusinessObject: getLoopCharacteristics,
    idPrefix: "multiInstance-",
    labelPrefix: translate2("Multi Instance ")
  }, translate2));
  group.entries = group.entries.concat(jobRetryTimeCycle$1(element, bpmnFactory, {
    getBusinessObject: getLoopCharacteristics,
    idPrefix: "multiInstance-",
    labelPrefix: translate2("Multi Instance ")
  }, translate2));
};
var domQuery$b = require$$6.query, escapeHTML$6 = Utils.escapeHTML, utils$9 = Utils;
function getScriptType(node2, idPrefix) {
  var selector2;
  if (idPrefix && idPrefix != "") {
    selector2 = 'select[id="' + idPrefix + 'cam-script-type"]';
  } else {
    selector2 = 'select[name="scriptType"]';
  }
  return utils$9.selectedType(selector2, node2.parentElement);
}
var Script = function(scriptLanguagePropName, scriptValuePropName, isFormatRequired, translate2, options) {
  var idPrefix = options && options.idPrefix || "";
  return {
    template: '<div class="bpp-row bpp-textfield"><label for="' + idPrefix + 'cam-script-format">' + escapeHTML$6(translate2("Script Format")) + '</label><div class="bpp-field-wrapper"><input id="' + idPrefix + 'cam-script-format" type="text" name="scriptFormat" /><button class="action-button clear" data-action="script.clearScriptFormat" data-show="script.canClearScriptFormat"><span>X</span></button></div></div><div class="bpp-row"><label for="' + idPrefix + 'cam-script-type">' + escapeHTML$6(translate2("Script Type")) + '</label><div class="bpp-field-wrapper"><select id="' + idPrefix + 'cam-script-type" name="scriptType" data-value><option value="script" selected>' + escapeHTML$6(translate2("Inline Script")) + '</option><option value="scriptResource">' + escapeHTML$6(translate2("External Resource")) + '</option></select></div></div><div class="bpp-row bpp-textfield"><label for="' + idPrefix + 'cam-script-resource-val" data-show="script.isScriptResource">' + escapeHTML$6(translate2("Resource")) + '</label><div class="bpp-field-wrapper" data-show="script.isScriptResource"><input id="' + idPrefix + 'cam-script-resource-val" type="text" name="scriptResourceValue" /><button class="action-button clear" data-action="script.clearScriptResource" data-show="script.canClearScriptResource"><span>X</span></button></div></div><div class="bpp-row"><label for="' + idPrefix + 'cam-script-val" data-show="script.isScript">' + escapeHTML$6(translate2("Script")) + '</label><div class="bpp-field-wrapper" data-show="script.isScript"><textarea id="' + idPrefix + 'cam-script-val" type="text" name="scriptValue"></textarea></div></div>',
    get: function(element, bo) {
      var values2 = {};
      var boScriptResource = bo.get("camunda:resource"), boScript = bo.get(scriptValuePropName), boScriptFormat = bo.get(scriptLanguagePropName);
      if (typeof boScriptResource !== "undefined") {
        values2.scriptResourceValue = boScriptResource;
        values2.scriptType = "scriptResource";
      } else {
        values2.scriptValue = boScript;
        values2.scriptType = "script";
      }
      values2.scriptFormat = boScriptFormat;
      return values2;
    },
    set: function(element, values2, containerElement) {
      var scriptFormat = values2.scriptFormat, scriptType = values2.scriptType, scriptResourceValue = values2.scriptResourceValue, scriptValue = values2.scriptValue;
      var update2 = {
        "camunda:resource": void 0
      };
      update2[scriptValuePropName] = void 0;
      update2[scriptLanguagePropName] = void 0;
      if (isFormatRequired) {
        update2[scriptLanguagePropName] = scriptFormat || "";
      } else if (scriptFormat !== "") {
        update2[scriptLanguagePropName] = scriptFormat;
      }
      if (scriptType === "scriptResource") {
        update2["camunda:resource"] = scriptResourceValue || "";
      } else {
        update2[scriptValuePropName] = scriptValue || "";
      }
      return update2;
    },
    validate: function(element, values2) {
      var validationResult = {};
      if (values2.scriptType === "script" && !values2.scriptValue) {
        validationResult.scriptValue = translate2("Must provide a value");
      }
      if (values2.scriptType === "scriptResource" && !values2.scriptResourceValue) {
        validationResult.scriptResourceValue = translate2("Must provide a value");
      }
      if (isFormatRequired && (!values2.scriptFormat || values2.scriptFormat.length === 0)) {
        validationResult.scriptFormat = translate2("Must provide a value");
      }
      return validationResult;
    },
    clearScriptFormat: function(element, inputNode, btnNode, scopeNode) {
      domQuery$b("input[name=scriptFormat]", scopeNode).value = "";
      return true;
    },
    canClearScriptFormat: function(element, inputNode, btnNode, scopeNode) {
      var input = domQuery$b("input[name=scriptFormat]", scopeNode);
      return input.value !== "";
    },
    clearScriptResource: function(element, inputNode, btnNode, scopeNode) {
      domQuery$b("input[name=scriptResourceValue]", scopeNode).value = "";
      return true;
    },
    canClearScriptResource: function(element, inputNode, btnNode, scopeNode) {
      var input = domQuery$b("input[name=scriptResourceValue]", scopeNode);
      return input.value !== "";
    },
    clearScript: function(element, inputNode, btnNode, scopeNode) {
      domQuery$b("textarea[name=scriptValue]", scopeNode).value = "";
      return true;
    },
    canClearScript: function(element, inputNode, btnNode, scopeNode) {
      var input = domQuery$b("textarea[name=scriptValue]", scopeNode);
      return input.value !== "";
    },
    isScriptResource: function(element, inputNode, btnNode, scopeNode) {
      var scriptType = getScriptType(scopeNode, idPrefix);
      return scriptType === "scriptResource";
    },
    isScript: function(element, inputNode, btnNode, scopeNode) {
      var scriptType = getScriptType(scopeNode, idPrefix);
      return scriptType === "script";
    }
  };
};
var is$n = require$$2$2.is, isAny$6 = require$$1$2.isAny, getBusinessObject$v = require$$2$2.getBusinessObject, escapeHTML$5 = Utils.escapeHTML, domQuery$a = require$$6.query, cmdHelper$p = CmdHelper_1, elementHelper$e = ElementHelper_1, eventDefinitionHelper$3 = EventDefinitionHelper_1, scriptImplementation$3 = Script;
var ConditionalProps = function(group, element, bpmnFactory, translate2) {
  var bo = getBusinessObject$v(element);
  if (!bo) {
    return;
  }
  var conditionalEventDefinition = eventDefinitionHelper$3.getConditionalEventDefinition(element);
  if (!(is$n(element, "bpmn:SequenceFlow") && isConditionalSource(element.source)) && !conditionalEventDefinition) {
    return;
  }
  var script = scriptImplementation$3("language", "body", true, translate2);
  group.entries.push({
    id: "condition",
    label: translate2("Condition"),
    html: '<div class="bpp-row"><label for="cam-condition-type">' + escapeHTML$5(translate2("Condition Type")) + '</label><div class="bpp-field-wrapper"><select id="cam-condition-type" name="conditionType" data-value><option value="expression">' + escapeHTML$5(translate2("Expression")) + '</option><option value="script">' + escapeHTML$5(translate2("Script")) + '</option><option value="" selected></option></select></div></div><div class="bpp-row"><label for="cam-condition" data-show="isExpression">' + escapeHTML$5(translate2("Expression")) + '</label><div class="bpp-field-wrapper" data-show="isExpression"><input id="cam-condition" type="text" name="condition" /><button class="action-button clear" data-action="clear" data-show="canClear"><span>X</span></button></div><div data-show="isScript">' + script.template + "</div></div>",
    get: function(element2, propertyName) {
      var conditionalEventDefinition2 = eventDefinitionHelper$3.getConditionalEventDefinition(element2);
      var conditionExpression = conditionalEventDefinition2 ? conditionalEventDefinition2.condition : bo.conditionExpression;
      var values2 = {}, conditionType = "";
      if (conditionExpression) {
        var conditionLanguage = conditionExpression.language;
        if (typeof conditionLanguage !== "undefined") {
          conditionType = "script";
          values2 = script.get(element2, conditionExpression);
        } else {
          conditionType = "expression";
          values2.condition = conditionExpression.get("body");
        }
      }
      values2.conditionType = conditionType;
      return values2;
    },
    set: function(element2, values2, containerElement) {
      var conditionType = values2.conditionType;
      var commands = [];
      var conditionProps = {
        body: void 0
      };
      if (conditionType === "script") {
        conditionProps = script.set(element2, values2, containerElement);
      } else {
        var condition2 = values2.condition;
        conditionProps.body = condition2;
      }
      var conditionOrConditionExpression;
      if (conditionType) {
        conditionOrConditionExpression = elementHelper$e.createElement("bpmn:FormalExpression", conditionProps, conditionalEventDefinition || bo, bpmnFactory);
        var source = element2.source;
        if (source && source.businessObject.default === bo) {
          commands.push(cmdHelper$p.updateProperties(source, { "default": void 0 }));
        }
      }
      var update2 = conditionalEventDefinition ? { condition: conditionOrConditionExpression } : { conditionExpression: conditionOrConditionExpression };
      commands.push(cmdHelper$p.updateBusinessObject(element2, conditionalEventDefinition || bo, update2));
      return commands;
    },
    validate: function(element2, values2) {
      var validationResult = {};
      if (!values2.condition && values2.conditionType === "expression") {
        validationResult.condition = translate2("Must provide a value");
      } else if (values2.conditionType === "script") {
        validationResult = script.validate(element2, values2);
      }
      return validationResult;
    },
    isExpression: function(element2, inputNode) {
      var conditionType = domQuery$a("select[name=conditionType]", inputNode);
      if (conditionType.selectedIndex >= 0) {
        return conditionType.options[conditionType.selectedIndex].value === "expression";
      }
    },
    isScript: function(element2, inputNode) {
      var conditionType = domQuery$a("select[name=conditionType]", inputNode);
      if (conditionType.selectedIndex >= 0) {
        return conditionType.options[conditionType.selectedIndex].value === "script";
      }
    },
    clear: function(element2, inputNode) {
      domQuery$a("input[name=condition]", inputNode).value = "";
      return true;
    },
    canClear: function(element2, inputNode) {
      var input = domQuery$a("input[name=condition]", inputNode);
      return input.value !== "";
    },
    script,
    cssClasses: ["bpp-textfield"]
  });
};
var CONDITIONAL_SOURCES = [
  "bpmn:Activity",
  "bpmn:ExclusiveGateway",
  "bpmn:InclusiveGateway",
  "bpmn:ComplexGateway"
];
function isConditionalSource(element) {
  return isAny$6(element, CONDITIONAL_SOURCES);
}
var getBusinessObject$u = require$$2$2.getBusinessObject, is$m = require$$2$2.is, entryFactory$k = EntryFactory_1, cmdHelper$o = CmdHelper_1, scriptImplementation$2 = Script;
var ScriptTaskProps = function(group, element, bpmnFactory, translate2) {
  var bo;
  if (is$m(element, "bpmn:ScriptTask")) {
    bo = getBusinessObject$u(element);
  }
  if (!bo) {
    return;
  }
  var script = scriptImplementation$2("scriptFormat", "script", false, translate2);
  group.entries.push({
    id: "script-implementation",
    label: translate2("Script"),
    html: script.template,
    get: function(element2) {
      return script.get(element2, bo);
    },
    set: function(element2, values2, containerElement) {
      var properties2 = script.set(element2, values2, containerElement);
      return cmdHelper$o.updateProperties(element2, properties2);
    },
    validate: function(element2, values2) {
      return script.validate(element2, values2);
    },
    script,
    cssClasses: ["bpp-textfield"]
  });
  group.entries.push(entryFactory$k.textField(translate2, {
    id: "scriptResultVariable",
    label: translate2("Result Variable"),
    modelProperty: "scriptResultVariable",
    get: function(element2, propertyName) {
      var boResultVariable = bo.get("camunda:resultVariable");
      return { scriptResultVariable: boResultVariable };
    },
    set: function(element2, values2, containerElement) {
      return cmdHelper$o.updateProperties(element2, {
        "camunda:resultVariable": values2.scriptResultVariable.length ? values2.scriptResultVariable : void 0
      });
    }
  }));
};
var entryFactory$j = EntryFactory_1, cmdHelper$n = CmdHelper_1, elementReferenceProperty$1 = ElementReferenceProperty, utils$8 = Utils;
var ErrorEventDefinition = function(group, element, bpmnFactory, errorEventDefinition, showErrorCodeVariable, showErrorMessageVariable, translate2) {
  var getValue2 = function(modelProperty) {
    return function(element2) {
      var modelPropertyValue = errorEventDefinition.get("camunda:" + modelProperty);
      return modelPropertyValue;
    };
  };
  var setValue = function(modelProperty) {
    return function(element2, values2) {
      if (values2[modelProperty] === "")
        values2[modelProperty] = void 0;
      return cmdHelper$n.updateBusinessObject(element2, errorEventDefinition, values2);
    };
  };
  group.entries = group.entries.concat(elementReferenceProperty$1(element, errorEventDefinition, bpmnFactory, translate2, {
    id: "error-element-message",
    label: translate2("Message"),
    referenceProperty: "errorRef",
    modelProperty: "errorMessage"
  }));
  if (showErrorCodeVariable) {
    group.entries.push(entryFactory$j.validationAwareTextField(translate2, {
      id: "errorCodeVariable",
      label: translate2("Code Variable"),
      modelProperty: "errorCodeVariable",
      description: translate2("Define the name of the variable that will contain the error code"),
      getProperty: getValue2("errorCodeVariable"),
      setProperty: setValue("errorCodeVariable"),
      validate: function(element2, values2) {
        var validation = {}, targetValue = values2.errorCodeVariable;
        if (utils$8.containsSpace(targetValue)) {
          validation.errorCodeVariable = translate2("Error code variable must not contain spaces.");
        }
        return validation;
      }
    }));
  }
  if (showErrorMessageVariable) {
    group.entries.push(entryFactory$j.validationAwareTextField(translate2, {
      id: "errorMessageVariable",
      label: translate2("Message Variable"),
      modelProperty: "errorMessageVariable",
      getProperty: getValue2("errorMessageVariable"),
      setProperty: setValue("errorMessageVariable"),
      description: translate2("Define the name of the variable that will contain the error message"),
      validate: function(element2, values2) {
        var validation = {}, targetValue = values2.errorMessageVariable;
        if (utils$8.containsSpace(targetValue)) {
          validation.errorMessageVariable = translate2("Error message variable must not contain spaces.");
        }
        return validation;
      }
    }));
  }
};
var is$l = require$$2$2.is, eventDefinitionHelper$2 = EventDefinitionHelper_1, error = ErrorEventDefinition;
var forEach$6 = forEach_1;
var ErrorEventProps = function(group, element, bpmnFactory, translate2) {
  var errorEvents = [
    "bpmn:StartEvent",
    "bpmn:BoundaryEvent",
    "bpmn:EndEvent"
  ];
  forEach$6(errorEvents, function(event) {
    if (is$l(element, event)) {
      var errorEventDefinition = eventDefinitionHelper$2.getErrorEventDefinition(element);
      if (errorEventDefinition) {
        var isCatchingErrorEvent = is$l(element, "bpmn:StartEvent") || is$l(element, "bpmn:BoundaryEvent");
        var showErrorCodeVariable = isCatchingErrorEvent, showErrorMessageVariable = isCatchingErrorEvent;
        error(group, element, bpmnFactory, errorEventDefinition, showErrorCodeVariable, showErrorMessageVariable, translate2);
      }
    }
  });
};
var getBusinessObject$t = require$$2$2.getBusinessObject;
var domQuery$9 = require$$6.query, domClosest = require$$6.closest, domify$3 = require$$6.domify, forEach$5 = forEach_1;
var elementHelper$d = ElementHelper_1, cmdHelper$m = CmdHelper_1, utils$7 = Utils, escapeHTML$4 = utils$7.escapeHTML;
function getSelectBox(node2, id2) {
  var currentTab = domClosest(node2, "div.bpp-properties-tab");
  var query2 = "select[name=selectedExtensionElement]" + (id2 ? "[id=cam-extensionElements-" + id2 + "]" : "");
  return domQuery$9(query2, currentTab);
}
function getSelected(node2, id2) {
  var selectBox = getSelectBox(node2, id2);
  return {
    value: (selectBox || {}).value,
    idx: (selectBox || {}).selectedIndex
  };
}
function generateElementId$2(prefix2) {
  prefix2 = prefix2 + "_";
  return utils$7.nextId(prefix2);
}
var CREATE_EXTENSION_ELEMENT_ACTION = "create-extension-element", REMOVE_EXTENSION_ELEMENT_ACTION = "remove-extension-element";
var ExtensionElements = function(element, bpmnFactory, options, translate2) {
  var id2 = options.id, prefix2 = options.prefix || "elem", label2 = options.label || id2, idGeneration = options.idGeneration === false ? options.idGeneration : true, businessObject = options.businessObject || getBusinessObject$t(element);
  var modelProperty = options.modelProperty || "id";
  var getElements2 = options.getExtensionElements;
  var createElement2 = options.createExtensionElement, canCreate2 = typeof createElement2 === "function";
  var removeElement2 = options.removeExtensionElement, canRemove = typeof removeElement2 === "function";
  var onSelectionChange = options.onSelectionChange;
  var hideElements = options.hideExtensionElements, canBeHidden = typeof hideElements === "function";
  var setOptionLabelValue = options.setOptionLabelValue;
  var defaultSize = options.size || 5, resizable = options.resizable;
  var reference = options.reference || void 0;
  var selectionChanged = function(element2, node2, event, scope) {
    if (typeof onSelectionChange === "function") {
      return onSelectionChange(element2, node2, event, scope);
    }
  };
  var createOption2 = function(value) {
    return '<option value="' + escapeHTML$4(value) + '" data-value data-name="extensionElementValue">' + escapeHTML$4(value) + "</option>";
  };
  var initSelectionSize = function(selectBox, optionsLength) {
    if (resizable) {
      selectBox.size = optionsLength > defaultSize ? optionsLength : defaultSize;
    }
  };
  return {
    id: id2,
    html: '<div class="bpp-row bpp-element-list" ' + (canBeHidden ? 'data-show="hideElements"' : "") + '><label for="cam-extensionElements-' + escapeHTML$4(id2) + '">' + escapeHTML$4(label2) + '</label><div class="bpp-field-wrapper"><select id="cam-extensionElements-' + escapeHTML$4(id2) + '"name="selectedExtensionElement" size="' + escapeHTML$4(defaultSize) + '" data-list-entry-container data-on-change="selectElement"></select>' + (canCreate2 ? '<button class="action-button add" id="cam-extensionElements-create-' + escapeHTML$4(id2) + '" data-action="createElement"><span>+</span></button>' : "") + (canRemove ? '<button class="action-button clear" id="cam-extensionElements-remove-' + escapeHTML$4(id2) + '" data-action="removeElement" data-disable="disableRemove"><span>-</span></button>' : "") + "</div></div>",
    get: function(element2, node2) {
      var elements = getElements2(element2, node2);
      var result = [];
      forEach$5(elements, function(elem) {
        result.push({
          extensionElementValue: elem.get(modelProperty)
        });
      });
      var selectBox = getSelectBox(node2.parentNode, id2);
      initSelectionSize(selectBox, result.length);
      return result;
    },
    set: function(element2, values2, node2) {
      var action = this.__action;
      delete this.__action;
      businessObject = businessObject || getBusinessObject$t(element2);
      var bo = reference && businessObject.get(reference) ? businessObject.get(reference) : businessObject;
      var extensionElements2 = bo.get("extensionElements");
      if (action.id === CREATE_EXTENSION_ELEMENT_ACTION) {
        var commands = [];
        if (!extensionElements2) {
          extensionElements2 = elementHelper$d.createElement("bpmn:ExtensionElements", { values: [] }, bo, bpmnFactory);
          commands.push(cmdHelper$m.updateBusinessObject(element2, bo, { extensionElements: extensionElements2 }));
        }
        commands.push(createElement2(element2, extensionElements2, action.value, node2));
        return commands;
      } else if (action.id === REMOVE_EXTENSION_ELEMENT_ACTION) {
        return removeElement2(element2, extensionElements2, action.value, action.idx, node2);
      }
    },
    createListEntryTemplate: function(value, index2, selectBox) {
      initSelectionSize(selectBox, selectBox.options.length + 1);
      return createOption2(value.extensionElementValue);
    },
    deselect: function(element2, node2) {
      var selectBox = getSelectBox(node2, id2);
      selectBox.selectedIndex = -1;
    },
    getSelected: function(element2, node2) {
      return getSelected(node2, id2);
    },
    setControlValue: function(element2, node2, option2, property2, value, idx) {
      node2.value = value;
      if (!setOptionLabelValue) {
        node2.text = value;
      } else {
        setOptionLabelValue(element2, node2, option2, property2, value, idx);
      }
    },
    createElement: function(element2, node2) {
      var generatedId;
      if (idGeneration) {
        generatedId = generateElementId$2(prefix2);
      }
      var selectBox = getSelectBox(node2, id2);
      var template2 = domify$3(createOption2(generatedId));
      selectBox.appendChild(template2);
      selectBox.lastChild.selected = "selected";
      selectionChanged(element2, node2);
      initSelectionSize(selectBox, selectBox.options.length);
      this.__action = {
        id: CREATE_EXTENSION_ELEMENT_ACTION,
        value: generatedId
      };
      return true;
    },
    removeElement: function(element2, node2) {
      var selection = getSelected(node2, id2);
      var selectBox = getSelectBox(node2, id2);
      selectBox.removeChild(selectBox.options[selection.idx]);
      initSelectionSize(selectBox, selectBox.options.length);
      this.__action = {
        id: REMOVE_EXTENSION_ELEMENT_ACTION,
        value: selection.value,
        idx: selection.idx
      };
      return true;
    },
    hideElements: function(element2, entryNode, node2, scopeNode) {
      return !hideElements(element2, entryNode, node2, scopeNode);
    },
    disableRemove: function(element2, entryNode, node2, scopeNode) {
      return (getSelected(entryNode, id2) || {}).idx < 0;
    },
    selectElement: selectionChanged
  };
};
var getBusinessObject$s = require$$2$2.getBusinessObject, is$k = require$$2$2.is;
var factory$1 = EntryFactory_1;
var elementHelper$c = ElementHelper_1, extensionElementsHelper$6 = ExtensionElementsHelper_1, cmdHelper$l = CmdHelper_1, utils$6 = Utils;
var assign$4 = assign_1, forEach$4 = forEach_1, find$4 = find_1;
function generatePropertyId() {
  return utils$6.nextId("Property_");
}
function getPropertyValues(parent2) {
  var properties2 = parent2 && getPropertiesElement(parent2);
  if (properties2 && properties2.values) {
    return properties2.values;
  }
  return [];
}
function getPropertiesElement(element) {
  if (!isExtensionElements(element)) {
    return element.properties;
  } else {
    return getPropertiesElementInsideExtensionElements(element);
  }
}
function getPropertiesElementInsideExtensionElements(extensionElements2) {
  return find$4(extensionElements2.values, function(elem) {
    return is$k(elem, "camunda:Properties");
  });
}
function isExtensionElements(element) {
  return is$k(element, "bpmn:ExtensionElements");
}
var Properties = function(element, bpmnFactory, options, translate2) {
  var getParent2 = options.getParent;
  var modelProperties = options.modelProperties, createParent = options.createParent;
  var bo = getBusinessObject$s(element);
  if (is$k(element, "bpmn:Participant")) {
    bo = bo.get("processRef");
  }
  if (!bo) {
    return;
  }
  assign$4(options, {
    addLabel: translate2("Add Property"),
    getElements: function(element2, node2) {
      var parent2 = getParent2(element2, node2, bo);
      return getPropertyValues(parent2);
    },
    addElement: function(element2, node2) {
      var commands = [], parent2 = getParent2(element2, node2, bo);
      if (!parent2 && typeof createParent === "function") {
        var result = createParent(element2, bo);
        parent2 = result.parent;
        commands.push(result.cmd);
      }
      var properties2 = getPropertiesElement(parent2);
      if (!properties2) {
        properties2 = elementHelper$c.createElement("camunda:Properties", {}, parent2, bpmnFactory);
        if (!isExtensionElements(parent2)) {
          commands.push(cmdHelper$l.updateBusinessObject(element2, parent2, { "properties": properties2 }));
        } else {
          commands.push(cmdHelper$l.addAndRemoveElementsFromList(element2, parent2, "values", "extensionElements", [properties2], []));
        }
      }
      var propertyProps = {};
      forEach$4(modelProperties, function(prop) {
        propertyProps[prop] = void 0;
      });
      if (modelProperties.indexOf("id") >= 0) {
        propertyProps.id = generatePropertyId();
      }
      var property2 = elementHelper$c.createElement("camunda:Property", propertyProps, properties2, bpmnFactory);
      commands.push(cmdHelper$l.addElementsTolist(element2, properties2, "values", [property2]));
      return commands;
    },
    updateElement: function(element2, value, node2, idx) {
      var parent2 = getParent2(element2, node2, bo), property2 = getPropertyValues(parent2)[idx];
      forEach$4(modelProperties, function(prop) {
        value[prop] = value[prop] || void 0;
      });
      return cmdHelper$l.updateBusinessObject(element2, property2, value);
    },
    validate: function(element2, value, node2, idx) {
      if (modelProperties.indexOf("id") >= 0) {
        var parent2 = getParent2(element2, node2, bo), properties2 = getPropertyValues(parent2), property2 = properties2[idx];
        if (property2) {
          var validationError = utils$6.isIdValid(property2, value.id, translate2);
          if (validationError) {
            return { id: validationError };
          }
        }
      }
    },
    removeElement: function(element2, node2, idx) {
      var commands = [], parent2 = getParent2(element2, node2, bo), properties2 = getPropertiesElement(parent2), propertyValues = getPropertyValues(parent2), currentProperty = propertyValues[idx];
      commands.push(cmdHelper$l.removeElementsFromList(element2, properties2, "values", null, [currentProperty]));
      if (propertyValues.length === 1) {
        if (!isExtensionElements(parent2)) {
          commands.push(cmdHelper$l.updateBusinessObject(element2, parent2, { properties: void 0 }));
        } else {
          forEach$4(parent2.values, function(value) {
            if (is$k(value, "camunda:Properties")) {
              commands.push(extensionElementsHelper$6.removeEntry(bo, element2, value));
            }
          });
        }
      }
      return commands;
    }
  });
  return factory$1.table(translate2, options);
};
var getBusinessObject$r = require$$2$2.getBusinessObject, getExtensionElements$2 = ExtensionElementsHelper_1.getExtensionElements;
var FormHelper = {};
var FormHelper_1 = FormHelper;
FormHelper.getFormData = function(element) {
  var bo = getBusinessObject$r(element);
  var formData = getExtensionElements$2(bo, "camunda:FormData");
  return formData[0];
};
FormHelper.getFormFields = function(element) {
  var formData = this.getFormData(element);
  if (typeof formData === "undefined") {
    return [];
  }
  return formData.fields || [];
};
FormHelper.getFormField = function(element, idx) {
  var formFields = this.getFormFields(element);
  return formFields[idx];
};
FormHelper.getConstraints = function(formField) {
  if (formField && formField.validation && formField.validation.constraints) {
    return formField.validation.constraints;
  }
  return [];
};
FormHelper.getEnumValues = function(formField) {
  if (formField && formField.values) {
    return formField.values;
  }
  return [];
};
var getBusinessObject$q = require$$2$2.getBusinessObject, getExtensionElements$1 = ExtensionElementsHelper_1.getExtensionElements, removeEntry$2 = ExtensionElementsHelper_1.removeEntry, extensionElements = ExtensionElements, properties$2 = Properties, entryFactory$i = EntryFactory_1, elementHelper$b = ElementHelper_1, cmdHelper$k = CmdHelper_1, formHelper = FormHelper_1, utils$5 = Utils, is$j = require$$2$2.is, find$3 = find_1, each = forEach_1, isUndefined$3 = isUndefined_1;
function generateValueId() {
  return utils$5.nextId("Value_");
}
function formFieldTextField(translate2, options, getSelectedFormField) {
  var id2 = options.id, label2 = options.label, modelProperty = options.modelProperty, validate2 = options.validate;
  return entryFactory$i.textField(translate2, {
    id: id2,
    label: label2,
    modelProperty,
    get: function(element, node2) {
      var selectedFormField = getSelectedFormField(element, node2) || {}, values2 = {};
      values2[modelProperty] = selectedFormField[modelProperty];
      return values2;
    },
    set: function(element, values2, node2) {
      var commands = [];
      if (typeof options.set === "function") {
        var cmd2 = options.set(element, values2, node2);
        if (cmd2) {
          commands.push(cmd2);
        }
      }
      var formField = getSelectedFormField(element, node2), properties2 = {};
      properties2[modelProperty] = values2[modelProperty] || void 0;
      commands.push(cmdHelper$k.updateBusinessObject(element, formField, properties2));
      return commands;
    },
    hidden: function(element, node2) {
      return !getSelectedFormField(element, node2);
    },
    validate: validate2
  });
}
var FormProps = function(group, element, bpmnFactory, translate2) {
  if (!isFormSupported(element)) {
    return;
  }
  function getSelectedFormField(element2, node2) {
    var selected = formFieldsEntry.getSelected(element2, node2.parentNode);
    if (selected.idx === -1) {
      return;
    }
    return formHelper.getFormField(element2, selected.idx);
  }
  group.entries.push(entryFactory$i.selectBox(translate2, {
    id: "form-type",
    label: translate2("Type"),
    selectOptions: [
      { value: "", name: translate2("<none>") },
      { value: "formKey", name: translate2("Embedded or External Task Forms") },
      { value: "formRef", name: translate2("Camunda Forms") }
    ],
    modelProperty: "formType",
    get: function(element2, node2) {
      var businessObject = getBusinessObject$q(element2);
      var values2 = {
        formType: ""
      };
      if (!isUndefined$3(businessObject.get("camunda:formKey"))) {
        values2.formType = "formKey";
      } else if (!isUndefined$3(businessObject.get("camunda:formRef"))) {
        values2.formType = "formRef";
      }
      return values2;
    },
    set: function(element2, values2, node2) {
      var properties2 = {};
      var value = values2.formType;
      if (value === "formKey") {
        properties2 = {
          "camunda:formKey": ""
        };
      } else if (value === "formRef") {
        properties2 = {
          "camunda:formRef": ""
        };
      } else {
        properties2 = {
          "camunda:formRef": void 0,
          "camunda:formRefBinding": void 0,
          "camunda:formRefVersion": void 0,
          "camunda:formKey": void 0
        };
      }
      var businessObject = getBusinessObject$q(element2);
      return [cmdHelper$k.updateBusinessObject(element2, businessObject, properties2)];
    }
  }));
  group.entries.push(entryFactory$i.textField(translate2, {
    id: "form-key",
    label: translate2("Form Key"),
    modelProperty: "formKey",
    get: function(element2, node2) {
      var bo = getBusinessObject$q(element2);
      return {
        formKey: bo.get("camunda:formKey")
      };
    },
    set: function(element2, values2, node2) {
      var bo = getBusinessObject$q(element2), formKey = values2.formKey;
      return cmdHelper$k.updateBusinessObject(element2, bo, { "camunda:formKey": formKey });
    },
    hidden: function(element2, node2) {
      var formType = getFormType(element2);
      return formType !== "formKey";
    }
  }));
  group.entries.push(entryFactory$i.textField(translate2, {
    id: "form-ref",
    label: translate2("Form Ref"),
    modelProperty: "formRef",
    get: function(element2, node2) {
      var businessObject = getBusinessObject$q(element2);
      return {
        formRef: businessObject.get("camunda:formRef")
      };
    },
    set: function(element2, values2, node2) {
      var businessObject = getBusinessObject$q(element2), formRef = values2.formRef;
      return cmdHelper$k.updateBusinessObject(element2, businessObject, { "camunda:formRef": formRef });
    },
    hidden: function(element2, node2) {
      var formType = getFormType(element2);
      return formType !== "formRef";
    }
  }));
  group.entries.push(entryFactory$i.selectBox(translate2, {
    id: "form-ref-binding",
    label: translate2("Binding"),
    selectOptions: [
      { value: "deployment", name: translate2("deployment") },
      { value: "latest", name: translate2("latest") },
      { value: "version", name: translate2("version") }
    ],
    modelProperty: "formRefBinding",
    get: function(element2, node2) {
      return {
        formRefBinding: getFormRefBinding(element2)
      };
    },
    set: function(element2, values2, node2) {
      var value = values2.formRefBinding;
      var properties2 = {
        "camunda:formRefBinding": value
      };
      var businessObject = getBusinessObject$q(element2);
      return [cmdHelper$k.updateBusinessObject(element2, businessObject, properties2)];
    },
    hidden: function(element2, node2) {
      var formType = getFormType(element2);
      return formType !== "formRef";
    }
  }));
  group.entries.push(entryFactory$i.textField(translate2, {
    id: "form-ref-version",
    label: translate2("Version"),
    modelProperty: "formRefVersion",
    get: function(element2, node2) {
      var businessObject = getBusinessObject$q(element2);
      return {
        formRefVersion: businessObject.get("camunda:formRefVersion")
      };
    },
    set: function(element2, values2, node2) {
      var businessObject = getBusinessObject$q(element2), formRefVersion = values2.formRefVersion || void 0;
      return cmdHelper$k.updateBusinessObject(element2, businessObject, { "camunda:formRefVersion": formRefVersion });
    },
    hidden: function(element2, node2) {
      var bindingType = getFormRefBinding(element2);
      return bindingType !== "version";
    }
  }));
  var formFieldsEntry = extensionElements(element, bpmnFactory, {
    id: "form-fields",
    label: translate2("Form Fields"),
    modelProperty: "id",
    prefix: "FormField",
    createExtensionElement: function(element2, extensionElements2, value) {
      var bo = getBusinessObject$q(element2), commands = [];
      if (!extensionElements2) {
        extensionElements2 = elementHelper$b.createElement("bpmn:ExtensionElements", { values: [] }, bo, bpmnFactory);
        commands.push(cmdHelper$k.updateProperties(element2, { extensionElements: extensionElements2 }));
      }
      var formData = formHelper.getFormData(element2);
      if (!formData) {
        formData = elementHelper$b.createElement("camunda:FormData", { fields: [] }, extensionElements2, bpmnFactory);
        commands.push(cmdHelper$k.addAndRemoveElementsFromList(element2, extensionElements2, "values", "extensionElements", [formData], []));
      }
      var field = elementHelper$b.createElement("camunda:FormField", { id: value }, formData, bpmnFactory);
      if (typeof formData.fields !== "undefined") {
        commands.push(cmdHelper$k.addElementsTolist(element2, formData, "fields", [field]));
      } else {
        commands.push(cmdHelper$k.updateBusinessObject(element2, formData, {
          fields: [field]
        }));
      }
      return commands;
    },
    removeExtensionElement: function(element2, extensionElements2, value, idx) {
      var formData = getExtensionElements$1(getBusinessObject$q(element2), "camunda:FormData")[0], entry = formData.fields[idx], commands = [];
      if (formData.fields.length < 2) {
        commands.push(removeEntry$2(getBusinessObject$q(element2), element2, formData));
      } else {
        commands.push(cmdHelper$k.removeElementsFromList(element2, formData, "fields", null, [entry]));
        if (entry.id === formData.get("businessKey")) {
          commands.push(cmdHelper$k.updateBusinessObject(element2, formData, { "businessKey": void 0 }));
        }
      }
      return commands;
    },
    getExtensionElements: function(element2) {
      return formHelper.getFormFields(element2);
    },
    hideExtensionElements: function(element2, node2) {
      return false;
    }
  });
  group.entries.push(formFieldsEntry);
  var formBusinessKeyFormFieldEntry = entryFactory$i.selectBox(translate2, {
    id: "form-business-key",
    label: translate2("Business Key"),
    modelProperty: "businessKey",
    selectOptions: function(element2, inputNode) {
      var selectOptions = [{ name: "", value: "" }];
      var formFields = formHelper.getFormFields(element2);
      each(formFields, function(field) {
        if (field.type !== "boolean") {
          selectOptions.push({ name: field.id, value: field.id });
        }
      });
      return selectOptions;
    },
    get: function(element2, node2) {
      var result = { businessKey: "" };
      var bo = getBusinessObject$q(element2);
      var formDataExtension = getExtensionElements$1(bo, "camunda:FormData");
      if (formDataExtension.length) {
        var formData = formDataExtension[0];
        var storedValue = formData.get("businessKey");
        result = { businessKey: storedValue };
      }
      return result;
    },
    set: function(element2, values2, node2) {
      var formData = getExtensionElements$1(getBusinessObject$q(element2), "camunda:FormData")[0];
      return cmdHelper$k.updateBusinessObject(element2, formData, { "businessKey": values2.businessKey || void 0 });
    },
    hidden: function(element2, node2) {
      var isStartEvent = is$j(element2, "bpmn:StartEvent");
      return !(isStartEvent && formHelper.getFormFields(element2).length > 0);
    }
  });
  group.entries.push(formBusinessKeyFormFieldEntry);
  group.entries.push(entryFactory$i.label({
    id: "form-field-header",
    labelText: translate2("Form Field"),
    showLabel: function(element2, node2) {
      return !!getSelectedFormField(element2, node2);
    }
  }));
  group.entries.push(entryFactory$i.validationAwareTextField(translate2, {
    id: "form-field-id",
    label: translate2("ID (process variable name)"),
    modelProperty: "id",
    getProperty: function(element2, node2) {
      var selectedFormField = getSelectedFormField(element2, node2) || {};
      return selectedFormField.id;
    },
    setProperty: function(element2, properties2, node2) {
      var formField = getSelectedFormField(element2, node2);
      return cmdHelper$k.updateBusinessObject(element2, formField, properties2);
    },
    hidden: function(element2, node2) {
      return !getSelectedFormField(element2, node2);
    },
    validate: function(element2, values2, node2) {
      var formField = getSelectedFormField(element2, node2);
      if (formField) {
        var idValue = values2.id;
        if (!idValue || idValue.trim() === "") {
          return { id: "Form field id must not be empty" };
        }
        var formFields = formHelper.getFormFields(element2);
        var existingFormField = find$3(formFields, function(f) {
          return f !== formField && f.id === idValue;
        });
        if (existingFormField) {
          return { id: "Form field id already used in form data." };
        }
      }
    }
  }));
  group.entries.push(entryFactory$i.comboBox(translate2, {
    id: "form-field-type",
    label: translate2("Type"),
    selectOptions: [
      { name: "string", value: "string" },
      { name: "long", value: "long" },
      { name: "boolean", value: "boolean" },
      { name: "date", value: "date" },
      { name: "enum", value: "enum" }
    ],
    modelProperty: "type",
    emptyParameter: true,
    get: function(element2, node2) {
      var selectedFormField = getSelectedFormField(element2, node2);
      if (selectedFormField) {
        return { type: selectedFormField.type };
      } else {
        return {};
      }
    },
    set: function(element2, values2, node2) {
      var selectedFormField = getSelectedFormField(element2, node2), formData = getExtensionElements$1(getBusinessObject$q(element2), "camunda:FormData")[0], commands = [];
      if (selectedFormField.type === "enum" && values2.type !== "enum") {
        commands.push(cmdHelper$k.updateBusinessObject(element2, selectedFormField, { values: void 0 }));
      }
      if (values2.type === "boolean" && selectedFormField.get("id") === formData.get("businessKey")) {
        commands.push(cmdHelper$k.updateBusinessObject(element2, formData, { "businessKey": void 0 }));
      }
      commands.push(cmdHelper$k.updateBusinessObject(element2, selectedFormField, values2));
      return commands;
    },
    hidden: function(element2, node2) {
      return !getSelectedFormField(element2, node2);
    }
  }));
  group.entries.push(formFieldTextField(translate2, {
    id: "form-field-label",
    label: translate2("Label"),
    modelProperty: "label"
  }, getSelectedFormField));
  group.entries.push(formFieldTextField(translate2, {
    id: "form-field-defaultValue",
    label: translate2("Default Value"),
    modelProperty: "defaultValue"
  }, getSelectedFormField));
  group.entries.push(entryFactory$i.label({
    id: "form-field-enum-values-header",
    labelText: translate2("Values"),
    divider: true,
    showLabel: function(element2, node2) {
      var selectedFormField = getSelectedFormField(element2, node2);
      return selectedFormField && selectedFormField.type === "enum";
    }
  }));
  group.entries.push(entryFactory$i.table(translate2, {
    id: "form-field-enum-values",
    labels: [translate2("Id"), translate2("Name")],
    modelProperties: ["id", "name"],
    show: function(element2, node2) {
      var selectedFormField = getSelectedFormField(element2, node2);
      return selectedFormField && selectedFormField.type === "enum";
    },
    getElements: function(element2, node2) {
      var selectedFormField = getSelectedFormField(element2, node2);
      return formHelper.getEnumValues(selectedFormField);
    },
    addElement: function(element2, node2) {
      var selectedFormField = getSelectedFormField(element2, node2), id2 = generateValueId();
      var enumValue = elementHelper$b.createElement("camunda:Value", { id: id2, name: void 0 }, getBusinessObject$q(element2), bpmnFactory);
      return cmdHelper$k.addElementsTolist(element2, selectedFormField, "values", [enumValue]);
    },
    removeElement: function(element2, node2, idx) {
      var selectedFormField = getSelectedFormField(element2, node2), enumValue = selectedFormField.values[idx];
      return cmdHelper$k.removeElementsFromList(element2, selectedFormField, "values", null, [enumValue]);
    },
    updateElement: function(element2, value, node2, idx) {
      var selectedFormField = getSelectedFormField(element2, node2), enumValue = selectedFormField.values[idx];
      value.name = value.name || void 0;
      return cmdHelper$k.updateBusinessObject(element2, enumValue, value);
    },
    validate: function(element2, value, node2, idx) {
      var selectedFormField = getSelectedFormField(element2, node2), enumValue = selectedFormField.values[idx];
      if (enumValue) {
        var validationError = utils$5.isIdValid(enumValue, value.id, translate2);
        if (validationError) {
          return { id: validationError };
        }
      }
    }
  }));
  group.entries.push(entryFactory$i.label({
    id: "form-field-validation-header",
    labelText: translate2("Validation"),
    divider: true,
    showLabel: function(element2, node2) {
      return !!getSelectedFormField(element2, node2);
    }
  }));
  group.entries.push(entryFactory$i.table(translate2, {
    id: "constraints-list",
    modelProperties: ["name", "config"],
    labels: [translate2("Name"), translate2("Config")],
    addLabel: translate2("Add Constraint"),
    getElements: function(element2, node2) {
      var formField = getSelectedFormField(element2, node2);
      return formHelper.getConstraints(formField);
    },
    addElement: function(element2, node2) {
      var commands = [], formField = getSelectedFormField(element2, node2), validation = formField.validation;
      if (!validation) {
        validation = elementHelper$b.createElement("camunda:Validation", {}, getBusinessObject$q(element2), bpmnFactory);
        commands.push(cmdHelper$k.updateBusinessObject(element2, formField, { "validation": validation }));
      }
      var newConstraint = elementHelper$b.createElement("camunda:Constraint", { name: void 0, config: void 0 }, validation, bpmnFactory);
      commands.push(cmdHelper$k.addElementsTolist(element2, validation, "constraints", [newConstraint]));
      return commands;
    },
    updateElement: function(element2, value, node2, idx) {
      var formField = getSelectedFormField(element2, node2), constraint = formHelper.getConstraints(formField)[idx];
      value.name = value.name || void 0;
      value.config = value.config || void 0;
      return cmdHelper$k.updateBusinessObject(element2, constraint, value);
    },
    removeElement: function(element2, node2, idx) {
      var commands = [], formField = getSelectedFormField(element2, node2), constraints = formHelper.getConstraints(formField), currentConstraint = constraints[idx];
      commands.push(cmdHelper$k.removeElementsFromList(element2, formField.validation, "constraints", null, [currentConstraint]));
      if (constraints.length === 1) {
        commands.push(cmdHelper$k.updateBusinessObject(element2, formField, { validation: void 0 }));
      }
      return commands;
    },
    show: function(element2, node2) {
      return !!getSelectedFormField(element2, node2);
    }
  }));
  group.entries.push(entryFactory$i.label({
    id: "form-field-properties-header",
    labelText: translate2("Properties"),
    divider: true,
    showLabel: function(element2, node2) {
      return !!getSelectedFormField(element2, node2);
    }
  }));
  group.entries.push(properties$2(element, bpmnFactory, {
    id: "form-field-properties",
    modelProperties: ["id", "value"],
    labels: [translate2("Id"), translate2("Value")],
    getParent: function(element2, node2) {
      return getSelectedFormField(element2, node2);
    },
    show: function(element2, node2) {
      return !!getSelectedFormField(element2, node2);
    }
  }, translate2));
};
function getFormRefBinding(element) {
  var businessObject = getBusinessObject$q(element);
  return businessObject.get("camunda:formRefBinding");
}
function getFormType(element) {
  var businessObject = getBusinessObject$q(element);
  if (!isUndefined$3(businessObject.get("camunda:formKey"))) {
    return "formKey";
  } else if (!isUndefined$3(businessObject.get("camunda:formRef"))) {
    return "formRef";
  }
}
function isFormSupported(element) {
  return is$j(element, "bpmn:StartEvent") && !is$j(element.parent, "bpmn:SubProcess") || is$j(element, "bpmn:UserTask");
}
var entryFactory$h = EntryFactory_1, is$i = require$$2$2.is, getBusinessObject$p = require$$2$2.getBusinessObject;
var StartEventInitiator = function(group, element, translate2) {
  var bo = getBusinessObject$p(element);
  if (!bo) {
    return;
  }
  if (is$i(element, "camunda:Initiator") && !is$i(element.parent, "bpmn:SubProcess")) {
    group.entries.push(entryFactory$h.textField(translate2, {
      id: "initiator",
      label: translate2("Initiator"),
      modelProperty: "initiator"
    }));
  }
};
var is$h = require$$2$2.is, isAny$5 = require$$1$2.isAny, getBusinessObject$o = require$$2$2.getBusinessObject;
var filter$4 = filter_1;
var extensionElementsHelper$5 = ExtensionElementsHelper_1, cmdHelper$j = CmdHelper_1, elementHelper$a = ElementHelper_1, eventDefinitionHelper$1 = EventDefinitionHelper_1;
var extensionElementsEntry$2 = ExtensionElements;
var entryFactory$g = EntryFactory_1;
function getCamundaInOutMappings(element, type) {
  var bo = getBusinessObject$o(element);
  var signalEventDefinition = eventDefinitionHelper$1.getSignalEventDefinition(bo);
  return extensionElementsHelper$5.getExtensionElements(signalEventDefinition || bo, type);
}
function getVariableMappings(element, type) {
  var camundaMappings = getCamundaInOutMappings(element, type);
  return filter$4(camundaMappings, function(mapping) {
    return !mapping.businessKey;
  });
}
function getInOutType(mapping) {
  var inOutType = "source";
  if (mapping.variables === "all") {
    inOutType = "variables";
  } else if (typeof mapping.source !== "undefined") {
    inOutType = "source";
  } else if (typeof mapping.sourceExpression !== "undefined") {
    inOutType = "sourceExpression";
  }
  return inOutType;
}
var CAMUNDA_IN_EXTENSION_ELEMENT = "camunda:In", CAMUNDA_OUT_EXTENSION_ELEMENT = "camunda:Out";
var WHITESPACE_REGEX = /\s/;
var VariableMappingProps = function(group, element, bpmnFactory, translate2) {
  var inOutTypeOptions = [
    {
      name: translate2("Source"),
      value: "source"
    },
    {
      name: translate2("Source Expression"),
      value: "sourceExpression"
    },
    {
      name: translate2("All"),
      value: "variables"
    }
  ];
  var signalEventDefinition = eventDefinitionHelper$1.getSignalEventDefinition(element);
  if (!is$h(element, "camunda:CallActivity") && !signalEventDefinition) {
    return;
  }
  if (signalEventDefinition && !isAny$5(element, [
    "bpmn:IntermediateThrowEvent",
    "bpmn:EndEvent"
  ])) {
    return;
  }
  var isSelected = function(element2, node2) {
    return !!getSelected2(element2, node2);
  };
  var getSelected2 = function(element2, node2) {
    var parentNode = node2.parentNode;
    var selection = inEntry.getSelected(element2, parentNode);
    var parameter = getVariableMappings(element2, CAMUNDA_IN_EXTENSION_ELEMENT)[selection.idx];
    if (!parameter && outEntry) {
      selection = outEntry.getSelected(element2, parentNode);
      parameter = getVariableMappings(element2, CAMUNDA_OUT_EXTENSION_ELEMENT)[selection.idx];
    }
    return parameter;
  };
  var setOptionLabelValue = function(type) {
    return function(element2, node2, option2, property2, value, idx) {
      var variableMappings = getVariableMappings(element2, type);
      var mappingValue = variableMappings[idx];
      var label2 = (mappingValue.target || "<undefined>") + " := ";
      var mappingType = getInOutType(mappingValue);
      if (mappingType === "variables") {
        label2 = "all";
      } else if (mappingType === "source") {
        label2 = label2 + (mappingValue.source || "<empty>");
      } else if (mappingType === "sourceExpression") {
        label2 = label2 + (mappingValue.sourceExpression || "<empty>");
      } else {
        label2 = label2 + "<empty>";
      }
      option2.text = label2;
    };
  };
  var newElement = function(type) {
    return function(element2, extensionElements2, value) {
      var newElem = elementHelper$a.createElement(type, { source: "" }, extensionElements2, bpmnFactory);
      return cmdHelper$j.addElementsTolist(element2, extensionElements2, "values", [newElem]);
    };
  };
  var removeElement2 = function(type) {
    return function(element2, extensionElements2, value, idx) {
      var variablesMappings = getVariableMappings(element2, type);
      var mapping = variablesMappings[idx];
      if (mapping) {
        return extensionElementsHelper$5.removeEntry(signalEventDefinition || getBusinessObject$o(element2), element2, mapping);
      }
    };
  };
  var inEntry = extensionElementsEntry$2(element, bpmnFactory, {
    id: "variableMapping-in",
    label: translate2("In Mapping"),
    modelProperty: "source",
    prefix: "In",
    idGeneration: false,
    resizable: true,
    businessObject: signalEventDefinition || getBusinessObject$o(element),
    createExtensionElement: newElement(CAMUNDA_IN_EXTENSION_ELEMENT),
    removeExtensionElement: removeElement2(CAMUNDA_IN_EXTENSION_ELEMENT),
    getExtensionElements: function(element2) {
      return getVariableMappings(element2, CAMUNDA_IN_EXTENSION_ELEMENT);
    },
    onSelectionChange: function(element2, node2, event, scope) {
      outEntry && outEntry.deselect(element2, node2.parentNode);
    },
    setOptionLabelValue: setOptionLabelValue(CAMUNDA_IN_EXTENSION_ELEMENT)
  });
  group.entries.push(inEntry);
  if (!signalEventDefinition) {
    var outEntry = extensionElementsEntry$2(element, bpmnFactory, {
      id: "variableMapping-out",
      label: translate2("Out Mapping"),
      modelProperty: "source",
      prefix: "Out",
      idGeneration: false,
      resizable: true,
      createExtensionElement: newElement(CAMUNDA_OUT_EXTENSION_ELEMENT),
      removeExtensionElement: removeElement2(CAMUNDA_OUT_EXTENSION_ELEMENT),
      getExtensionElements: function(element2) {
        return getVariableMappings(element2, CAMUNDA_OUT_EXTENSION_ELEMENT);
      },
      onSelectionChange: function(element2, node2, event, scope) {
        inEntry.deselect(element2, node2.parentNode);
      },
      setOptionLabelValue: setOptionLabelValue(CAMUNDA_OUT_EXTENSION_ELEMENT)
    });
    group.entries.push(outEntry);
  }
  group.entries.push(entryFactory$g.label({
    id: "variableMapping-typeLabel",
    get: function(element2, node2) {
      var mapping = getSelected2(element2, node2);
      var value = "";
      if (is$h(mapping, CAMUNDA_IN_EXTENSION_ELEMENT)) {
        value = translate2("In Mapping");
      } else if (is$h(mapping, CAMUNDA_OUT_EXTENSION_ELEMENT)) {
        value = translate2("Out Mapping");
      }
      return {
        label: value
      };
    },
    showLabel: function(element2, node2) {
      return isSelected(element2, node2);
    }
  }));
  group.entries.push(entryFactory$g.selectBox(translate2, {
    id: "variableMapping-inOutType",
    label: translate2("Type"),
    selectOptions: inOutTypeOptions,
    modelProperty: "inOutType",
    get: function(element2, node2) {
      var mapping = getSelected2(element2, node2) || {};
      return {
        inOutType: getInOutType(mapping)
      };
    },
    set: function(element2, values2, node2) {
      var inOutType = values2.inOutType;
      var props = {
        "source": void 0,
        "sourceExpression": void 0,
        "variables": void 0
      };
      if (inOutType === "source") {
        props.source = "";
      } else if (inOutType === "sourceExpression") {
        props.sourceExpression = "";
      } else if (inOutType === "variables") {
        props.variables = "all";
        props.target = void 0;
      }
      var mapping = getSelected2(element2, node2);
      return cmdHelper$j.updateBusinessObject(element2, mapping, props);
    },
    hidden: function(element2, node2) {
      return !isSelected(element2, node2);
    }
  }));
  group.entries.push(entryFactory$g.textField(translate2, {
    id: "variableMapping-source",
    dataValueLabel: "sourceLabel",
    modelProperty: "source",
    get: function(element2, node2) {
      var mapping = getSelected2(element2, node2) || {};
      var label2 = "";
      var inOutType = getInOutType(mapping);
      if (inOutType === "source") {
        label2 = translate2("Source");
      } else if (inOutType === "sourceExpression") {
        label2 = translate2("Source Expression");
      }
      return {
        source: mapping[inOutType],
        sourceLabel: label2
      };
    },
    set: function(element2, values2, node2) {
      values2.source = values2.source || void 0;
      var mapping = getSelected2(element2, node2);
      var inOutType = getInOutType(mapping);
      var props = {};
      props[inOutType] = values2.source || "";
      return cmdHelper$j.updateBusinessObject(element2, mapping, props);
    },
    validate: function(element2, values2, node2) {
      var mapping = getSelected2(element2, node2);
      var validation = {};
      if (mapping) {
        if (!values2.source) {
          validation.source = validation.source = values2.sourceLabel ? translate2("Mapping must have a {value}", { value: values2.sourceLabel.toLowerCase() }) : translate2("Mapping must have a value");
        }
        var inOutType = getInOutType(mapping);
        if (WHITESPACE_REGEX.test(values2.source) && inOutType !== "sourceExpression") {
          validation.source = translate2("{label} must not contain whitespace", { label: values2.sourceLabel });
        }
      }
      return validation;
    },
    hidden: function(element2, node2) {
      var selectedMapping = getSelected2(element2, node2);
      return !selectedMapping || selectedMapping && selectedMapping.variables;
    }
  }));
  group.entries.push(entryFactory$g.textField(translate2, {
    id: "variableMapping-target",
    label: translate2("Target"),
    modelProperty: "target",
    get: function(element2, node2) {
      return {
        target: (getSelected2(element2, node2) || {}).target
      };
    },
    set: function(element2, values2, node2) {
      values2.target = values2.target || void 0;
      var mapping = getSelected2(element2, node2);
      return cmdHelper$j.updateBusinessObject(element2, mapping, values2);
    },
    validate: function(element2, values2, node2) {
      var mapping = getSelected2(element2, node2);
      var validation = {};
      if (mapping) {
        var mappingType = getInOutType(mapping);
        if (!values2.target && mappingType !== "variables") {
          validation.target = translate2("Mapping must have a target");
        }
        if (values2.target && WHITESPACE_REGEX.test(values2.target) && mappingType !== "variables") {
          validation.target = translate2("Target must not contain whitespace");
        }
      }
      return validation;
    },
    hidden: function(element2, node2) {
      var selectedMapping = getSelected2(element2, node2);
      return !selectedMapping || selectedMapping && selectedMapping.variables;
    }
  }));
  group.entries.push(entryFactory$g.checkbox(translate2, {
    id: "variableMapping-local",
    label: translate2("Local"),
    modelProperty: "local",
    get: function(element2, node2) {
      return {
        local: (getSelected2(element2, node2) || {}).local
      };
    },
    set: function(element2, values2, node2) {
      values2.local = values2.local || false;
      var mapping = getSelected2(element2, node2);
      return cmdHelper$j.updateBusinessObject(element2, mapping, values2);
    },
    hidden: function(element2, node2) {
      return !isSelected(element2, node2);
    }
  }));
};
var entryFactory$f = EntryFactory_1, cmdHelper$i = CmdHelper_1, is$g = require$$2$2.is, getBusinessObject$n = require$$2$2.getBusinessObject;
var VersionTagProps = function(group, element, translate2) {
  var bo = getBusinessObject$n(element);
  if (!bo) {
    return;
  }
  if (is$g(element, "bpmn:Process") || is$g(element, "bpmn:Participant") && bo.get("processRef")) {
    var versionTagEntry = entryFactory$f.textField(translate2, {
      id: "versionTag",
      label: translate2("Version Tag"),
      modelProperty: "versionTag"
    });
    if (is$g(element, "bpmn:Participant")) {
      versionTagEntry.get = function(element2) {
        var processBo = bo.get("processRef");
        return {
          versionTag: processBo.get("camunda:versionTag")
        };
      };
      versionTagEntry.set = function(element2, values2) {
        var processBo = bo.get("processRef");
        return cmdHelper$i.updateBusinessObject(element2, processBo, {
          "camunda:versionTag": values2.versionTag || void 0
        });
      };
    }
    group.entries.push(versionTagEntry);
  }
};
function getInputOutput$2(element) {
  return (getElements(element, "camunda:InputOutput") || [])[0];
}
function getInputParameters$1(element) {
  return getParameters(element, "inputParameters");
}
function getOutputParameters$1(element) {
  return getParameters(element, "outputParameters");
}
function getFormFields(element) {
  var formData = getFormData(element);
  return formData && formData.get("fields") || [];
}
function getFormData(element) {
  return getElements(element, "camunda:FormData")[0];
}
function getOutMappings(element) {
  return getElements(element, "camunda:Out");
}
function getElements(element, type, property2) {
  var elements = getExtensionElements(element, type);
  return !property2 ? elements : (elements[0] || {})[property2] || [];
}
function getParameters(element, property2) {
  var inputOutput = getInputOutput$2(element);
  return inputOutput && inputOutput.get(property2) || [];
}
function getExtensionElements(element, type) {
  var elements = [];
  var extensionElements2 = element.get("extensionElements");
  if (typeof extensionElements2 !== "undefined") {
    var extensionValues = extensionElements2.get("values");
    if (typeof extensionValues !== "undefined") {
      elements = filter$a(extensionValues, function(value) {
        return is$f(value, type);
      });
    }
  }
  return elements;
}
function is$f(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
function getParents(element) {
  var parents = [];
  var current = element;
  while (current.$parent) {
    parents.push(current.$parent);
    current = current.$parent;
  }
  return parents;
}
function eachElement(elements, fn, depth) {
  depth = depth || 0;
  if (!isArray$n(elements)) {
    elements = [elements];
  }
  forEach$q(elements, function(s, i) {
    var filter2 = fn(s, i, depth);
    if (isArray$n(filter2) && filter2.length) {
      eachElement(filter2, fn, depth + 1);
    }
  });
}
function add(elements, e, unique) {
  var canAdd = !unique || elements.indexOf(e) === -1;
  if (canAdd) {
    elements.push(e);
  }
  return canAdd;
}
function selfAndFlowElements(elements, unique, maxDepth) {
  var result = [], processedFlowElements = [];
  eachElement(elements, function(element, i, depth) {
    add(result, element, unique);
    var flowElements = element.flowElements;
    if (maxDepth === -1 || depth < maxDepth) {
      if (flowElements && add(processedFlowElements, flowElements, unique)) {
        return flowElements;
      }
    }
  });
  return result;
}
function selfAndAllFlowElements(elements, allowDuplicates) {
  return selfAndFlowElements(elements, !allowDuplicates, -1);
}
function getElement(elementId, rootElement) {
  var allElements = selfAndAllFlowElements(rootElement);
  return find$e(allElements, function(element) {
    return element.id === elementId;
  });
}
function addVariableToList(variablesList, newVariable) {
  var foundIdx = findIndex$4(variablesList, function(variable) {
    return variable.name === newVariable.name && variable.scope === newVariable.scope;
  });
  if (foundIdx >= 0) {
    variablesList[foundIdx].origin = combineArrays(variablesList[foundIdx].origin, newVariable.origin);
  } else {
    variablesList.push(newVariable);
  }
}
function createProcessVariable(flowElement, name2, defaultScope) {
  var scope = getScope$2(flowElement, defaultScope, name2);
  return {
    name: name2,
    origin: [flowElement],
    scope
  };
}
function getScope$2(element, globalScope, variableName) {
  var parents = getParents(element);
  var scopedParent = find$e(parents, function(parent2) {
    return is$1$1(parent2, "bpmn:SubProcess") && hasInputParameter(parent2, variableName);
  });
  return scopedParent ? scopedParent : globalScope;
}
function is$1$1(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
function hasInputParameter(element, name2) {
  return find$e(getInputParameters$1(element), function(input) {
    return input.name === name2;
  });
}
function combineArrays(a, b) {
  return a.concat(b);
}
function extractOutputParameters(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables2 = options.processVariables;
  if (!isArray$n(elements)) {
    elements = [elements];
  }
  forEach$q(elements, function(element) {
    var outputParameters2 = getOutputParameters$1(element);
    forEach$q(outputParameters2, function(parameter) {
      var newVariable = createProcessVariable(element, parameter.name, containerElement);
      addVariableToList(processVariables2, newVariable);
    });
  });
  return processVariables2;
}
function extractResultVariables(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables2 = options.processVariables;
  if (!isArray$n(elements)) {
    elements = [elements];
  }
  forEach$q(elements, function(element) {
    var resultVariable2 = getResultVariable(element);
    if (resultVariable2) {
      var newVariable = createProcessVariable(element, resultVariable2, containerElement);
      addVariableToList(processVariables2, newVariable);
    }
  });
  return processVariables2;
}
function getResultVariable(element) {
  return element.get("camunda:resultVariable");
}
function extractFormFields(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables2 = options.processVariables;
  if (!isArray$n(elements)) {
    elements = [elements];
  }
  forEach$q(elements, function(element) {
    var formFields = getFormFields(element);
    forEach$q(formFields, function(field) {
      var newVariable = createProcessVariable(element, field.id, containerElement);
      addVariableToList(processVariables2, newVariable);
    });
  });
  return processVariables2;
}
function extractOutMappings(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables2 = options.processVariables;
  if (!isArray$n(elements)) {
    elements = [elements];
  }
  forEach$q(elements, function(element) {
    var outMappings = getOutMappings(element);
    forEach$q(outMappings, function(mapping) {
      if (mapping.local) {
        return;
      }
      var newVariable = createProcessVariable(element, mapping.target, containerElement);
      addVariableToList(processVariables2, newVariable);
    });
  });
  return processVariables2;
}
function getEventDefinitions(element, type) {
  var eventDefinitions = element.eventDefinitions;
  if (!eventDefinitions || !type) {
    return eventDefinitions;
  }
  return filter$a(eventDefinitions, function(definition) {
    return is$2$1(definition, type);
  });
}
function getErrorEventDefinitions(element) {
  return getEventDefinitions(element, "bpmn:ErrorEventDefinition");
}
function getEscalationEventDefinitions(element) {
  return getEventDefinitions(element, "bpmn:EscalationEventDefinition");
}
function is$2$1(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
function extractEventDefinitionVariables(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables2 = options.processVariables;
  var addVariable = function(element, name2) {
    var newVariable = createProcessVariable(element, name2, containerElement);
    addVariableToList(processVariables2, newVariable);
  };
  if (!isArray$n(elements)) {
    elements = [elements];
  }
  forEach$q(elements, function(element) {
    var errorEventDefinitions = getErrorEventDefinitions(element);
    forEach$q(errorEventDefinitions, function(definition) {
      var errorCodeVariable = definition.get("errorCodeVariable"), errorMessageVariable = definition.get("errorMessageVariable");
      if (errorCodeVariable) {
        addVariable(element, errorCodeVariable);
      }
      if (errorMessageVariable) {
        addVariable(element, errorMessageVariable);
      }
    });
    var escalationEventDefinitions = getEscalationEventDefinitions(element);
    forEach$q(escalationEventDefinitions, function(definition) {
      var escalationCodeVariable = definition.get("escalationCodeVariable");
      if (escalationCodeVariable) {
        addVariable(element, escalationCodeVariable);
      }
    });
  });
  return processVariables2;
}
var extractors = [
  extractOutputParameters,
  extractResultVariables,
  extractFormFields,
  extractOutMappings,
  extractEventDefinitionVariables
];
function getProcessVariables(containerElement) {
  var processVariables2 = [];
  var elements = selfAndAllFlowElements([containerElement], false);
  forEach$q(extractors, function(extractor) {
    extractor({
      elements,
      containerElement,
      processVariables: processVariables2
    });
  });
  return processVariables2;
}
function getVariablesForScope$2(scope, rootElement) {
  var allVariables = getProcessVariables(rootElement);
  var scopeElement = getElement(scope, rootElement);
  var scopeVariables = filter$a(allVariables, function(variable) {
    return variable.scope.id === scopeElement.id;
  });
  var parents = getParents(scopeElement);
  var parentsScopeVariables = filter$a(allVariables, function(variable) {
    return find$e(parents, function(parent2) {
      return parent2.id === variable.scope.id;
    });
  });
  return combineArrays$1(scopeVariables, parentsScopeVariables);
}
function combineArrays$1(a, b) {
  return a.concat(b);
}
var index_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getProcessVariables,
  getVariablesForScope: getVariablesForScope$2
}, Symbol.toStringTag, { value: "Module" }));
var require$$2 = /* @__PURE__ */ getAugmentedNamespace(index_esm);
var getVariablesForScope$1 = require$$2.getVariablesForScope;
var groupBy = require$$1$1.groupBy, flatten$7 = require$$1$1.flatten, forEach$3 = require$$1$1.forEach, keys = require$$1$1.keys, map$1 = require$$1$1.map, sortBy$1 = require$$1$1.sortBy;
var getBusinessObject$m = require$$2$2.getBusinessObject, is$e = require$$2$2.is, isAny$4 = require$$1$2.isAny;
var escapeHTML$3 = Utils.escapeHTML;
var factory = EntryFactory_1;
var entryFieldDescription$3 = EntryFieldDescription;
var ProcessVariables = function(element, translate2) {
  var entries = [];
  function createVariablesList(variables2, scope2) {
    var scopePrefix = scope2 ? scope2 + "-" : "";
    return flatten$7(map$1(variables2, function(variable, idx) {
      var name2 = variable.name, origin = variable.origin, variableEntries = [];
      var collapsible2 = factory.collapsible({
        id: scopePrefix + "variable- " + idx + "-collapsible",
        title: escapeHTML$3(name2),
        description: origin.toString(),
        open: false,
        get: function() {
          return {
            title: escapeHTML$3(name2),
            description: origin.toString()
          };
        }
      });
      var isOpen = collapsible2.isOpen;
      variableEntries.push(collapsible2);
      var createdInHtml = '<div data-show="show"><b>' + escapeHTML$3(translate2("Created in")) + "</b>" + createdInList(origin) + "</div>";
      variableEntries.push({
        id: scopePrefix + "variable- " + idx + "-created-in",
        html: createdInHtml,
        cssClasses: [
          "bpp-process-variables",
          "bpp-process-variables__created-in"
        ],
        show: function() {
          return isOpen();
        }
      });
      return variableEntries;
    }));
  }
  if (!canHaveProcessVariables(element)) {
    return entries;
  }
  var businessObject = getBusinessObject$m(element), rootElement = getRootElement$1(businessObject), scope = getScope$1(element);
  var variables = getVariablesForScope$1(scope, rootElement), sorted = sortByName$1(variables), withNames = populateElementNames(sorted), byScope = groupByScope(withNames);
  var description = entryFieldDescription$3(translate2, translate2("Available process variables, identified in the diagram."));
  entries.push({
    id: "process-variables-description",
    html: description,
    cssClasses: [
      "bpp-process-variables",
      "bpp-process-variables__description"
    ]
  });
  if (!withNames.length) {
    var placeholder = entryFieldDescription$3(translate2, translate2("No variables found."));
    entries.push({
      id: "process-variables-placeholder",
      html: placeholder
    });
    return entries;
  }
  if (keys(byScope).length > 1) {
    forEach$3(reverse(keys(byScope)), function(scope2) {
      var variables2 = byScope[scope2];
      entries.push({
        id: scope2 + "-scope-title",
        html: "<div>" + escapeHTML$3(translate2("Scope: ")) + scope2 + "</div>",
        cssClasses: [
          "bpp-process-variables",
          "bpp-process-variables__scope-title",
          "bpp-collapsible-break"
        ]
      });
      entries = entries.concat(createVariablesList(variables2, scope2));
    });
  } else {
    entries = entries.concat(createVariablesList(withNames));
  }
  return entries;
};
function getRootElement$1(element) {
  var businessObject = getBusinessObject$m(element);
  if (is$e(businessObject, "bpmn:Participant")) {
    return businessObject.processRef;
  }
  if (is$e(businessObject, "bpmn:Process")) {
    return businessObject;
  }
  var parent2 = businessObject;
  while (parent2.$parent && !is$e(parent2, "bpmn:Process")) {
    parent2 = parent2.$parent;
  }
  return parent2;
}
function getScope$1(element) {
  if (is$e(element, "bpmn:Participant")) {
    return getBusinessObject$m(element).processRef.id;
  }
  return element.id;
}
function sortByName$1(variables) {
  return sortBy$1(variables, function(variable) {
    return variable.name;
  });
}
function populateElementNames(variables) {
  forEach$3(variables, function(variable) {
    var names = map$1(variable.origin, function(element) {
      return element.name || element.id;
    });
    variable.origin = names;
    variable.scope = variable.scope.name || variable.scope.id;
  });
  return variables;
}
function canHaveProcessVariables(element) {
  var businessObject = getBusinessObject$m(element);
  return isAny$4(element, ["bpmn:Process", "bpmn:SubProcess"]) || is$e(element, "bpmn:Participant") && businessObject.get("processRef");
}
function groupByScope(variables) {
  return groupBy(variables, "scope");
}
function createdInList(origin) {
  var html = "";
  forEach$3(origin, function(o) {
    html += '<p class="bpp-process-variables__created-in-item">' + o + "</p>";
  });
  return html;
}
function reverse(array) {
  return map$1(array, function(a, i) {
    return array[array.length - 1 - i];
  });
}
var isAny$3 = require$$1$2.isAny, is$d = require$$2$2.is, getBusinessObject$l = require$$2$2.getBusinessObject;
var processVariables = ProcessVariables;
var ProcessVariablesProps = function(group, element, translate2) {
  if (canHaveOverview(element)) {
    var processVariablesEntries = processVariables(element, translate2);
    group.entries = group.entries.concat(processVariablesEntries);
  }
};
function canHaveOverview(element) {
  var businessObject = getBusinessObject$l(element);
  return isAny$3(element, ["bpmn:Process", "bpmn:SubProcess"]) || is$d(element, "bpmn:Participant") && businessObject.get("processRef");
}
var is$c = require$$2$2.is, getBusinessObject$k = require$$2$2.getBusinessObject;
var extensionElementsEntry$1 = ExtensionElements, extensionElementsHelper$4 = ExtensionElementsHelper_1, cmdHelper$h = CmdHelper_1, elementHelper$9 = ElementHelper_1, ImplementationTypeHelper$5 = ImplementationTypeHelper_1;
function getListeners(bo, type) {
  return bo && extensionElementsHelper$4.getExtensionElements(bo, type) || [];
}
var CAMUNDA_EXECUTION_LISTENER_ELEMENT = "camunda:ExecutionListener";
var CAMUNDA_TASK_LISTENER_ELEMENT = "camunda:TaskListener";
var Listener = function(element, bpmnFactory, options, translate2) {
  var LISTENER_TYPE_LABEL = {
    class: translate2("Java Class"),
    expression: translate2("Expression"),
    delegateExpression: translate2("Delegate Expression"),
    script: translate2("Script")
  };
  var bo;
  var result = {
    getSelectedListener
  };
  var entries = result.entries = [];
  var isSequenceFlow2 = ImplementationTypeHelper$5.isSequenceFlow(element);
  function getSelectedListener(element2, node2) {
    var selection = executionListenerEntry && executionListenerEntry.getSelected(element2, node2) || { idx: -1 };
    var listener2 = getListeners(bo, CAMUNDA_EXECUTION_LISTENER_ELEMENT)[selection.idx];
    if (!listener2 && taskListenerEntry) {
      selection = taskListenerEntry.getSelected(element2, node2);
      listener2 = getListeners(bo, CAMUNDA_TASK_LISTENER_ELEMENT)[selection.idx];
    }
    return listener2;
  }
  var setOptionLabelValue = function(type) {
    return function(element2, node2, option2, property2, value, idx) {
      var listeners = getListeners(bo, type);
      var listener2 = listeners[idx];
      var listenerType = ImplementationTypeHelper$5.getImplementationType(listener2);
      var event = listener2.get("event") ? listener2.get("event") : "<empty>";
      var label2 = (event || "*") + " : " + (LISTENER_TYPE_LABEL[listenerType] || "");
      option2.text = label2;
    };
  };
  var newElement = function(element2, type, initialEvent) {
    return function(element3, extensionElements2, value) {
      var props = {
        event: initialEvent,
        class: ""
      };
      var newElem = elementHelper$9.createElement(type, props, extensionElements2, bpmnFactory);
      return cmdHelper$h.addElementsTolist(element3, extensionElements2, "values", [newElem]);
    };
  };
  var removeElement2 = function(element2, type) {
    return function(element3, extensionElements2, value, idx) {
      var listeners = getListeners(bo, type);
      var listener2 = listeners[idx];
      if (listener2) {
        return extensionElementsHelper$4.removeEntry(bo, element3, listener2);
      }
    };
  };
  if (is$c(element, "bpmn:FlowElement") || is$c(element, "bpmn:Process") || is$c(element, "bpmn:Participant")) {
    bo = getBusinessObject$k(element);
    if (is$c(element, "bpmn:Participant")) {
      element = element.processRef;
      bo = bo.get("processRef");
    }
    if (bo) {
      var executionListenerEntry = extensionElementsEntry$1(element, bpmnFactory, {
        id: "executionListeners",
        label: translate2("Execution Listener"),
        modelProperty: "name",
        idGeneration: "false",
        reference: "processRef",
        createExtensionElement: newElement(element, CAMUNDA_EXECUTION_LISTENER_ELEMENT, isSequenceFlow2 ? "take" : "start"),
        removeExtensionElement: removeElement2(element, CAMUNDA_EXECUTION_LISTENER_ELEMENT),
        getExtensionElements: function(element2) {
          return getListeners(bo, CAMUNDA_EXECUTION_LISTENER_ELEMENT);
        },
        onSelectionChange: function(element2, node2, event, scope) {
          taskListenerEntry && taskListenerEntry.deselect(element2, node2);
        },
        setOptionLabelValue: setOptionLabelValue(CAMUNDA_EXECUTION_LISTENER_ELEMENT)
      });
      entries.push(executionListenerEntry);
    }
  }
  if (is$c(element, "bpmn:UserTask")) {
    bo = getBusinessObject$k(element);
    var taskListenerEntry = extensionElementsEntry$1(element, bpmnFactory, {
      id: "taskListeners",
      label: translate2("Task Listener"),
      modelProperty: "name",
      idGeneration: "false",
      createExtensionElement: newElement(element, CAMUNDA_TASK_LISTENER_ELEMENT, "create"),
      removeExtensionElement: removeElement2(element, CAMUNDA_TASK_LISTENER_ELEMENT),
      getExtensionElements: function(element2) {
        return getListeners(bo, CAMUNDA_TASK_LISTENER_ELEMENT);
      },
      onSelectionChange: function(element2, node2, event, scope) {
        executionListenerEntry.deselect(element2, node2);
      },
      setOptionLabelValue: setOptionLabelValue(CAMUNDA_TASK_LISTENER_ELEMENT)
    });
    entries.push(taskListenerEntry);
  }
  return result;
};
var listener = Listener;
var ListenerProps = function(group, element, bpmnFactory, translate2) {
  var listenerEntry = listener(element, bpmnFactory, {}, translate2);
  group.entries = group.entries.concat(listenerEntry.entries);
  return {
    getSelectedListener: listenerEntry.getSelectedListener
  };
};
var is$b = require$$2$2.is;
var find$2 = require$$1$1.find;
var entryFactory$e = EntryFactory_1;
var cmdHelper$g = CmdHelper_1, ImplementationTypeHelper$4 = ImplementationTypeHelper_1, scriptImplementation$1 = Script, timerImplementation = TimerEventDefinition_1;
var ListenerDetailProps = function(group, element, bpmnFactory, options, translate2) {
  var LISTENER_TYPE_LABEL = {
    class: translate2("Java Class"),
    expression: translate2("Expression"),
    delegateExpression: translate2("Delegate Expression"),
    script: translate2("Script")
  };
  options = options || {};
  var getSelectedListener = options.getSelectedListener;
  var classProp = "class", expressionProp = "expression", delegateExpressionProp = "delegateExpression", scriptProp = "script";
  var executionListenerEventTypeOptions = ImplementationTypeHelper$4.isSequenceFlow(element) ? [
    { name: translate2("take"), value: "take" }
  ] : [
    { name: translate2("start"), value: "start" },
    { name: translate2("end"), value: "end" }
  ];
  var taskListenerEventTypeOptions = [
    { name: translate2("create"), value: "create" },
    { name: translate2("assignment"), value: "assignment" },
    { name: translate2("complete"), value: "complete" },
    { name: translate2("delete"), value: "delete" },
    { name: translate2("update"), value: "update" },
    { name: translate2("timeout"), value: "timeout" }
  ];
  var isSelected = function(element2, node2) {
    return getSelectedListener(element2, node2);
  };
  group.entries.push(entryFactory$e.selectBox(translate2, {
    id: "listener-event-type",
    label: translate2("Event Type"),
    modelProperty: "eventType",
    emptyParameter: false,
    get: function(element2, node2) {
      var listener2 = getSelectedListener(element2, node2);
      var eventType = listener2 && listener2.get("event");
      return {
        eventType
      };
    },
    set: function(element2, values2, node2) {
      var eventType = values2.eventType, listener2 = getSelectedListener(element2, node2), eventDefinitions = listener2 && listener2.eventDefinitions;
      if (eventDefinitions && eventType !== "timeout") {
        eventDefinitions = [];
      }
      return cmdHelper$g.updateBusinessObject(element2, listener2, {
        event: eventType,
        eventDefinitions
      });
    },
    selectOptions: function(element2, node2) {
      var eventTypeOptions;
      var selectedListener = getSelectedListener(element2, node2);
      if (ImplementationTypeHelper$4.isTaskListener(selectedListener)) {
        eventTypeOptions = taskListenerEventTypeOptions;
      } else if (ImplementationTypeHelper$4.isExecutionListener(selectedListener)) {
        eventTypeOptions = executionListenerEventTypeOptions;
      }
      return eventTypeOptions;
    },
    hidden: function(element2, node2) {
      return !isSelected(element2, node2);
    }
  }));
  group.entries.push(entryFactory$e.textField(translate2, {
    id: "listener-id",
    label: translate2("Listener Id"),
    modelProperty: "listenerId",
    get: function(element2, node2) {
      var value = {}, listener2 = getSelectedListener(element2, node2);
      value.listenerId = listener2 && listener2.get("id") || void 0;
      return value;
    },
    set: function(element2, values2, node2) {
      var update2 = {}, listener2 = getSelectedListener(element2, node2);
      update2["id"] = values2.listenerId || "";
      return cmdHelper$g.updateBusinessObject(element2, listener2, update2);
    },
    hidden: function(element2, node2) {
      var listener2 = getSelectedListener(element2, node2);
      return !ImplementationTypeHelper$4.isTaskListener(listener2);
    },
    validate: function(element2, values2, node2) {
      var value = values2.listenerId, listener2 = getSelectedListener(element2, node2), validate2 = {};
      if (!value && isTimeoutTaskListener(listener2)) {
        validate2.listenerId = translate2("Must provide a value for timeout task listener");
      }
      return validate2;
    }
  }));
  group.entries.push(entryFactory$e.selectBox(translate2, {
    id: "listener-type",
    label: translate2("Listener Type"),
    selectOptions: [
      { value: classProp, name: translate2("Java Class") },
      { value: expressionProp, name: translate2("Expression") },
      { value: delegateExpressionProp, name: translate2("Delegate Expression") },
      { value: scriptProp, name: translate2("Script") }
    ],
    modelProperty: "listenerType",
    emptyParameter: false,
    get: function(element2, node2) {
      var listener2 = getSelectedListener(element2, node2);
      return {
        listenerType: ImplementationTypeHelper$4.getImplementationType(listener2)
      };
    },
    set: function(element2, values2, node2) {
      var listener2 = getSelectedListener(element2, node2), listenerType = values2.listenerType || void 0, update2 = {};
      update2[classProp] = listenerType === classProp ? "" : void 0;
      update2[expressionProp] = listenerType === expressionProp ? "" : void 0;
      update2[delegateExpressionProp] = listenerType === delegateExpressionProp ? "" : void 0;
      update2[scriptProp] = listenerType === scriptProp ? bpmnFactory.create("camunda:Script") : void 0;
      return cmdHelper$g.updateBusinessObject(element2, listener2, update2);
    },
    hidden: function(element2, node2) {
      return !isSelected(element2, node2);
    }
  }));
  group.entries.push(entryFactory$e.textField(translate2, {
    id: "listener-value",
    dataValueLabel: "listenerValueLabel",
    modelProperty: "listenerValue",
    get: function(element2, node2) {
      var value = {}, listener2 = getSelectedListener(element2, node2), listenerType = ImplementationTypeHelper$4.getImplementationType(listener2);
      value.listenerValueLabel = LISTENER_TYPE_LABEL[listenerType] || "";
      value.listenerValue = listener2 && listener2.get(listenerType) || void 0;
      return value;
    },
    set: function(element2, values2, node2) {
      var update2 = {}, listener2 = getSelectedListener(element2, node2), listenerType = ImplementationTypeHelper$4.getImplementationType(listener2);
      update2[listenerType] = values2.listenerValue || "";
      return cmdHelper$g.updateBusinessObject(element2, listener2, update2);
    },
    hidden: function(element2, node2) {
      var listener2 = getSelectedListener(element2, node2);
      return !listener2 || listener2.script;
    },
    validate: function(element2, values2) {
      var value = values2.listenerValue, validate2 = {};
      if (!value) {
        validate2.listenerValue = translate2("Must provide a value");
      }
      return validate2;
    }
  }));
  var script = scriptImplementation$1("scriptFormat", "value", true, translate2);
  group.entries.push({
    id: "listener-script-value",
    html: '<div data-show="isScript">' + script.template + "</div>",
    get: function(element2, node2) {
      var listener2 = getSelectedListener(element2, node2);
      return listener2 && listener2.script ? script.get(element2, listener2.script) : {};
    },
    set: function(element2, values2, node2) {
      var listener2 = getSelectedListener(element2, node2);
      var update2 = script.set(element2, values2, listener2);
      return cmdHelper$g.updateBusinessObject(element2, listener2.script, update2);
    },
    validate: function(element2, values2, node2) {
      var listener2 = getSelectedListener(element2, node2);
      return listener2 && listener2.script ? script.validate(element2, values2) : {};
    },
    isScript: function(element2, node2) {
      var listener2 = getSelectedListener(element2, node2);
      return listener2 && listener2.script;
    },
    script
  });
  var timerEventDefinitionHandler = function(element2, node2) {
    var listener2 = getSelectedListener(element2, node2);
    if (!listener2 || !isTimeoutTaskListener(listener2)) {
      return;
    }
    var timerEventDefinition = getTimerEventDefinition(listener2);
    if (!timerEventDefinition) {
      return false;
    }
    return timerEventDefinition;
  };
  function createTimerEventDefinition(element2, node2) {
    var listener2 = getSelectedListener(element2, node2);
    if (!listener2 || !isTimeoutTaskListener(listener2)) {
      return;
    }
    var eventDefinitions = listener2.get("eventDefinitions") || [], timerEventDefinition = bpmnFactory.create("bpmn:TimerEventDefinition");
    eventDefinitions.push(timerEventDefinition);
    listener2.eventDefinitions = eventDefinitions;
    return timerEventDefinition;
  }
  var timerOptions = {
    idPrefix: "listener-",
    createTimerEventDefinition
  };
  timerImplementation(group, element, bpmnFactory, timerEventDefinitionHandler, translate2, timerOptions);
};
function isTimeoutTaskListener(listener2) {
  var eventType = listener2 && listener2.event;
  return eventType === "timeout";
}
function getTimerEventDefinition(bo) {
  var eventDefinitions = bo.eventDefinitions || [];
  return find$2(eventDefinitions, function(event) {
    return is$b(event, "bpmn:TimerEventDefinition");
  });
}
var extensionElementsHelper$3 = ExtensionElementsHelper_1, elementHelper$8 = ElementHelper_1, cmdHelper$f = CmdHelper_1;
var utils$4 = Utils;
var entryFactory$d = EntryFactory_1;
var extensionElementsEntry = ExtensionElements;
var ModelUtil = require$$2$2, getBusinessObject$j = ModelUtil.getBusinessObject;
var assign$3 = assign_1;
var DEFAULT_PROPS = {
  "stringValue": void 0,
  "string": void 0,
  "expression": void 0
};
var CAMUNDA_FIELD_EXTENSION_ELEMENT = "camunda:Field";
var FieldInjection = function(element, bpmnFactory, translate2, options) {
  options = options || {};
  var insideListener = !!options.insideListener, idPrefix = options.idPrefix || "", getSelectedListener = options.getSelectedListener, businessObject = options.businessObject || getBusinessObject$j(element);
  var entries = [];
  var isSelected = function(element2, node2) {
    return getSelectedField(element2, node2);
  };
  function getSelectedField(element2, node2) {
    var selected = fieldEntry.getSelected(element2, node2.parentNode);
    if (selected.idx === -1) {
      return;
    }
    var fields = getCamundaFields(element2, node2);
    return fields[selected.idx];
  }
  function getCamundaFields(element2, node2) {
    if (!insideListener) {
      return businessObject && extensionElementsHelper$3.getExtensionElements(businessObject, CAMUNDA_FIELD_EXTENSION_ELEMENT);
    }
    return getCamundaListenerFields(element2, node2);
  }
  function getCamundaListenerFields(element2, node2) {
    var selectedListener = getSelectedListener(element2, node2);
    return selectedListener && selectedListener.fields || [];
  }
  function getFieldType(bo) {
    var fieldType = "string";
    var expressionValue = bo && bo.expression;
    var stringValue = bo && (bo.string || bo.stringValue);
    if (typeof stringValue !== "undefined") {
      fieldType = "string";
    } else if (typeof expressionValue !== "undefined") {
      fieldType = "expression";
    }
    return fieldType;
  }
  var setOptionLabelValue = function() {
    return function(element2, node2, option2, property2, value, idx) {
      var camundaFields = getCamundaFields(element2, node2);
      var field = camundaFields[idx];
      value = field.name ? field.name : "<empty>";
      var label2 = idx + " : " + value;
      option2.text = label2;
    };
  };
  var newElement = function() {
    return function(element2, extensionElements2, value, node2) {
      var props = {
        name: "",
        string: ""
      };
      var newFieldElem;
      if (!insideListener) {
        newFieldElem = elementHelper$8.createElement(CAMUNDA_FIELD_EXTENSION_ELEMENT, props, extensionElements2, bpmnFactory);
        return cmdHelper$f.addElementsTolist(element2, extensionElements2, "values", [newFieldElem]);
      } else {
        var selectedListener = getSelectedListener(element2, node2);
        newFieldElem = elementHelper$8.createElement(CAMUNDA_FIELD_EXTENSION_ELEMENT, props, selectedListener, bpmnFactory);
        return cmdHelper$f.addElementsTolist(element2, selectedListener, "fields", [newFieldElem]);
      }
    };
  };
  var removeElement2 = function() {
    return function(element2, extensionElements2, value, idx, node2) {
      var camundaFields = getCamundaFields(element2, node2);
      var field = camundaFields[idx];
      if (field) {
        if (!insideListener) {
          return extensionElementsHelper$3.removeEntry(businessObject, element2, field);
        }
        var selectedListener = getSelectedListener(element2, node2);
        return cmdHelper$f.removeElementsFromList(element2, selectedListener, "fields", null, [field]);
      }
    };
  };
  var fieldEntry = extensionElementsEntry(element, bpmnFactory, {
    id: idPrefix + "fields",
    label: translate2("Fields"),
    modelProperty: "fieldName",
    idGeneration: "false",
    businessObject,
    createExtensionElement: newElement(),
    removeExtensionElement: removeElement2(),
    getExtensionElements: function(element2, node2) {
      return getCamundaFields(element2, node2);
    },
    setOptionLabelValue: setOptionLabelValue()
  });
  entries.push(fieldEntry);
  entries.push(entryFactory$d.validationAwareTextField(translate2, {
    id: idPrefix + "field-name",
    label: translate2("Name"),
    modelProperty: "fieldName",
    getProperty: function(element2, node2) {
      return (getSelectedField(element2, node2) || {}).name;
    },
    setProperty: function(element2, values2, node2) {
      var selectedField = getSelectedField(element2, node2);
      return cmdHelper$f.updateBusinessObject(element2, selectedField, { name: values2.fieldName });
    },
    validate: function(element2, values2, node2) {
      var bo = getSelectedField(element2, node2);
      var validation = {};
      if (bo) {
        var nameValue = values2.fieldName;
        if (nameValue) {
          if (utils$4.containsSpace(nameValue)) {
            validation.fieldName = translate2("Name must not contain spaces");
          }
        } else {
          validation.fieldName = translate2("Parameter must have a name");
        }
      }
      return validation;
    },
    hidden: function(element2, node2) {
      return !isSelected(element2, node2);
    }
  }));
  var fieldTypeOptions = [
    {
      name: translate2("String"),
      value: "string"
    },
    {
      name: translate2("Expression"),
      value: "expression"
    }
  ];
  entries.push(entryFactory$d.selectBox(translate2, {
    id: idPrefix + "field-type",
    label: translate2("Type"),
    selectOptions: fieldTypeOptions,
    modelProperty: "fieldType",
    get: function(element2, node2) {
      var bo = getSelectedField(element2, node2);
      var fieldType = getFieldType(bo);
      return {
        fieldType
      };
    },
    set: function(element2, values2, node2) {
      var props = assign$3({}, DEFAULT_PROPS);
      var fieldType = values2.fieldType;
      if (fieldType === "string") {
        props.string = "";
      } else if (fieldType === "expression") {
        props.expression = "";
      }
      return cmdHelper$f.updateBusinessObject(element2, getSelectedField(element2, node2), props);
    },
    hidden: function(element2, node2) {
      return !isSelected(element2, node2);
    }
  }));
  entries.push(entryFactory$d.textBox(translate2, {
    id: idPrefix + "field-value",
    label: translate2("Value"),
    modelProperty: "fieldValue",
    get: function(element2, node2) {
      var bo = getSelectedField(element2, node2);
      var fieldType = getFieldType(bo);
      var fieldValue;
      if (fieldType === "string") {
        fieldValue = bo && (bo.string || bo.stringValue);
      } else if (fieldType === "expression") {
        fieldValue = bo && bo.expression;
      }
      return {
        fieldValue
      };
    },
    set: function(element2, values2, node2) {
      var bo = getSelectedField(element2, node2);
      var fieldType = getFieldType(bo);
      var props = assign$3({}, DEFAULT_PROPS);
      var fieldValue = values2.fieldValue || void 0;
      if (fieldType === "string") {
        props.string = fieldValue;
      } else if (fieldType === "expression") {
        props.expression = fieldValue;
      }
      return cmdHelper$f.updateBusinessObject(element2, bo, props);
    },
    validate: function(element2, values2, node2) {
      var bo = getSelectedField(element2, node2);
      var validation = {};
      if (bo) {
        if (!values2.fieldValue) {
          validation.fieldValue = translate2("Must provide a value");
        }
      }
      return validation;
    },
    show: function(element2, node2) {
      return isSelected(element2, node2);
    }
  }));
  return entries;
};
var assign$2 = assign_1;
var fieldInjection$1 = FieldInjection;
var ListenerFieldInjectionProps = function(group, element, bpmnFactory, options, translate2) {
  options = assign$2({
    idPrefix: "listener-",
    insideListener: true
  }, options);
  var fieldInjectionEntry = fieldInjection$1(element, bpmnFactory, translate2, options);
  if (fieldInjectionEntry && fieldInjectionEntry.length > 0) {
    group.entries = group.entries.concat(fieldInjectionEntry);
  }
};
var Helper = {};
var find$1 = find_1, isUndefined$2 = isUndefined_1;
var isAny$2 = require$$1$2.isAny;
var ELEMENT_TEMPLATE_OPTION_EMPTY$1 = "element-template-option-empty";
Helper.ELEMENT_TEMPLATE_OPTION_EMPTY = ELEMENT_TEMPLATE_OPTION_EMPTY$1;
var emptyOption = {
  name: "",
  value: ELEMENT_TEMPLATE_OPTION_EMPTY$1
};
function getOptions$1(element, elementTemplates2, translate2) {
  var options = [emptyOption];
  var defaultTemplate = elementTemplates2.getDefault(element);
  if (defaultTemplate) {
    options.push(option("element-template-option-0", defaultTemplate, translate2));
    return options;
  }
  var index2 = 0;
  elementTemplates2.getAll().forEach(function(template2) {
    if (!isAny$2(element, template2.appliesTo)) {
      return;
    }
    options.push(option("element-template-option-" + index2, template2, translate2));
    index2++;
  });
  return options;
}
Helper.getOptions = getOptions$1;
function getOption$1(optionId, options) {
  return find$1(options, function(option2) {
    return optionId === option2.value;
  });
}
Helper.getOption = getOption$1;
function option(value, template2, translate2) {
  var name2 = translate2(template2.name);
  if (template2.version) {
    name2 += " (v" + template2.version + ")";
  }
  var option2 = {
    id: template2.id,
    name: name2,
    value
  };
  if (template2.version) {
    option2.version = template2.version;
  }
  return option2;
}
Helper.getVersionOrDateFromTemplate = function(template2) {
  var metadata = template2.metadata, version2 = template2.version;
  if (metadata) {
    if (!isUndefined$2(metadata.created)) {
      return "Version " + toDateString(metadata.created);
    } else if (!isUndefined$2(metadata.updated)) {
      return "Version " + toDateString(metadata.updated);
    }
  }
  if (isUndefined$2(version2)) {
    return null;
  }
  return "Version " + version2;
};
function toDateString(timestamp) {
  var date = new Date(timestamp);
  var year = date.getFullYear();
  var month = leftPad(String(date.getMonth() + 1), 2, "0");
  var day = leftPad(String(date.getDate()), 2, "0");
  return day + "." + month + "." + year;
}
function leftPad(string, length2, character) {
  while (string.length < length2) {
    string = character + string;
  }
  return string;
}
var escapeHTML$2 = Utils.escapeHTML;
var getTemplateId$2 = Helper$1.getTemplateId;
var domClasses$2 = require$$6.classes, domEvent$2 = require$$6.event, domify$2 = require$$6.domify, domQuery$8 = require$$6.query;
var isUndefined$1 = isUndefined_1;
var getBusinessObject$i = require$$2$2.getBusinessObject;
var getVersionOrDateFromTemplate = Helper.getVersionOrDateFromTemplate;
var MAX_DESCRIPTION_LENGTH$2 = 200;
var DescriptionProps = function(element, commandStack, elementTemplates2, modeling, replace, selection, translate2) {
  var currentElementTemplate = elementTemplates2.get(element);
  var entries = [];
  var description, newestElementTemplate;
  if (currentElementTemplate) {
    newestElementTemplate = findNewestElementTemplate(elementTemplates2, currentElementTemplate);
    if (newestElementTemplate) {
      entries.push({
        id: "element-template-update",
        cssClasses: ["bpp-entry--warning"],
        html: createUpdateTemplateEntry(element, currentElementTemplate, newestElementTemplate, commandStack, translate2)
      });
    }
    description = currentElementTemplate.description;
    if (description) {
      entries.push(createDescriptionEntry$2(description, translate2));
    }
  } else {
    entries.push({
      id: "element-template-not-found",
      cssClasses: ["bpp-entry--warning"],
      html: createTemplateNotFoundEntry(element, modeling, translate2)
    });
  }
  if (currentElementTemplate && currentElementTemplate.version) {
    entries.push({
      id: "element-template-version",
      html: "<p>" + getVersionOrDateFromTemplate(currentElementTemplate) + "</p>"
    });
  }
  return {
    id: "elementTemplateDescription",
    label: currentElementTemplate ? currentElementTemplate.name : translate2("Missing Template"),
    dropdown: {
      menu: [
        {
          id: "element-template-unlink",
          label: translate2("Unlink"),
          onClick: function() {
            modeling.updateProperties(element, {
              "camunda:modelerTemplate": null,
              "camunda:modelerTemplateVersion": null
            });
          }
        },
        {
          id: "element-template-remove",
          label: translate2("Remove"),
          onClick: function() {
            var businessObject = getBusinessObject$i(element);
            var type = businessObject.$type, eventDefinitionType = getEventDefinitionType(businessObject);
            var newElement = replace.replaceElement(element, {
              type,
              eventDefinitionType
            });
            selection.select(newElement);
          }
        }
      ]
    },
    entries
  };
};
function createDescriptionEntry$2(description, translate2) {
  description = escapeHTML$2(description);
  var html = domify$2('<p class="description description--expanded"></p>');
  var descriptionText = domify$2('<span class="description__text">' + description + "</span>");
  html.appendChild(descriptionText);
  function toggleExpanded(expanded2) {
    if (expanded2) {
      domClasses$2(html).add("description--expanded");
      descriptionText.textContent = description + " ";
      expand.textContent = translate2("Less");
    } else {
      domClasses$2(html).remove("description--expanded");
      descriptionText.textContent = descriptionShortened + " ... ";
      expand.textContent = translate2("More");
    }
  }
  var descriptionShortened, expand, expanded = false;
  if (description.length > MAX_DESCRIPTION_LENGTH$2) {
    descriptionShortened = description.slice(0, MAX_DESCRIPTION_LENGTH$2);
    expand = domify$2('<span class="bpp-entry-link description__expand">' + translate2("More") + "</span>");
    domEvent$2.bind(expand, "click", function() {
      expanded = !expanded;
      toggleExpanded(expanded);
    });
    html.appendChild(expand);
    toggleExpanded(expanded);
  }
  return {
    id: "element-template-description",
    html
  };
}
function getEventDefinitionType(businessObject) {
  if (!businessObject.eventDefinitions) {
    return null;
  }
  var eventDefinition = businessObject.eventDefinitions[0];
  if (!eventDefinition) {
    return null;
  }
  return eventDefinition.$type;
}
function createTemplateNotFoundEntry(element, modeling, translate2) {
  var templateId = getTemplateId$2(element);
  var html = domify$2("<p>" + translate2("The applied Template &lt;{templateId}&gt; was not found and therefore its data is not accessible.<br /><br />Unlink in order to access the data.", { templateId }) + '</p><p style="text-align: right;"><a class="bpp-entry-link bpp-entry-link-button">Unlink</a></p>');
  domQuery$8(".bpp-entry-link", html).addEventListener("click", function() {
    modeling.updateProperties(element, {
      "camunda:modelerTemplate": null
    });
  });
  return html;
}
function createUpdateTemplateEntry(element, oldElementTemplate, newElementTemplate, commandStack, translate2) {
  var newElementTemplateVersion = getVersionOrDateFromTemplate(newElementTemplate);
  var html = domify$2("<p>" + translate2("A new version of the Template ({newElementTemplateVersion}) is available.", { newElementTemplateVersion }) + '</p><p style="text-align: right;"><a class="bpp-entry-link bpp-entry-link-button">Update</a></p>');
  domQuery$8(".bpp-entry-link", html).addEventListener("click", function() {
    commandStack.execute("propertiesPanel.camunda.changeTemplate", {
      element,
      newTemplate: newElementTemplate,
      oldTemplate: oldElementTemplate
    });
  });
  return html;
}
function findNewestElementTemplate(elementTemplates2, currentElementTemplate) {
  if (isUndefined$1(currentElementTemplate.version)) {
    return null;
  }
  return elementTemplates2.getAll().filter(function(elementTemplate) {
    return currentElementTemplate.id === elementTemplate.id && !isUndefined$1(elementTemplate.version);
  }).reduce(function(newestElementTemplate, elementTemplate) {
    if (currentElementTemplate.version < elementTemplate.version) {
      return elementTemplate;
    }
    if (newestElementTemplate && newestElementTemplate.version < elementTemplate.version) {
      return elementTemplate;
    }
    return newestElementTemplate;
  }, null);
}
function isNull$1(value) {
  return value === null;
}
var isNull_1 = isNull$1;
var assignValue = _assignValue, castPath$1 = _castPath, isIndex = _isIndex, isObject$1 = isObject_1, toKey = _toKey;
function baseSet$1(object, path, value, customizer) {
  if (!isObject$1(object)) {
    return object;
  }
  path = castPath$1(path, object);
  var index2 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
  while (nested != null && ++index2 < length2) {
    var key = toKey(path[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$1(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$1;
var baseGet = _baseGet, baseSet = _baseSet, castPath = _castPath;
function basePickBy$1(object, paths2, predicate) {
  var index2 = -1, length2 = paths2.length, result = {};
  while (++index2 < length2) {
    var path = paths2[index2], value = baseGet(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
var basePickBy = _basePickBy, hasIn = hasIn_1;
function basePick$1(object, paths2) {
  return basePickBy(object, paths2, function(value, path) {
    return hasIn(object, path);
  });
}
var _basePick = basePick$1;
var flatten$6 = flatten_1, overRest = _overRest, setToString = _setToString;
function flatRest$1(func) {
  return setToString(overRest(func, void 0, flatten$6), func + "");
}
var _flatRest = flatRest$1;
var basePick = _basePick, flatRest = _flatRest;
var pick$1 = flatRest(function(object, paths2) {
  return object == null ? {} : basePick(object, paths2);
});
var pick_1 = pick$1;
var entryFactory$c = EntryFactory_1;
var getOption = Helper.getOption, getOptions = Helper.getOptions, getTemplateId$1 = Helper$1.getTemplateId, ELEMENT_TEMPLATE_OPTION_EMPTY = Helper$1.ELEMENT_TEMPLATE_OPTION_EMPTY;
var isNull = isNull_1, isUndefined = isUndefined_1, pick = pick_1;
var ChooserProps = function(group, element, elementTemplates2, translate2) {
  if (!isUndefined(getTemplateId$1(element)) && !isNull(getTemplateId$1(element))) {
    return;
  }
  var options = getOptions(element, elementTemplates2, translate2);
  if (options.length === 1) {
    return;
  }
  var selectOptions = options.map(function(option2) {
    return pick(option2, ["name", "value"]);
  });
  group.entries.push(entryFactory$c.selectBox(translate2, {
    id: "elementTemplate-chooser",
    label: translate2("Element Template"),
    modelProperty: "elementTemplateOption",
    selectOptions,
    get: function(element2) {
      return {
        elementTemplateOption: ELEMENT_TEMPLATE_OPTION_EMPTY
      };
    },
    set: function(element2, properties2) {
      var optionId = properties2["elementTemplateOption"];
      var option2 = getOption(optionId, options);
      var id2 = option2.id, version2 = option2.version;
      var newTemplate = elementTemplates2.get(id2, version2);
      return applyTemplate(element2, newTemplate, elementTemplates2);
    }
  }));
};
function applyTemplate(element, newTemplate, elementTemplates2) {
  var oldTemplate = elementTemplates2.get(element);
  if (oldTemplate === newTemplate) {
    return;
  }
  return {
    cmd: "propertiesPanel.camunda.changeTemplate",
    context: {
      element,
      oldTemplate,
      newTemplate
    }
  };
}
var CustomProps = { exports: {} };
var assign$1 = assign_1;
var entryFactory$b = EntryFactory_1, getBusinessObject$h = require$$2$2.getBusinessObject, cmdHelper$e = CmdHelper_1, elementHelper$7 = ElementHelper_1;
var findExtension$2 = Helper$1.findExtension, findExtensions$1 = Helper$1.findExtensions, findInputParameter$1 = Helper$1.findInputParameter, findOutputParameter$1 = Helper$1.findOutputParameter, findCamundaProperty = Helper$1.findCamundaProperty, findCamundaInOut = Helper$1.findCamundaInOut, findCamundaErrorEventDefinition$1 = Helper$1.findCamundaErrorEventDefinition;
var createCamundaProperty = CreateHelper.createCamundaProperty, createInputParameter$1 = CreateHelper.createInputParameter, createOutputParameter$1 = CreateHelper.createOutputParameter, createCamundaIn = CreateHelper.createCamundaIn, createCamundaOut = CreateHelper.createCamundaOut, createCamundaInWithBusinessKey = CreateHelper.createCamundaInWithBusinessKey, createCamundaFieldInjection = CreateHelper.createCamundaFieldInjection, createCamundaErrorEventDefinition = CreateHelper.createCamundaErrorEventDefinition, createError = CreateHelper.createError;
var handleLegacyScopes = handleLegacyScopes$3;
var getRoot = Utils.getRoot;
var PROPERTY_TYPE = "property", CAMUNDA_PROPERTY_TYPE = "camunda:property", CAMUNDA_INPUT_PARAMETER_TYPE$1 = "camunda:inputParameter", CAMUNDA_OUTPUT_PARAMETER_TYPE$1 = "camunda:outputParameter", CAMUNDA_IN_TYPE = "camunda:in", CAMUNDA_OUT_TYPE = "camunda:out", CAMUNDA_IN_BUSINESS_KEY_TYPE = "camunda:in:businessKey", CAMUNDA_EXECUTION_LISTENER_TYPE = "camunda:executionListener", CAMUNDA_FIELD = "camunda:field", CAMUNDA_ERROR_EVENT_DEFINITION = "camunda:errorEventDefinition";
var BASIC_MODDLE_TYPES = [
  "Boolean",
  "Integer",
  "String"
];
var EXTENSION_BINDING_TYPES = [
  CAMUNDA_PROPERTY_TYPE,
  CAMUNDA_INPUT_PARAMETER_TYPE$1,
  CAMUNDA_OUTPUT_PARAMETER_TYPE$1,
  CAMUNDA_IN_TYPE,
  CAMUNDA_OUT_TYPE,
  CAMUNDA_IN_BUSINESS_KEY_TYPE,
  CAMUNDA_FIELD,
  CAMUNDA_ERROR_EVENT_DEFINITION
];
var IO_BINDING_TYPES = [
  CAMUNDA_INPUT_PARAMETER_TYPE$1,
  CAMUNDA_OUTPUT_PARAMETER_TYPE$1
];
var IN_OUT_BINDING_TYPES = [
  CAMUNDA_IN_TYPE,
  CAMUNDA_OUT_TYPE,
  CAMUNDA_IN_BUSINESS_KEY_TYPE
];
CustomProps.exports = function(element, elementTemplates2, bpmnFactory, translate2) {
  var template2 = elementTemplates2.get(element);
  if (!template2) {
    return [];
  }
  var renderCustomField = function(id3, p, idx) {
    var propertyType = p.type;
    var entryOptions = {
      id: id3,
      description: p.description,
      label: p.label ? translate2(p.label) : p.label,
      modelProperty: id3,
      get: propertyGetter(id3, p),
      set: propertySetter(id3, p, bpmnFactory),
      validate: propertyValidator(id3, p, translate2)
    };
    var entry2;
    if (!propertyType) {
      propertyType = getDefaultType(p);
    }
    if (propertyType === "Boolean") {
      entry2 = entryFactory$b.checkbox(translate2, entryOptions);
    }
    if (propertyType === "String") {
      entry2 = entryFactory$b.textField(translate2, entryOptions);
    }
    if (propertyType === "Text") {
      entry2 = entryFactory$b.textBox(translate2, entryOptions);
    }
    if (propertyType === "Dropdown") {
      entryOptions.selectOptions = p.choices;
      entry2 = entryFactory$b.selectBox(translate2, entryOptions);
    }
    return entry2;
  };
  var groups = [];
  var id2, entry;
  var customFieldsGroup = {
    id: "customField",
    label: translate2("Custom Fields"),
    entries: []
  };
  template2.properties.forEach(function(p, idx) {
    id2 = "custom-" + template2.id + "-" + idx;
    entry = renderCustomField(id2, p);
    if (entry) {
      customFieldsGroup.entries.push(entry);
    }
  });
  if (customFieldsGroup.entries.length > 0) {
    groups.push(customFieldsGroup);
  }
  if (template2.scopes) {
    handleLegacyScopes(template2.scopes).forEach(function(scope) {
      var scopeType = scope.type;
      var idScopeName = scopeType.replace(/:/g, "_");
      var customScopeFieldsGroup = {
        id: "customField-" + idScopeName,
        label: translate2("Custom Fields for scope: ") + scopeType,
        entries: []
      };
      scope.properties.forEach(function(p, idx) {
        var propertyId = "custom-" + template2.id + "-" + idScopeName + "-" + idx;
        var scopedProperty = propertyWithScope(p, scope);
        entry = renderCustomField(propertyId, scopedProperty);
        if (entry) {
          customScopeFieldsGroup.entries.push(entry);
        }
      });
      if (customScopeFieldsGroup.entries.length > 0) {
        groups.push(customScopeFieldsGroup);
      }
    });
  }
  return groups;
};
function propertyGetter(name2, property2) {
  return function get2(element) {
    var value = getPropertyValue(element, property2);
    return objectWithKey(name2, value);
  };
}
function propertySetter(name2, property2, bpmnFactory) {
  return function set2(element, values2) {
    var value = values2[name2];
    return setPropertyValue(element, property2, value, bpmnFactory);
  };
}
function propertyValidator(name2, property2, translate2) {
  return function validate2(element, values2) {
    var value = values2[name2];
    var error2 = validateValue(value, property2, translate2);
    if (error2) {
      return objectWithKey(name2, error2);
    }
  };
}
function getPropertyValue(element, property2) {
  var bo = getBusinessObject$h(element);
  var binding = property2.binding, scope = property2.scope;
  var bindingType = binding.type, bindingName = binding.name;
  var propertyValue = property2.value || "";
  if (scope) {
    bo = findScopeElement(bo, scope);
    if (!bo) {
      return propertyValue;
    }
  }
  if (bindingType === "property") {
    var value = bo.get(bindingName);
    if (bindingName === "conditionExpression") {
      if (value) {
        return value.body;
      } else {
        return propertyValue;
      }
    } else {
      return typeof value !== "undefined" ? value : propertyValue;
    }
  }
  var camundaProperties, camundaProperty;
  if (bindingType === CAMUNDA_PROPERTY_TYPE) {
    if (scope) {
      camundaProperties = bo.get("properties");
    } else {
      camundaProperties = findExtension$2(bo, "camunda:Properties");
    }
    if (camundaProperties) {
      camundaProperty = findCamundaProperty(camundaProperties, binding);
      if (camundaProperty) {
        return camundaProperty.value;
      }
    }
    return propertyValue;
  }
  var inputOutput, ioParameter;
  if (IO_BINDING_TYPES.indexOf(bindingType) !== -1) {
    if (scope) {
      inputOutput = bo.get("inputOutput");
    } else {
      inputOutput = findExtension$2(bo, "camunda:InputOutput");
    }
    if (!inputOutput) {
      return propertyValue;
    }
  }
  if (bindingType === CAMUNDA_INPUT_PARAMETER_TYPE$1) {
    ioParameter = findInputParameter$1(inputOutput, binding);
    if (ioParameter) {
      if (binding.scriptFormat) {
        if (ioParameter.definition) {
          return ioParameter.definition.value;
        }
      } else {
        return ioParameter.value || "";
      }
    }
    return propertyValue;
  }
  if (binding.type === CAMUNDA_OUTPUT_PARAMETER_TYPE$1) {
    ioParameter = findOutputParameter$1(inputOutput, binding);
    if (ioParameter) {
      return ioParameter.name;
    }
    return propertyValue;
  }
  var ioElement;
  if (IN_OUT_BINDING_TYPES.indexOf(bindingType) != -1) {
    ioElement = findCamundaInOut(bo, binding);
    if (ioElement) {
      if (bindingType === CAMUNDA_IN_BUSINESS_KEY_TYPE) {
        return ioElement.businessKey;
      } else if (bindingType === CAMUNDA_OUT_TYPE) {
        return ioElement.target;
      } else if (bindingType === CAMUNDA_IN_TYPE) {
        return ioElement[binding.expression ? "sourceExpression" : "source"];
      }
    }
    return propertyValue;
  }
  if (bindingType === CAMUNDA_EXECUTION_LISTENER_TYPE) {
    var executionListener;
    if (scope) {
      executionListener = bo.get("executionListener");
    } else {
      executionListener = findExtension$2(bo, "camunda:ExecutionListener");
    }
    return executionListener.script.value;
  }
  var fieldInjection2;
  if (CAMUNDA_FIELD === bindingType) {
    var fieldInjections2 = findExtensions$1(bo, ["camunda:Field"]);
    fieldInjections2.forEach(function(item) {
      if (item.name === binding.name) {
        fieldInjection2 = item;
      }
    });
    if (fieldInjection2) {
      return fieldInjection2.string || fieldInjection2.expression;
    } else {
      return "";
    }
  }
  var errorEventDefinition;
  if (CAMUNDA_ERROR_EVENT_DEFINITION === bindingType) {
    errorEventDefinition = findCamundaErrorEventDefinition$1(bo, binding.errorRef);
    if (errorEventDefinition) {
      return errorEventDefinition.expression;
    } else {
      return "";
    }
  }
  throw unknownPropertyBinding(property2);
}
CustomProps.exports.getPropertyValue = getPropertyValue;
function setPropertyValue(element, property2, value, bpmnFactory) {
  var bo = getBusinessObject$h(element);
  var binding = property2.binding, scope = property2.scope;
  var bindingType = binding.type, bindingName = binding.name;
  var rootElement = getRoot(bo);
  var propertyValue;
  var updates = [];
  var extensionElements2;
  if (EXTENSION_BINDING_TYPES.indexOf(bindingType) !== -1) {
    extensionElements2 = bo.get("extensionElements");
    if (!extensionElements2) {
      extensionElements2 = elementHelper$7.createElement("bpmn:ExtensionElements", null, element, bpmnFactory);
      updates.push(cmdHelper$e.updateBusinessObject(element, bo, objectWithKey("extensionElements", extensionElements2)));
    }
  }
  if (scope) {
    bo = findScopeElement(bo, scope);
    if (!bo) {
      if (scope.name === "bpmn:Error") {
        bo = createError(scope.id, rootElement, bpmnFactory);
        updates.push(cmdHelper$e.addElementsTolist(bo, rootElement, "rootElements", [bo]));
      } else {
        bo = elementHelper$7.createElement(scope.name, null, element, bpmnFactory);
        updates.push(cmdHelper$e.addElementsTolist(bo, extensionElements2, "values", [bo]));
      }
    }
  }
  if (bindingType === "property") {
    if (bindingName === "conditionExpression") {
      propertyValue = elementHelper$7.createElement("bpmn:FormalExpression", {
        body: value,
        language: binding.scriptFormat
      }, bo, bpmnFactory);
    } else {
      var moddlePropertyDescriptor = bo.$descriptor.propertiesByName[bindingName];
      var moddleType = moddlePropertyDescriptor.type;
      if (BASIC_MODDLE_TYPES.indexOf(moddleType) === -1) {
        throw new Error("cannot set moddle type <" + moddleType + ">");
      }
      if (moddleType === "Boolean") {
        propertyValue = !!value;
      } else if (moddleType === "Integer") {
        propertyValue = parseInt(value, 10);
        if (isNaN(propertyValue)) {
          propertyValue = void 0;
        }
      } else {
        propertyValue = value;
      }
    }
    if (propertyValue !== void 0) {
      updates.push(cmdHelper$e.updateBusinessObject(element, bo, objectWithKey(bindingName, propertyValue)));
    }
  }
  var camundaProperties, existingCamundaProperty, newCamundaProperty;
  if (bindingType === CAMUNDA_PROPERTY_TYPE) {
    if (scope) {
      camundaProperties = bo.get("properties");
    } else {
      camundaProperties = findExtension$2(extensionElements2, "camunda:Properties");
    }
    if (!camundaProperties) {
      camundaProperties = elementHelper$7.createElement("camunda:Properties", null, bo, bpmnFactory);
      if (scope) {
        updates.push(cmdHelper$e.updateBusinessObject(element, bo, { properties: camundaProperties }));
      } else {
        updates.push(cmdHelper$e.addElementsTolist(element, extensionElements2, "values", [camundaProperties]));
      }
    }
    existingCamundaProperty = findCamundaProperty(camundaProperties, binding);
    newCamundaProperty = createCamundaProperty(binding, value, bpmnFactory);
    updates.push(cmdHelper$e.addAndRemoveElementsFromList(element, camundaProperties, "values", null, [newCamundaProperty], existingCamundaProperty ? [existingCamundaProperty] : []));
  }
  var inputOutput, existingIoParameter, newIoParameter;
  if (IO_BINDING_TYPES.indexOf(bindingType) !== -1) {
    if (scope) {
      inputOutput = bo.get("inputOutput");
    } else {
      inputOutput = findExtension$2(extensionElements2, "camunda:InputOutput");
    }
    if (!inputOutput) {
      inputOutput = elementHelper$7.createElement("camunda:InputOutput", null, bo, bpmnFactory);
      if (scope) {
        updates.push(cmdHelper$e.updateBusinessObject(element, bo, { inputOutput }));
      } else {
        updates.push(cmdHelper$e.addElementsTolist(element, extensionElements2, "values", inputOutput));
      }
    }
  }
  if (bindingType === CAMUNDA_INPUT_PARAMETER_TYPE$1) {
    existingIoParameter = findInputParameter$1(inputOutput, binding);
    newIoParameter = createInputParameter$1(binding, value, bpmnFactory);
    updates.push(cmdHelper$e.addAndRemoveElementsFromList(element, inputOutput, "inputParameters", null, [newIoParameter], existingIoParameter ? [existingIoParameter] : []));
  }
  if (bindingType === CAMUNDA_OUTPUT_PARAMETER_TYPE$1) {
    existingIoParameter = findOutputParameter$1(inputOutput, binding);
    newIoParameter = createOutputParameter$1(binding, value, bpmnFactory);
    updates.push(cmdHelper$e.addAndRemoveElementsFromList(element, inputOutput, "outputParameters", null, [newIoParameter], existingIoParameter ? [existingIoParameter] : []));
  }
  var existingInOut, newInOut;
  if (IN_OUT_BINDING_TYPES.indexOf(bindingType) !== -1) {
    existingInOut = findCamundaInOut(bo, binding);
    if (bindingType === CAMUNDA_IN_TYPE) {
      newInOut = createCamundaIn(binding, value, bpmnFactory);
    } else if (bindingType === CAMUNDA_OUT_TYPE) {
      newInOut = createCamundaOut(binding, value, bpmnFactory);
    } else {
      newInOut = createCamundaInWithBusinessKey(binding, value, bpmnFactory);
    }
    updates.push(cmdHelper$e.addAndRemoveElementsFromList(element, extensionElements2, "values", null, [newInOut], existingInOut ? [existingInOut] : []));
  }
  if (bindingType === CAMUNDA_FIELD) {
    var existingFieldInjections = findExtensions$1(bo, ["camunda:Field"]);
    var newFieldInjections = [];
    if (existingFieldInjections.length > 0) {
      existingFieldInjections.forEach(function(item) {
        if (item.name === binding.name) {
          newFieldInjections.push(createCamundaFieldInjection(binding, value, bpmnFactory));
        } else {
          newFieldInjections.push(item);
        }
      });
    } else {
      newFieldInjections.push(createCamundaFieldInjection(binding, value, bpmnFactory));
    }
    updates.push(cmdHelper$e.addAndRemoveElementsFromList(element, extensionElements2, "values", null, newFieldInjections, existingFieldInjections ? existingFieldInjections : []));
  }
  if (bindingType === CAMUNDA_ERROR_EVENT_DEFINITION) {
    var existingErrorEventDefinition = findCamundaErrorEventDefinition$1(bo, binding.errorRef);
    if (existingErrorEventDefinition) {
      updates.push(cmdHelper$e.updateBusinessObject(element, existingErrorEventDefinition, { expression: value }));
    } else {
      var newError = createError(binding.errorRef, rootElement, bpmnFactory), newEventDefinition = createCamundaErrorEventDefinition(binding, value, newError, extensionElements2, bpmnFactory);
      updates.push(cmdHelper$e.addAndRemoveElementsFromList(element, rootElement, "rootElements", null, [newError], []));
      updates.push(cmdHelper$e.addAndRemoveElementsFromList(element, extensionElements2, "values", null, [newEventDefinition], []));
    }
  }
  if (updates.length) {
    return updates;
  }
  console.warn("no update", element, property2, value);
}
CustomProps.exports.setPropertyValue = setPropertyValue;
function validateValue(value, property2, translate2) {
  var constraints = property2.constraints || {};
  if (constraints.notEmpty && isEmpty(value)) {
    return translate2("Must not be empty");
  }
  if (constraints.maxLength && value.length > constraints.maxLength) {
    return translate2("Must have max length {length}", { length: constraints.maxLength });
  }
  if (constraints.minLength && value.length < constraints.minLength) {
    return translate2("Must have min length {length}", { length: constraints.minLength });
  }
  var pattern = constraints.pattern, message2;
  if (pattern) {
    if (typeof pattern !== "string") {
      message2 = pattern.message;
      pattern = pattern.value;
    }
    if (!matchesPattern(value, pattern)) {
      return message2 || translate2("Must match pattern {pattern}", { pattern });
    }
  }
}
function propertyWithScope(property2, scope) {
  var scopeName = scope.type, scopeId = scope.id;
  if (!scopeName) {
    return property2;
  }
  return assign$1({}, property2, {
    scope: {
      name: scopeName,
      id: scopeId
    }
  });
}
function objectWithKey(key, value) {
  var obj = {};
  obj[key] = value;
  return obj;
}
function matchesPattern(str, pattern) {
  var regexp = new RegExp(pattern);
  return regexp.test(str);
}
function isEmpty(str) {
  return !str || /^\s*$/.test(str);
}
function unknownPropertyBinding(property2) {
  var binding = property2.binding;
  return new Error("unknown binding: <" + binding.type + ">");
}
function getDefaultType(property2) {
  var binding = property2.binding, bindingType = binding.type;
  if (bindingType === PROPERTY_TYPE || bindingType === CAMUNDA_PROPERTY_TYPE || bindingType === CAMUNDA_IN_TYPE || bindingType === CAMUNDA_IN_BUSINESS_KEY_TYPE || bindingType === CAMUNDA_OUT_TYPE || bindingType === CAMUNDA_FIELD) {
    return "String";
  }
  if (bindingType === CAMUNDA_EXECUTION_LISTENER_TYPE) {
    return "Hidden";
  }
}
function findScopeElement(businessObject, scope) {
  var scopeName = scope.name, scopeId = scope.id;
  if (scopeName === "bpmn:Error") {
    var errorEventDefinition = findCamundaErrorEventDefinition$1(businessObject, scopeId);
    if (errorEventDefinition) {
      return errorEventDefinition.errorRef;
    }
  }
  return findExtension$2(businessObject, scopeName);
}
var is$a = require$$2$2.is, getBusinessObject$g = require$$2$2.getBusinessObject;
var isAny$1 = require$$1$2.isAny;
var getVariablesForScope = require$$2.getVariablesForScope;
var filter$3 = require$$1$1.filter, map = require$$1$1.map, sortBy = require$$1$1.sortBy;
var elementHelper$6 = ElementHelper_1, cmdHelper$d = CmdHelper_1, utils$3 = Utils;
var entryFactory$a = EntryFactory_1, scriptImplementation = Script;
var domQuery$7 = require$$6.query;
var InputOutputParameter$3 = function(parameter, bpmnFactory, options, translate2) {
  var typeInfo = {
    "camunda:Map": {
      value: "map",
      label: translate2("Map")
    },
    "camunda:List": {
      value: "list",
      label: translate2("List")
    },
    "camunda:Script": {
      value: "script",
      label: translate2("Script")
    }
  };
  options = options || {};
  var idPrefix = options.idPrefix || "";
  var getParameter = options.getParameter && typeof options.getParameter === "function" ? function() {
    return options.getParameter();
  } : function() {
    return parameter;
  };
  var result = {}, entries = [];
  result.entries = entries;
  var collapsible2 = entryFactory$a.collapsible({
    id: idPrefix + "collapsible",
    title: parameter.name,
    description: getDescription(parameter),
    cssClasses: ["bpp-collapsible--with-mapping"],
    open: false,
    onRemove: options.onRemove,
    onToggle: options.onToggle,
    get: function() {
      return {
        title: getParameter().name,
        description: getDescription(getParameter())
      };
    }
  });
  var isOpen = options.isOpen || collapsible2.isOpen;
  result.setOpen = function(value, parentElement) {
    var entryNode = domQuery$7('[data-entry="' + collapsible2.id + '"]', parentElement);
    collapsible2.setOpen(value, entryNode);
  };
  entries.push(collapsible2);
  entries.push(entryFactory$a.validationAwareTextField(translate2, {
    id: idPrefix + "parameterName",
    label: is$a(parameter, "camunda:InputParameter") ? translate2("Local Variable Name") : translate2("Process Variable Name"),
    modelProperty: "name",
    getProperty: function(element, node2) {
      return parameter.name;
    },
    setProperty: function(element, values2, node2) {
      return cmdHelper$d.updateBusinessObject(element, parameter, values2);
    },
    validate: function(element, values2, node2) {
      var validation = {};
      var nameValue = values2.name;
      if (nameValue) {
        if (utils$3.containsSpace(nameValue)) {
          validation.name = translate2("Name must not contain spaces");
        }
      } else {
        validation.name = translate2("Parameter must have a name");
      }
      return validation;
    },
    hidden: function(element, node2) {
      return !isOpen();
    }
  }));
  var selectOptions = [
    { value: "text", name: translate2("String or Expression") },
    { value: "script", name: translate2("Script") },
    { value: "list", name: translate2("List") },
    { value: "map", name: translate2("Map") }
  ];
  entries.push(entryFactory$a.selectBox(translate2, {
    id: idPrefix + "parameterType",
    label: translate2("Variable Assignment Type"),
    selectOptions,
    modelProperty: "parameterType",
    get: function(element, node2) {
      var parameterType = "text";
      var definition = getParameter().get("definition");
      if (typeof definition !== "undefined") {
        var type = definition.$type;
        parameterType = typeInfo[type].value;
      }
      return {
        parameterType
      };
    },
    set: function(element, values2, node2) {
      var properties2 = {
        value: void 0,
        definition: void 0
      };
      var createParameterTypeElem = function(type) {
        return createElement$2(type, getParameter(), bpmnFactory);
      };
      var parameterType = values2.parameterType;
      if (parameterType === "script") {
        properties2.definition = createParameterTypeElem("camunda:Script");
      } else if (parameterType === "list") {
        properties2.definition = createParameterTypeElem("camunda:List");
      } else if (parameterType === "map") {
        properties2.definition = createParameterTypeElem("camunda:Map");
      }
      return cmdHelper$d.updateBusinessObject(element, getParameter(), properties2);
    },
    hidden: function(element, node2) {
      return !isOpen();
    }
  }));
  entries.push(entryFactory$a.autoSuggest(translate2, {
    id: idPrefix + "parameterType-text",
    label: translate2("Variable Assignment Value"),
    description: translate2('Start typing "${}" to create an expression.'),
    modelProperty: "value",
    get: function(element, node2) {
      return {
        value: getParameter().value
      };
    },
    set: function(element, values2, node2) {
      values2.value = values2.value || void 0;
      return cmdHelper$d.updateBusinessObject(element, getParameter(), values2);
    },
    show: function(element, node2) {
      return isOpen() && !getParameter().definition;
    },
    getItems: function(element) {
      var scope = getScope(element), rootElement = getRootElement(element);
      var variables = getVariablesForScope(scope, rootElement);
      variables = filter$3(variables, function(variable) {
        var origin = variable.origin, withOutCurrent = filter$3(origin, function(o) {
          return o.id !== element.id;
        });
        return !!withOutCurrent.length;
      });
      var sorted = sortByName(variables);
      return map(sorted, function(variable) {
        return variable.name;
      });
    },
    canSuggest: function(word, editorNode, focusNode) {
      var globalIndex = findWordInContentEditable(word, editorNode, focusNode);
      if (isInsideExpression(editorNode.innerText, globalIndex)) {
        return true;
      }
      if (isInsideUnclosedExpression(editorNode.innerText, globalIndex)) {
        return true;
      }
      return false;
    }
  }));
  var script = scriptImplementation("scriptFormat", "value", true, translate2, { idPrefix });
  entries.push({
    id: idPrefix + "parameterType-script",
    html: '<div data-show="show">' + script.template + "</div>",
    get: function(element, node2) {
      return isScript(getParameter().definition) ? script.get(element, getParameter().definition) : {};
    },
    set: function(element, values2, node2) {
      var update2 = script.set(element, values2);
      return cmdHelper$d.updateBusinessObject(element, getParameter().definition, update2);
    },
    validate: function(element, values2, node2) {
      return isScript(getParameter().definition) ? script.validate(element, getParameter().definition) : {};
    },
    script,
    show: function(element, node2) {
      return isOpen() && getParameter().definition && isScript(getParameter().definition);
    }
  });
  entries.push(entryFactory$a.table(translate2, {
    id: idPrefix + "parameterType-list",
    modelProperties: ["value"],
    labels: [translate2("Value")],
    addLabel: translate2("Add Value"),
    getElements: function(element, node2) {
      if (isList(getParameter().definition)) {
        return getParameter().definition.items;
      }
      return [];
    },
    updateElement: function(element, values2, node2, idx) {
      var item = getParameter().definition.items[idx];
      return cmdHelper$d.updateBusinessObject(element, item, values2);
    },
    addElement: function(element, node2) {
      var newValue = createElement$2("camunda:Value", getParameter().definition, bpmnFactory, { value: void 0 });
      return cmdHelper$d.addElementsTolist(element, getParameter().definition, "items", [newValue]);
    },
    removeElement: function(element, node2, idx) {
      return cmdHelper$d.removeElementsFromList(element, getParameter().definition, "items", null, [getParameter().definition.items[idx]]);
    },
    editable: function(element, node2, prop, idx) {
      var item = getParameter().definition.items[idx];
      return !isMap(item) && !isList(item) && !isScript(item);
    },
    setControlValue: function(element, node2, input, prop, value, idx) {
      var item = getParameter().definition.items[idx];
      if (!isMap(item) && !isList(item) && !isScript(item)) {
        input.value = value;
      } else {
        input.value = typeInfo[item.$type].label;
      }
    },
    show: function(element, node2) {
      return isOpen() && getParameter().definition && isList(getParameter().definition);
    }
  }));
  entries.push(entryFactory$a.table(translate2, {
    id: idPrefix + "parameterType-map",
    modelProperties: ["key", "value"],
    labels: [translate2("Key"), translate2("Value")],
    addLabel: translate2("Add Entry"),
    getElements: function(element, node2) {
      if (getParameter() && isMap(getParameter().definition)) {
        return getParameter().definition.entries;
      }
      return [];
    },
    updateElement: function(element, values2, node2, idx) {
      var entry = getParameter().definition.entries[idx];
      if (isMap(entry.definition) || isList(entry.definition) || isScript(entry.definition)) {
        values2 = {
          key: values2.key
        };
      }
      return cmdHelper$d.updateBusinessObject(element, entry, values2);
    },
    addElement: function(element, node2) {
      var newEntry = createElement$2("camunda:Entry", getParameter().definition, bpmnFactory, { key: void 0, value: void 0 });
      return cmdHelper$d.addElementsTolist(element, getParameter().definition, "entries", [newEntry]);
    },
    removeElement: function(element, node2, idx) {
      return cmdHelper$d.removeElementsFromList(element, getParameter().definition, "entries", null, [getParameter().definition.entries[idx]]);
    },
    editable: function(element, node2, prop, idx) {
      var entry = getParameter().definition.entries[idx];
      return prop === "key" || !isMap(entry.definition) && !isList(entry.definition) && !isScript(entry.definition);
    },
    setControlValue: function(element, node2, input, prop, value, idx) {
      var entry = getParameter().definition.entries[idx];
      if (prop === "key" || !isMap(entry.definition) && !isList(entry.definition) && !isScript(entry.definition)) {
        input.value = value;
      } else {
        input.value = typeInfo[entry.definition.$type].label;
      }
    },
    show: function(element, node2) {
      return isOpen() && getParameter().definition && isMap(getParameter().definition);
    }
  }));
  return result;
};
function createElement$2(type, parent2, factory2, properties2) {
  return elementHelper$6.createElement(type, properties2, parent2, factory2);
}
function isScript(elem) {
  return is$a(elem, "camunda:Script");
}
function isList(elem) {
  return is$a(elem, "camunda:List");
}
function isMap(elem) {
  return is$a(elem, "camunda:Map");
}
function sortByName(variables) {
  return sortBy(variables, function(variable) {
    return variable.name;
  });
}
function getScope(element) {
  var businessObject = getBusinessObject$g(element);
  if (isAny$1(businessObject, ["bpmn:Process", "bpmn:SubProcess"])) {
    return businessObject.id;
  }
  var parent2 = businessObject;
  while (parent2.$parent && !isAny$1(parent2, ["bpmn:Process", "bpmn:SubProcess"])) {
    parent2 = parent2.$parent;
  }
  return parent2.id;
}
function getRootElement(element) {
  var businessObject = getBusinessObject$g(element), parent2 = businessObject;
  while (parent2.$parent && !is$a(parent2, "bpmn:Process")) {
    parent2 = parent2.$parent;
  }
  return parent2;
}
function isInsideExpression(value, index2) {
  var openIndex = value.indexOf("${"), closeIndex = value.indexOf("}");
  return openIndex > -1 && openIndex <= index2 && closeIndex > -1 && index2 < closeIndex;
}
function isInsideUnclosedExpression(value, index2) {
  var closeIndex = value.lastIndexOf("}", index2), openIndex = value.indexOf("${", closeIndex + 1);
  return openIndex > -1 && openIndex <= index2;
}
function findWordInContentEditable(word, editorNode, focusNode) {
  var children = editorNode.childNodes, textBefore = "";
  for (var i = 0; i <= children.length - 1; i++) {
    var child = children[i];
    if (child.contains(focusNode)) {
      break;
    }
    textBefore += (child.innerText || child.wholeText) + "\n";
  }
  return textBefore.length + (word.index || 0);
}
function getDescription(parameter) {
  var definition = parameter.get("definition");
  if (!definition) {
    return parameter.value;
  }
  if (isScript(definition)) {
    return definition.value;
  } else if (isList(definition)) {
    return "List";
  } else if (isMap(definition)) {
    return "Map";
  }
}
var assign = require$$1$1.assign, flatten$5 = require$$1$1.flatten, filter$2 = require$$1$1.filter, findIndex$1 = require$$1$1.findIndex, forEach$2 = require$$1$1.forEach;
var domClasses$1 = require$$6.classes, domEvent$1 = require$$6.event, domify$1 = require$$6.domify, domQuery$6 = require$$6.query;
var getBusinessObject$f = require$$2$2.getBusinessObject;
var findExtension$1 = Helper$1.findExtension, findInputParameter = Helper$1.findInputParameter;
var createInputParameter = CreateHelper.createInputParameter;
var escapeHTML$1 = Utils.escapeHTML;
var entryFactory$9 = EntryFactory_1;
var cmdHelper$c = CmdHelper_1, elementHelper$5 = ElementHelper_1;
var InputOutputParameter$2 = InputOutputParameter$3;
var CAMUNDA_INPUT_PARAMETER_TYPE = "camunda:inputParameter";
var MAX_DESCRIPTION_LENGTH$1 = 200;
var EMPTY_PARAMETER$1 = {
  get: function() {
  },
  set: function() {
  }
};
var InputParametersProps$1 = function(group, element, elementTemplates2, bpmnFactory, translate2) {
  var template2 = elementTemplates2.get(element);
  if (!template2) {
    return [];
  }
  var inputEntries = [];
  function onToggle(value, entryNode) {
    if (!value) {
      return;
    }
    var currentEntryId = entryNode.dataset.entry;
    inputEntries.forEach(function(entries) {
      var collapsible2 = entries[0];
      if (collapsible2.id === currentEntryId) {
        return;
      }
      var entryNode2 = domQuery$6('[data-entry="' + collapsible2.id + '"]');
      collapsible2.setOpen(false, entryNode2);
    });
  }
  function renderInputParameter(id2, templateProperty) {
    var parameterEntries = [], collapsibleEntry;
    var bo = getBusinessObject$f(element), inputOutput = findExtension$1(bo, "camunda:InputOutput");
    if (!inputOutput) {
      return parameterEntries;
    }
    var getParameter = function() {
      return findInputParameter(inputOutput, templateProperty.binding) || EMPTY_PARAMETER$1;
    };
    var parameter = getParameter();
    var isOpen = function() {
      return collapsibleEntry.isOpen();
    };
    var assignmentIsOn = function() {
      var inputOutput2 = findExtension$1(getBusinessObject$f(element), "camunda:InputOutput"), parameter2 = findInputParameter(inputOutput2, templateProperty.binding);
      return !!parameter2;
    };
    var options = {
      idPrefix: id2 + "-",
      onToggle,
      getParameter,
      isOpen: function() {
        return isOpen() && assignmentIsOn();
      }
    };
    var inputImplementation = InputOutputParameter$2(parameter, bpmnFactory, options, translate2);
    parameterEntries = inputImplementation.entries;
    var nameIdx = findEntry$1(parameterEntries, id2 + "-parameterName");
    collapsibleEntry = parameterEntries[findEntry$1(parameterEntries, id2 + "-collapsible")];
    var defaultGet = collapsibleEntry.get;
    collapsibleEntry.get = function() {
      return assign(defaultGet(), {
        title: templateProperty.label ? translate2(templateProperty.label) : templateProperty.binding.name
      });
    };
    removeEntry$1(parameterEntries, nameIdx);
    if (templateProperty.description) {
      parameterEntries.splice(1, 0, createDescriptionEntry$1(templateProperty.description, id2, collapsibleEntry.isOpen, translate2));
    }
    parameterEntries.splice(templateProperty.description ? 2 : 1, 0, entryFactory$9.toggleSwitch(translate2, {
      id: id2 + "-assignment-toggle",
      label: translate2("Local Variable Assignment"),
      modelProperty: "isActive",
      labelOn: translate2("On"),
      labelOff: translate2("Off"),
      descriptionOff: translate2("The parameter won't be created as local variable."),
      isOn: assignmentIsOn,
      get: function(element2, node2) {
        return { isActive: assignmentIsOn() };
      },
      set: function(element2, values2, node2) {
        var isActive = values2.isActive || false;
        if (isActive) {
          return createNewInputParameter(element2, templateProperty.binding, bpmnFactory);
        } else {
          return removeInputParameter(element2, templateProperty.binding);
        }
      },
      hidden: function(element2, node2) {
        return !isOpen();
      }
    }));
    return parameterEntries;
  }
  var inputParameters2 = filter$2(template2.properties, function(p) {
    return !p.type && p.binding.type === CAMUNDA_INPUT_PARAMETER_TYPE;
  });
  forEach$2(inputParameters2, function(property2, idx) {
    var id2 = "template-inputs-" + template2.id + "-" + idx;
    inputEntries.push(renderInputParameter(id2, property2));
  });
  group.entries = group.entries.concat(flatten$5(inputEntries));
};
function findEntry$1(entries, id2) {
  return findIndex$1(entries, function(entry) {
    return entry.id === id2;
  });
}
function removeEntry$1(entries, idx) {
  entries.splice(idx, 1);
}
function createDescriptionEntry$1(description, id2, show, translate2) {
  description = escapeHTML$1(description);
  var html = domify$1('<p class="description description--expanded" data-show="show"></p>');
  var descriptionText = domify$1('<span class="description__text">' + description + "</span>");
  html.appendChild(descriptionText);
  function toggleExpanded(expanded2) {
    if (expanded2) {
      domClasses$1(html).add("description--expanded");
      descriptionText.textContent = description + " ";
      expand.textContent = translate2("Less");
    } else {
      domClasses$1(html).remove("description--expanded");
      descriptionText.textContent = descriptionShortened + " ... ";
      expand.textContent = translate2("More");
    }
  }
  var descriptionShortened, expand, expanded = false;
  if (description.length > MAX_DESCRIPTION_LENGTH$1) {
    descriptionShortened = description.slice(0, MAX_DESCRIPTION_LENGTH$1);
    expand = domify$1('<span class="bpp-entry-link description__expand">' + translate2("More") + "</span>");
    domEvent$1.bind(expand, "click", function() {
      expanded = !expanded;
      toggleExpanded(expanded);
    });
    html.appendChild(expand);
    toggleExpanded(expanded);
  }
  return {
    id: id2 + "-description",
    html,
    show
  };
}
function removeInputParameter(element, binding) {
  var bo = getBusinessObject$f(element), updates = [], extensionElements2 = bo.get("extensionElements");
  if (!extensionElements2) {
    return updates;
  }
  var inputOutput = findExtension$1(extensionElements2, "camunda:InputOutput");
  if (!inputOutput) {
    return updates;
  }
  var inputParameter = findInputParameter(inputOutput, binding);
  if (!inputParameter) {
    return updates;
  }
  updates.push(cmdHelper$c.removeElementsFromList(element, inputOutput, "inputParameters", null, [inputParameter]));
  return updates;
}
function createNewInputParameter(element, binding, bpmnFactory) {
  var bo = getBusinessObject$f(element), updates = [], extensionElements2 = bo.get("extensionElements");
  if (!extensionElements2) {
    extensionElements2 = elementHelper$5.createElement("bpmn:ExtensionElements", null, element, bpmnFactory);
    updates.push(cmdHelper$c.updateBusinessObject(element, bo, { extensionElements: extensionElements2 }));
  }
  var inputOutput = findExtension$1(extensionElements2, "camunda:InputOutput");
  if (!inputOutput) {
    inputOutput = elementHelper$5.createElement("camunda:InputOutput", null, bo, bpmnFactory);
    updates.push(cmdHelper$c.addElementsTolist(element, extensionElements2, "values", inputOutput));
  }
  var inputParameter = createInputParameter(binding, null, bpmnFactory);
  updates.push(cmdHelper$c.addAndRemoveElementsFromList(element, inputOutput, "inputParameters", null, [inputParameter], []));
  return updates;
}
var flatten$4 = require$$1$1.flatten, filter$1 = require$$1$1.filter, forEach$1 = require$$1$1.forEach;
var entryFactory$8 = EntryFactory_1, getBusinessObject$e = require$$2$2.getBusinessObject, cmdHelper$b = CmdHelper_1, elementHelper$4 = ElementHelper_1;
var findExtension = Helper$1.findExtension, findOutputParameter = Helper$1.findOutputParameter;
var createOutputParameter = CreateHelper.createOutputParameter;
var domClasses = require$$6.classes, domEvent = require$$6.event, domify = require$$6.domify, domQuery$5 = require$$6.query;
var escapeHTML = Utils.escapeHTML;
var utils$2 = Utils;
var CAMUNDA_OUTPUT_PARAMETER_TYPE = "camunda:outputParameter";
var MAX_DESCRIPTION_LENGTH = 200;
var EMPTY_PARAMETER = {
  get: function() {
  },
  set: function() {
  }
};
var OutputParametersProps$1 = function(group, element, elementTemplates2, bpmnFactory, translate2) {
  var template2 = elementTemplates2.get(element);
  if (!template2) {
    return [];
  }
  var outputEntries = [];
  function onToggle(value, entryNode) {
    if (!value) {
      return;
    }
    var currentEntryId = entryNode.dataset.entry;
    outputEntries.forEach(function(entries) {
      var collapsible2 = entries[0];
      if (collapsible2.id === currentEntryId) {
        return;
      }
      var entryNode2 = domQuery$5('[data-entry="' + collapsible2.id + '"]');
      collapsible2.setOpen(false, entryNode2);
    });
  }
  function renderOutputParameter(id2, templateProperty) {
    var parameterEntries = [];
    var bo = getBusinessObject$e(element), inputOutput = findExtension(bo, "camunda:InputOutput");
    if (!inputOutput) {
      return parameterEntries;
    }
    var getParameter = function() {
      return findOutputParameter(inputOutput, templateProperty.binding) || EMPTY_PARAMETER;
    };
    var collapsible2 = entryFactory$8.collapsible({
      id: id2 + "-collapsible",
      title: translate2(templateProperty.label),
      cssClasses: [
        "bpp-collapsible--with-mapping",
        "bpp-collapsible--with-template-out"
      ],
      onToggle,
      open: false,
      get: function() {
        return {
          title: translate2(templateProperty.label),
          description: getParameter().name
        };
      }
    });
    parameterEntries.push(collapsible2);
    var isOpen = collapsible2.isOpen;
    var assignmentIsOn = function() {
      var inputOutput2 = findExtension(getBusinessObject$e(element), "camunda:InputOutput"), parameter = findOutputParameter(inputOutput2, templateProperty.binding);
      return !!parameter;
    };
    if (templateProperty.description) {
      parameterEntries.push(createDescriptionEntry(templateProperty.description, id2, isOpen, translate2));
    }
    parameterEntries.splice(templateProperty.description ? 2 : 1, 0, entryFactory$8.toggleSwitch(translate2, {
      id: id2 + "-assignment-toggle",
      label: translate2("Process Variable Assignment"),
      modelProperty: "isActive",
      labelOn: translate2("On"),
      labelOff: translate2("Off"),
      descriptionOff: translate2("The parameter won't be available in the process scope."),
      isOn: assignmentIsOn,
      get: function(element2, node2) {
        return { isActive: assignmentIsOn() };
      },
      set: function(element2, values2, node2) {
        var isActive = values2.isActive || false;
        if (isActive) {
          return createNewOutputParameter(element2, templateProperty.binding, bpmnFactory);
        } else {
          return removeOutputParameter(element2, templateProperty.binding);
        }
      },
      hidden: function(element2, node2) {
        return !isOpen();
      }
    }));
    parameterEntries.push(entryFactory$8.validationAwareTextField(translate2, {
      id: id2 + "-variableName",
      label: translate2("Assign to Process Variable"),
      modelProperty: "variableName",
      getProperty: function(element2) {
        return getParameter().name;
      },
      setProperty: function(element2, values2) {
        return cmdHelper$b.updateBusinessObject(element2, getParameter(), { name: values2.variableName });
      },
      validate: function(element2, values2) {
        var validation = {}, nameValue = values2.variableName;
        if (nameValue) {
          if (utils$2.containsSpace(nameValue)) {
            validation.variableName = translate2("Process Variable Name must not contain spaces.");
          }
        } else {
          validation.variableName = translate2("Process Variable Name must not be empty.");
        }
        return validation;
      },
      hidden: function(element2, node2) {
        return !isOpen() || !assignmentIsOn();
      }
    }));
    return parameterEntries;
  }
  var outputParameters2 = filter$1(template2.properties, function(p) {
    return !p.type && p.binding.type === CAMUNDA_OUTPUT_PARAMETER_TYPE;
  });
  forEach$1(outputParameters2, function(property2, idx) {
    var id2 = "template-outputs-" + template2.id + "-" + idx;
    outputEntries.push(renderOutputParameter(id2, property2));
  });
  group.entries = group.entries.concat(flatten$4(outputEntries));
};
function createDescriptionEntry(description, id2, show, translate2) {
  description = escapeHTML(description);
  var html = domify('<p class="description description--expanded" data-show="show"></p>');
  var descriptionText = domify('<span class="description__text">' + description + "</span>");
  html.appendChild(descriptionText);
  function toggleExpanded(expanded2) {
    if (expanded2) {
      domClasses(html).add("description--expanded");
      descriptionText.textContent = description + " ";
      expand.textContent = translate2("Less");
    } else {
      domClasses(html).remove("description--expanded");
      descriptionText.textContent = descriptionShortened + " ... ";
      expand.textContent = translate2("More");
    }
  }
  var descriptionShortened, expand, expanded = false;
  if (description.length > MAX_DESCRIPTION_LENGTH) {
    descriptionShortened = description.slice(0, MAX_DESCRIPTION_LENGTH);
    expand = domify('<span class="bpp-entry-link description__expand">' + translate2("More") + "</span>");
    domEvent.bind(expand, "click", function() {
      expanded = !expanded;
      toggleExpanded(expanded);
    });
    html.appendChild(expand);
    toggleExpanded(expanded);
  }
  return {
    id: id2 + "-description",
    html,
    show
  };
}
function removeOutputParameter(element, binding) {
  var bo = getBusinessObject$e(element), updates = [], extensionElements2 = bo.get("extensionElements");
  if (!extensionElements2) {
    return updates;
  }
  var inputOutput = findExtension(extensionElements2, "camunda:InputOutput");
  if (!inputOutput) {
    return updates;
  }
  var outputParameter = findOutputParameter(inputOutput, binding);
  if (!outputParameter) {
    return updates;
  }
  updates.push(cmdHelper$b.removeElementsFromList(element, inputOutput, "outputParameters", null, [outputParameter]));
  return updates;
}
function createNewOutputParameter(element, binding, bpmnFactory) {
  var bo = getBusinessObject$e(element), updates = [], extensionElements2 = bo.get("extensionElements");
  if (!extensionElements2) {
    extensionElements2 = elementHelper$4.createElement("bpmn:ExtensionElements", null, element, bpmnFactory);
    updates.push(cmdHelper$b.updateBusinessObject(element, bo, { extensionElements: extensionElements2 }));
  }
  var inputOutput = findExtension(extensionElements2, "camunda:InputOutput");
  if (!inputOutput) {
    inputOutput = elementHelper$4.createElement("camunda:InputOutput", null, bo, bpmnFactory);
    updates.push(cmdHelper$b.addElementsTolist(element, extensionElements2, "values", inputOutput));
  }
  var outputParameter = createOutputParameter(binding, null, bpmnFactory);
  updates.push(cmdHelper$b.addAndRemoveElementsFromList(element, inputOutput, "outputParameters", null, [outputParameter], []));
  return updates;
}
var cmdHelper$a = CmdHelper_1;
var entryFactory$7 = EntryFactory_1;
var eventDefinitionReference = EventDefinitionReference, elementReferenceProperty = ElementReferenceProperty;
var domQuery$4 = require$$6.query;
var ErrorsEntries$1 = function(error2, bpmnFactory, element, options, translate2) {
  options = options || {};
  var idPrefix = options.idPrefix || "";
  var getError = options.getError && typeof options.getError === "function" ? function() {
    return options.getError();
  } : function() {
    return error2;
  };
  var result = {}, entries = [];
  result.entries = entries;
  var getCollapsibleTitle = function() {
    var error3 = getError();
    var title = "No Error referenced";
    if (error3.errorRef) {
      title = error3.errorRef.name;
      if (error3.errorRef.errorCode) {
        title += " (code = " + error3.errorRef.errorCode + ")";
      }
    }
    return title;
  };
  var collapsible2 = entryFactory$7.collapsible({
    id: idPrefix + "collapsible",
    title: getCollapsibleTitle(),
    description: getError().expression || "",
    cssClasses: ["bpp-collapsible-error"],
    open: false,
    onRemove: options.onRemove,
    onToggle: options.onToggle,
    get: function() {
      return {
        title: getCollapsibleTitle(),
        description: getError().expression || ""
      };
    }
  });
  var isOpen = options.isOpen || collapsible2.isOpen;
  result.setOpen = function(value) {
    var entryNode = domQuery$4('[data-entry="' + collapsible2.id + '"]');
    collapsible2.setOpen(value, entryNode);
  };
  entries.push(collapsible2);
  entries.push(entryFactory$7.validationAwareTextField(translate2, {
    id: idPrefix + "error-expression",
    label: translate2("Throw Expression"),
    modelProperty: "expression",
    getProperty: function(element2, node2) {
      return error2.expression;
    },
    setProperty: function(element2, values2, node2) {
      return cmdHelper$a.updateBusinessObject(element2, error2, values2);
    },
    validate: function(element2, values2, node2) {
      var validation = {};
      var expressionValue = values2.expression;
      if (!expressionValue) {
        validation.expression = translate2("Error must have an expression");
      }
      return validation;
    },
    hidden: function(element2, node2) {
      return !isOpen();
    }
  }));
  entries.push.apply(entries, eventDefinitionReference(element, error2, bpmnFactory, {
    id: idPrefix + "error-reference",
    label: translate2("Global Error referenced"),
    elementName: "error",
    elementType: "bpmn:Error",
    referenceProperty: "errorRef",
    newElementIdPrefix: "Error_",
    hidden: function(element2, node2) {
      return !isOpen();
    }
  }));
  entries.push.apply(entries, elementReferenceProperty(element, error2, bpmnFactory, translate2, {
    id: idPrefix + "error-element-name",
    label: translate2("Name"),
    referenceProperty: "errorRef",
    modelProperty: "name",
    shouldValidate: true,
    hidden: function(element2, node2) {
      return !isOpen();
    }
  }));
  entries.push.apply(entries, elementReferenceProperty(element, error2, bpmnFactory, translate2, {
    id: idPrefix + "error-element-code",
    label: translate2("Code"),
    referenceProperty: "errorRef",
    modelProperty: "errorCode",
    shouldValidate: true,
    hidden: function(element2, node2) {
      return !isOpen();
    }
  }));
  entries.push.apply(entries, elementReferenceProperty(element, error2, bpmnFactory, translate2, {
    id: idPrefix + "error-element-message",
    label: translate2("Message"),
    referenceProperty: "errorRef",
    modelProperty: "errorMessage",
    hidden: function(element2, node2) {
      return !isOpen();
    }
  }));
  return result;
};
var forEach = require$$1$1.forEach, filter = require$$1$1.filter, flatten$3 = require$$1$1.flatten, findIndex = require$$1$1.findIndex;
var getBusinessObject$d = require$$2$2.getBusinessObject;
var findExtensions = Helper$1.findExtensions, findCamundaErrorEventDefinition = Helper$1.findCamundaErrorEventDefinition;
var ErrorEntries = ErrorsEntries$1;
var entryFactory$6 = EntryFactory_1;
var domQuery$3 = require$$6.query;
var CAMUNDA_ERROR_EVENT_DEFINITION_TYPE = "camunda:errorEventDefinition";
var EMPTY_ERROR = {
  get: function() {
  },
  set: function() {
  },
  errorRef: {}
};
var ErrorsProps$1 = function(group, element, elementTemplates2, bpmnFactory, translate2) {
  var template2 = elementTemplates2.get(element);
  if (!template2) {
    return [];
  }
  var errorEntries = [];
  function onToggle(value, entryNode) {
    if (!value) {
      return;
    }
    var currentEntryId = entryNode.dataset.entry;
    errorEntries.forEach(function(entries) {
      var collapsible2 = entries[0];
      if (collapsible2.id === currentEntryId) {
        return;
      }
      var entryNode2 = domQuery$3('[data-entry="' + collapsible2.id + '"]');
      collapsible2.setOpen(false, entryNode2);
    });
  }
  function renderError(id2, templateProperty) {
    var binding = templateProperty.binding, bindingErrorRef = binding.errorRef, errorEntries2 = [], collapsibleEntry;
    var bo = getBusinessObject$d(element), errorEventDefinitions = findExtensions(bo, ["camunda:ErrorEventDefinition"]);
    if (!errorEventDefinitions) {
      return errorEntries2;
    }
    var getError = function() {
      var definition = findCamundaErrorEventDefinition(element, bindingErrorRef);
      if (!definition) {
        return EMPTY_ERROR;
      }
      return definition;
    };
    var error2 = getError();
    var isOpen = function() {
      return collapsibleEntry.isOpen();
    };
    var options = {
      idPrefix: id2 + "-",
      onToggle,
      getError,
      isOpen: function() {
        return isOpen();
      }
    };
    var errorImplementation = ErrorEntries(error2, bpmnFactory, element, options, translate2);
    errorEntries2 = errorImplementation.entries;
    var errorReferenceIdx = findEntry(errorEntries2, id2 + "-error-reference");
    collapsibleEntry = errorEntries2[findEntry(errorEntries2, id2 + "-collapsible")];
    var expressionIdx = findEntry(errorEntries2, id2 + "-error-expression");
    removeEntry(errorEntries2, expressionIdx);
    var expressionEntry = entryFactory$6.textField(translate2, {
      id: id2 + "-error-expression",
      label: translate2("Throw Expression"),
      modelProperty: "expression",
      get: function() {
        return { expression: getError().expression };
      },
      buttonShow: {
        method: function() {
          return false;
        }
      },
      hidden: function() {
        return !isOpen();
      },
      disabled: function() {
        return true;
      }
    });
    errorEntries2.splice(expressionIdx, 0, expressionEntry);
    removeEntry(errorEntries2, errorReferenceIdx);
    return errorEntries2;
  }
  var errors2 = filter(template2.properties, function(p) {
    return !p.type && p.binding.type === CAMUNDA_ERROR_EVENT_DEFINITION_TYPE;
  });
  forEach(errors2, function(property2, idx) {
    var id2 = "template-errors-" + template2.id + "-" + idx;
    errorEntries.push(renderError(id2, property2));
  });
  group.entries = group.entries.concat(flatten$3(errorEntries));
};
function findEntry(entries, id2) {
  return findIndex(entries, function(entry) {
    return entry.id === id2;
  });
}
function removeEntry(entries, idx) {
  entries.splice(idx, 1);
}
var getBusinessObject$c = require$$2$2.getBusinessObject;
var elementHelper$3 = ElementHelper_1, extensionElementsHelper$2 = ExtensionElementsHelper_1, inputOutputHelper$1 = InputOutputHelper_1, cmdHelper$9 = CmdHelper_1, utils$1 = Utils;
var entryFieldDescription$2 = EntryFieldDescription;
var domQuery$2 = require$$6.query;
var InputOutputParameter$1 = InputOutputParameter$3;
var InputParameters = function(element, bpmnFactory, options, translate2) {
  options = options || {};
  var insideConnector = !!options.insideConnector, idPrefix = options.idPrefix || "";
  var result = {};
  var entries = result.entries = [];
  if (!inputOutputHelper$1.isInputOutputSupported(element, insideConnector)) {
    return result;
  }
  var parametersOptions = {
    insideConnector,
    idPrefix
  };
  entries.push(getParametersHeading$1(element, bpmnFactory, {
    idPrefix,
    insideConnector,
    type: "camunda:InputParameter",
    prop: "inputParameters",
    prefix: "Input"
  }));
  append$2(entries, getInputParameterEntries(element, bpmnFactory, parametersOptions, translate2));
  return result;
};
function getParametersHeading$1(element, bpmnFactory, options) {
  var idPrefix = options.idPrefix || "", prefix2 = options.prefix, type = options.type, prop = options.prop, insideConnector = options.insideConnector;
  var entry = {
    id: idPrefix + prefix2 + "-heading",
    cssClasses: ["bpp-input-output"],
    html: '<div class="bpp-field-wrapper"><button type="button" class="bpp-input-output__add add action-button" data-action="createElement"></button><input name="hidden" type="hidden"></div>'
  };
  entry.createElement = function(_, entryNode) {
    var commands = createElement2();
    if (commands) {
      scheduleCommands(commands, entryNode);
      return true;
    }
  };
  entry.set = function() {
    var commands = entry._commands;
    if (commands) {
      delete entry._commands;
      return commands;
    }
  };
  function createElement2() {
    var commands = [];
    var bo = getBusinessObject$c(element);
    var extensionElements2 = bo.get("extensionElements");
    if (!extensionElements2) {
      extensionElements2 = elementHelper$3.createElement("bpmn:ExtensionElements", { values: [] }, bo, bpmnFactory);
      commands.push(cmdHelper$9.updateBusinessObject(element, bo, { extensionElements: extensionElements2 }));
    }
    var inputOutput = getInputOutput$1(element, insideConnector);
    if (!inputOutput) {
      var parent2 = !insideConnector ? extensionElements2 : getConnector$2(element);
      inputOutput = createInputOutput$1(parent2, bpmnFactory, {
        inputParameters: [],
        outputParameters: []
      });
      if (!insideConnector) {
        commands.push(cmdHelper$9.addAndRemoveElementsFromList(element, extensionElements2, "values", "extensionElements", [inputOutput], []));
      } else {
        commands.push(cmdHelper$9.updateBusinessObject(element, parent2, { inputOutput }));
      }
    }
    var newElem = createParameter$1(type, inputOutput, bpmnFactory, { name: generateElementId$1(prefix2) });
    commands.push(cmdHelper$9.addElementsTolist(element, inputOutput, prop, [], [newElem]));
    return commands;
  }
  function scheduleCommands(commands, entryNode) {
    entry._commands = commands;
    var input = domQuery$2('input[type="hidden"]', entryNode);
    input.value = 1;
  }
  return entry;
}
function getInputParameterEntries(element, bpmnFactory, options, translate2) {
  var idPrefix = options.idPrefix, insideConnector = options.insideConnector, inputOutput = getInputOutput$1(element, insideConnector), params = getInputParameters(element, insideConnector), entries;
  if (!params.length) {
    var description = entryFieldDescription$2(translate2, translate2("No variables defined."));
    return [{
      id: idPrefix + "input-parameter-placeholder",
      cssClasses: ["bpp-input-output-placeholder"],
      html: description
    }];
  }
  var inputParameters2 = params.map(function(param, index2) {
    function onRemove() {
      var commands = [];
      commands.push(cmdHelper$9.removeElementsFromList(element, inputOutput, "inputParameters", null, [param]));
      if (inputOutput.get("inputParameters").length === 1 && (inputOutput.get("outputParameters") || []).length === 0) {
        if (!insideConnector) {
          commands.push(extensionElementsHelper$2.removeEntry(getBusinessObject$c(element), element, inputOutput));
        } else {
          var connector = getConnector$2(element);
          commands.push(cmdHelper$9.updateBusinessObject(element, connector, { inputOutput: void 0 }));
        }
      }
      return commands;
    }
    return InputOutputParameter$1(param, bpmnFactory, {
      idPrefix: idPrefix + "input-parameter-" + index2,
      onRemove,
      onToggle
    }, translate2);
  });
  function onToggle(value, entryNode) {
    if (!value) {
      return;
    }
    var currentEntryId = entryNode.dataset.entry;
    inputParameters2.forEach(function(inputParameter) {
      if (inputParameter.entries[0].id === currentEntryId) {
        return;
      }
      inputParameter.setOpen(false, entryNode.parentElement);
    });
  }
  entries = inputParameters2.map(function(input) {
    return input.entries;
  });
  return flatten$2(entries);
}
function append$2(array, items) {
  Array.prototype.push.apply(array, items);
}
function flatten$2(arrays) {
  return Array.prototype.concat.apply([], arrays);
}
function generateElementId$1(prefix2) {
  prefix2 = prefix2 + "_";
  return utils$1.nextId(prefix2);
}
function getInputOutput$1(element, insideConnector) {
  return inputOutputHelper$1.getInputOutput(element, insideConnector);
}
function getConnector$2(element) {
  return inputOutputHelper$1.getConnector(element);
}
function getInputParameters(element, insideConnector) {
  return inputOutputHelper$1.getInputParameters(element, insideConnector);
}
function createElement$1(type, parent2, factory2, properties2) {
  return elementHelper$3.createElement(type, properties2, parent2, factory2);
}
function createInputOutput$1(parent2, bpmnFactory, properties2) {
  return createElement$1("camunda:InputOutput", parent2, bpmnFactory, properties2);
}
function createParameter$1(type, parent2, bpmnFactory, properties2) {
  return createElement$1(type, parent2, bpmnFactory, properties2);
}
var inputParameters$2 = InputParameters;
var InputParametersProps = function(group, element, bpmnFactory, elementTemplates2, translate2) {
  var template2 = elementTemplates2.get(element);
  if (template2) {
    return;
  }
  var inputParametersEntry = inputParameters$2(element, bpmnFactory, {}, translate2);
  group.entries = group.entries.concat(inputParametersEntry.entries);
};
var getBusinessObject$b = require$$2$2.getBusinessObject;
var elementHelper$2 = ElementHelper_1, extensionElementsHelper$1 = ExtensionElementsHelper_1, inputOutputHelper = InputOutputHelper_1, cmdHelper$8 = CmdHelper_1, utils = Utils;
var entryFieldDescription$1 = EntryFieldDescription;
var domQuery$1 = require$$6.query;
var InputOutputParameter = InputOutputParameter$3;
var OutputParameters = function(element, bpmnFactory, options, translate2) {
  options = options || {};
  var insideConnector = !!options.insideConnector, idPrefix = options.idPrefix || "";
  var result = {};
  var entries = result.entries = [];
  if (!inputOutputHelper.isInputOutputSupported(element, insideConnector) || !inputOutputHelper.areOutputParametersSupported(element, insideConnector)) {
    return result;
  }
  var parametersOptions = {
    insideConnector,
    idPrefix
  };
  entries.push(getParametersHeading(element, bpmnFactory, {
    idPrefix,
    insideConnector,
    type: "camunda:OutputParameter",
    prop: "outputParameters",
    prefix: "Output"
  }));
  append$1(entries, getOutputParameterEntries(element, bpmnFactory, parametersOptions, translate2));
  return result;
};
function getParametersHeading(element, bpmnFactory, options) {
  var idPrefix = options.idPrefix || "", prefix2 = options.prefix, type = options.type, prop = options.prop, insideConnector = options.insideConnector;
  var entry = {
    id: idPrefix + prefix2 + "-heading",
    cssClasses: ["bpp-input-output"],
    html: '<div class="bpp-field-wrapper"><button type="button" class="bpp-input-output__add add action-button" data-action="createElement"></button><input name="hidden" type="hidden"></div>'
  };
  entry.createElement = function(_, entryNode) {
    var commands = createElement2();
    if (commands) {
      scheduleCommands(commands, entryNode);
      return true;
    }
  };
  entry.set = function() {
    var commands = entry._commands;
    if (commands) {
      delete entry._commands;
      return commands;
    }
  };
  function createElement2() {
    var commands = [];
    var bo = getBusinessObject$b(element);
    var extensionElements2 = bo.get("extensionElements");
    if (!extensionElements2) {
      extensionElements2 = elementHelper$2.createElement("bpmn:ExtensionElements", { values: [] }, bo, bpmnFactory);
      commands.push(cmdHelper$8.updateBusinessObject(element, bo, { extensionElements: extensionElements2 }));
    }
    var inputOutput = getInputOutput(element, insideConnector);
    if (!inputOutput) {
      var parent2 = !insideConnector ? extensionElements2 : getConnector$1(element);
      inputOutput = createInputOutput(parent2, bpmnFactory, {
        inputParameters: [],
        outputParameters: []
      });
      if (!insideConnector) {
        commands.push(cmdHelper$8.addAndRemoveElementsFromList(element, extensionElements2, "values", "extensionElements", [inputOutput], []));
      } else {
        commands.push(cmdHelper$8.updateBusinessObject(element, parent2, { inputOutput }));
      }
    }
    var newElem = createParameter(type, inputOutput, bpmnFactory, { name: generateElementId(prefix2) });
    commands.push(cmdHelper$8.addElementsTolist(element, inputOutput, prop, [], [newElem]));
    return commands;
  }
  function scheduleCommands(commands, entryNode) {
    entry._commands = commands;
    var input = domQuery$1('input[type="hidden"]', entryNode);
    input.value = 1;
  }
  return entry;
}
function getOutputParameterEntries(element, bpmnFactory, options, translate2) {
  var idPrefix = options.idPrefix, insideConnector = options.insideConnector, inputOutput = getInputOutput(element, insideConnector), params = getOutputParameters(element, insideConnector), entries;
  if (!params.length) {
    var description = entryFieldDescription$1(translate2, translate2("No variables defined."));
    return [{
      id: idPrefix + "output-parameter-placeholder",
      cssClasses: ["bpp-input-output-placeholder"],
      html: description
    }];
  }
  var outputParameters2 = params.map(function(param, index2) {
    function onRemove() {
      var commands = [];
      commands.push(cmdHelper$8.removeElementsFromList(element, inputOutput, "outputParameters", null, [param]));
      if (inputOutput.get("outputParameters").length === 1 && (inputOutput.get("inputParameters") || []).length === 0) {
        if (!insideConnector) {
          commands.push(extensionElementsHelper$1.removeEntry(getBusinessObject$b(element), element, inputOutput));
        } else {
          var connector = getConnector$1(element);
          commands.push(cmdHelper$8.updateBusinessObject(element, connector, { inputOutput: void 0 }));
        }
      }
      return commands;
    }
    return InputOutputParameter(param, bpmnFactory, {
      idPrefix: idPrefix + "output-parameter-" + index2,
      onRemove,
      onToggle
    }, translate2);
  });
  function onToggle(value, entryNode) {
    if (!value) {
      return;
    }
    var currentEntryId = entryNode.dataset.entry;
    outputParameters2.forEach(function(outputParameter) {
      if (outputParameter.entries[0].id === currentEntryId) {
        return;
      }
      outputParameter.setOpen(false, entryNode.parentElement);
    });
  }
  entries = outputParameters2.map(function(input) {
    return input.entries;
  });
  return flatten$1(entries);
}
function append$1(array, items) {
  Array.prototype.push.apply(array, items);
}
function flatten$1(arrays) {
  return Array.prototype.concat.apply([], arrays);
}
function generateElementId(prefix2) {
  prefix2 = prefix2 + "_";
  return utils.nextId(prefix2);
}
function getInputOutput(element, insideConnector) {
  return inputOutputHelper.getInputOutput(element, insideConnector);
}
function getConnector$1(element) {
  return inputOutputHelper.getConnector(element);
}
function getOutputParameters(element, insideConnector) {
  return inputOutputHelper.getOutputParameters(element, insideConnector);
}
function createElement(type, parent2, factory2, properties2) {
  return elementHelper$2.createElement(type, properties2, parent2, factory2);
}
function createInputOutput(parent2, bpmnFactory, properties2) {
  return createElement("camunda:InputOutput", parent2, bpmnFactory, properties2);
}
function createParameter(type, parent2, bpmnFactory, properties2) {
  return createElement(type, parent2, bpmnFactory, properties2);
}
var outputParameters$2 = OutputParameters;
var OutputParametersProps = function(group, element, bpmnFactory, elementTemplates2, translate2) {
  var template2 = elementTemplates2.get(element);
  if (template2) {
    return;
  }
  var outputParametersEntry = outputParameters$2(element, bpmnFactory, {}, translate2);
  group.entries = group.entries.concat(outputParametersEntry.entries);
};
var getBusinessObject$a = require$$2$2.getBusinessObject;
var entryFieldDescription = EntryFieldDescription;
var elementHelper$1 = ElementHelper_1, extensionElementsHelper = ExtensionElementsHelper_1, cmdHelper$7 = CmdHelper_1;
var ErrorsEntries = ErrorsEntries$1;
var domQuery = require$$6.query;
var Errors = function(element, bpmnFactory, options, translate2) {
  var result = {};
  var entries = result.entries = [];
  entries.push(getErrorsHeading(element, bpmnFactory, {
    type: "camunda:ErrorEventDefinition",
    prop: "errorEventDefinition",
    prefix: "Error"
  }));
  append(entries, getErrorsEntries(element, bpmnFactory, {}, translate2));
  return result;
};
function getErrorsHeading(element, bpmnFactory, options) {
  var prefix2 = options.prefix;
  var entry = {
    id: prefix2 + "-heading",
    cssClasses: ["bpp-error"],
    html: '<div class="bpp-field-wrapper"><button type="button" class="bpp-error__add add action-button" data-action="createElement"></button><input name="hidden" type="hidden"></div>'
  };
  entry.createElement = function(_, entryNode) {
    var commands = createElement2();
    if (commands) {
      scheduleCommands(commands, entryNode);
      return true;
    }
  };
  entry.set = function() {
    var commands = entry._commands;
    if (commands) {
      delete entry._commands;
      return commands;
    }
  };
  function createElement2() {
    var commands = [];
    var bo = getBusinessObject$a(element);
    var extensionElements2 = bo.get("extensionElements");
    if (!extensionElements2) {
      extensionElements2 = elementHelper$1.createElement("bpmn:ExtensionElements", { values: [] }, bo, bpmnFactory);
      commands.push(cmdHelper$7.updateBusinessObject(element, bo, { extensionElements: extensionElements2 }));
    }
    var newElem = elementHelper$1.createElement("camunda:ErrorEventDefinition", {}, extensionElements2, bpmnFactory);
    commands.push(cmdHelper$7.addElementsTolist(element, extensionElements2, "values", [newElem]));
    return commands;
  }
  function scheduleCommands(commands, entryNode) {
    entry._commands = commands;
    var input = domQuery('input[type="hidden"]', entryNode);
    input.value = 1;
  }
  return entry;
}
function getErrors(bo) {
  return extensionElementsHelper.getExtensionElements(bo, "camunda:ErrorEventDefinition") || [];
}
function getErrorsEntries(element, bpmnFactory, options, translate2) {
  var idPrefix = options.idPrefix || "", bo = getBusinessObject$a(element), errorEventDefinitions = getErrors(bo), extensionElements2 = bo.get("extensionElements"), entries;
  if (errorEventDefinitions && !errorEventDefinitions.length) {
    var description = entryFieldDescription(translate2, translate2("No errors defined."));
    return [{
      id: idPrefix + "error-placeholder",
      cssClasses: ["bpp-error-placeholder"],
      html: description
    }];
  }
  var errorsEntries = errorEventDefinitions.map(function(definition, index2) {
    function onRemove() {
      var commands = [];
      commands.push(cmdHelper$7.removeElementsFromList(element, extensionElements2, "values", "extensionElements", [definition]));
      return commands;
    }
    return ErrorsEntries(definition, bpmnFactory, element, {
      idPrefix: idPrefix + "error-" + index2,
      onRemove,
      onToggle
    }, translate2);
    function onToggle(value, entryNode) {
      if (!value) {
        return;
      }
      var currentEntryId = entryNode.dataset.entry;
      errorsEntries.forEach(function(entry) {
        if (entry.entries[0].id === currentEntryId) {
          return;
        }
        entry.setOpen(false, entryNode.parentElement);
      });
    }
  });
  entries = errorsEntries.map(function(input) {
    return input.entries;
  });
  return flatten(entries);
}
function flatten(arrays) {
  return Array.prototype.concat.apply([], arrays);
}
function append(array, items) {
  Array.prototype.push.apply(array, items);
}
var errors = Errors;
var ErrorsProps = function(group, element, bpmnFactory, elementTemplates2, translate2) {
  var template2 = elementTemplates2.get(element);
  if (template2) {
    return;
  }
  var errorsEntry = errors(element, bpmnFactory, {}, translate2);
  group.entries = group.entries.concat(errorsEntry.entries);
};
var ImplementationTypeHelper$3 = ImplementationTypeHelper_1, InputOutputHelper = InputOutputHelper_1;
var entryFactory$5 = EntryFactory_1, cmdHelper$6 = CmdHelper_1;
function getImplementationType(element) {
  return ImplementationTypeHelper$3.getImplementationType(element);
}
function getBusinessObject$9(element) {
  return ImplementationTypeHelper$3.getServiceTaskLikeBusinessObject(element);
}
function getConnector(bo) {
  return InputOutputHelper.getConnector(bo);
}
function isConnector(element) {
  return getImplementationType(element) === "connector";
}
var ConnectorDetailProps = function(group, element, bpmnFactory, translate2) {
  group.entries.push(entryFactory$5.textField(translate2, {
    id: "connectorId",
    label: translate2("Connector Id"),
    modelProperty: "connectorId",
    get: function(element2, node2) {
      var bo = getBusinessObject$9(element2);
      var connector = bo && getConnector(bo);
      var value = connector && connector.get("connectorId");
      return { connectorId: value };
    },
    set: function(element2, values2, node2) {
      var bo = getBusinessObject$9(element2);
      var connector = getConnector(bo);
      return cmdHelper$6.updateBusinessObject(element2, connector, {
        connectorId: values2.connectorId || void 0
      });
    },
    validate: function(element2, values2, node2) {
      return isConnector(element2) && !values2.connectorId ? { connectorId: translate2("Must provide a value") } : {};
    },
    hidden: function(element2, node2) {
      return !isConnector(element2);
    }
  }));
};
var inputParameters$1 = InputParameters;
var ConnectorInputParametersProps = function(group, element, bpmnFactory, translate2) {
  var inputParametersEntry = inputParameters$1(element, bpmnFactory, {
    idPrefix: "connector-",
    insideConnector: true
  }, translate2);
  group.entries = group.entries.concat(inputParametersEntry.entries);
};
var outputParameters$1 = OutputParameters;
var ConnectorOutputParametersProps = function(group, element, bpmnFactory, translate2) {
  var outputParametersEntry = outputParameters$1(element, bpmnFactory, {
    idPrefix: "connector-",
    insideConnector: true
  }, translate2);
  group.entries = group.entries.concat(outputParametersEntry.entries);
};
var properties$1 = Properties, elementHelper = ElementHelper_1, cmdHelper$5 = CmdHelper_1;
var PropertiesProps = function(group, element, bpmnFactory, translate2) {
  var propertiesEntry = properties$1(element, bpmnFactory, {
    id: "properties",
    modelProperties: ["name", "value"],
    labels: [translate2("Name"), translate2("Value")],
    getParent: function(element2, node2, bo) {
      return bo.extensionElements;
    },
    createParent: function(element2, bo) {
      var parent2 = elementHelper.createElement("bpmn:ExtensionElements", { values: [] }, bo, bpmnFactory);
      var cmd2 = cmdHelper$5.updateBusinessObject(element2, bo, { extensionElements: parent2 });
      return {
        cmd: cmd2,
        parent: parent2
      };
    }
  }, translate2);
  if (propertiesEntry) {
    group.entries.push(propertiesEntry);
  }
};
var entryFactory$4 = EntryFactory_1;
var cmdHelper$4 = CmdHelper_1;
var JobPriority = function(element, bpmnFactory, options, translate2) {
  var getBusinessObject2 = options.getBusinessObject;
  var jobPriorityEntry = entryFactory$4.textField(translate2, {
    id: "jobPriority",
    label: translate2("Job Priority"),
    modelProperty: "jobPriority",
    get: function(element2, node2) {
      var bo = getBusinessObject2(element2);
      return {
        jobPriority: bo.get("camunda:jobPriority")
      };
    },
    set: function(element2, values2) {
      var bo = getBusinessObject2(element2);
      return cmdHelper$4.updateBusinessObject(element2, bo, {
        "camunda:jobPriority": values2.jobPriority || void 0
      });
    }
  });
  return [jobPriorityEntry];
};
var is$9 = require$$2$2.is, getBusinessObject$8 = require$$2$2.getBusinessObject;
var jobPriority = JobPriority, jobRetryTimeCycle = JobRetryTimeCycle;
var JobConfigurationProps = function(group, element, bpmnFactory, translate2) {
  var businessObject = getBusinessObject$8(element);
  if (is$9(element, "camunda:JobPriorized") || is$9(element, "bpmn:Participant") && businessObject.get("processRef")) {
    group.entries = group.entries.concat(jobPriority(element, bpmnFactory, {
      getBusinessObject: function(element2) {
        var bo = getBusinessObject$8(element2);
        if (!is$9(bo, "bpmn:Participant")) {
          return bo;
        }
        return bo.get("processRef");
      }
    }, translate2));
  }
  if (is$9(element, "camunda:AsyncCapable")) {
    group.entries = group.entries.concat(jobRetryTimeCycle(element, bpmnFactory, {
      getBusinessObject: getBusinessObject$8
    }, translate2));
  }
};
var entryFactory$3 = EntryFactory_1;
var cmdHelper$3 = CmdHelper_1;
var HistoryTimeToLive = function(element, bpmnFactory, options, translate2) {
  var getBusinessObject2 = options.getBusinessObject;
  var historyTimeToLiveEntry = entryFactory$3.textField(translate2, {
    id: "historyTimeToLive",
    label: translate2("History Time To Live"),
    modelProperty: "historyTimeToLive",
    get: function(element2, node2) {
      var bo = getBusinessObject2(element2);
      var historyTimeToLive2 = bo.get("camunda:historyTimeToLive");
      return {
        historyTimeToLive: historyTimeToLive2 ? historyTimeToLive2 : ""
      };
    },
    set: function(element2, values2) {
      var bo = getBusinessObject2(element2);
      return cmdHelper$3.updateBusinessObject(element2, bo, {
        "camunda:historyTimeToLive": values2.historyTimeToLive || void 0
      });
    }
  });
  return [historyTimeToLiveEntry];
};
var is$8 = require$$2$2.is, getBusinessObject$7 = require$$2$2.getBusinessObject;
var historyTimeToLive$1 = HistoryTimeToLive;
var HistoryTimeToLiveProps = function(group, element, bpmnFactory, translate2) {
  var businessObject = getBusinessObject$7(element);
  if (is$8(element, "camunda:Process") || is$8(element, "bpmn:Participant") && businessObject.get("processRef")) {
    group.entries = group.entries.concat(historyTimeToLive$1(element, bpmnFactory, {
      getBusinessObject: function(element2) {
        var bo = getBusinessObject$7(element2);
        if (!is$8(bo, "bpmn:Participant")) {
          return bo;
        }
        return bo.get("processRef");
      }
    }, translate2));
  }
};
var entryFactory$2 = EntryFactory_1;
var cmdHelper$2 = CmdHelper_1;
var CandidateStarter = function(element, bpmnFactory, options, translate2) {
  var getBusinessObject2 = options.getBusinessObject;
  var candidateStarterGroupsEntry = entryFactory$2.textField(translate2, {
    id: "candidateStarterGroups",
    label: translate2("Candidate Starter Groups"),
    modelProperty: "candidateStarterGroups",
    description: translate2("Specify more than one group as a comma separated list."),
    get: function(element2, node2) {
      var bo = getBusinessObject2(element2);
      var candidateStarterGroups = bo.get("camunda:candidateStarterGroups");
      return {
        candidateStarterGroups: candidateStarterGroups ? candidateStarterGroups : ""
      };
    },
    set: function(element2, values2) {
      var bo = getBusinessObject2(element2);
      return cmdHelper$2.updateBusinessObject(element2, bo, {
        "camunda:candidateStarterGroups": values2.candidateStarterGroups || void 0
      });
    }
  });
  var candidateStarterUsersEntry = entryFactory$2.textField(translate2, {
    id: "candidateStarterUsers",
    label: translate2("Candidate Starter Users"),
    modelProperty: "candidateStarterUsers",
    description: translate2("Specify more than one user as a comma separated list."),
    get: function(element2, node2) {
      var bo = getBusinessObject2(element2);
      var candidateStarterUsers = bo.get("camunda:candidateStarterUsers");
      return {
        candidateStarterUsers: candidateStarterUsers ? candidateStarterUsers : ""
      };
    },
    set: function(element2, values2) {
      var bo = getBusinessObject2(element2);
      return cmdHelper$2.updateBusinessObject(element2, bo, {
        "camunda:candidateStarterUsers": values2.candidateStarterUsers || void 0
      });
    }
  });
  return [
    candidateStarterGroupsEntry,
    candidateStarterUsersEntry
  ];
};
var is$7 = require$$2$2.is, getBusinessObject$6 = require$$2$2.getBusinessObject;
var candidateStarter$1 = CandidateStarter;
var CandidateStarterProps = function(group, element, bpmnFactory, translate2) {
  var businessObject = getBusinessObject$6(element);
  if (is$7(element, "camunda:Process") || is$7(element, "bpmn:Participant") && businessObject.get("processRef")) {
    group.entries = group.entries.concat(candidateStarter$1(element, bpmnFactory, {
      getBusinessObject: function(element2) {
        var bo = getBusinessObject$6(element2);
        if (!is$7(bo, "bpmn:Participant")) {
          return bo;
        }
        return bo.get("processRef");
      }
    }, translate2));
  }
};
var entryFactory$1 = EntryFactory_1;
var cmdHelper$1 = CmdHelper_1;
var Tasklist = function(element, bpmnFactory, options, translate2) {
  var getBusinessObject2 = options.getBusinessObject;
  var isStartableInTasklistEntry = entryFactory$1.checkbox(translate2, {
    id: "isStartableInTasklist",
    label: translate2("Startable"),
    modelProperty: "isStartableInTasklist",
    get: function(element2, node2) {
      var bo = getBusinessObject2(element2);
      var isStartableInTasklist = bo.get("camunda:isStartableInTasklist");
      return {
        isStartableInTasklist: isStartableInTasklist ? isStartableInTasklist : ""
      };
    },
    set: function(element2, values2) {
      var bo = getBusinessObject2(element2);
      return cmdHelper$1.updateBusinessObject(element2, bo, {
        "camunda:isStartableInTasklist": !!values2.isStartableInTasklist
      });
    }
  });
  return [
    isStartableInTasklistEntry
  ];
};
var is$6 = require$$2$2.is, getBusinessObject$5 = require$$2$2.getBusinessObject;
var tasklist$1 = Tasklist;
var TasklistProps = function(group, element, bpmnFactory, translate2) {
  var businessObject = getBusinessObject$5(element);
  if (is$6(element, "camunda:Process") || is$6(element, "bpmn:Participant") && businessObject.get("processRef")) {
    group.entries = group.entries.concat(tasklist$1(element, bpmnFactory, {
      getBusinessObject: function(element2) {
        var bo = getBusinessObject$5(element2);
        if (!is$6(bo, "bpmn:Participant")) {
          return bo;
        }
        return bo.get("processRef");
      }
    }, translate2));
  }
};
var entryFactory = EntryFactory_1;
var cmdHelper = CmdHelper_1;
var ExternalTaskPriority = function(element, bpmnFactory, options, translate2) {
  var getBusinessObject2 = options.getBusinessObject;
  var externalTaskPriorityEntry = entryFactory.textField(translate2, {
    id: "externalTaskPriority",
    label: translate2("Task Priority"),
    modelProperty: "taskPriority",
    get: function(element2, node2) {
      var bo = getBusinessObject2(element2);
      return {
        taskPriority: bo.get("camunda:taskPriority")
      };
    },
    set: function(element2, values2) {
      var bo = getBusinessObject2(element2);
      return cmdHelper.updateBusinessObject(element2, bo, {
        "camunda:taskPriority": values2.taskPriority || void 0
      });
    }
  });
  return [externalTaskPriorityEntry];
};
var is$5 = require$$2$2.is, getBusinessObject$4 = require$$2$2.getBusinessObject;
var ImplementationTypeHelper$2 = ImplementationTypeHelper_1;
var externalTaskPriority = ExternalTaskPriority;
function getServiceTaskLikeBusinessObject(element) {
  var bo = ImplementationTypeHelper$2.getServiceTaskLikeBusinessObject(element);
  if (!bo) {
    bo = getBusinessObject$4(element);
  }
  return bo;
}
var ExternalTaskConfigurationProps = function(group, element, bpmnFactory, translate2) {
  var bo = getServiceTaskLikeBusinessObject(element);
  if (!bo) {
    return;
  }
  if (is$5(bo, "camunda:TaskPriorized") || is$5(bo, "bpmn:Participant") && bo.get("processRef")) {
    group.entries = group.entries.concat(externalTaskPriority(element, bpmnFactory, {
      getBusinessObject: function(element2) {
        if (!is$5(bo, "bpmn:Participant")) {
          return bo;
        }
        return bo.get("processRef");
      }
    }, translate2));
  }
};
var ImplementationTypeHelper$1 = ImplementationTypeHelper_1;
var fieldInjection = FieldInjection;
var FieldInjectionProps = function(group, element, bpmnFactory, translate2) {
  var bo = ImplementationTypeHelper$1.getServiceTaskLikeBusinessObject(element);
  if (!bo) {
    return;
  }
  var fieldInjectionEntry = fieldInjection(element, bpmnFactory, translate2, { businessObject: bo });
  if (fieldInjectionEntry && fieldInjectionEntry.length > 0) {
    group.entries = group.entries.concat(fieldInjectionEntry);
  }
};
var inherits$3 = inherits_browser.exports;
var PropertiesActivator = PropertiesActivator_1;
var asyncCapableHelper = AsyncCapableHelper, ImplementationTypeHelper = ImplementationTypeHelper_1;
var is$4 = require$$2$2.is;
var processProps = ProcessProps, eventProps = EventProps, linkProps = LinkProps, documentationProps = DocumentationProps, idProps = IdProps, nameProps = NameProps, executableProps = ExecutableProps;
var serviceTaskDelegateProps = ServiceTaskDelegateProps, userTaskProps = UserTaskProps, asynchronousContinuationProps = AsynchronousContinuationProps, callActivityProps = CallActivityProps, multiInstanceProps = MultiInstanceLoopProps, conditionalProps = ConditionalProps, scriptProps = ScriptTaskProps, errorProps = ErrorEventProps, formProps = FormProps, startEventInitiator = StartEventInitiator, variableMapping = VariableMappingProps, versionTag = VersionTagProps, processVariablesProps = ProcessVariablesProps;
var listenerProps = ListenerProps, listenerDetails = ListenerDetailProps, listenerFields = ListenerFieldInjectionProps;
var elementTemplateDescriptionProps = DescriptionProps, elementTemplateChooserProps = ChooserProps, elementTemplateCustomProps = CustomProps.exports, elementTemplateInputParametersProps = InputParametersProps$1, elementTemplateOutputParametersProps = OutputParametersProps$1, elementTemplateErrorsProps = ErrorsProps$1, getTemplateId = Helper$1.getTemplateId;
var inputParameters = InputParametersProps, outputParameters = OutputParametersProps, errorsProps = ErrorsProps;
var connectorDetails = ConnectorDetailProps, connectorInputParameters = ConnectorInputParametersProps, connectorOutputParameters = ConnectorOutputParametersProps;
var properties = PropertiesProps;
var jobConfiguration = JobConfigurationProps;
var historyTimeToLive = HistoryTimeToLiveProps;
var candidateStarter = CandidateStarterProps;
var tasklist = TasklistProps;
var externalTaskConfiguration = ExternalTaskConfigurationProps;
var fieldInjections = FieldInjectionProps;
var getBusinessObject$3 = require$$2$2.getBusinessObject, eventDefinitionHelper = EventDefinitionHelper_1, implementationTypeHelper = ImplementationTypeHelper_1;
var isExternalTaskPriorityEnabled = function(element) {
  var businessObject = getBusinessObject$3(element);
  if (is$4(element, "bpmn:Process") || is$4(element, "bpmn:Participant") && businessObject.get("processRef")) {
    return true;
  }
  var externalBo = ImplementationTypeHelper.getServiceTaskLikeBusinessObject(element), isExternalTask = ImplementationTypeHelper.getImplementationType(externalBo) === "external";
  return !!ImplementationTypeHelper.isExternalCapable(externalBo) && isExternalTask;
};
var isJobConfigEnabled = function(element) {
  var businessObject = getBusinessObject$3(element);
  if (is$4(element, "bpmn:Process") || is$4(element, "bpmn:Participant") && businessObject.get("processRef")) {
    return true;
  }
  var bo = getBusinessObject$3(element);
  if (asyncCapableHelper.isAsyncBefore(bo) || asyncCapableHelper.isAsyncAfter(bo)) {
    return true;
  }
  if (is$4(element, "bpmn:Event")) {
    return !!eventDefinitionHelper.getTimerEventDefinition(element);
  }
  return false;
};
var getListenerLabel = function(param, translate2) {
  if (is$4(param, "camunda:ExecutionListener")) {
    return translate2("Execution Listener");
  }
  if (is$4(param, "camunda:TaskListener")) {
    return translate2("Task Listener");
  }
  return "";
};
var PROCESS_KEY_HINT = "This maps to the process definition key.";
var TASK_KEY_HINT = "This maps to the task definition key.";
function getIdOptions(element) {
  if (is$4(element, "bpmn:Participant")) {
    return { id: "participant-id", label: "Participant Id" };
  }
  if (is$4(element, "bpmn:Process")) {
    return { description: PROCESS_KEY_HINT };
  }
  if (is$4(element, "bpmn:UserTask")) {
    return { description: TASK_KEY_HINT };
  }
}
function getNameOptions(element) {
  if (is$4(element, "bpmn:Participant")) {
    return { id: "participant-name", label: "Participant Name" };
  }
}
function getProcessOptions(element) {
  if (is$4(element, "bpmn:Participant")) {
    return { processIdDescription: PROCESS_KEY_HINT };
  }
}
function createElementTemplateGroups(element, bpmnFactory, canvas, commandStack, elementTemplates2, modeling, replace, selection, translate2) {
  var templateId = getTemplateId(element);
  if (!templateId) {
    return [];
  }
  var descriptionGroup = elementTemplateDescriptionProps(element, commandStack, elementTemplates2, modeling, replace, selection, translate2);
  var idOptions = getIdOptions(element) || {};
  idOptions.id = "element-template-element-id";
  var nameOptions = { id: "element-template-element-name" };
  idProps(descriptionGroup, element, translate2, idOptions);
  nameProps(descriptionGroup, element, bpmnFactory, canvas, translate2, nameOptions);
  processProps(descriptionGroup, element, translate2, getProcessOptions(element));
  var elementTemplateInputParametersGroup = {
    id: "template-inputs",
    label: translate2("Input Parameters"),
    entries: []
  };
  elementTemplateInputParametersProps(elementTemplateInputParametersGroup, element, elementTemplates2, bpmnFactory, translate2);
  var elementTemplateOutputParametersGroup = {
    id: "template-outputs",
    label: translate2("Output Parameters"),
    entries: []
  };
  elementTemplateOutputParametersProps(elementTemplateOutputParametersGroup, element, elementTemplates2, bpmnFactory, translate2);
  var elementTemplateErrorsGroup = {
    id: "template-errors",
    label: translate2("Errors"),
    entries: []
  };
  elementTemplateErrorsProps(elementTemplateErrorsGroup, element, elementTemplates2, bpmnFactory, translate2);
  var customFieldsGroups = elementTemplateCustomProps(element, elementTemplates2, bpmnFactory, translate2);
  return [
    descriptionGroup,
    elementTemplateInputParametersGroup,
    elementTemplateOutputParametersGroup,
    elementTemplateErrorsGroup
  ].concat(customFieldsGroups);
}
function createGeneralTabGroups(element, canvas, bpmnFactory, elementRegistry, elementTemplates2, translate2) {
  element = element.labelTarget || element;
  var generalGroup = {
    id: "general",
    label: translate2("General"),
    entries: []
  };
  idProps(generalGroup, element, translate2, getIdOptions(element));
  nameProps(generalGroup, element, bpmnFactory, canvas, translate2, getNameOptions(element));
  processProps(generalGroup, element, translate2, getProcessOptions(element));
  versionTag(generalGroup, element, translate2);
  executableProps(generalGroup, element, translate2);
  elementTemplateChooserProps(generalGroup, element, elementTemplates2, translate2);
  var detailsGroup = {
    id: "details",
    label: translate2("Details"),
    entries: []
  };
  serviceTaskDelegateProps(detailsGroup, element, bpmnFactory, translate2);
  userTaskProps(detailsGroup, element, translate2);
  scriptProps(detailsGroup, element, bpmnFactory, translate2);
  linkProps(detailsGroup, element, translate2);
  callActivityProps(detailsGroup, element, bpmnFactory, translate2);
  eventProps(detailsGroup, element, bpmnFactory, elementRegistry, translate2);
  errorProps(detailsGroup, element, bpmnFactory, translate2);
  conditionalProps(detailsGroup, element, bpmnFactory, translate2);
  startEventInitiator(detailsGroup, element, translate2);
  var multiInstanceGroup = {
    id: "multiInstance",
    label: translate2("Multi Instance"),
    entries: []
  };
  multiInstanceProps(multiInstanceGroup, element, bpmnFactory, translate2);
  var asyncGroup = {
    id: "async",
    label: translate2("Asynchronous Continuations"),
    entries: []
  };
  asynchronousContinuationProps(asyncGroup, element, bpmnFactory, translate2);
  var jobConfigurationGroup = {
    id: "jobConfiguration",
    label: translate2("Job Configuration"),
    entries: [],
    enabled: isJobConfigEnabled
  };
  jobConfiguration(jobConfigurationGroup, element, bpmnFactory, translate2);
  var externalTaskGroup = {
    id: "externalTaskConfiguration",
    label: translate2("External Task Configuration"),
    entries: [],
    enabled: isExternalTaskPriorityEnabled
  };
  externalTaskConfiguration(externalTaskGroup, element, bpmnFactory, translate2);
  var candidateStarterGroup = {
    id: "candidateStarterConfiguration",
    label: translate2("Candidate Starter Configuration"),
    entries: []
  };
  candidateStarter(candidateStarterGroup, element, bpmnFactory, translate2);
  var historyTimeToLiveGroup = {
    id: "historyConfiguration",
    label: translate2("History Configuration"),
    entries: []
  };
  historyTimeToLive(historyTimeToLiveGroup, element, bpmnFactory, translate2);
  var tasklistGroup = {
    id: "tasklist",
    label: translate2("Tasklist Configuration"),
    entries: []
  };
  tasklist(tasklistGroup, element, bpmnFactory, translate2);
  var documentationGroup = {
    id: "documentation",
    label: translate2("Documentation"),
    entries: []
  };
  documentationProps(documentationGroup, element, bpmnFactory, translate2);
  var groups = [];
  groups.push(generalGroup);
  groups.push(detailsGroup);
  groups.push(externalTaskGroup);
  groups.push(multiInstanceGroup);
  groups.push(asyncGroup);
  groups.push(jobConfigurationGroup);
  groups.push(candidateStarterGroup);
  groups.push(historyTimeToLiveGroup);
  groups.push(tasklistGroup);
  groups.push(documentationGroup);
  return groups;
}
function createVariablesTabGroups(element, bpmnFactory, elementRegistry, translate2) {
  var variablesGroup = {
    id: "variables",
    label: translate2("Variables"),
    entries: []
  };
  variableMapping(variablesGroup, element, bpmnFactory, translate2);
  return [
    variablesGroup
  ];
}
function createProcessVariablesTabGroups(element, translate2) {
  var processVariablesGroup = {
    id: "process-variables",
    label: translate2("Variables"),
    entries: []
  };
  processVariablesProps(processVariablesGroup, element, translate2);
  return [
    processVariablesGroup
  ];
}
function createFormsTabGroups(element, bpmnFactory, elementRegistry, translate2) {
  var formGroup = {
    id: "forms",
    label: translate2("Forms"),
    entries: []
  };
  formProps(formGroup, element, bpmnFactory, translate2);
  return [
    formGroup
  ];
}
function createListenersTabGroups(element, bpmnFactory, elementRegistry, translate2) {
  var listenersGroup = {
    id: "listeners",
    label: translate2("Listeners"),
    entries: []
  };
  var options = listenerProps(listenersGroup, element, bpmnFactory, translate2);
  var listenerDetailsGroup = {
    id: "listener-details",
    entries: [],
    enabled: function(element2, node2) {
      return options.getSelectedListener(element2, node2);
    },
    label: function(element2, node2) {
      var param = options.getSelectedListener(element2, node2);
      return getListenerLabel(param, translate2);
    }
  };
  listenerDetails(listenerDetailsGroup, element, bpmnFactory, options, translate2);
  var listenerFieldsGroup = {
    id: "listener-fields",
    label: translate2("Field Injection"),
    entries: [],
    enabled: function(element2, node2) {
      return options.getSelectedListener(element2, node2);
    }
  };
  listenerFields(listenerFieldsGroup, element, bpmnFactory, options, translate2);
  return [
    listenersGroup,
    listenerDetailsGroup,
    listenerFieldsGroup
  ];
}
function createInputOutputTabGroups(element, bpmnFactory, elementTemplates2, translate2) {
  var inputParametersGroup = {
    id: "input-parameters",
    label: translate2("Input Parameters"),
    entries: []
  };
  inputParameters(inputParametersGroup, element, bpmnFactory, elementTemplates2, translate2);
  var outputParametersGroup = {
    id: "output-parameters",
    label: translate2("Output Parameters"),
    entries: []
  };
  outputParameters(outputParametersGroup, element, bpmnFactory, elementTemplates2, translate2);
  var errorsGroup = {
    id: "errors",
    label: translate2("Errors"),
    entries: [],
    enabled: function(element2, node2) {
      var businessObject = getBusinessObject$3(element2);
      var isExternal = ImplementationTypeHelper.getImplementationType(businessObject) === "external";
      return is$4(element2, "bpmn:ServiceTask") && isExternal;
    }
  };
  errorsProps(errorsGroup, element, bpmnFactory, elementTemplates2, translate2);
  return [
    inputParametersGroup,
    outputParametersGroup,
    errorsGroup
  ];
}
function createConnectorTabGroups(element, bpmnFactory, elementRegistry, translate2) {
  var connectorDetailsGroup = {
    id: "connector-details",
    label: translate2("Details"),
    entries: []
  };
  connectorDetails(connectorDetailsGroup, element, bpmnFactory, translate2);
  var connectorInputParametersGroup = {
    id: "connector-input-parameters",
    label: translate2("Input Parameters"),
    entries: []
  };
  connectorInputParameters(connectorInputParametersGroup, element, bpmnFactory, translate2);
  var connectorOutputParametersGroup = {
    id: "connector-output-parameters",
    label: translate2("Output Parameters"),
    entries: []
  };
  connectorOutputParameters(connectorOutputParametersGroup, element, bpmnFactory, translate2);
  return [
    connectorDetailsGroup,
    connectorInputParametersGroup,
    connectorOutputParametersGroup
  ];
}
function createFieldInjectionsTabGroups(element, bpmnFactory, elementRegistry, translate2) {
  var fieldGroup = {
    id: "field-injections-properties",
    label: translate2("Field Injections"),
    entries: []
  };
  fieldInjections(fieldGroup, element, bpmnFactory, translate2);
  return [
    fieldGroup
  ];
}
function createExtensionElementsGroups(element, bpmnFactory, elementRegistry, translate2) {
  var propertiesGroup = {
    id: "extensionElements-properties",
    label: translate2("Properties"),
    entries: []
  };
  properties(propertiesGroup, element, bpmnFactory, translate2);
  return [
    propertiesGroup
  ];
}
function CamundaPropertiesProvider(bpmnFactory, canvas, commandStack, elementRegistry, elementTemplates2, eventBus, modeling, replace, selection, translate2) {
  PropertiesActivator.call(this, eventBus);
  this.getTabs = function(element) {
    var generalTab = {
      id: "general",
      label: translate2("General"),
      groups: createGeneralTabGroups(element, canvas, bpmnFactory, elementRegistry, elementTemplates2, translate2)
    };
    var elementTemplateTab = {
      id: "element-template",
      label: translate2("Template"),
      groups: createElementTemplateGroups(element, bpmnFactory, canvas, commandStack, elementTemplates2, modeling, replace, selection, translate2)
    };
    var variablesTab = {
      id: "variables",
      label: translate2("Variables"),
      groups: createVariablesTabGroups(element, bpmnFactory, elementRegistry, translate2)
    };
    var processVariablesTab = {
      id: "process-variables",
      label: translate2("Variables"),
      groups: createProcessVariablesTabGroups(element, translate2)
    };
    var formsTab = {
      id: "forms",
      label: translate2("Forms"),
      groups: createFormsTabGroups(element, bpmnFactory, elementRegistry, translate2)
    };
    var listenersTab = {
      id: "listeners",
      label: translate2("Listeners"),
      groups: createListenersTabGroups(element, bpmnFactory, elementRegistry, translate2),
      enabled: function(element2) {
        return !eventDefinitionHelper.getLinkEventDefinition(element2) || !is$4(element2, "bpmn:IntermediateThrowEvent") && eventDefinitionHelper.getLinkEventDefinition(element2);
      }
    };
    var inputOutputTab = {
      id: "input-output",
      label: translate2("Input/Output"),
      groups: createInputOutputTabGroups(element, bpmnFactory, elementTemplates2, translate2)
    };
    var connectorTab = {
      id: "connector",
      label: translate2("Connector"),
      groups: createConnectorTabGroups(element, bpmnFactory, elementRegistry, translate2),
      enabled: function(element2) {
        var bo = implementationTypeHelper.getServiceTaskLikeBusinessObject(element2);
        return bo && implementationTypeHelper.getImplementationType(bo) === "connector";
      }
    };
    var fieldInjectionsTab = {
      id: "field-injections",
      label: translate2("Field Injections"),
      groups: createFieldInjectionsTabGroups(element, bpmnFactory, elementRegistry, translate2)
    };
    var extensionsTab = {
      id: "extensionElements",
      label: translate2("Extensions"),
      groups: createExtensionElementsGroups(element, bpmnFactory, elementRegistry, translate2)
    };
    return [
      generalTab,
      elementTemplateTab,
      variablesTab,
      processVariablesTab,
      connectorTab,
      formsTab,
      listenersTab,
      inputOutputTab,
      fieldInjectionsTab,
      extensionsTab
    ];
  };
}
CamundaPropertiesProvider.$inject = [
  "bpmnFactory",
  "canvas",
  "commandStack",
  "elementRegistry",
  "elementTemplates",
  "eventBus",
  "modeling",
  "replace",
  "selection",
  "translate"
];
inherits$3(CamundaPropertiesProvider, PropertiesActivator);
var CamundaPropertiesProvider_1 = CamundaPropertiesProvider;
var camunda = {
  __depends__: [
    elementTemplates,
    require$$1$3.default
  ],
  __init__: ["propertiesProvider"],
  propertiesProvider: ["type", CamundaPropertiesProvider_1]
};
var isFunction = require$$1$1.isFunction, isObject = require$$1$1.isObject, some = require$$1$1.some;
var WILDCARD = "*";
function CopyPasteBehavior(eventBus) {
  var self2 = this;
  eventBus.on("moddleCopy.canCopyProperty", function(context) {
    var property2 = context.property, parent2 = context.parent;
    return self2.canCopyProperty(property2, parent2);
  });
}
CopyPasteBehavior.$inject = ["eventBus"];
CopyPasteBehavior.prototype.canCopyProperty = function(property2, parent2) {
  if (isObject(property2) && !isAllowedInParent(property2, parent2)) {
    return false;
  }
  if (is$3(property2, "camunda:InputOutput") && !this.canHostInputOutput(parent2)) {
    return false;
  }
  if (isAny(property2, ["camunda:Connector", "camunda:Field"]) && !this.canHostConnector(parent2)) {
    return false;
  }
  if (is$3(property2, "camunda:In") && !this.canHostIn(parent2)) {
    return false;
  }
};
CopyPasteBehavior.prototype.canHostInputOutput = function(parent2) {
  var connector = getParent(parent2, "camunda:Connector");
  if (connector) {
    return true;
  }
  var flowNode = getParent(parent2, "bpmn:FlowNode");
  if (!flowNode) {
    return false;
  }
  if (isAny(flowNode, ["bpmn:StartEvent", "bpmn:Gateway", "bpmn:BoundaryEvent"])) {
    return false;
  }
  if (is$3(flowNode, "bpmn:SubProcess") && flowNode.get("triggeredByEvent")) {
    return false;
  }
  return true;
};
CopyPasteBehavior.prototype.canHostConnector = function(parent2) {
  var serviceTaskLike = getParent(parent2, "camunda:ServiceTaskLike");
  if (is$3(serviceTaskLike, "bpmn:MessageEventDefinition")) {
    return getParent(parent2, "bpmn:IntermediateThrowEvent") || getParent(parent2, "bpmn:EndEvent");
  }
  return true;
};
CopyPasteBehavior.prototype.canHostIn = function(parent2) {
  var callActivity = getParent(parent2, "bpmn:CallActivity");
  if (callActivity) {
    return true;
  }
  var signalEventDefinition = getParent(parent2, "bpmn:SignalEventDefinition");
  if (signalEventDefinition) {
    return getParent(parent2, "bpmn:IntermediateThrowEvent") || getParent(parent2, "bpmn:EndEvent");
  }
  return true;
};
var CopyPasteBehavior_1 = CopyPasteBehavior;
function is$3(element, type) {
  return element && isFunction(element.$instanceOf) && element.$instanceOf(type);
}
function isAny(element, types2) {
  return some(types2, function(t) {
    return is$3(element, t);
  });
}
function getParent(element, type) {
  if (!type) {
    return element.$parent;
  }
  if (is$3(element, type)) {
    return element;
  }
  if (!element.$parent) {
    return;
  }
  return getParent(element.$parent, type);
}
function isAllowedInParent(property2, parent2) {
  var descriptor = property2.$type && property2.$model.getTypeDescriptor(property2.$type);
  var allowedIn = descriptor && descriptor.meta && descriptor.meta.allowedIn;
  if (!allowedIn || isWildcard(allowedIn)) {
    return true;
  }
  return some(allowedIn, function(type) {
    return getParent(parent2, type);
  });
}
function isWildcard(allowedIn) {
  return allowedIn.indexOf(WILDCARD) !== -1;
}
var DEFAULT_PRIORITY = 1e3;
function CommandInterceptor$3(eventBus) {
  this._eventBus = eventBus;
}
CommandInterceptor$3.$inject = ["eventBus"];
function unwrapEvent(fn, that) {
  return function(event) {
    return fn.call(that || null, event.context, event.command, event);
  };
}
CommandInterceptor$3.prototype.on = function(events, hook, priority, handlerFn, unwrap, that) {
  if (isFunction$6(hook) || isNumber$1(hook)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = hook;
    hook = null;
  }
  if (isFunction$6(priority)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = DEFAULT_PRIORITY;
  }
  if (isObject$e(unwrap)) {
    that = unwrap;
    unwrap = false;
  }
  if (!isFunction$6(handlerFn)) {
    throw new Error("handlerFn must be a function");
  }
  if (!isArray$n(events)) {
    events = [events];
  }
  var eventBus = this._eventBus;
  forEach$q(events, function(event) {
    var fullEvent = ["commandStack", event, hook].filter(function(e) {
      return e;
    }).join(".");
    eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
  });
};
var hooks = [
  "canExecute",
  "preExecute",
  "preExecuted",
  "execute",
  "executed",
  "postExecute",
  "postExecuted",
  "revert",
  "reverted"
];
forEach$q(hooks, function(hook) {
  CommandInterceptor$3.prototype[hook] = function(events, priority, handlerFn, unwrap, that) {
    if (isFunction$6(events) || isNumber$1(events)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = events;
      events = null;
    }
    this.on(events, hook, priority, handlerFn, unwrap, that);
  };
});
var CommandInterceptor$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": CommandInterceptor$3
}, Symbol.toStringTag, { value: "Module" }));
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(CommandInterceptor$4);
var inherits$2 = inherits_browser.exports;
var find = require$$1$1.find, matchPattern = require$$1$1.matchPattern;
var CommandInterceptor$2 = require$$1.default;
var collectionAdd = require$$3.add, collectionRemove = require$$3.remove;
var getBusinessObject$2 = require$$2$2.getBusinessObject, is$2 = require$$2$2.is;
var LOW_PRIORITY = 500;
function CopyPasteRootElementBehavior(bpmnjs, eventBus, injector, moddleCopy, bpmnFactory) {
  injector.invoke(CommandInterceptor$2, this);
  function hasRootElement(rootElement) {
    var definitions = bpmnjs.getDefinitions(), rootElements = definitions.get("rootElements");
    return !!find(rootElements, matchPattern({ id: rootElement.id }));
  }
  this.executed("shape.create", function(context) {
    var shape = context.shape, businessObject = getBusinessObject$2(shape);
    if (!canHaveNestedRootElementReference(businessObject)) {
      return;
    }
    var referencedRootElements = getRootElements(businessObject, getReferencingElement(shape)), rootElements = bpmnjs.getDefinitions().get("rootElements");
    context.addedRootElements = [];
    referencedRootElements.forEach(function(reference) {
      var element = reference.referencedElement;
      if (element && !hasRootElement(element)) {
        collectionAdd(rootElements, element);
        context.addedRootElements.push(element);
      }
    });
  }, true);
  this.reverted("shape.create", function(context) {
    var addedRootElements = context.addedRootElements;
    if (!addedRootElements) {
      return;
    }
    var rootElements = bpmnjs.getDefinitions().get("rootElements");
    addedRootElements.forEach(function(addedRootElement) {
      collectionRemove(rootElements, addedRootElement);
    });
  }, true);
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element, businessObject = getBusinessObject$2(element);
    if (!canHaveNestedRootElementReference(businessObject)) {
      return;
    }
    var rootElements = getRootElements(businessObject, getReferencingElement(element));
    if (rootElements) {
      descriptor.referencedRootElements = rootElements;
    }
  });
  eventBus.on("copyPaste.pasteElement", LOW_PRIORITY, function(context) {
    var descriptor = context.descriptor, businessObject = descriptor.businessObject;
    if (!canHaveNestedRootElementReference(businessObject)) {
      return;
    }
    var referencedRootElements = descriptor.referencedRootElements;
    if (referencedRootElements && referencedRootElements.length) {
      referencedRootElements.forEach(function(reference) {
        var element = reference.referencedElement, idx = reference.idx;
        if (!element) {
          return;
        }
        if (!hasRootElement(element)) {
          element = moddleCopy.copyElement(element, bpmnFactory.create(element.$type));
        }
        setRootElement(businessObject, element, idx);
      });
    }
    delete descriptor.referencedRootElements;
  });
}
CopyPasteRootElementBehavior.$inject = [
  "bpmnjs",
  "eventBus",
  "injector",
  "moddleCopy",
  "bpmnFactory"
];
inherits$2(CopyPasteRootElementBehavior, CommandInterceptor$2);
var CopyPasteRootElementBehavior_1 = CopyPasteRootElementBehavior;
function getReferencingElement(element) {
  if (is$2(element, "bpmn:ServiceTask")) {
    return "camunda:ErrorEventDefinition";
  }
}
function getRootElementReferencePropertyName(bo) {
  if (is$2(bo, "camunda:ErrorEventDefinition")) {
    return "errorRef";
  }
}
function canHaveNestedRootElementReference(bo) {
  var isExternalServiceTask = is$2(bo, "bpmn:ServiceTask") && bo.type === "external";
  return isExternalServiceTask;
}
function getRootElements(bo, extensionElementType) {
  var extensionElements2 = bo.get("extensionElements"), filteredExtensionElements = [], rootElementReference;
  if (extensionElements2) {
    filteredExtensionElements = extensionElements2.values.filter(function(element) {
      return is$2(element, extensionElementType);
    });
  }
  var rootElements = filteredExtensionElements.reduce(function(result, element) {
    rootElementReference = element[getRootElementReferencePropertyName(element)];
    if (rootElementReference) {
      result.push({
        idx: findExtensionElement(bo, element),
        referencedElement: rootElementReference
      });
    }
    return result;
  }, []);
  return rootElements;
}
function setRootElement(bo, rootElement, index2) {
  var extensionElement = bo.get("extensionElements").values[index2];
  extensionElement.set(getRootElementReferencePropertyName(extensionElement), rootElement);
}
function findExtensionElement(bo, extensionElement) {
  var extensionElements2 = bo.get("extensionElements");
  if (!extensionElements2) {
    return -1;
  }
  return extensionElements2.values.indexOf(extensionElement);
}
var inherits$1 = inherits_browser.exports;
var CommandInterceptor$1 = require$$1.default;
var is$1 = require$$2$2.is;
var getBusinessObject$1 = require$$2$2.getBusinessObject;
function RemoveInitiatorBehaviour(modeling, injector) {
  injector.invoke(CommandInterceptor$1, this);
  this.postExecuted(["shape.create", "shape.move"], function(context) {
    var shape = context.shape, newParent = context.newParent || context.parent, businessObject = getBusinessObject$1(shape);
    if (is$1(shape, "bpmn:StartEvent") && businessObject.get("camunda:initiator") !== void 0) {
      if (is$1(newParent, "bpmn:SubProcess")) {
        modeling.updateProperties(shape, { "camunda:initiator": void 0 });
      }
    }
  }, true);
}
RemoveInitiatorBehaviour.$inject = [
  "modeling",
  "injector"
];
inherits$1(RemoveInitiatorBehaviour, CommandInterceptor$1);
var RemoveInitiatorBehaviour_1 = RemoveInitiatorBehaviour;
var inherits = inherits_browser.exports;
var CommandInterceptor = require$$1.default;
var is = require$$2$2.is;
var getBusinessObject = require$$2$2.getBusinessObject;
function RemoveVariableEventBehaviour(modeling, injector, bpmnFactory, moddleCopy) {
  injector.invoke(CommandInterceptor, this);
  this.postExecuted(["shape.move", "shape.create"], function(context) {
    var newParent = context.newParent || context.parent, newParentBusinessObject = getBusinessObject(newParent), shape = context.shape, shapeBusinessObject = getBusinessObject(shape), eventDefinitions, definitionsCopy;
    var update2 = false;
    if (is(shape, "bpmn:StartEvent")) {
      if (!(is(newParent, "bpmn:SubProcess") && newParentBusinessObject.get("triggeredByEvent"))) {
        eventDefinitions = shapeBusinessObject.get("eventDefinitions");
        definitionsCopy = eventDefinitions.slice();
        definitionsCopy.forEach(function(eventDefinition, index2) {
          if (!is(eventDefinition, "bpmn:ConditionalEventDefinition")) {
            return;
          }
          if (eventDefinition.get("camunda:variableEvents")) {
            update2 = true;
            var newDefinition = bpmnFactory.create("bpmn:ConditionalEventDefinition");
            moddleCopy.copyElement(eventDefinition, newDefinition);
            newDefinition.$parent = eventDefinition.$parent;
            newDefinition.variableEvents = void 0;
            definitionsCopy[index2] = newDefinition;
          }
        });
        if (update2) {
          modeling.updateProperties(shape, { "eventDefinitions": definitionsCopy });
        }
      }
    }
  }, true);
}
RemoveVariableEventBehaviour.$inject = [
  "modeling",
  "injector",
  "bpmnFactory",
  "moddleCopy"
];
inherits(RemoveVariableEventBehaviour, CommandInterceptor);
var RemoveVariableEventBehaviour_1 = RemoveVariableEventBehaviour;
var lib = {
  __init__: [
    "camundaCopyPasteBehavior",
    "camundaCopyPasteRootElementBehavior",
    "camundaRemoveInitiatorBehaviour",
    "camundaRemoveVariableEventBehaviour"
  ],
  camundaCopyPasteBehavior: ["type", CopyPasteBehavior_1],
  camundaCopyPasteRootElementBehavior: ["type", CopyPasteRootElementBehavior_1],
  camundaRemoveInitiatorBehaviour: ["type", RemoveInitiatorBehaviour_1],
  camundaRemoveVariableEventBehaviour: ["type", RemoveVariableEventBehaviour_1]
};
const name = "Camunda";
const uri = "http://camunda.org/schema/1.0/bpmn";
const prefix = "camunda";
const xml = {
  tagAlias: "lowerCase"
};
const associations = [];
const types = [
  {
    name: "Definitions",
    isAbstract: true,
    "extends": [
      "bpmn:Definitions"
    ],
    properties: [
      {
        name: "diagramRelationId",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "InOutBinding",
    superClass: [
      "Element"
    ],
    isAbstract: true,
    properties: [
      {
        name: "source",
        isAttr: true,
        type: "String"
      },
      {
        name: "sourceExpression",
        isAttr: true,
        type: "String"
      },
      {
        name: "target",
        isAttr: true,
        type: "String"
      },
      {
        name: "businessKey",
        isAttr: true,
        type: "String"
      },
      {
        name: "local",
        isAttr: true,
        type: "Boolean",
        "default": false
      },
      {
        name: "variables",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "In",
    superClass: [
      "InOutBinding"
    ],
    meta: {
      allowedIn: [
        "bpmn:CallActivity",
        "bpmn:SignalEventDefinition"
      ]
    }
  },
  {
    name: "Out",
    superClass: [
      "InOutBinding"
    ],
    meta: {
      allowedIn: [
        "bpmn:CallActivity"
      ]
    }
  },
  {
    name: "AsyncCapable",
    isAbstract: true,
    "extends": [
      "bpmn:Activity",
      "bpmn:Gateway",
      "bpmn:Event"
    ],
    properties: [
      {
        name: "async",
        isAttr: true,
        type: "Boolean",
        "default": false
      },
      {
        name: "asyncBefore",
        isAttr: true,
        type: "Boolean",
        "default": false
      },
      {
        name: "asyncAfter",
        isAttr: true,
        type: "Boolean",
        "default": false
      },
      {
        name: "exclusive",
        isAttr: true,
        type: "Boolean",
        "default": true
      }
    ]
  },
  {
    name: "JobPriorized",
    isAbstract: true,
    "extends": [
      "bpmn:Process",
      "camunda:AsyncCapable"
    ],
    properties: [
      {
        name: "jobPriority",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "SignalEventDefinitionExtension",
    isAbstract: true,
    "extends": [
      "bpmn:SignalEventDefinition"
    ],
    properties: [
      {
        name: "async",
        isAttr: true,
        type: "Boolean",
        "default": false
      }
    ]
  },
  {
    name: "ErrorEventDefinitionExtension",
    isAbstract: true,
    "extends": [
      "bpmn:ErrorEventDefinition"
    ],
    properties: [
      {
        name: "errorCodeVariable",
        isAttr: true,
        type: "String"
      },
      {
        name: "errorMessageVariable",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ErrorEventDefinition",
    superClass: [
      "bpmn:ErrorEventDefinition",
      "Element"
    ],
    properties: [
      {
        name: "expression",
        isAttr: true,
        type: "String"
      }
    ],
    meta: {
      allowedIn: [
        "bpmn:ServiceTask"
      ]
    }
  },
  {
    name: "Error",
    isAbstract: true,
    "extends": [
      "bpmn:Error"
    ],
    properties: [
      {
        name: "camunda:errorMessage",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "PotentialStarter",
    superClass: [
      "Element"
    ],
    properties: [
      {
        name: "resourceAssignmentExpression",
        type: "bpmn:ResourceAssignmentExpression"
      }
    ]
  },
  {
    name: "FormSupported",
    isAbstract: true,
    "extends": [
      "bpmn:StartEvent",
      "bpmn:UserTask"
    ],
    properties: [
      {
        name: "formHandlerClass",
        isAttr: true,
        type: "String"
      },
      {
        name: "formKey",
        isAttr: true,
        type: "String"
      },
      {
        name: "formRef",
        isAttr: true,
        type: "String"
      },
      {
        name: "formRefBinding",
        isAttr: true,
        type: "String"
      },
      {
        name: "formRefVersion",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "TemplateSupported",
    isAbstract: true,
    "extends": [
      "bpmn:Collaboration",
      "bpmn:Process",
      "bpmn:FlowElement"
    ],
    properties: [
      {
        name: "modelerTemplate",
        isAttr: true,
        type: "String"
      },
      {
        name: "modelerTemplateVersion",
        isAttr: true,
        type: "Integer"
      }
    ]
  },
  {
    name: "Initiator",
    isAbstract: true,
    "extends": [
      "bpmn:StartEvent"
    ],
    properties: [
      {
        name: "initiator",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ScriptTask",
    isAbstract: true,
    "extends": [
      "bpmn:ScriptTask"
    ],
    properties: [
      {
        name: "resultVariable",
        isAttr: true,
        type: "String"
      },
      {
        name: "resource",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Process",
    isAbstract: true,
    "extends": [
      "bpmn:Process"
    ],
    properties: [
      {
        name: "candidateStarterGroups",
        isAttr: true,
        type: "String"
      },
      {
        name: "candidateStarterUsers",
        isAttr: true,
        type: "String"
      },
      {
        name: "versionTag",
        isAttr: true,
        type: "String"
      },
      {
        name: "historyTimeToLive",
        isAttr: true,
        type: "String"
      },
      {
        name: "isStartableInTasklist",
        isAttr: true,
        type: "Boolean",
        "default": true
      }
    ]
  },
  {
    name: "EscalationEventDefinitionExtension",
    isAbstract: true,
    "extends": [
      "bpmn:EscalationEventDefinition"
    ],
    properties: [
      {
        name: "escalationCodeVariable",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "FormalExpression",
    isAbstract: true,
    "extends": [
      "bpmn:FormalExpression"
    ],
    properties: [
      {
        name: "resource",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Assignable",
    "extends": [
      "bpmn:UserTask"
    ],
    properties: [
      {
        name: "assignee",
        isAttr: true,
        type: "String"
      },
      {
        name: "candidateUsers",
        isAttr: true,
        type: "String"
      },
      {
        name: "candidateGroups",
        isAttr: true,
        type: "String"
      },
      {
        name: "dueDate",
        isAttr: true,
        type: "String"
      },
      {
        name: "followUpDate",
        isAttr: true,
        type: "String"
      },
      {
        name: "priority",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "CallActivity",
    "extends": [
      "bpmn:CallActivity"
    ],
    properties: [
      {
        name: "calledElementBinding",
        isAttr: true,
        type: "String",
        "default": "latest"
      },
      {
        name: "calledElementVersion",
        isAttr: true,
        type: "String"
      },
      {
        name: "calledElementVersionTag",
        isAttr: true,
        type: "String"
      },
      {
        name: "calledElementTenantId",
        isAttr: true,
        type: "String"
      },
      {
        name: "caseRef",
        isAttr: true,
        type: "String"
      },
      {
        name: "caseBinding",
        isAttr: true,
        type: "String",
        "default": "latest"
      },
      {
        name: "caseVersion",
        isAttr: true,
        type: "String"
      },
      {
        name: "caseTenantId",
        isAttr: true,
        type: "String"
      },
      {
        name: "variableMappingClass",
        isAttr: true,
        type: "String"
      },
      {
        name: "variableMappingDelegateExpression",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ServiceTaskLike",
    "extends": [
      "bpmn:ServiceTask",
      "bpmn:BusinessRuleTask",
      "bpmn:SendTask",
      "bpmn:MessageEventDefinition"
    ],
    properties: [
      {
        name: "expression",
        isAttr: true,
        type: "String"
      },
      {
        name: "class",
        isAttr: true,
        type: "String"
      },
      {
        name: "delegateExpression",
        isAttr: true,
        type: "String"
      },
      {
        name: "resultVariable",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "DmnCapable",
    "extends": [
      "bpmn:BusinessRuleTask"
    ],
    properties: [
      {
        name: "decisionRef",
        isAttr: true,
        type: "String"
      },
      {
        name: "decisionRefBinding",
        isAttr: true,
        type: "String",
        "default": "latest"
      },
      {
        name: "decisionRefVersion",
        isAttr: true,
        type: "String"
      },
      {
        name: "mapDecisionResult",
        isAttr: true,
        type: "String",
        "default": "resultList"
      },
      {
        name: "decisionRefTenantId",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ExternalCapable",
    "extends": [
      "camunda:ServiceTaskLike"
    ],
    properties: [
      {
        name: "type",
        isAttr: true,
        type: "String"
      },
      {
        name: "topic",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "TaskPriorized",
    "extends": [
      "bpmn:Process",
      "camunda:ExternalCapable"
    ],
    properties: [
      {
        name: "taskPriority",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Properties",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "*"
      ]
    },
    properties: [
      {
        name: "values",
        type: "Property",
        isMany: true
      }
    ]
  },
  {
    name: "Property",
    superClass: [
      "Element"
    ],
    properties: [
      {
        name: "id",
        type: "String",
        isAttr: true
      },
      {
        name: "name",
        type: "String",
        isAttr: true
      },
      {
        name: "value",
        type: "String",
        isAttr: true
      }
    ]
  },
  {
    name: "Connector",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "camunda:ServiceTaskLike"
      ]
    },
    properties: [
      {
        name: "inputOutput",
        type: "InputOutput"
      },
      {
        name: "connectorId",
        type: "String"
      }
    ]
  },
  {
    name: "InputOutput",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "bpmn:FlowNode",
        "camunda:Connector"
      ]
    },
    properties: [
      {
        name: "inputOutput",
        type: "InputOutput"
      },
      {
        name: "connectorId",
        type: "String"
      },
      {
        name: "inputParameters",
        isMany: true,
        type: "InputParameter"
      },
      {
        name: "outputParameters",
        isMany: true,
        type: "OutputParameter"
      }
    ]
  },
  {
    name: "InputOutputParameter",
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "value",
        isBody: true,
        type: "String"
      },
      {
        name: "definition",
        type: "InputOutputParameterDefinition"
      }
    ]
  },
  {
    name: "InputOutputParameterDefinition",
    isAbstract: true
  },
  {
    name: "List",
    superClass: [
      "InputOutputParameterDefinition"
    ],
    properties: [
      {
        name: "items",
        isMany: true,
        type: "InputOutputParameterDefinition"
      }
    ]
  },
  {
    name: "Map",
    superClass: [
      "InputOutputParameterDefinition"
    ],
    properties: [
      {
        name: "entries",
        isMany: true,
        type: "Entry"
      }
    ]
  },
  {
    name: "Entry",
    properties: [
      {
        name: "key",
        isAttr: true,
        type: "String"
      },
      {
        name: "value",
        isBody: true,
        type: "String"
      },
      {
        name: "definition",
        type: "InputOutputParameterDefinition"
      }
    ]
  },
  {
    name: "Value",
    superClass: [
      "InputOutputParameterDefinition"
    ],
    properties: [
      {
        name: "id",
        isAttr: true,
        type: "String"
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "value",
        isBody: true,
        type: "String"
      }
    ]
  },
  {
    name: "Script",
    superClass: [
      "InputOutputParameterDefinition"
    ],
    properties: [
      {
        name: "scriptFormat",
        isAttr: true,
        type: "String"
      },
      {
        name: "resource",
        isAttr: true,
        type: "String"
      },
      {
        name: "value",
        isBody: true,
        type: "String"
      }
    ]
  },
  {
    name: "Field",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "camunda:ServiceTaskLike",
        "camunda:ExecutionListener",
        "camunda:TaskListener"
      ]
    },
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "expression",
        type: "String"
      },
      {
        name: "stringValue",
        isAttr: true,
        type: "String"
      },
      {
        name: "string",
        type: "String"
      }
    ]
  },
  {
    name: "InputParameter",
    superClass: [
      "InputOutputParameter"
    ]
  },
  {
    name: "OutputParameter",
    superClass: [
      "InputOutputParameter"
    ]
  },
  {
    name: "Collectable",
    isAbstract: true,
    "extends": [
      "bpmn:MultiInstanceLoopCharacteristics"
    ],
    superClass: [
      "camunda:AsyncCapable"
    ],
    properties: [
      {
        name: "collection",
        isAttr: true,
        type: "String"
      },
      {
        name: "elementVariable",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "FailedJobRetryTimeCycle",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "camunda:AsyncCapable",
        "bpmn:MultiInstanceLoopCharacteristics"
      ]
    },
    properties: [
      {
        name: "body",
        isBody: true,
        type: "String"
      }
    ]
  },
  {
    name: "ExecutionListener",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "bpmn:Task",
        "bpmn:ServiceTask",
        "bpmn:UserTask",
        "bpmn:BusinessRuleTask",
        "bpmn:ScriptTask",
        "bpmn:ReceiveTask",
        "bpmn:ManualTask",
        "bpmn:ExclusiveGateway",
        "bpmn:SequenceFlow",
        "bpmn:ParallelGateway",
        "bpmn:InclusiveGateway",
        "bpmn:EventBasedGateway",
        "bpmn:StartEvent",
        "bpmn:IntermediateCatchEvent",
        "bpmn:IntermediateThrowEvent",
        "bpmn:EndEvent",
        "bpmn:BoundaryEvent",
        "bpmn:CallActivity",
        "bpmn:SubProcess",
        "bpmn:Process"
      ]
    },
    properties: [
      {
        name: "expression",
        isAttr: true,
        type: "String"
      },
      {
        name: "class",
        isAttr: true,
        type: "String"
      },
      {
        name: "delegateExpression",
        isAttr: true,
        type: "String"
      },
      {
        name: "event",
        isAttr: true,
        type: "String"
      },
      {
        name: "script",
        type: "Script"
      },
      {
        name: "fields",
        type: "Field",
        isMany: true
      }
    ]
  },
  {
    name: "TaskListener",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "bpmn:UserTask"
      ]
    },
    properties: [
      {
        name: "expression",
        isAttr: true,
        type: "String"
      },
      {
        name: "class",
        isAttr: true,
        type: "String"
      },
      {
        name: "delegateExpression",
        isAttr: true,
        type: "String"
      },
      {
        name: "event",
        isAttr: true,
        type: "String"
      },
      {
        name: "script",
        type: "Script"
      },
      {
        name: "fields",
        type: "Field",
        isMany: true
      },
      {
        name: "id",
        type: "String",
        isAttr: true
      },
      {
        name: "eventDefinitions",
        type: "bpmn:TimerEventDefinition",
        isMany: true
      }
    ]
  },
  {
    name: "FormProperty",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "bpmn:StartEvent",
        "bpmn:UserTask"
      ]
    },
    properties: [
      {
        name: "id",
        type: "String",
        isAttr: true
      },
      {
        name: "name",
        type: "String",
        isAttr: true
      },
      {
        name: "type",
        type: "String",
        isAttr: true
      },
      {
        name: "required",
        type: "String",
        isAttr: true
      },
      {
        name: "readable",
        type: "String",
        isAttr: true
      },
      {
        name: "writable",
        type: "String",
        isAttr: true
      },
      {
        name: "variable",
        type: "String",
        isAttr: true
      },
      {
        name: "expression",
        type: "String",
        isAttr: true
      },
      {
        name: "datePattern",
        type: "String",
        isAttr: true
      },
      {
        name: "default",
        type: "String",
        isAttr: true
      },
      {
        name: "values",
        type: "Value",
        isMany: true
      }
    ]
  },
  {
    name: "FormData",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "bpmn:StartEvent",
        "bpmn:UserTask"
      ]
    },
    properties: [
      {
        name: "fields",
        type: "FormField",
        isMany: true
      },
      {
        name: "businessKey",
        type: "String",
        isAttr: true
      }
    ]
  },
  {
    name: "FormField",
    superClass: [
      "Element"
    ],
    properties: [
      {
        name: "id",
        type: "String",
        isAttr: true
      },
      {
        name: "label",
        type: "String",
        isAttr: true
      },
      {
        name: "type",
        type: "String",
        isAttr: true
      },
      {
        name: "datePattern",
        type: "String",
        isAttr: true
      },
      {
        name: "defaultValue",
        type: "String",
        isAttr: true
      },
      {
        name: "properties",
        type: "Properties"
      },
      {
        name: "validation",
        type: "Validation"
      },
      {
        name: "values",
        type: "Value",
        isMany: true
      }
    ]
  },
  {
    name: "Validation",
    superClass: [
      "Element"
    ],
    properties: [
      {
        name: "constraints",
        type: "Constraint",
        isMany: true
      }
    ]
  },
  {
    name: "Constraint",
    superClass: [
      "Element"
    ],
    properties: [
      {
        name: "name",
        type: "String",
        isAttr: true
      },
      {
        name: "config",
        type: "String",
        isAttr: true
      }
    ]
  },
  {
    name: "ConditionalEventDefinitionExtension",
    isAbstract: true,
    "extends": [
      "bpmn:ConditionalEventDefinition"
    ],
    properties: [
      {
        name: "variableName",
        isAttr: true,
        type: "String"
      },
      {
        name: "variableEvents",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
const emumerations = [];
var customDescriptor = {
  name,
  uri,
  prefix,
  xml,
  associations,
  types,
  emumerations
};
class CustomBpmnModelerFactory {
}
class CustomBpmnModeler extends Modeler {
}
CustomBpmnModeler.prototype._modules = [
  ...Modeler.prototype._modules,
  bpmnJsPropertiesPanel,
  camunda
];
CustomBpmnModelerFactory.prototype.get_instance = (divIdContainer, divIdParentPropertiesPanel) => {
  const bpmnModeler2 = new CustomBpmnModeler({
    container: divIdContainer,
    keyboard: {
      bindTo: document
    },
    propertiesPanel: {
      parent: divIdParentPropertiesPanel
    },
    additionalModules: [lib],
    moddleExtensions: {
      camunda: customDescriptor
    }
  });
  return bpmnModeler2;
};
var modeler = "";
const init = (sessuuid2) => {
  const sessdata = {
    "id": "1",
    "file_name": "qr-code.bpmn",
    "SESSUUID": sessuuid2,
    "SCREEN_NAME": "Modeler"
  };
  SessionStateStore.saveState(sessuuid2, sessdata);
};
const displayDiagram = async (xml_data, file_name, id2 = "") => {
  try {
    const result = bpmnModeler.importXML(xml_data);
    const { warnings } = result;
    console.log("Open a file :" + file_name);
    $("#file_name").text(file_name);
    $("#id").text(id2);
  } catch (err) {
    console.log(err.message, err.warnings);
    alert("could not import BPMN 2.0 XML, see console");
  }
};
const drawCanvas = (bpmnXML, file_name, id2) => {
  displayDiagram(bpmnXML, file_name, id2);
  const canvas = bpmnModeler.get("canvas");
  canvas.zoom("fit-viewport");
};
const renderHbs = async (sessuuid2) => {
  const stateData = SessionStateStore.loadState(sessuuid2);
  const file_name = stateData.file_name;
  const id2 = stateData.id;
  let STATIC_PATH = $(EL_STATIC_PATH).text();
  if (STATIC_PATH == "") {
    STATIC_PATH = STATIC_PATH_CUSTOMED;
  }
  await HbsUtil.renderComponent(EL_APP, STATIC_PATH + HBS_MAIN_TEMPLATE, stateData);
  $(EL_COMPONENTS).html(divComponents);
  console.log(`render ${STATIC_PATH + HBS_MAIN_TEMPLATE} ...`);
  for (let itm of aryHbsComponents) {
    console.log(`render ${STATIC_PATH + itm.hbsPath} ...`);
    await HbsUtil.renderComponent(itm.el, STATIC_PATH + itm.hbsPath, itm.data);
  }
  const factory2 = new CustomBpmnModelerFactory();
  bpmnModeler = factory2.get_instance(EL_CANVAS, EL_PROPERTIES_PANEL_PARENT);
  const initialDiagram2 = await DataUtil.fetchData(MEDIA_PATH + INITIAL_XML_NAME);
  $("#btn_openLocal").on("click", openLocal);
  $("#btn_createNew").on("click", { bpmnModeler, initialDiagram: initialDiagram2, fileName: INITIAL_XML_NAME }, createNew);
  $("#btn_uploadBpmn").on("click", uploadBpmn);
  $("#btn_saveLocal").on("click", saveLocal);
  $("#btn_saveSvg").on("click", saveSvg);
  $("#btn_displayKeyMap").on("click", displayKeyMap);
  $("#btn_toggleFullscreen").on("click", toggleFullscreen);
  $("#btn_zoomReset").on("click", zoomReset);
  $("#btn_zoomIn").on("click", zoomIn);
  $("#btn_zoomOut").on("click", zoomOut);
  $(".toggle-panel").on("click", togglePanel);
  const dropArea = $(EL_DROP_AREA);
  if (!window.FileList || !window.FileReader) {
    window.alert("Looks like you use an older browser that does not support drag and drop. Try using Chrome, Firefox or the Internet Explorer > 10.");
  } else {
    registerFileDrop(dropArea, displayDiagram);
  }
  const url = MEDIA_PATH + file_name;
  const bpmnXML = await DataUtil.fetchData(url);
  drawCanvas(bpmnXML, file_name, id2);
};
const MEDIA_PATH = "../../media/xml/";
const INITIAL_XML_NAME = "initialDiagram.bpmn";
const HBS_MAIN_TEMPLATE = "./modeler/modeler.hbs";
const aryHbsComponents = [
  { el: "#io-alerts", data: {}, hbsPath: "./modeler/components/io-alerts.hbs" },
  { el: "#io-dialog-import-warnings", data: {}, hbsPath: "./modeler/components/io-dialog import-warnings.hbs" },
  { el: "#io-dialog-keybindings-dialog", data: {}, hbsPath: "./modeler/components/io-dialog keybindings-dialog.hbs" },
  { el: "#io-editing-tools", data: {}, hbsPath: "./modeler/components/io-editing-tools.hbs" },
  { el: "#io-import-export", data: {}, hbsPath: "./modeler/components/io-import-export.hbs" },
  { el: "#io-zoom-controls", data: {}, hbsPath: "./modeler/components/io-zoom-controls.hbs" }
];
const divComponents = `
    <div id='io-alerts'></div>
    <div id='io-dialog-import-warnings'></div>
    <div id='io-dialog-keybindings-dialog'></div>
    <div id='io-editing-tools'></div>
    <div id='io-import-export'></div>
    <div id='io-zoom-controls'></div>
`;
let bpmnModeler = {};
const sessuuid = "999999999999999";
init(sessuuid);
const EL_APP = "#app";
const EL_COMPONENTS = "#div-components";
const EL_CANVAS = "#js-canvas";
const EL_PROPERTIES_PANEL_PARENT = "#properties-panel-parent";
const EL_DROP_AREA = "#row-main";
const EL_STATIC_PATH = "#STATIC-PATH";
const STATIC_PATH_CUSTOMED = "../../../static/modeler-customed/src/";
$(document).on("load", renderHbs(sessuuid));
